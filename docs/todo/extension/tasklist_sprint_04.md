# Task List: Sub-Sprint 4 - Message Routing & State

**Goal:** To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** | ☐ To Do | **Create `StateManager.ts` File:** Create the new file `src/stateManager.ts`. Define a simple `StateManager` class. Add a private boolean property `_isIndexing` initialized to `false`. Implement a public getter `isIndexing(): boolean` and a public setter `setIndexing(state: boolean): void` for this property. | `src/stateManager.ts` (New) |
| **4.2** | ☐ To Do | **Create `MessageRouter.ts` File:** Create the new file `src/messageRouter.ts`. Define the `MessageRouter` class. Its constructor should accept `extensionManager: ExtensionManager` and `webview: vscode.Webview`. In the constructor, set up the `webview.onDidReceiveMessage` listener, delegating to a private `routeMessage` method. | `src/messageRouter.ts` (New) |
| **4.3** | ☐ To Do | **Implement `routeMessage` Method:** In `src/messageRouter.ts`, implement the private `async routeMessage(message: any): Promise<void>` method. This method should contain a `switch` statement to handle different `message.command` values (e.g., `'startIndexing'`). It should call the appropriate service method via `this.extensionManager` and send a response back to the webview using `this.webview.postMessage()`, including `requestId`, `result`, and `error` fields. | `src/messageRouter.ts` |
| **4.4** | ☐ To Do | **Integrate State Check in `MessageRouter`:** In `src/messageRouter.ts`, within the `routeMessage` method, for the `'startIndexing'` case, add a check: `if (this.extensionManager.stateManager.isIndexing()) { throw new Error('Indexing is already in progress.'); }` before calling `startIndexing()`. | `src/messageRouter.ts` |
| **4.5** | ☐ To Do | **Update `ExtensionManager` for `StateManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, instantiate `StateManager` (e.g., `this.stateManager = new StateManager();`). Make `stateManager` a public property. Pass the `stateManager` instance as a dependency to `IndexingService` during its instantiation. | `src/extensionManager.ts` |
| **4.6** | ☐ To Do | **Update `IndexingService` to Use `StateManager`:** Open `src/indexing/indexingService.ts`. Modify the constructor to accept `stateManager: StateManager` as a dependency. In the `startIndexing()` method, call `this.stateManager.setIndexing(true)` at the beginning and `this.stateManager.setIndexing(false)` in a `finally` block to ensure the state is reset after the operation completes (whether successful or not). | `src/indexing/indexingService.ts` |
| **4.7** | ☐ To Do | **Integrate `MessageRouter` in `WebviewManager`:** Open `src/webviewManager.ts`. Modify the `showMainPanel()` and `showSettingsPanel()` methods. Remove any existing `webview.onDidReceiveMessage` listener. Instead, instantiate `MessageRouter` (e.g., `new MessageRouter(this.extensionManager, this.mainPanel.webview);`) for each panel. Ensure `WebviewManager`'s constructor now accepts `extensionManager: ExtensionManager` as a dependency. | `src/webviewManager.ts` |
| **4.8** | ☐ To Do | **Update `ExtensionManager` to Pass Itself to `WebviewManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, when instantiating `WebviewManager`, pass `this` (the `ExtensionManager` instance itself) as the second argument (e.g., `this.webviewManager = new WebviewManager(this.context, this);`). | `src/extensionManager.ts` |
