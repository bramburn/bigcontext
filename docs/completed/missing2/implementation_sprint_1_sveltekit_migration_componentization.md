This guide provides implementation details for Sprint 1: SvelteKit Migration & Componentization.

### 1. Scaffolding the SvelteKit Project

The PRD requires replacing the existing webview with a new SvelteKit project. The `webview-backup-20250826-101914` directory suggests this may have already been done. If starting from scratch:

1.  **Backup**: `mv webview webview-backup-$(date +%Y%m%d-%H%M%S)`
2.  **Initialize**: Run `npm create svelte@latest webview`.
    -   Select: **Skeleton project**
    -   Select: **Yes, using TypeScript syntax**
    -   Select: **Add ESLint for code linting**
    -   Select: **Add Prettier for code formatting**

### 2. Configuring the Static Adapter

To ensure the SvelteKit app can be loaded as a set of static files in a VS Code webview, we must use `@sveltejs/adapter-static`.

**Installation**:
```bash
npm i -D @sveltejs/adapter-static
```

**`webview/svelte.config.js` Configuration**:

```javascript
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
    preprocess: vitePreprocess(),

    kit: {
        adapter: adapter({
            // Default is pages: 'build', assets: 'build'
            pages: 'build',
            assets: 'build',
            // The fallback is crucial for SPA-like behavior in the webview
            fallback: 'index.html',
            precompress: false,
            strict: true
        }),
        // Ensure all pages are prerendered
        prerender: {
            entries: ['*']
        },
        // App-relative paths are needed for VS Code webviews
        paths: {
            base: '.',
            relative: true
        }
    }
};

export default config;
```

### 3. Integrating Fluent UI Web Components

Fluent UI provides a professional look and feel. It can be integrated by registering the desired components.

**Installation**:
```bash
npm i @fluentui/web-components
```

**Usage**: A good place to register global components is in the root layout file `webview/src/routes/+layout.svelte`.

```html
<script lang="ts">
  import { onMount } from 'svelte';
  import { provideFluentDesignSystem, fluentCard, fluentButton } from '@fluentui/web-components';

  onMount(() => {
    // Registering components makes them available throughout the app
    provideFluentDesignSystem().register(fluentCard(), fluentButton());
  });
</script>

<slot></slot>
```

### 4. State Management with Svelte Stores

Svelte stores are the idiomatic way to handle shared state. For managing the current view, a writable store is perfect.

**`webview/src/lib/stores/viewStore.ts`**:
```typescript
import { writable } from 'svelte/store';

// Define the possible views for type safety
export type View = 'setup' | 'indexing' | 'query';

// Export a writable store with a default value
export const currentView = writable<View>('setup');
```

This store can now be imported into any component to read its value or set a new one.

### 5. Updating `WebviewManager.ts`

The `WebviewManager` must be updated to serve the built SvelteKit application. The existing code in `src/webviewManager.ts` already contains logic for this, which can be adapted.

**Key changes in `getWebviewContent`**:

1.  **Path Correction**: The path to `index.html` must point to `webview/build/index.html`.
2.  **Asset Path Rewriting**: The regex for rewriting asset paths is critical. The existing implementation is a good starting point, but ensure it correctly handles paths generated by SvelteKit.

**Example `getWebviewContent` in `src/webviewManager.ts`**:

```typescript
private getWebviewContent(webview: vscode.Webview, panelName: string): string {
    try {
        const buildPath = vscode.Uri.joinPath(this.context.extensionUri, 'webview', 'build');
        const indexPath = vscode.Uri.joinPath(buildPath, 'index.html');
        let html = fs.readFileSync(indexPath.fsPath, 'utf8');

        // Replace asset paths with webview-compatible URIs
        html = html.replace(/<(script|link|img)([^>]+)(src|href)="([^"]+)"/g,
            (match, tag, attrs, attrName, src) => {
                const assetPath = vscode.Uri.joinPath(buildPath, src);
                const assetUri = webview.asWebviewUri(assetPath);
                return `<${tag}${attrs}${attrName}="${assetUri}"`;
            });

        return html;
    } catch (error) {
        console.error('WebviewManager: Error loading webview content:', error);
        return `<html><body>Error: ${error.message}</body></html>`;
    }
}
```

This updated logic ensures that when the webview loads `index.html`, all relative paths to JavaScript, CSS, or image files are correctly translated into URIs that the webview can access.
