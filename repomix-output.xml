This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  todo/
    fe/
      backlog_sprint_1_setup_view_implementation.md
      backlog_sprint_1_web_api_boilerplate.md
      backlog_sprint_2_extensible_client_framework.md
      backlog_sprint_3_backend_process_management.md
      backlog_sprint_4_onboarding_setup_ui.md
      backlog_sprint_5_concrete_client_implementation.md
      backlog_sprint_6_end_to_end_indexing_query_ui.md
      backlog_sub_sprint_1_database_configuration_component.md
      implementation_sprint_1_setup_view_implementation.md
      implementation_sprint_1_web_api_boilerplate.md
      implementation_sprint_2_extensible_client_framework.md
      implementation_sprint_3_backend_process_management.md
      implementation_sprint_4_onboarding_setup_ui.md
      implementation_sprint_5_concrete_client_implementation.md
      implementation_sub_sprint_1_database_configuration_component.md
      prd.md
    setup/
      backlog_sprint_6_lsp_integration_devops.md
      backlog_sprint_7_documentation_publishing.md
      backlog_sub_sprint_1_vs_code_extension_boilerplate_setup.md
      backlog_sub_sprint_2_sveltekit_fluent_ui_integration.md
      backlog_sub_sprint_5_implement_context_query_api.md
      backlog_sub_sprint_6_develop_settings_ui.md
      implementation_sprint_6_lsp_integration_devops.md
      implementation_sprint_7_documentation_publishing.md
      implementation_sub_sprint_1_vs_code_extension_boilerplate_setup.md
      implementation_sub_sprint_2_sveltekit_fluent_ui_integration.md
      implementation_sub_sprint_5_implement_context_query_api.md
      implementation_sub_sprint_6_develop_settings_ui.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
      tasklist_sprint_03.md
      tasklist_sprint_04.md
      tasklist_sprint_05.md
      tasklist_sprint_06.md
      tasklist_sprint_07.md
    ux/
      prd.md
src/
  extension.ts
webview/
  src/
    index.html
    index.ts
  package.json
  tsconfig.json
  webpack.config.js
.eslintrc.json
.gitignore
.repomixignore
package.json
repomix.config.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/todo/fe/backlog_sprint_1_setup_view_implementation.md">
# Backlog: Sprint 1 - Setup View Implementation

**Objective:** To build the complete user onboarding and setup UI within the VS Code extension's webview. This view is the user's first interaction and must clearly guide them through configuring the necessary database and embedding providers for a new, un-indexed repository.

---

### User Story 1: Display Initial Setup Screen

**As a** new user (Devin), **I want to** see a clear setup screen when I open an un-indexed project, **so that** I know what I need to do to get started.

**Workflow:**
1.  The extension's activation logic checks if a `code-context.json` file exists in the root of the opened workspace.
2.  If the file does not exist, the extension opens a new Webview panel displaying the `SetupView`.
3.  The `SetupView` component renders the primary UI structure.

**Codebase Review:**
*   `src/extension.ts`: Will need modification to add the file check and the command to launch the webview.
*   `webview/`: This directory is currently empty. The entire SvelteKit application will be created here.

**File Changes:**
*   `src/extension.ts`: Modify `activate` function.
*   `webview/src/+page.svelte` (New File): To be created as the main `SetupView` component.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    *   **Action**: On activation, check for the existence of `code-context.json` in the workspace root.
    *   **Implementation**: Use `vscode.workspace.findFiles('code-context.json')` to check for the file. If the result is empty, set a context key like `code-context.isConfigured: false`.
    *   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `package.json`
    *   **Action**: Add a `when` clause to the `viewsWelcome` contribution point to show a welcome view with a "Setup Project" button only when `!code-context.isConfigured`.
    *   **Implementation**:
        ```json
        "contributes": {
          "viewsWelcome": [
            {
              "view": "explorer",
              "contents": "Welcome to Code Context! [Setup Project](command:code-context.setup)\n",
              "when": "!code-context.isConfigured"
            }
          ]
        }
        ```
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Register a command `code-context.setup` that creates and shows a new webview panel.
    *   **Implementation**: Use `vscode.window.createWebviewPanel` to create the panel. The panel should load the SvelteKit build output.
    *   **Imports**: `import * as path from 'path';`, `import * as fs from 'fs';`
4.  **Filepath**: `webview/src/+page.svelte` (New File)
    *   **Action**: Create the main Svelte component for the setup view.
    *   **Implementation**:
        ```html
        <script>
          import DatabaseSetup from '$lib/components/DatabaseSetup.svelte';
          import EmbeddingSetup from '$lib/components/EmbeddingSetup.svelte';
        </script>
        <h1>Code Context Setup</h1>
        <DatabaseSetup />
        <EmbeddingSetup />
        ```
    *   **Imports**: None.

**Acceptance Criteria:**
-   When a project without `code-context.json` is opened, a welcome view in the explorer prompts the user to set up the project.
-   Running the setup command opens a webview titled "Code Context Setup".
-   The view contains distinct sections for "Database Configuration" and "Embedding Provider".
-   The primary call-to-action button ("Index Now") is initially disabled.

---

### User Story 2: Configure Vector Database

**As a** new user (Devin), **I want to** select my desired vector database and get help starting it if it's not running, **so that** my code can be indexed.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte` (New File)
    *   **Action**: Create a Svelte component for database configuration.
    *   **Implementation**: Include a Fluent UI `<Select>` for "Qdrant" and a `<Button>` labeled "Start Local Qdrant".
    *   **Imports**: `import { Select, Button } from '@svelte-fui/core';`
2.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Implement the button's `on:click` handler to send a message to the VS Code extension host.
    *   **Implementation**: `vscode.postMessage({ command: 'startDatabase' });`
    *   **Imports**: None.
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Add a message listener to the webview panel to handle the `startDatabase` command.
    *   **Implementation**: The listener will execute `docker-compose up` in a new VS Code terminal.
    *   **Implementation**: `const terminal = vscode.window.createTerminal('Qdrant'); terminal.sendText('docker-compose up'); terminal.show();`
    *   **Imports**: `import * as vscode from 'vscode';`
4.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Display a status icon that changes from "Not Running" to "Running" based on a message from the backend.
    *   **Implementation**: The extension backend will perform a health check and `postMessage` to the webview with the status.
    *   **Imports**: None.

**Acceptance Criteria:**
-   A dropdown allows selecting "Qdrant".
-   Clicking "Start Local Qdrant" opens a new terminal and runs `docker-compose up`.
-   A status indicator correctly reflects the database's running status after a health check from the backend.

---

### User Story 3: Configure Embedding Provider

**As a** new user (Devin), **I want to** choose which embedding model to use for indexing my code, **so that** the context is generated accurately.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/EmbeddingSetup.svelte` (New File)
    *   **Action**: Create a Svelte component for embedding provider selection.
    *   **Implementation**: Use a Fluent UI `<Select>` with options "Ollama" and "OpenAI".
    *   **Imports**: `import { Select } from '@svelte-fui/core';`
2.  **Filepath**: `webview/src/lib/stores/setupStore.ts` (New File)
    *   **Action**: Create a Svelte writable store to manage the setup state.
    *   **Implementation**: `export const setupState = writable({ databaseReady: false, providerSelected: null });`
    *   **Imports**: `import { writable } from 'svelte/store';`
3.  **Filepath**: `webview/src/+page.svelte`
    *   **Action**: Create the main "Index Now" button. Its `disabled` attribute should be reactively bound to the store's state.
    *   **Implementation**: `<Button disabled={!$setupState.databaseReady || !$setupState.providerSelected}>Index Now</Button>`
    *   **Imports**: `import { Button } from '@svelte-fui/core';`, `import { setupState } from '$lib/stores/setupStore';`
4.  **Filepath**: `webview/src/+page.svelte`
    *   **Action**: When clicked, the "Index Now" button sends the selected configuration to the extension backend.
    *   **Implementation**: `vscode.postMessage({ command: 'startIndexing', config: $setupState });`
    *   **Imports**: None.

**Acceptance Criteria:**
-   A dropdown allows selecting "Ollama" or "OpenAI".
-   The "Index Now" button is enabled only after the database is running and an embedding provider is selected.
-   Clicking the button sends the chosen configuration to the extension backend.

**Testing Plan:**
-   **Manual Test Case 1**: Open a project without `code-context.json`. Verify the welcome view appears.
-   **Manual Test Case 2**: Click the setup button. Verify the webview opens.
-   **Manual Test Case 3**: Click "Start Local Qdrant". Verify a terminal opens and runs the command.
-   **Manual Test Case 4**: Select an embedding provider. Verify the "Index Now" button becomes enabled once the DB is "running".
-   **Manual Test Case 5**: Click "Index Now" and verify the configuration is sent to the extension (check debugger).
</file>

<file path="docs/todo/fe/backlog_sprint_1_web_api_boilerplate.md">
### User Story 1: Create C# Web API Foundation
**As Alisha, I want to** create a new ASP.NET Core Web API project, **so that** we have the foundational service for our backend logic.

**Actions to Undertake:**
1.  **Filepath**: `(Project Root)`
    -   **Action**: Create a new .NET solution and three projects: `CodeContext.Api` (webapi), `CodeContext.Core` (classlib), and `CodeContext.Infrastructure` (classlib).
    -   **Implementation**:
        ```bash
        dotnet new sln -n CodeContext
        dotnet new webapi -n CodeContext.Api -o CodeContext.Api
        dotnet new classlib -n CodeContext.Core -o CodeContext.Core
        dotnet new classlib -n CodeContext.Infrastructure -o CodeContext.Infrastructure
        dotnet sln CodeContext.sln add CodeContext.Api/CodeContext.Api.csproj
        dotnet sln CodeContext.sln add CodeContext.Core/CodeContext.Core.csproj
        dotnet sln CodeContext.sln add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Api/CodeContext.Api.csproj`
    -   **Action**: Add project references from `CodeContext.Api` to `CodeContext.Core` and `CodeContext.Infrastructure`.
    -   **Implementation**:
        ```xml
        <ItemGroup>
            <ProjectReference Include="..\CodeContext.Core\CodeContext.Core.csproj" />
            <ProjectReference Include="..\CodeContext.Infrastructure\CodeContext.Infrastructure.csproj" />
        </ItemGroup>
        ```
    -   **Imports**: None.
3.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Implement a basic `/health` endpoint using minimal API syntax.
    -   **Implementation**:
        ```csharp
        app.MapGet("/health", () => Results.Ok());
        ```
    -   **Imports**: `using Microsoft.AspNetCore.Builder;` (already there)
4.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Add Swagger/OpenAPI support.
    -   **Implementation**:
        ```csharp
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();
        // ...
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }
        ```
    -   **Imports**: `using Microsoft.OpenApi.Models;` (not directly in Program.cs, but implicitly used by AddSwaggerGen)
5.  **Filepath**: `CodeContext.Core/`
    -   **Action**: Create placeholder interfaces `IEmbeddingProvider.cs` and `IVectorDatabaseClient.cs` in the `CodeContext.Core` project.
    -   **Implementation**:
        ```csharp
        // CodeContext.Core/IEmbeddingProvider.cs
        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                // Placeholder for future methods
            }
        }

        // CodeContext.Core/IVectorDatabaseClient.cs
        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                // Placeholder for future methods
            }
        }
        ```
    -   **Imports**: None.
6.  **Filepath**: `CodeContext.Infrastructure/`
    -   **Action**: Create placeholder folders `DatabaseClients` and `EmbeddingProviders` in the `CodeContext.Infrastructure` project.
    -   **Implementation**: (This is a folder creation, not code. I'll describe it.)
        ```
        (Create directory CodeContext.Infrastructure/DatabaseClients)
        (Create directory CodeContext.Infrastructure/EmbeddingProviders)
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   A new .NET solution is created containing `CodeContext.Api`, `CodeContext.Core`, and `CodeContext.Infrastructure` projects.
-   The `CodeContext.Api` project correctly references `CodeContext.Core` and `CodeContext.Infrastructure`.
-   A basic `/health` endpoint is accessible and returns a `200 OK` status.
-   Swagger/OpenAPI documentation is available and functional.
-   Placeholder interfaces `IEmbeddingProvider` and `IVectorDatabaseClient` exist in `CodeContext.Core`.
-   Placeholder folders `DatabaseClients` and `EmbeddingProviders` exist in `CodeContext.Infrastructure`.

**Testing Plan:**
-   **Test Case 1**: Run `dotnet build CodeContext.sln` to ensure all projects build successfully.
-   **Test Case 2**: Navigate to the `CodeContext.Api` directory and run `dotnet run`. Verify the API starts without errors.
-   **Test Case 3**: Access `http://localhost:<port>/health` in a browser or via `curl` and confirm a `200 OK` response.
-   **Test Case 4**: Access `http://localhost:<port>/swagger` in a browser and confirm the Swagger UI loads correctly.
</file>

<file path="docs/todo/fe/backlog_sprint_2_extensible_client_framework.md">
### User Story 1: Define Abstract Interfaces for Clients
**As Alisha, I want to** define abstract interfaces for database clients and embedding providers, **so that** we can easily add new implementations in the future.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/IEmbeddingProvider.cs`
    -   **Action**: Add `GenerateEmbeddingsAsync` method to `IEmbeddingProvider` interface.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts);
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`
2.  **Filepath**: `CodeContext.Core/IVectorDatabaseClient.cs`
    -   **Action**: Add `UpsertAsync` and `QueryAsync` methods to `IVectorDatabaseClient` interface.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                Task UpsertAsync(string collectionName, List<VectorData> vectors);
                Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK);
            }

            public class VectorData
            {
                public string Id { get; set; }
                public float[] Vector { get; set; }
                public Dictionary<string, object> Payload { get; set; }
            }

            public class QueryResult
            {
                public string Id { get; set; }
                public double Score { get; set; }
                public Dictionary<string, object> Payload { get; set; }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`

### User Story 2: Implement Dependency Injection for Clients
**As Alisha, I want to** use dependency injection to register and resolve these clients, **so that** the application is loosely coupled and testable.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Configure .NET's built-in dependency injection container.
    -   **Implementation**: (This is more about how to use DI, not a specific code snippet to add, but rather how to register services. I'll provide a conceptual example.)
        ```csharp
        // Example: Registering a concrete implementation (will be done in later sprints)
        // builder.Services.AddSingleton<IEmbeddingProvider, OllamaProvider>();
        // builder.Services.AddSingleton<IVectorDatabaseClient, QdrantClient>();
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Core/ClientFactory.cs` (New File)
    -   **Action**: Create a `ClientFactory` or `ClientStrategy` service that can resolve the correct client implementation based on a configuration string.
    -   **Implementation**:
        ```csharp
        using System;
        using Microsoft.Extensions.DependencyInjection;

        namespace CodeContext.Core
        {
            public class ClientFactory
            {
                private readonly IServiceProvider _serviceProvider;

                public ClientFactory(IServiceProvider serviceProvider)
                {
                    _serviceProvider = serviceProvider;
                }

                public IEmbeddingProvider GetEmbeddingProvider(string providerType)
                {
                    return providerType.ToLowerInvariant() switch
                    {
                        "ollama" => _serviceProvider.GetRequiredService<OllamaProvider>(), // Concrete type will be registered
                        _ => throw new ArgumentException($"Unknown embedding provider type: {providerType}")
                    };
                }

                public IVectorDatabaseClient GetVectorDatabaseClient(string clientType)
                {
                    return clientType.ToLowerInvariant() switch
                    {
                        "qdrant" => _serviceProvider.GetRequiredService<QdrantClient>(), // Concrete type will be registered
                        _ => throw new ArgumentException($"Unknown vector database client type: {clientType}")
                    };
                }
            }
        }
        ```
    -   **Imports**: `using System;`, `using Microsoft.Extensions.DependencyInjection;`
3.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Register the `ClientFactory` with the DI container.
    -   **Implementation**:
        ```csharp
        builder.Services.AddSingleton<ClientFactory>();
        ```
    -   **Imports**: `using CodeContext.Core;`

**Acceptance Criteria:**
-   `IEmbeddingProvider` interface in `CodeContext.Core` includes `GenerateEmbeddingsAsync(List<string> texts)` method.
-   `IVectorDatabaseClient` interface in `CodeContext.Core` includes `UpsertAsync(string collectionName, List<VectorData> vectors)` and `QueryAsync(string collectionName, float[] vector, int topK)` methods, along with `VectorData` and `QueryResult` classes.
-   .NET's built-in dependency injection container is configured to allow registration and resolution of these interfaces.
-   A `ClientFactory` class exists in `CodeContext.Core` that can resolve client implementations based on a string.
-   The `ClientFactory` is registered with the DI container.
-   Unit tests (to be written in a separate test project) verify that the correct client is returned for a given configuration.

**Testing Plan:**
-   **Test Case 1**: (Conceptual, as concrete implementations are not yet present) Verify that the `IEmbeddingProvider` and `IVectorDatabaseClient` interfaces compile without errors.
-   **Test Case 2**: (Conceptual) Write a simple console application or a unit test project that attempts to resolve `ClientFactory` from the DI container and then calls its `GetEmbeddingProvider` and `GetVectorDatabaseClient` methods with dummy strings (e.g., "ollama", "qdrant") to ensure it compiles and the factory logic is sound (it will throw exceptions until concrete types are registered).
-   **Test Case 3**: (Conceptual) Ensure the `VectorData` and `QueryResult` classes are correctly defined and accessible.
</file>

<file path="docs/todo/fe/backlog_sprint_3_backend_process_management.md">
### User Story 1: Auto-Start C# Backend Service
**As a** developer, **I want the** VS Code extension to automatically start the C# backend service when the extension is activated, **so that** I don't have to run it manually.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts` (Assuming this is the main extension file)
    -   **Action**: Implement logic to spawn the C# backend executable using `child_process.spawn`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
        import * as path from 'path';

        let backendProcess: ChildProcessWithoutNullStreams | null = null;

        export function activate(context: vscode.ExtensionContext) {
            console.log('Code Context extension is now active!');

            // Determine the path to the C# backend executable
            // This path will depend on your build process and where the executable is placed.
            // Example: Assuming it's in a 'bin' folder relative to the extension root
            const backendExecutablePath = path.join(context.extensionPath, 'bin', 'CodeContext.Api'); // Adjust as needed

            backendProcess = spawn(backendExecutablePath, [], {
                cwd: path.dirname(backendExecutablePath), // Run from the executable's directory
                stdio: ['ignore', 'pipe', 'pipe'] // Ignore stdin, pipe stdout/stderr
            });

            backendProcess.stdout.on('data', (data) => {
                console.log(`Backend stdout: ${data}`);
                // You might want to log this to an output channel in VS Code
            });

            backendProcess.stderr.on('data', (data) => {
                console.error(`Backend stderr: ${data}`);
                // Log errors to an output channel
            });

            backendProcess.on('close', (code) => {
                console.log(`Backend process exited with code ${code}`);
                backendProcess = null;
                // Handle process exit, e.g., attempt restart or notify user
            });

            backendProcess.on('error', (err) => {
                console.error('Failed to start backend process:', err);
                vscode.window.showErrorMessage(`Failed to start Code Context backend: ${err.message}`);
                backendProcess = null;
            });

            // Add a disposable to ensure process is killed on deactivate
            context.subscriptions.push({
                dispose: () => {
                    if (backendProcess) {
                        console.log('Terminating backend process...');
                        backendProcess.kill(); // Send SIGTERM
                        backendProcess = null;
                    }
                }
            });
        }

        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill();
                backendProcess = null;
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { spawn, ChildProcessWithoutNullStreams } from 'child_process';`, `import * as path from 'path';`
2.  **Filepath**: `extension.ts`
    -   **Action**: Ensure the child process is terminated when the extension is deactivated.
    -   **Implementation**: (Included in the `activate` and `deactivate` functions above)
        ```typescript
        // In activate:
        context.subscriptions.push({
            dispose: () => {
                if (backendProcess) {
                    console.log('Terminating backend process...');
                    backendProcess.kill();
                    backendProcess = null;
                }
            }
        });

        // In deactivate:
        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill();
                backendProcess = null;
            }
        }
        ```
    -   **Imports**: None.

### User Story 2: Monitor Backend Service Health
**As a** developer, **I want the** extension to monitor the health of the C# backend service, **so that** it can reliably send API requests.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts`
    -   **Action**: Periodically send HTTP GET requests to the backend's `/health` endpoint.
    -   **Implementation**:
        ```typescript
        // Inside activate function, after spawning backendProcess
        const backendPort = 5000; // Or read from configuration
        const healthCheckInterval = 5000; // 5 seconds
        let healthCheckAttempts = 0;
        const maxHealthCheckAttempts = 10;
        let healthCheckTimer: NodeJS.Timeout | null = null;

        function startHealthCheck() {
            if (healthCheckTimer) {
                clearInterval(healthCheckTimer);
            }
            healthCheckTimer = setInterval(async () => {
                if (!backendProcess) {
                    console.log('Backend process not running, stopping health check.');
                    clearInterval(healthCheckTimer!);
                    return;
                }

                try {
                    const response = await fetch(`http://localhost:${backendPort}/health`);
                    if (response.ok) {
                        console.log('Backend is healthy.');
                        healthCheckAttempts = 0;
                        // Update UI state to "Running"
                        // vscode.window.showInformationMessage('Code Context Backend is Running!');
                        // If you have a webview, send a message to it
                        // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'running' });
                    } else {
                        console.warn(`Backend health check failed: ${response.status}`);
                        healthCheckAttempts++;
                        // Update UI state to "Starting" or "Error"
                        // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'starting' });
                        if (healthCheckAttempts >= maxHealthCheckAttempts) {
                            console.error('Max health check attempts reached. Attempting to restart backend.');
                            clearInterval(healthCheckTimer!);
                            restartBackend(); // Implement this function
                        }
                    }
                } catch (error) {
                    console.error('Error during backend health check:', error);
                    healthCheckAttempts++;
                    // Update UI state to "Error"
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'error' });
                    if (healthCheckAttempts >= maxHealthCheckAttempts) {
                        console.error('Max health check attempts reached. Attempting to restart backend.');
                        clearInterval(healthCheckTimer!);
                        restartBackend(); // Implement this function
                    }
                }
            }, healthCheckInterval);
        }

        function restartBackend() {
            if (backendProcess) {
                backendProcess.kill();
                backendProcess = null;
            }
            console.log('Restarting backend process...');
            // Re-call the spawn logic from activate, or a dedicated function
            // For simplicity, let's assume activate handles it, or create a startBackend function
            // startBackend(); // Call a function that encapsulates the spawning logic
            // For now, just log and let the user know
            vscode.window.showWarningMessage('Code Context Backend is restarting due to health check failures.');
            // In a real scenario, you'd re-run the spawn logic here.
            // For this backlog, we'll assume a simple restart mechanism.
            activate(context); // This is a simplified restart, might need more robust logic
        }

        // Call this after backendProcess is successfully spawned
        startHealthCheck();
        ```
    -   **Imports**: `import fetch from 'node-fetch';` (or `import { fetch } from 'undici';` for Node.js 18+)
2.  **Filepath**: `extension.ts`
    -   **Action**: Implement logic to restart the backend if health checks consistently fail.
    -   **Implementation**: (Included in the `startHealthCheck` and `restartBackend` functions above)
    -   **Imports**: None.

**Acceptance Criteria:**
-   The VS Code extension successfully launches the C# backend executable upon activation.
-   `stdout` and `stderr` from the backend process are captured and logged (e.g., to VS Code's output channel).
-   The backend process is reliably terminated when the extension is deactivated or VS Code is closed.
-   The extension periodically pings the backend's `/health` endpoint.
-   The extension can detect when the backend is unhealthy and attempts to restart it after a configurable number of failures.
-   (Implicit) The UI (webview) can receive status updates about the backend's health (e.g., "Starting", "Running", "Error").

**Testing Plan:**
-   **Test Case 1**: Activate the extension and verify that the C# backend process starts (check task manager/process list).
-   **Test Case 2**: Deactivate the extension and verify that the C# backend process is terminated.
-   **Test Case 3**: Introduce a deliberate error in the C# backend's `/health` endpoint (e.g., make it return 500) and observe if the extension attempts to restart the backend after multiple failures.
-   **Test Case 4**: Verify that backend `stdout` and `stderr` messages appear in the VS Code output channel (if implemented).
-   **Test Case 5**: (Manual) Observe the UI state changes (if a basic UI is already present) reflecting the backend's status.
</file>

<file path="docs/todo/fe/backlog_sprint_4_onboarding_setup_ui.md">
### User Story 1: Display Setup/Query UI Based on Index Status
**As Devin, when I open a new project, I want the** extension to check if it's been indexed and show me a setup screen if it hasn't.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts`
    -   **Action**: Check for the existence of `.vscode/code-context.json` on extension activation.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';

        // ... (existing imports and backend process management logic) ...

        export function activate(context: vscode.ExtensionContext) {
            // ... (existing backend process spawning and health check setup) ...

            // Create and show the webview panel
            const panel = vscode.window.createWebviewPanel(
                'codeContext', // Identifies the type of the webview
                'Code Context', // Title of the panel displayed to the user
                vscode.ViewColumn.One, // Editor column to show the new webview panel in
                {
                    enableScripts: true, // Enable JavaScript in the webview
                    localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                }
            );

            // Get path to SvelteKit build output
            const svelteAppPath = path.join(context.extensionPath, 'webview', 'dist', 'index.html');
            panel.webview.html = fs.readFileSync(svelteAppPath, 'utf8');

            // Check for code-context.json
            const workspaceFolders = vscode.workspace.workspaceFolders;
            let configFilePath: string | undefined;
            if (workspaceFolders && workspaceFolders.length > 0) {
                configFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'code-context.json');
            }

            let initialView: 'setup' | 'query' = 'setup';
            if (configFilePath && fs.existsSync(configFilePath)) {
                initialView = 'query';
            }

            // Send initial view state to webview
            panel.webview.postMessage({ type: 'initialView', view: initialView });

            // Handle messages from the webview
            panel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showInformationMessage(message.text);
                            return;
                        case 'startDocker':
                            // Handle Docker command execution
                            handleStartDockerCommand(message.service, context);
                            return;
                        // ... other commands
                    }
                },
                undefined,
                context.subscriptions
            );

            // Add panel to disposables
            context.subscriptions.push(panel);
        }

        // ... (deactivate function) ...
        ```
    -   **Imports**: `import * as fs from 'fs';`
2.  **Filepath**: `webview/src/lib/stores/viewStore.ts` (New File)
    -   **Action**: Create a Svelte store to manage the current view state (`'setup'` or `'query'`).
    -   **Implementation**:
        ```typescript
        import { writable } from 'svelte/store';

        export const currentView = writable<'setup' | 'query'>('setup'); // Default to setup
        ```
    -   **Imports**: `import { writable } from 'svelte/store';`
3.  **Filepath**: `webview/src/App.svelte` (Main Svelte component)
    -   **Action**: Render `SetupView.svelte` or `QueryView.svelte` based on the `currentView` store.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';

            onMount(() => {
                // Listen for messages from the VS Code extension
                window.addEventListener('message', event => {
                    const message = event.data; // The JSON data that the extension sent
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        // ... handle other messages like backend status
                    }
                });
            });
        </script>

        {#if $currentView === 'setup'}
            <SetupView />
        {:else if $currentView === 'query'}
            <QueryView />
        {/if}
        ```
    -   **Imports**: `import { onMount } from 'svelte';`, `import { currentView } from './lib/stores/viewStore';`, `import SetupView from './lib/components/SetupView.svelte';`, `import QueryView from './lib/components/QueryView.svelte';`

### User Story 2: Implement Setup UI with Docker Helper
**As Devin, I want the** setup screen to let me choose my database and embedding provider, with helper buttons to start any required local services.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/SetupView.svelte` (New File)
    -   **Action**: Create the Svelte component for the setup view with dropdowns for database/embedding provider and a "Start Local" button.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { createEventDispatcher } from 'svelte';
            import { postMessageToVsCode } from '../utils/vscode'; // Helper to send messages to extension

            const dispatch = createEventDispatcher();

            let selectedDatabase: string = 'qdrant'; // Default
            let selectedEmbeddingProvider: string = 'ollama'; // Default

            function handleStartLocalService(service: string) {
                postMessageToVsCode('startDocker', { service });
            }

            function handleSaveAndIndex() {
                // Send configuration to extension to save and trigger indexing
                postMessageToVsCode('saveConfigAndIndex', {
                    database: selectedDatabase,
                    embeddingProvider: selectedEmbeddingProvider
                });
            }
        </script>

        <div class="setup-container">
            <h1>Setup Code Context</h1>

            <section>
                <h2>Database Configuration</h2>
                <label for="database-select">Select Database:</label>
                <select id="database-select" bind:value={selectedDatabase}>
                    <option value="qdrant">Qdrant (Local)</option>
                    <!-- Add other options later -->
                </select>
                <button on:click={() => handleStartLocalService('qdrant')}>Start Local Qdrant</button>
                <!-- Add status indicator here -->
            </section>

            <section>
                <h2>Embedding Provider Configuration</h2>
                <label for="embedding-select">Select Embedding Provider:</label>
                <select id="embedding-select" bind:value={selectedEmbeddingProvider}>
                    <option value="ollama">Ollama (Local)</option>
                    <!-- Add other options later -->
                </select>
                <button on:click={() => handleStartLocalService('ollama')}>Start Local Ollama</button>
                <!-- Add status indicator here -->
            </section>

            <button on:click={handleSaveAndIndex}>Save & Index</button>
        </div>

        <style>
            /* Basic styling for layout */
            .setup-container {
                padding: 20px;
                font-family: sans-serif;
            }
            section {
                margin-bottom: 20px;
                border: 1px solid #ccc;
                padding: 15px;
                border-radius: 5px;
            }
            label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            select, button {
                margin-right: 10px;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid #ddd;
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                cursor: pointer;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
        </style>
        ```
    -   **Imports**: `import { createEventDispatcher } from 'svelte';`, `import { postMessageToVsCode } from '../utils/vscode';`
2.  **Filepath**: `webview/src/lib/utils/vscode.ts` (New File)
    -   **Action**: Create a utility function to send messages from the Svelte webview to the VS Code extension.
    -   **Implementation**:
        ```typescript
        // This is how you send messages from the webview to the extension
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        export function postMessageToVsCode(command: string, data: any) {
            vscode.postMessage({ command, ...data });
        }
        ```
    -   **Imports**: None (uses `declare const acquireVsCodeApi: any;` for VS Code API)
3.  **Filepath**: `extension.ts`
    -   **Action**: Implement `handleStartDockerCommand` to open a new VS Code terminal and run `docker-compose` commands.
    -   **Implementation**:
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        function handleStartDockerCommand(service: string, context: vscode.ExtensionContext) {
            let command: string;
            let terminalName: string;

            switch (service) {
                case 'qdrant':
                    command = 'docker-compose -f docker-compose.qdrant.yml up -d'; // Assuming a docker-compose file
                    terminalName = 'Qdrant Docker';
                    break;
                case 'ollama':
                    command = 'docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama'; // Example Ollama command
                    terminalName = 'Ollama Docker';
                    break;
                default:
                    vscode.window.showErrorMessage(`Unknown service to start: ${service}`);
                    return;
            }

            const terminal = vscode.window.createTerminal(terminalName);
            terminal.show();
            terminal.sendText(command);

            // Optional: You might want to poll for service health after starting Docker
            // and send a message back to the webview to update status.
            // For this backlog, we'll assume the command execution is sufficient.
        }
        ```
    -   **Imports**: None.
4.  **Filepath**: `webview/src/lib/components/QueryView.svelte` (New File)
    -   **Action**: Create a placeholder Svelte component for the query view.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            // Placeholder for future query functionality
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <p>Your code is indexed. Query functionality will be available here soon!</p>
            <!-- Future: input box, results display -->
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: sans-serif;
            }
        </style>
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   On extension activation, the webview panel is displayed.
-   If `.vscode/code-context.json` does not exist in the workspace root, the `SetupView` component is rendered.
-   If `.vscode/code-context.json` exists, the `QueryView` component is rendered.
-   The `SetupView` contains dropdowns for selecting database and embedding provider.
-   "Start Local" buttons are present next to the selections.
-   Clicking a "Start Local" button opens a new VS Code terminal and executes the corresponding Docker command.
-   (Implicit) The UI can receive and display status updates (e.g., "Running") for the Docker services.

**Testing Plan:**
-   **Test Case 1**: Start VS Code with an empty workspace (no `.vscode/code-context.json`). Verify the `SetupView` is displayed.
-   **Test Case 2**: Create an empty `.vscode/code-context.json` file in the workspace root. Restart VS Code. Verify the `QueryView` is displayed.
-   **Test Case 3**: In `SetupView`, click the "Start Local Qdrant" button. Verify a new terminal opens and the `docker-compose` command is executed.
-   **Test Case 4**: In `SetupView`, click the "Start Local Ollama" button. Verify a new terminal opens and the `docker run` command is executed.
-   **Test Case 5**: (Manual) Verify that the dropdowns in `SetupView` are functional.
</file>

<file path="docs/todo/fe/backlog_sprint_5_concrete_client_implementation.md">
### User Story 1: Implement Qdrant Client
**As Alisha, I want to** implement the concrete client for Qdrant, **so that** the backend can communicate with the vector database.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Infrastructure/CodeContext.Infrastructure.csproj`
    -   **Action**: Add the `Qdrant.Client` NuGet package.
    -   **Implementation**:
        ```xml
        <ItemGroup>
            <PackageReference Include="Qdrant.Client" Version="1.x.x" /> <!-- Use the latest stable version -->
        </ItemGroup>
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs` (New File)
    -   **Action**: Create `QdrantClient` class implementing `IVectorDatabaseClient` and its `UpsertAsync` method.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IVectorDatabaseClient, VectorData, QueryResult
        using Qdrant.Client;
        using Qdrant.Client.Grpc;

        namespace CodeContext.Infrastructure.DatabaseClients
        {
            public class QdrantClient : IVectorDatabaseClient
            {
                private readonly QdrantGrpcClient _client;
                private readonly string _host;
                private readonly int _port;

                public QdrantClient(string host, int port)
                {
                    _host = host;
                    _port = port;
                    _client = new QdrantGrpcClient(host, port);
                }

                public async Task UpsertAsync(string collectionName, List<VectorData> vectors)
                {
                    // Ensure collection exists (or create it)
                    var collections = await _client.Collections.ListAsync();
                    if (!collections.Any(c => c.Name == collectionName))
                    {
                        await _client.Collections.CreateAsync(
                            collectionName,
                            new VectorParams { Size = vectors.First().Vector.Length, Distance = Distance.Cosine } // Assuming all vectors have same size
                        );
                    }

                    var points = vectors.Select(v => new PointStruct
                    {
                        Id = v.Id,
                        Vectors = v.Vector.ToList(),
                        Payload = v.Payload.ToDictionary(p => p.Key, p => Value.From(p.Value)) // Convert payload to Qdrant's Value
                    }).ToList();

                    await _client.Points.UpsertAsync(collectionName, points);
                }

                public async Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK)
                {
                    var searchResult = await _client.Points.SearchAsync(
                        collectionName,
                        vector.ToList(),
                        limit: (ulong)topK
                    );

                    return searchResult.Select(s => new QueryResult
                    {
                        Id = s.Id,
                        Score = s.Score,
                        Payload = s.Payload.ToDictionary(p => p.Key, p => p.Value.ToValue()) // Convert Qdrant's Value back to object
                    }).ToList();
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Linq;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`, `using Qdrant.Client;`, `using Qdrant.Client.Grpc;`

### User Story 2: Implement Ollama Provider
**As Alisha, I want to** implement the concrete client for Ollama, **so that** the backend can generate embeddings.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs` (New File)
    -   **Action**: Create `OllamaProvider` class implementing `IEmbeddingProvider` and its `GenerateEmbeddingsAsync` method.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Net.Http;
        using System.Text;
        using System.Text.Json;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider

        namespace CodeContext.Infrastructure.EmbeddingProviders
        {
            public class OllamaProvider : IEmbeddingProvider
            {
                private readonly HttpClient _httpClient;
                private readonly string _ollamaApiUrl;
                private readonly string _modelName;

                public OllamaProvider(HttpClient httpClient, string ollamaApiUrl, string modelName)
                {
                    _httpClient = httpClient;
                    _ollamaApiUrl = ollamaApiUrl;
                    _modelName = modelName;
                }

                public async Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts)
                {
                    var embeddings = new List<float[]>();
                    foreach (var text in texts)
                    {
                        var requestBody = new
                        {
                            model = _modelName,
                            prompt = text
                        };

                        var json = JsonSerializer.Serialize(requestBody);
                        var content = new StringContent(json, Encoding.UTF8, "application/json");

                        var response = await _httpClient.PostAsync($"{_ollamaApiUrl}/api/embeddings", content);
                        response.EnsureSuccessStatusCode(); // Throws an exception if not 2xx

                        var responseBody = await response.Content.ReadAsStringAsync();
                        var jsonDoc = JsonDocument.Parse(responseBody);
                        var embeddingArray = jsonDoc.RootElement.GetProperty("embedding").EnumerateArray().Select(e => (float)e.GetDouble()).ToArray();
                        embeddings.Add(embeddingArray);
                    }
                    return embeddings;
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Linq;`, `using System.Net.Http;`, `using System.Text;`, `using System.Text.Json;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`

### User Story 3: Implement AST Parsing and Indexing Service
**As Alisha, I want to** integrate AST parsing and create an indexing service, **so that** the backend can process code and store embeddings.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/Services/ParsingService.cs` (New File)
    -   **Action**: Create `ParsingService` to handle Abstract Syntax Tree (AST) parsing of code files. (Conceptual, as specific AST library is not chosen yet).
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core.Services
        {
            public class ParsingService
            {
                public Task<List<string>> ParseCodeFileAsync(string filePath)
                {
                    // This is a placeholder. Actual implementation would use a library
                    // like Microsoft.CodeAnalysis (Roslyn) for C#, or similar for other languages.
                    // It would extract meaningful code snippets, function definitions, etc.
                    return Task.FromResult(new List<string> { $"Content of {filePath} for embedding." });
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`
2.  **Filepath**: `CodeContext.Core/Services/IndexingService.cs` (New File)
    -   **Action**: Create `IndexingService` to orchestrate the indexing workflow (parsing, embedding, upserting).
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider, IVectorDatabaseClient, VectorData

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                private readonly ParsingService _parsingService;
                private readonly IEmbeddingProvider _embeddingProvider;
                private readonly IVectorDatabaseClient _vectorDatabaseClient;

                public IndexingService(
                    ParsingService parsingService,
                    IEmbeddingProvider embeddingProvider,
                    IVectorDatabaseClient vectorDatabaseClient)
                {
                    _parsingService = parsingService;
                    _embeddingProvider = embeddingProvider;
                    _vectorDatabaseClient = vectorDatabaseClient;
                }

                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName)
                {
                    // Placeholder: In a real scenario, you'd enumerate files in repositoryPath
                    // and process them.
                    var filePaths = new List<string> {
                        "path/to/file1.cs",
                        "path/to/file2.ts"
                    };

                    foreach (var filePath in filePaths)
                    {
                        var codeSnippets = await _parsingService.ParseCodeFileAsync(filePath);
                        if (codeSnippets.Any())
                        {
                            var embeddings = await _embeddingProvider.GenerateEmbeddingsAsync(codeSnippets);

                            var vectorsToUpsert = new List<VectorData>();
                            for (int i = 0; i < embeddings.Count; i++)
                            {
                                vectorsToUpsert.Add(new VectorData
                                {
                                    Id = $"{filePath}_{i}", // Unique ID for each snippet
                                    Vector = embeddings[i],
                                    Payload = new Dictionary<string, object> { { "filePath", filePath }, { "snippet", codeSnippets[i] } }
                                });
                            }
                            await _vectorDatabaseClient.UpsertAsync(collectionName, vectorsToUpsert);
                        }
                    }
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`

### User Story 4: Register Services and Create Index Endpoint
**As Alisha, I want to** register all new services with the DI container and create an `/index` endpoint, **so that** the API can trigger the indexing process.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Register `QdrantClient`, `OllamaProvider`, `ParsingService`, and `IndexingService` with the DI container.
    -   **Implementation**:
        ```csharp
        using CodeContext.Core;
        using CodeContext.Core.Services;
        using CodeContext.Infrastructure.DatabaseClients;
        using CodeContext.Infrastructure.EmbeddingProviders;
        using System.Net.Http; // For HttpClient

        // ... existing builder.Services ...

        // Register HttpClient for OllamaProvider
        builder.Services.AddHttpClient<OllamaProvider>(); // Registers HttpClient and OllamaProvider

        // Register concrete client implementations
        // For QdrantClient, you might need configuration for host/port
        builder.Services.AddSingleton<IVectorDatabaseClient>(sp =>
        {
            // Read configuration for Qdrant host/port
            var configuration = sp.GetRequiredService<IConfiguration>();
            var qdrantHost = configuration["Qdrant:Host"] ?? "localhost";
            var qdrantPort = int.Parse(configuration["Qdrant:Port"] ?? "6334");
            return new QdrantClient(qdrantHost, qdrantPort);
        });

        builder.Services.AddSingleton<IEmbeddingProvider>(sp =>
        {
            // Read configuration for Ollama API URL and model name
            var configuration = sp.GetRequiredService<IConfiguration>();
            var ollamaApiUrl = configuration["Ollama:ApiUrl"] ?? "http://localhost:11434";
            var ollamaModel = configuration["Ollama:Model"] ?? "llama2"; // Default model
            var httpClient = sp.GetRequiredService<HttpClient>(); // Get HttpClient from DI
            return new OllamaProvider(httpClient, ollamaApiUrl, ollamaModel);
        });

        // Register services
        builder.Services.AddSingleton<ParsingService>();
        builder.Services.AddSingleton<IndexingService>();

        // ... existing app.MapGet("/health") ...
        ```
    -   **Imports**: `using CodeContext.Core;`, `using CodeContext.Core.Services;`, `using CodeContext.Infrastructure.DatabaseClients;`, `using CodeContext.Infrastructure.EmbeddingProviders;`, `using System.Net.Http;`, `using Microsoft.Extensions.Configuration;`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Create a `POST /index` endpoint that triggers the `IndexingService`.
    -   **Implementation**:
        ```csharp
        // ... existing app.MapGet("/health") ...

        app.MapPost("/index", async (IndexingService indexingService) =>
        {
            // In a real scenario, you'd get the repository path from the request or configuration
            // For now, use a placeholder or read from appsettings.json
            var repositoryPath = "/path/to/your/code/repository"; // Placeholder
            var collectionName = "code_context_collection"; // Placeholder

            await indexingService.IndexRepositoryAsync(repositoryPath, collectionName);
            return Results.Ok("Indexing started.");
        });

        app.Run();
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   `Qdrant.Client` NuGet package is added to `CodeContext.Infrastructure`.
-   `QdrantClient` class implements `IVectorDatabaseClient` and correctly handles `UpsertAsync` and `QueryAsync` (though `QueryAsync` is not explicitly tested in this sprint's AC).
-   `OllamaProvider` class implements `IEmbeddingProvider` and correctly makes HTTP requests to Ollama and parses responses.
-   `ParsingService` and `IndexingService` classes are created in `CodeContext.Core/Services`.
-   All new services (`QdrantClient`, `OllamaProvider`, `ParsingService`, `IndexingService`) are registered with the DI container in `Program.cs`.
-   A `POST /index` endpoint exists in the API that triggers the `IndexingService`.

**Testing Plan:**
-   **Test Case 1**: Build the C# solution (`dotnet build CodeContext.sln`). Ensure no compilation errors.
-   **Test Case 2**: Run the API project (`dotnet run --project CodeContext.Api`).
-   **Test Case 3**: Use a tool like Postman or `curl` to send a `POST` request to `http://localhost:<port>/index`. Verify a `200 OK` response and that the indexing process (even if placeholder) is initiated.
-   **Test Case 4**: (Requires local Qdrant and Ollama instances) Start local Qdrant and Ollama containers. Run the API and trigger the `/index` endpoint. Observe logs for successful communication with Qdrant and Ollama. Verify data is inserted into Qdrant (e.g., using Qdrant's API or UI).
-   **Test Case 5**: (Unit Tests) Write unit tests for `QdrantClient` and `OllamaProvider` using mocking frameworks (e.g., Moq) to ensure their methods behave as expected without requiring actual external services.
</file>

<file path="docs/todo/fe/backlog_sprint_6_end_to_end_indexing_query_ui.md">
### User Story 1: Real-time Indexing Progress Feedback
**As Devin, I want to** click the "Index Now" button and see a progress bar while my code is being indexed, **so that** I have clear feedback on the process.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/Services/IndexingService.cs`
    -   **Action**: Implement a mechanism (e.g., `IProgress<T>`) to report progress updates during indexing.
    -   **Implementation**:
        ```csharp
        using System; // For Action
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core;

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                // ... (constructor and existing fields) ...

                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName, IProgress<int>? progress = null)
                {
                    // Simulate file discovery
                    var allFiles = new List<string> {
                        Path.Combine(repositoryPath, "src", "Program.cs"),
                        Path.Combine(repositoryPath, "src", "Utils.ts"),
                        Path.Combine(repositoryPath, "src", "AnotherFile.cs")
                    };
                    int totalFiles = allFiles.Count;
                    int processedFiles = 0;

                    foreach (var filePath in allFiles)
                    {
                        // ... (existing parsing, embedding, upserting logic) ...
                        processedFiles++;
                        int percentage = (int)((double)processedFiles / totalFiles * 100);
                        progress?.Report(percentage); // Report progress
                        await Task.Delay(100); // Simulate work
                    }
                }
            }
        }
        ```
    -   **Imports**: `using System;`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Create a Server-Sent Events (SSE) endpoint to stream progress updates from the backend to the UI.
    -   **Implementation**:
        ```csharp
        // ... existing imports ...
        using Microsoft.AspNetCore.Http; // For HttpContext
        using System.Threading.Channels; // For Channel

        // ... existing app.MapPost("/index") ...

        // Define a channel for broadcasting progress updates
        var progressChannel = Channel.CreateUnbounded<int>();

        app.MapPost("/index", async (IndexingService indexingService, HttpContext httpContext) =>
        {
            var repositoryPath = "/Users/bramburn/dev/bigcontext";
            var collectionName = "code_context_collection";

            // Create a progress reporter that pushes to the channel
            var progressReporter = new Progress<int>(percentage =>
            {
                progressChannel.Writer.TryWrite(percentage);
            });

            // Run indexing in a background task so the HTTP request can return quickly
            _ = Task.Run(async () =>
            {
                try
                {
                    await indexingService.IndexRepositoryAsync(repositoryPath, collectionName, progressReporter);
                    progressChannel.Writer.TryWrite(100); // Indicate completion
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Indexing error: {ex.Message}");
                    // Optionally send an error message through the channel or a separate mechanism
                }
            });

            return Results.Accepted(); // Return 202 Accepted
        });

        app.MapGet("/index-progress", async (HttpContext httpContext) =>
        {
            httpContext.Response.Headers.Add("Content-Type", "text/event-stream");
            httpContext.Response.Headers.Add("Cache-Control", "no-cache");
            httpContext.Response.Headers.Add("Connection", "keep-alive");

            await foreach (var percentage in progressChannel.Reader.ReadAllAsync(httpContext.RequestAborted))
            {
                await httpContext.Response.WriteAsync($"data: {percentage}\n\n");
                await httpContext.Response.Body.FlushAsync();
            }
        });

        app.Run();
        ```
    -   **Imports**: `using Microsoft.AspNetCore.Http;`, `using System.Threading.Channels;`
3.  **Filepath**: `webview/src/lib/components/IndexingView.svelte` (New File)
    -   **Action**: Create `IndexingView.svelte` with a progress bar and connect it to the SSE endpoint.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount, onDestroy } from 'svelte';
            import { postMessageToVsCode } from '../utils/vscode';
            import { currentView } from '../stores/viewStore';

            let progressPercentage: number = 0;
            let indexingStatus: string = 'Starting indexing...';
            let eventSource: EventSource | null = null;

            onMount(() => {
                // Start indexing process on mount (or when triggered by a button click)
                // For now, we'll assume it's triggered by the extension after config save.
                // In a real scenario, the "Save & Index" button in SetupView would trigger this.
                // postMessageToVsCode('startIndexing'); // Send message to extension to start backend indexing

                // Connect to SSE endpoint for progress updates
                eventSource = new EventSource('http://localhost:5000/index-progress'); // Adjust port if needed

                eventSource.onmessage = (event) => {
                    const percentage = parseInt(event.data, 10);
                    if (!isNaN(percentage)) {
                        progressPercentage = percentage;
                        indexingStatus = `Indexing progress: ${percentage}%`;
                        if (percentage >= 100) {
                            indexingStatus = 'Indexing complete!';
                            setTimeout(() => {
                                currentView.set('query'); // Transition to query view
                            }, 1000); // Give a moment for user to see 100%
                        }
                    }
                };

                eventSource.onerror = (error) => {
                    console.error('EventSource failed:', error);
                    indexingStatus = 'Indexing failed or disconnected.';
                    eventSource?.close();
                };
            });

            onDestroy(() => {
                eventSource?.close(); // Close the connection when component is destroyed
            });
        </script>

        <div class="indexing-container">
            <h1>Indexing Your Codebase</h1>
            <p>{indexingStatus}</p>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: {progressPercentage}%;"></div>
            </div>
            <p>{progressPercentage}%</p>
        </div>

        <style>
            .indexing-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            .progress-bar-container {
                width: 100%;
                background-color: var(--vscode-editorGroup-background);
                border: 1px solid var(--vscode-panel-border);
                border-radius: 5px;
                height: 20px;
                overflow: hidden;
            }
            .progress-bar {
                height: 100%;
                background-color: var(--vscode-progressBar-background);
                width: 0%;
                transition: width 0.3s ease-in-out;
            }
        </style>
        ```
    -   **Imports**: `import { onMount, onDestroy } from 'svelte';`, `import { postMessageToVsCode } from '../utils/vscode';`, `import { currentView } from '../stores/viewStore';`
4.  **Filepath**: `webview/src/App.svelte`
    -   **Action**: Update `App.svelte` to render `IndexingView` when indexing is in progress.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';
            import IndexingView from './lib/components/IndexingView.svelte'; // New import

            onMount(() => {
                window.addEventListener('message', event => {
                    const message = event.data;
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        case 'startIndexingUI': // Message from extension to show indexing view
                            currentView.set('indexing');
                            break;
                        // ... handle other messages
                    }
                });
            });
        </script>

        <main>
            {#if $currentView === 'setup'}
                <SetupView />
            {:else if $currentView === 'indexing'}
                <IndexingView />
            {:else if $currentView === 'query'}
                <QueryView />
            {/if}
        </main>
        ```
    -   **Imports**: `import IndexingView from './lib/components/IndexingView.svelte';`
5.  **Filepath**: `webview/src/lib/stores/viewStore.ts`
    -   **Action**: Update `currentView` store to include `'indexing'` state.
    -   **Implementation**:
        ```typescript
        import { writable } from 'svelte/store';

        export const currentView = writable<'setup' | 'indexing' | 'query'>('setup');
        ```
    -   **Imports**: None.

### User Story 2: Implement Core Query View
**As Devin, after indexing is complete, I want to** see a chat input box where I can type a question to find relevant code.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/QueryView.svelte`
    -   **Action**: Implement the `QueryView.svelte` component with a text input and a submit button, and a display area for results.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { postMessageToVsCode } from '../utils/vscode';

            let query: string = '';
            let searchResults: { filePath: string; snippet: string }[] = [];
            let isLoading: boolean = false;

            async function handleQuerySubmit() {
                if (!query.trim()) return;

                isLoading = true;
                searchResults = []; // Clear previous results

                // Send query to VS Code extension, which will forward to backend
                const response = await postMessageToVsCode('submitQuery', { query });

                // Assuming the extension sends back the results via a message
                // For now, we'll simulate or expect a direct return if possible (less ideal for async)
                // In a real scenario, the extension would send a message back to the webview
                // with the results, and this component would listen for it.
                // For this backlog, let's assume postMessageToVsCode can return a promise with results.
                // (This is a simplification for the backlog, actual implementation needs a message listener)
                if (response && response.type === 'queryResults') {
                    searchResults = response.results;
                } else {
                    // Simulate results for backlog purposes
                    searchResults = [
                        { filePath: "/path/to/file1.cs", snippet: "public class MyClass { /* ... */ }" },
                        { filePath: "/path/to/file2.ts", snippet: "function calculateSum(a: number, b: number) { /* ... */ }" }
                    ];
                }

                isLoading = false;
            }
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <div class="query-input-area">
                <input
                    type="text"
                    placeholder="Ask a question about your codebase..."
                    bind:value={query}
                    on:keydown={(e) => { if (e.key === 'Enter') handleQuerySubmit(); }}
                />
                <button on:click={handleQuerySubmit} disabled={isLoading}>
                    {#if isLoading}Searching...{:else}Search{/if}
                </button>
            </div>

            {#if searchResults.length > 0}
                <div class="search-results">
                    <h2>Results:</h2>
                    {#each searchResults as result}
                        <div class="result-item">
                            <h3>{result.filePath}</h3>
                            <pre><code>{result.snippet}</code></pre>
                        </div>
                    {/each}
                </div>
            {:else if !isLoading}
                <p>No results yet. Type a query above.</p>
            {/if}
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            .query-input-area {
                display: flex;
                margin-bottom: 20px;
            }
            .query-input-area input {
                flex-grow: 1;
                padding: 10px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border-radius: 4px;
                margin-right: 10px;
            }
            .query-input-area button {
                padding: 10px 15px;
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }
            button:hover:not(:disabled) {
                background-color: var(--vscode-button-hoverBackground);
            }
            button:disabled {
                opacity: 0.6;
                cursor: not-allowed;
            }
            .search-results {
                margin-top: 20px;
            }
            .result-item {
                background-color: var(--vscode-editorGroup-background);
                border: 1px solid var(--vscode-panel-border);
                padding: 15px;
                margin-bottom: 10px;
                border-radius: 5px;
            }
            .result-item h3 {
                margin-top: 0;
                color: var(--vscode-textLink-foreground);
            }
            .result-item pre {
                background-color: var(--vscode-editor-background);
                padding: 10px;
                border-radius: 3px;
                overflow-x: auto;
            }
        </style>
        ```
    -   **Imports**: `import { postMessageToVsCode } from '../utils/vscode';`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Implement a `POST /query` endpoint that takes a query string, generates an embedding, performs a vector search, and returns relevant file paths.
    -   **Implementation**:
        ```csharp
        // ... existing imports ...
        using CodeContext.Core.Services; // For IndexingService (and now QueryService)

        // ... existing endpoints ...

        app.MapPost("/query", async (QueryRequest request, IndexingService indexingService, IEmbeddingProvider embeddingProvider, IVectorDatabaseClient vectorDatabaseClient) =>
        {
            if (string.IsNullOrWhiteSpace(request.QueryText))
            {
                return Results.BadRequest("Query text cannot be empty.");
            }

            var collectionName = "code_context_collection"; // Must match indexing collection

            try
            {
                // 1. Generate embedding for the query text
                var queryEmbedding = (await embeddingProvider.GenerateEmbeddingsAsync(new List<string> { request.QueryText })).FirstOrDefault();
                if (queryEmbedding == null)
                {
                    return Results.Problem("Failed to generate embedding for query.", statusCode: 500);
                }

                // 2. Perform vector search
                var searchResults = await vectorDatabaseClient.QueryAsync(collectionName, queryEmbedding, topK: 5); // Get top 5 results

                // 3. Format results for UI
                var formattedResults = searchResults.Select(r => new QueryResponseItem
                {
                    FilePath = r.Payload.ContainsKey("filePath") ? r.Payload["filePath"].ToString() : "Unknown Path",
                    Snippet = r.Payload.ContainsKey("snippet") ? r.Payload["snippet"].ToString() : "No snippet available"
                }).ToList();

                return Results.Ok(formattedResults);
            }
            catch (Exception ex)
            {
                return Results.Problem($"Query failed: {ex.Message}", statusCode: 500);
            }
        });

        app.Run();

        // Define request and response models for the query endpoint
        public record QueryRequest(string QueryText);
        public record QueryResponseItem(string FilePath, string Snippet);
        ```
    -   **Imports**: `using CodeContext.Core.Services;`
3.  **Filepath**: `extension.ts`
    -   **Action**: Handle `submitQuery` message from webview, forward to backend, and send results back to webview.
    -   **Implementation**:
        ```typescript
        // ... (inside activate function, in panel.webview.onDidReceiveMessage) ...
        case 'submitQuery':
            try {
                const queryText = message.query;
                const backendUrl = `http://localhost:${backendPort}/query`;
                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ queryText })
                });

                if (response.ok) {
                    const results = await response.json();
                    panel.webview.postMessage({ type: 'queryResults', results });
                } else {
                    const errorText = await response.text();
                    vscode.window.showErrorMessage(`Backend query failed: ${response.status} - ${errorText}`);
                    panel.webview.postMessage({ type: 'queryResults', results: [] }); // Send empty results on error
                }
            } catch (error: any) {
                vscode.window.showErrorMessage(`Error sending query to backend: ${error.message}`);
                panel.webview.postMessage({ type: 'queryResults', results: [] });
            }
            return;
        // ...
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   Clicking "Save & Index" (from SetupView) or a dedicated "Index Now" button (if added) triggers the indexing process in the backend.
-   The Svelte UI displays a progress bar that updates in real-time based on progress events streamed from the backend.
-   Upon successful completion of indexing (100% progress), the UI automatically transitions from `IndexingView` to `QueryView`.
-   The `QueryView` component features a text input field and a submit button.
-   Typing a query and submitting it sends a `POST` request to the C# backend's `/query` endpoint.
-   The backend successfully generates an embedding for the query, performs a vector search, and returns a list of relevant file paths and snippets.
-   The `QueryView` displays the returned search results in a clear, readable format.

**Testing Plan:**
-   **Test Case 1**: Start the extension with no `code-context.json`. Go through the setup, click "Save & Index". Verify `IndexingView` appears and the progress bar updates.
-   **Test Case 2**: Observe the console logs of the C# backend to confirm indexing progress is being reported.
-   **Test Case 3**: After indexing completes, verify the UI automatically transitions to `QueryView`.
-   **Test Case 4**: In `QueryView`, type a simple query (e.g., "how to calculate sum") and click "Search".
-   **Test Case 5**: Observe the C# backend logs to confirm the query was received, embedding generated, and search performed.
-   **Test Case 6**: Verify that the `QueryView` displays the returned file paths and snippets.
-   **Test Case 7**: (Edge Case) Test with an empty query or a query that yields no results.
</file>

<file path="docs/todo/fe/backlog_sub_sprint_1_database_configuration_component.md">
# Backlog: Sub-Sprint 1 - Database Configuration Component

**Objective:** To build the Svelte component for the database selection and management part of the setup view.

**Parent Sprint:** Sprint 1: Setup View Implementation

---

### User Story: Manage Database Configuration

**As a** new user (Devin), **I want to** select my vector database, start it if needed, and see its status, **so that** I can prepare my project for indexing.

**Workflow:**
1.  The `DatabaseSetup.svelte` component renders a dropdown for database selection and a button to start the local service.
2.  A status indicator shows the current state of the database (e.g., "Not Running", "Running").
3.  Clicking the "Start" button sends a message to the extension backend.
4.  The backend runs the necessary command and sends a status update back to the webview.

**File Changes:**
*   `webview/src/lib/components/DatabaseSetup.svelte` (New File)
*   `src/extension.ts` (Modification)
*   `webview/src/lib/stores/setupStore.ts` (Modification)

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte` (New File)
    *   **Action**: Build the UI with a Fluent UI `<Select>` component for database choice (initially just "Qdrant") and a `<Button>` to start the service.
    *   **Implementation**:
        ```html
        <script lang="ts">
          import { Button, Select } from '@svelte-fui/core';
          import { setupState } from '$lib/stores/setupStore';
          // ... message handling logic ...
        </script>
        <h2>Database Configuration</h2>
        <Select items={['Qdrant']} placeholder="Select a database" />
        <Button on:click={startDatabase}>Start Local Qdrant</Button>
        <span>Status: {$setupState.databaseReady ? 'Running' : 'Not Running'}</span>
        ```
    *   **Imports**: `@svelte-fui/core`, `../stores/setupStore`
2.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Implement the `startDatabase` function to send a `startDatabase` message via `postMessage`.
    *   **Implementation**: `const vscode = acquireVsCodeApi(); function startDatabase() { vscode.postMessage({ command: 'startDatabase' }); }`
    *   **Imports**: None.
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Add a case for `startDatabase` in the `onDidReceiveMessage` listener. This should execute the `docker-compose up` command in a new terminal.
    *   **Implementation**: `case 'startDatabase': const terminal = vscode.window.createTerminal('Qdrant'); terminal.sendText('docker-compose up'); terminal.show(); break;`
    *   **Imports**: `vscode`
4.  **Filepath**: `src/extension.ts`
    *   **Action**: Implement a basic health check loop after starting the database. On success, `postMessage` to the webview with the updated status.
    *   **Implementation**: Use `setTimeout` and a fetch-like request to the Qdrant health endpoint. `panel.webview.postMessage({ command: 'databaseStatus', status: 'running' });`
    *   **Imports**: None.
5.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Add a listener for messages from the extension to update the `setupState` store.
    *   **Implementation**: `window.addEventListener('message', event => { const message = event.data; if (message.command === 'databaseStatus' && message.status === 'running') { setupState.update(s => ({ ...s, databaseReady: true })); } });`
    *   **Imports**: `setupState` from store.

**Acceptance Criteria:**
-   The dropdown displays "Qdrant" as an option.
-   Clicking the button successfully opens a terminal and runs `docker-compose up`.
-   The UI status correctly reflects the health status received from the backend, changing from "Not Running" to "Running".
-   The `databaseReady` state in the Svelte store is updated correctly.

**Dependencies:**
-   VS Code extension boilerplate must be complete.
-   A `docker-compose.yml` file must exist in the project root.
</file>

<file path="docs/todo/fe/implementation_sprint_1_setup_view_implementation.md">
# Implementation Guidance: Sprint 1 - Setup View Implementation

**Objective:** To provide the technical guidance, code examples, and API information needed to build the onboarding and setup UI using SvelteKit, Fluent UI, and the VS Code Webview API.

---

### 1. Scaffolding the SvelteKit Project in `webview/`

Since the `webview` directory is empty, you will need to create a new SvelteKit project there. This will serve as the foundation for the entire UI.

**Command:**
```bash
# Navigate to the project root
cd /Users/bramburn/dev/bigcontext

# Create a new SvelteKit project inside the webview directory
npm create svelte@latest webview

# Follow the prompts:
# ? Which Svelte app template? › SvelteKit demo app
# ? Add type checking with TypeScript? › Yes, using TypeScript syntax
# ? Select additional options › ESLint, Prettier
```

After creation, `cd webview` and run `npm install`.

### 2. Configuring SvelteKit for VS Code Webviews

For a webview, the SvelteKit app must be exported as a static, single-page application (SPA).

**1. Install Static Adapter:**
```bash
cd /Users/bramburn/dev/bigcontext/webview
npm install -D @sveltejs/adapter-static@next
```

**2. Configure `svelte.config.js`:**
Modify `webview/svelte.config.js` to use the static adapter. This ensures all UI assets are bundled into a `build` directory with predictable paths.

```javascript
// webview/svelte.config.js
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/kit/vite';

/** @type {import('@sveltejs/kit').Config} */
const config = {
    preprocess: vitePreprocess(),
    kit: {
        adapter: adapter({
            pages: 'build',
            assets: 'build',
            fallback: 'index.html', // Important for SPA behavior
            precompress: false
        }),
        // This is crucial for resolving asset paths correctly inside the webview
        paths: {
            base: '{{vscode-resource-base}}' // A placeholder we will replace
        },
        appDir: 'app'
    }
};

export default config;
```

### 3. Integrating Fluent UI

We will use `svelte-fui`, a community-maintained library for Fluent UI components in Svelte.

**1. Install Dependencies:**
```bash
cd /Users/bramburn/dev/bigcontext/webview
npm install @svelte-fui/core @svelte-fui/tailwindcss
```

**2. Configure TailwindCSS:**
Create `webview/tailwind.config.js` and add the `svelte-fui` preset.
```javascript
// webview/tailwind.config.js
/** @type {import('tailwindcss').Config}*/
const config = {
  content: ['./src/**/*.{html,js,svelte,ts}'],
  presets: [require('@svelte-fui/tailwindcss').preset()],
  theme: {
    extend: {}
  },
  plugins: []
};

module.exports = config;
```
You will also need to set up Tailwind by creating `postcss.config.js` and `src/app.css` as per the SvelteKit Tailwind integration docs.

### 4. Webview Panel Creation and Communication (`src/extension.ts`)

This is the core logic for loading and interacting with the Svelte UI from the extension host.

**1. Loading the UI:**
The `createWebviewPanel` function loads the `index.html` from the SvelteKit `build` directory. We must replace the asset paths with special `vscode-resource` URIs.

```typescript
// src/extension.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

function createWebviewPanel(context: vscode.ExtensionContext) {
    const panel = vscode.window.createWebviewPanel(
        'setupView',
        'Code Context Setup',
        vscode.ViewColumn.One,
        {
            enableScripts: true,
            localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'webview', 'build')]
        }
    );

    const buildPath = vscode.Uri.joinPath(context.extensionUri, 'webview', 'build').fsPath;
    let html = fs.readFileSync(path.join(buildPath, 'index.html'), 'utf8');

    // Create the base URI for webview resources
    const baseUri = panel.webview.asWebviewUri(vscode.Uri.file(buildPath)).toString();
    // Replace our placeholder with the correct base URI
    html = html.replace('{{vscode-resource-base}}', baseUri);

    panel.webview.html = html;
    return panel;
}
```

**2. Bidirectional Messaging:**
Communication relies on `panel.webview.postMessage` and `panel.webview.onDidReceiveMessage`.

*   **From Extension to Webview:**
    ```typescript
    // src/extension.ts
    // Example: Sending database status to the UI
    panel.webview.postMessage({ command: 'databaseStatus', status: 'Running' });
    ```

*   **From Webview to Extension:**
    First, get the VS Code API instance in your Svelte component.
    ```html
    <!-- webview/src/lib/components/DatabaseSetup.svelte -->
    <script lang="ts">
        const vscode = acquireVsCodeApi();

        function startDatabase() {
            vscode.postMessage({
                command: 'startDatabase',
                payload: { type: 'qdrant' }
            });
        }
    </script>
    <Button on:click={startDatabase}>Start Local Qdrant</Button>
    ```
    Then, handle the message in `extension.ts`.
    ```typescript
    // src/extension.ts
    panel.webview.onDidReceiveMessage(message => {
        switch (message.command) {
            case 'startDatabase':
                const terminal = vscode.window.createTerminal(`Qdrant DB`);
                terminal.sendText('docker-compose up');
                terminal.show();
                // Here you would add logic to health-check the DB
                // and post a message back to the webview on success.
                return;
        }
    });
    ```

### 5. Running Commands in a Terminal

The `vscode.window.createTerminal` API is used to create and manage terminal instances from the extension.

**API Reference:** `vscode.window.createTerminal`
*   **`name`**: A string that is shown in the terminal's dropdown.
*   **`shellPath`**: (Optional) Path to a custom shell executable.
*   **`shellArgs`**: (Optional) Arguments for the shell.

**Example:**
```typescript
// src/extension.ts
// This creates a new terminal named "My Command" and runs "echo Hello"
const terminal = vscode.window.createTerminal("My Command");
terminal.sendText("echo Hello");
terminal.show(); // Makes the terminal visible to the user
```
For the PRD requirement, you will use `terminal.sendText('docker-compose up');`. You should also advise the user that this requires `docker-compose.yml` to be present in the workspace root and Docker to be running.
</file>

<file path="docs/todo/fe/implementation_sprint_1_web_api_boilerplate.md">
### How to Implement Sprint 1: C# Web API Boilerplate

This sprint focuses on setting up the foundational C# ASP.NET Core Web API project with a clean architecture.

**Key Technologies and Concepts:**

*   **ASP.NET Core Minimal APIs:** A simplified approach to building HTTP APIs in .NET 6 and later, reducing boilerplate code.
*   **.NET CLI:** Command-line interface for developing .NET applications.
*   **Dependency Injection (DI):** Built-in feature in ASP.NET Core for managing object dependencies, promoting loose coupling.
*   **Swagger/OpenAPI:** Tools for documenting and testing RESTful APIs.
*   **Clean Architecture:** Organizing code into layers (e.g., Core, Infrastructure, API) to separate concerns and improve maintainability.

**Detailed Implementation Steps and Code Examples:**

1.  **Create .NET Solution and Projects:**
    Use the `dotnet new` command to scaffold the solution and projects.
    *   **Command:**
        ```bash
        dotnet new sln -n CodeContext
        dotnet new webapi -n CodeContext.Api -o CodeContext.Api
        dotnet new classlib -n CodeContext.Core -o CodeContext.Core
        dotnet new classlib -n CodeContext.Infrastructure -o CodeContext.Infrastructure
        dotnet sln CodeContext.sln add CodeContext.Api/CodeContext.Api.csproj
        dotnet sln CodeContext.sln add CodeContext.Core/CodeContext.Core.csproj
        dotnet sln CodeContext.sln add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj
        ```
    *   **Guidance:** The `-o` flag creates the project in a new directory. `dotnet sln add` links the projects to the solution file.

2.  **Set Project References:**
    Edit the `CodeContext.Api.csproj` file to add references to the Core and Infrastructure projects. This allows the API layer to access types defined in the other layers.
    *   **File:** `CodeContext.Api/CodeContext.Api.csproj`
    *   **Code Example (add inside `<Project>` tag):**
        ```xml
        <ItemGroup>
            <ProjectReference Include="..\CodeContext.Core\CodeContext.Core.csproj" />
            <ProjectReference Include="..\CodeContext.Infrastructure\CodeContext.Infrastructure.csproj" />
        </ItemGroup>
        ```
    *   **Guidance:** Ensure the `Include` paths correctly point to the `.csproj` files of the Core and Infrastructure projects relative to the API project.

3.  **Implement Health Check Endpoint:**
    Modify `Program.cs` in the API project to add a simple `/health` endpoint. This is crucial for monitoring the API's availability.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add before `app.Run();`):**
        ```csharp
        // ... existing code ...

        app.MapGet("/health", () => Results.Ok());

        app.Run();
        ```
    *   **Guidance:** `Results.Ok()` is part of the `Microsoft.AspNetCore.Http.Results` class, which is implicitly available in minimal API contexts. This endpoint will return an HTTP 200 OK status.

4.  **Add Swagger/OpenAPI:**
    Integrate Swashbuckle to generate OpenAPI specifications and provide a Swagger UI for API documentation and testing.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add in `builder.Services` section):**
        ```csharp
        // ... existing code ...
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();

        var app = builder.Build();

        // Configure the HTTP request pipeline.
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }
        // ... existing code ...
        ```
    *   **Guidance:** `AddEndpointsApiExplorer()` is needed for minimal APIs to be discovered by Swagger. `AddSwaggerGen()` registers the Swagger generator. `UseSwagger()` and `UseSwaggerUI()` enable the middleware for serving the generated specification and the UI, respectively. These are typically enabled only in development environments.

5.  **Define Core Interfaces:**
    Create placeholder interfaces in the `CodeContext.Core` project. These interfaces will define the contracts for embedding providers and vector database clients, promoting a clean separation of concerns and extensibility.
    *   **File:** `CodeContext.Core/IEmbeddingProvider.cs`
    *   **Code Example:**
        ```csharp
        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                // Future methods for generating embeddings will go here, e.g.:
                // Task<float[]> GenerateEmbeddingAsync(string text);
            }
        }
        ```
    *   **File:** `CodeContext.Core/IVectorDatabaseClient.cs`
    *   **Code Example:**
        ```csharp
        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                // Future methods for interacting with vector databases will go here, e.g.:
                // Task UpsertAsync(string id, float[] vector, Dictionary<string, object> payload);
                // Task<List<QueryResult>> QueryAsync(float[] vector, int topK);
            }
        }
        ```
    *   **Guidance:** These interfaces are currently empty but establish the architectural placeholders.

6.  **Define Infrastructure Placeholders:**
    Create directories within the `CodeContext.Infrastructure` project to logically separate concrete implementations of database clients and embedding providers.
    *   **Action:** Manually create the following directories:
        *   `CodeContext.Infrastructure/DatabaseClients`
        *   `CodeContext.Infrastructure/EmbeddingProviders`
    *   **Guidance:** These folders will house the actual implementations (e.g., `QdrantClient.cs`, `OllamaProvider.cs`) in later sprints.

**Verification:**

After implementing these steps, build the solution (`dotnet build CodeContext.sln`) and run the API project (`dotnet run --project CodeContext.Api`). Verify that:
*   The API starts successfully.
*   You can access `http://localhost:<port>/health` and get a 200 OK response.
*   You can access `http://localhost:<port>/swagger` and see the Swagger UI.
</file>

<file path="docs/todo/fe/implementation_sprint_2_extensible_client_framework.md">
### How to Implement Sprint 2: Extensible Client Framework

This sprint focuses on designing the core interfaces for our external dependencies (embedding providers and vector databases) and setting up the dependency injection (DI) mechanism to manage their concrete implementations. This is crucial for building a flexible and testable architecture.

**Key Technologies and Concepts:**

*   **Interfaces (C#):** Define contracts for classes, enabling polymorphism and loose coupling.
*   **Dependency Injection (DI):** A software design pattern that allows for the inversion of control, where dependencies are provided to a class rather than the class creating them. ASP.NET Core has a built-in DI container.
*   **Strategy Pattern / Factory Pattern:** Design patterns that can be used to select and provide the correct implementation of an interface at runtime based on configuration or other criteria.
*   **`IServiceProvider` and `GetRequiredService<T>()`:** Core components of the .NET DI system for resolving registered services.

**Detailed Implementation Steps and Code Examples:**

1.  **Enhance `IEmbeddingProvider` Interface:**
    Define the `GenerateEmbeddingsAsync` method, which will be responsible for converting text into numerical vector representations.
    *   **File:** `CodeContext.Core/IEmbeddingProvider.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                /// <summary>
                /// Generates embeddings for a list of text inputs.
                /// </summary>
                /// <param name="texts">A list of strings to generate embeddings for.</param>
                /// <returns>A list of float arrays, where each array is an embedding for the corresponding text.</returns>
                Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts);
            }
        }
        ```
    *   **Guidance:** The `List<float[]>` return type is a common representation for embeddings. `Task` indicates an asynchronous operation, which is standard for I/O-bound tasks like API calls.

2.  **Enhance `IVectorDatabaseClient` Interface:**
    Define methods for `UpsertAsync` (inserting/updating vectors) and `QueryAsync` (searching for similar vectors). Also, define helper classes `VectorData` and `QueryResult` for structured data transfer.
    *   **File:** `CodeContext.Core/IVectorDatabaseClient.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                /// <summary>
                /// Inserts or updates vectors in the specified collection.
                /// </summary>
                /// <param name="collectionName">The name of the vector collection.</param>
                /// <param name="vectors">A list of VectorData objects to upsert.</param>
                Task UpsertAsync(string collectionName, List<VectorData> vectors);

                /// <summary>
                /// Queries the vector database for similar vectors.
                /// </summary>
                /// <param name="collectionName">The name of the vector collection to query.</param>
                /// <param name="vector">The query vector.</param>
                /// <param name="topK">The number of top similar results to return.</param>
                /// <returns>A list of QueryResult objects.</returns>
                Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK);
            }

            /// <summary>
            /// Represents a single vector data point to be stored in the database.
            /// </summary>
            public class VectorData
            {
                public string Id { get; set; } // Unique identifier for the vector
                public float[] Vector { get; set; } // The embedding vector itself
                public Dictionary<string, object> Payload { get; set; } // Additional metadata
            }

            /// <summary>
            /// Represents a single query result from the vector database.
            /// </summary>
            public class QueryResult
            {
                public string Id { get; set; } // Identifier of the matched vector
                public double Score { get; set; } // Similarity score
                public Dictionary<string, object> Payload { get; set; } // Associated metadata
            }
        }
        ```
    *   **Guidance:** `Payload` is a `Dictionary<string, object>` to allow flexible metadata storage alongside vectors.

3.  **Create `ClientFactory` for Dynamic Resolution:**
    This factory will be responsible for providing the correct concrete implementation of `IEmbeddingProvider` or `IVectorDatabaseClient` based on a configuration string. This uses the Strategy/Factory pattern.
    *   **File:** `CodeContext.Core/ClientFactory.cs` (New File)
    *   **Code Example:**
        ```csharp
        using System;
        using Microsoft.Extensions.DependencyInjection; // Required for GetRequiredService

        namespace CodeContext.Core
        {
            public class ClientFactory
            {
                private readonly IServiceProvider _serviceProvider;

                public ClientFactory(IServiceProvider serviceProvider)
                {
                    _serviceProvider = serviceProvider;
                }

                public IEmbeddingProvider GetEmbeddingProvider(string providerType)
                {
                    // In a real application, you might use a more sophisticated lookup
                    // or configuration-driven approach. For now, a switch is sufficient.
                    return providerType.ToLowerInvariant() switch
                    {
                        "ollama" => _serviceProvider.GetRequiredService<OllamaProvider>(), // OllamaProvider will be registered in Program.cs
                        _ => throw new ArgumentException($"Unknown embedding provider type: {providerType}")
                    };
                }

                public IVectorDatabaseClient GetVectorDatabaseClient(string clientType)
                {
                    return clientType.ToLowerInvariant() switch
                    {
                        "qdrant" => _serviceProvider.GetRequiredService<QdrantClient>(), // QdrantClient will be registered in Program.cs
                        _ => throw new ArgumentException($"Unknown vector database client type: {clientType}")
                    };
                }
            }
        }
        ```
    *   **Guidance:** The `ClientFactory` takes `IServiceProvider` in its constructor, allowing it to resolve other services (our concrete client implementations) at runtime. Note that `OllamaProvider` and `QdrantClient` are concrete types that will be implemented and registered in later sprints.

4.  **Register `ClientFactory` with DI Container:**
    Add the `ClientFactory` as a singleton service in `Program.cs` so it can be injected wherever needed.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add in `builder.Services` section):**
        ```csharp
        using CodeContext.Core; // Add this import at the top

        // ... existing code ...
        builder.Services.AddSingleton<ClientFactory>();

        // In later sprints, you will register concrete implementations like this:
        // builder.Services.AddSingleton<OllamaProvider>();
        // builder.Services.AddSingleton<QdrantClient>();
        // builder.Services.AddSingleton<IEmbeddingProvider, OllamaProvider>(); // If you want to directly inject the interface
        // builder.Services.AddSingleton<IVectorDatabaseClient, QdrantClient>(); // If you want to directly inject the interface
        ```
    *   **Guidance:** `AddSingleton` ensures only one instance of `ClientFactory` is created and reused throughout the application's lifetime.

**Verification:**

*   Ensure the solution builds successfully after these changes.
*   While direct runtime testing of the factory's resolution capabilities is limited without concrete implementations, you can write unit tests in a separate test project (e.g., `CodeContext.Tests`) to verify the factory's logic.
    *   **Example Unit Test (Conceptual):**
        ```csharp
        // In CodeContext.Tests/ClientFactoryTests.cs
        using Xunit;
        using Microsoft.Extensions.DependencyInjection;
        using CodeContext.Core;
        using Moq; // For mocking interfaces

        public class ClientFactoryTests
        {
            [Fact]
            public void GetEmbeddingProvider_ReturnsOllamaProvider_WhenOllamaTypeIsRequested()
            {
                // Arrange
                var services = new ServiceCollection();
                var mockOllamaProvider = new Mock<IEmbeddingProvider>(); // Mock the concrete provider
                services.AddSingleton(mockOllamaProvider.Object); // Register the mock as the concrete type
                services.AddSingleton<ClientFactory>();
                var serviceProvider = services.BuildServiceProvider();
                var factory = serviceProvider.GetRequiredService<ClientFactory>();

                // Act
                var provider = factory.GetEmbeddingProvider("ollama");

                // Assert
                Assert.NotNull(provider);
                // You might assert the type if OllamaProvider was a concrete class,
                // but here we are just checking if a service was returned.
            }

            // Add similar tests for IVectorDatabaseClient
        }
        ```
    *   **Guidance:** This conceptual test demonstrates how you would set up a test environment using `ServiceCollection` and `Moq` (a mocking library) to verify the factory's behavior.
</file>

<file path="docs/todo/fe/implementation_sprint_3_backend_process_management.md">
### How to Implement Sprint 3: Backend Process Management

This sprint focuses on the critical integration between the VS Code extension (TypeScript) and the C# backend. The goal is to automate the lifecycle management of the backend process, ensuring it starts automatically, is monitored for health, and is properly terminated.

**Key Technologies and Concepts:**

*   **Node.js `child_process` module:** Provides the ability to spawn child processes, execute shell commands, and interact with their I/O streams. Specifically, `spawn` is preferred for long-running processes.
*   **VS Code Extension API:** `vscode.ExtensionContext` for managing disposables, `vscode.window.showInformationMessage` for user notifications.
*   **HTTP `fetch` API:** For making HTTP requests to the backend's health endpoint. In Node.js, you might need a polyfill like `node-fetch` or use `undici` for Node.js 18+.
*   **Process Management:** Handling `stdout`, `stderr`, `close`, and `error` events of the child process. Ensuring proper termination (`kill()`).

**Detailed Implementation Steps and Code Examples:**

1.  **Spawn C# Backend Executable:**
    In your extension's `activate` function, use `child_process.spawn` to launch the compiled C# executable. You'll need to determine the correct path to your executable after the C# project is built.
    *   **File:** `extension.ts` (main extension file)
    *   **Code Example:**
        ```typescript
        import * as vscode from 'vscode';
        import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
        import * as path from 'path';
        import fetch from 'node-fetch'; // Or 'undici' for Node.js 18+

        let backendProcess: ChildProcessWithoutNullStreams | null = null;
        const backendPort = 5000; // Define your backend's port

        export function activate(context: vscode.ExtensionContext) {
            console.log('Code Context extension is now active!');

            // IMPORTANT: Adjust this path based on your C# build output location.
            // This assumes the C# project builds to a 'bin' folder within the extension's root.
            const backendExecutablePath = path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api'); // Example for Windows/Linux
            // For macOS, it might be: path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api')
            // Or if it's a self-contained deployment: path.join(context.extensionPath, 'publish', 'CodeContext.Api')

            // Ensure the executable exists before trying to spawn
            if (!require('fs').existsSync(backendExecutablePath)) {
                vscode.window.showErrorMessage(`Code Context backend executable not found at: ${backendExecutablePath}`);
                return;
            }

            backendProcess = spawn(backendExecutablePath, [], {
                cwd: path.dirname(backendExecutablePath), // Run from the executable's directory
                stdio: ['ignore', 'pipe', 'pipe'] // Ignore stdin, pipe stdout/stderr
            });

            // Capture stdout for logging
            backendProcess.stdout.on('data', (data) => {
                console.log(`[Backend stdout]: ${data.toString()}`);
                // Consider using a dedicated VS Code OutputChannel for better logging
                // const outputChannel = vscode.window.createOutputChannel("Code Context Backend");
                // outputChannel.appendLine(`[Backend stdout]: ${data.toString()}`);
            });

            // Capture stderr for error logging
            backendProcess.stderr.on('data', (data) => {
                console.error(`[Backend stderr]: ${data.toString()}`);
                // outputChannel.appendLine(`[Backend stderr]: ${data.toString()}`);
            });

            // Handle process exit
            backendProcess.on('close', (code) => {
                console.log(`Backend process exited with code ${code}`);
                backendProcess = null;
                // Potentially notify user or attempt restart if unexpected exit
            });

            // Handle errors during spawning (e.g., executable not found, permissions)
            backendProcess.on('error', (err) => {
                console.error('Failed to start backend process:', err);
                vscode.window.showErrorMessage(`Failed to start Code Context backend: ${err.message}`);
                backendProcess = null;
            });

            // Ensure the process is killed when the extension deactivates
            context.subscriptions.push({
                dispose: () => {
                    if (backendProcess) {
                        console.log('Terminating backend process on extension deactivation...');
                        backendProcess.kill(); // Sends SIGTERM
                        backendProcess = null;
                    }
                }
            });

            // Start health check after a short delay to allow backend to start listening
            setTimeout(() => startHealthCheck(context), 2000);
        }

        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill(); // Ensure process is killed
                backendProcess = null;
            }
        }
        ```
    *   **Guidance:**
        *   `cwd`: Set the current working directory for the spawned process to the directory containing the executable.
        *   `stdio`: `['ignore', 'pipe', 'pipe']` means stdin is ignored, stdout and stderr are piped to the parent process (your extension), allowing you to capture their output.
        *   **Executable Path:** The path `path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api')` is a common pattern for .NET Core executables. For cross-platform compatibility, you might need to check `process.platform` or use a self-contained deployment.
        *   **Error Handling:** Implement robust error handling for `spawn` and `on('error')` events.

2.  **Implement Backend Health Monitoring:**
    Create a function to periodically check the backend's `/health` endpoint. If it fails repeatedly, attempt to restart the backend.
    *   **File:** `extension.ts`
    *   **Code Example (add as a new function):**
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        let healthCheckTimer: NodeJS.Timeout | null = null;
        let healthCheckAttempts = 0;
        const maxHealthCheckAttempts = 5; // Number of failed attempts before restart
        const healthCheckInterval = 5000; // Check every 5 seconds

        async function checkBackendHealth(context: vscode.ExtensionContext): Promise<boolean> {
            if (!backendProcess) {
                console.log('Backend process not running, health check skipped.');
                return false;
            }
            try {
                const response = await fetch(`http://localhost:${backendPort}/health`);
                if (response.ok) {
                    console.log('Backend is healthy.');
                    healthCheckAttempts = 0;
                    // You can send a message to your webview here to update UI status
                    // vscode.window.activeTextEditor?.document.uri.scheme === 'vscode-webview' &&
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'running' });
                    return true;
                } else {
                    console.warn(`Backend health check failed: HTTP ${response.status}`);
                    return false;
                }
            } catch (error) {
                console.error('Error during backend health check:', error);
                return false;
            }
        }

        function startHealthCheck(context: vscode.ExtensionContext) {
            if (healthCheckTimer) {
                clearInterval(healthCheckTimer);
            }
            healthCheckTimer = setInterval(async () => {
                const isHealthy = await checkBackendHealth(context);
                if (!isHealthy) {
                    healthCheckAttempts++;
                    // Update UI state to "Starting" or "Error"
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'starting' });

                    if (healthCheckAttempts >= maxHealthCheckAttempts) {
                        console.error('Max health check attempts reached. Attempting to restart backend.');
                        clearInterval(healthCheckTimer!);
                        restartBackend(context);
                    }
                }
            }, healthCheckInterval);
        }

        function restartBackend(context: vscode.ExtensionContext) {
            if (backendProcess) {
                console.log('Killing existing backend process for restart...');
                backendProcess.kill(); // Send SIGTERM
                backendProcess = null;
            }
            healthCheckAttempts = 0; // Reset attempts for new process
            console.log('Attempting to restart backend process...');
            // Re-call activate to re-spawn and re-initialize everything
            // In a more complex app, you might have a dedicated `startBackend` function
            deactivate(); // Clean up existing disposables
            activate(context); // Re-activate the extension, which will spawn a new process
            vscode.window.showWarningMessage('Code Context Backend is restarting due to health check failures.');
        }
        ```
    *   **Guidance:**
        *   `setInterval`: Used for periodic checks.
        *   `fetch`: Make HTTP requests. Remember to install `node-fetch` (`npm install node-fetch`) or use Node.js's built-in `fetch` if on Node.js 18+.
        *   **Restart Logic:** The `restartBackend` function kills the current process and then re-calls `activate(context)`. This is a simple way to re-initialize the extension and spawn a new backend. For more fine-grained control, you might extract the spawning logic into a separate `startBackend` function.
        *   **UI Integration:** The comments show where you would send messages to a VS Code Webview to update the UI status.

**Verification:**

*   **Manual Testing:**
    1.  Open VS Code and activate the extension. Check your system's process list (Task Manager on Windows, Activity Monitor on macOS, `ps aux | grep CodeContext.Api` on Linux) to confirm the C# backend process is running.
    2.  Deactivate the extension (e.g., by closing the VS Code window or disabling the extension). Verify the C# backend process is no longer running.
    3.  While the extension is active, manually kill the C# backend process (e.g., using Task Manager). Observe if the extension detects the unhealthiness and attempts to restart the backend after a few intervals.
*   **Logging:** Monitor the VS Code Debug Console (for `console.log` messages) or a dedicated Output Channel (if implemented) for messages indicating process start/stop, health checks, and errors.
</file>

<file path="docs/todo/fe/implementation_sprint_4_onboarding_setup_ui.md">
### How to Implement Sprint 4: Onboarding & Setup UI

This sprint focuses on building the initial user interface within the VS Code extension, specifically for onboarding new users and allowing them to configure their database and embedding provider. This involves creating a VS Code Webview and integrating a Svelte frontend.

**Key Technologies and Concepts:**

*   **VS Code Webviews:** Allow you to create custom UI within VS Code using HTML, CSS, and JavaScript (or frameworks like Svelte, React, Vue).
*   **Svelte:** A reactive JavaScript framework for building user interfaces.
*   **`vscode.workspace.workspaceFolders`:** API to get information about open workspace folders.
*   **`fs` module (Node.js):** For file system operations like checking file existence.
*   **`vscode.window.createTerminal()`:** API to create and interact with VS Code integrated terminals.
*   **Message Passing (Extension <-> Webview):** Communication between the VS Code extension (Node.js/TypeScript) and the webview (Svelte/JavaScript) is done via `postMessage` and `onDidReceiveMessage`.

**Detailed Implementation Steps and Code Examples:**

1.  **Create and Manage VS Code Webview:**
    The `extension.ts` file will be responsible for creating the webview panel and loading your Svelte application into it. It will also handle communication between the extension and the webview.
    *   **File:** `extension.ts`
    *   **Code Example (within `activate` function):**
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';
        // ... (other imports like child_process, fetch) ...

        export function activate(context: vscode.ExtensionContext) {
            // ... (backend process management setup) ...

            // Create and show the webview panel
            const panel = vscode.window.createWebviewPanel(
                'codeContext', // Unique ID for the webview
                'Code Context', // Title shown in VS Code tab
                vscode.ViewColumn.One, // Where to open the panel (e.g., in the first editor column)
                {
                    enableScripts: true, // VERY IMPORTANT: Allows JavaScript to run in the webview
                    // Restrict the webview to only load resources from our extension's 'webview/dist' directory
                    localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                }
            );

            // Get the path to the SvelteKit build output (index.html)
            const svelteAppPath = path.join(context.extensionPath, 'webview', 'dist', 'index.html');
            if (!fs.existsSync(svelteAppPath)) {
                vscode.window.showErrorMessage('Svelte webview build not found. Please run `npm run build` in the webview directory.');
                return;
            }
            panel.webview.html = fs.readFileSync(svelteAppPath, 'utf8');

            // Check for existing configuration file
            const workspaceFolders = vscode.workspace.workspaceFolders;
            let configFilePath: string | undefined;
            if (workspaceFolders && workspaceFolders.length > 0) {
                // Assuming config file is in .vscode/code-context.json relative to workspace root
                configFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'code-context.json');
            }

            let initialView: 'setup' | 'query' = 'setup';
            if (configFilePath && fs.existsSync(configFilePath)) {
                initialView = 'query'; // If config exists, show query view
            }

            // Send initial view state to the Svelte webview
            panel.webview.postMessage({ type: 'initialView', view: initialView });

            // Handle messages received from the webview (e.g., user clicks a button)
            panel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showInformationMessage(message.text);
                            return;
                        case 'startDocker':
                            handleStartDockerCommand(message.service, context);
                            return;
                        case 'saveConfigAndIndex':
                            // Implement saving config and triggering indexing in a later sprint
                            vscode.window.showInformationMessage('Configuration saved (not yet implemented) and indexing will start!');
                            return;
                    }
                },
                undefined,
                context.subscriptions // Ensure the message listener is disposed
            );

            // Add the panel to the extension's disposables so it's cleaned up when the extension deactivates
            context.subscriptions.push(panel);
        }
        ```
    *   **Guidance:**
        *   `enableScripts: true` is crucial for your Svelte app to run.
        *   `localResourceRoots` is a security measure to prevent the webview from loading arbitrary content.
        *   `panel.webview.html = fs.readFileSync(...)` loads your Svelte app's `index.html`.
        *   `panel.webview.postMessage` sends data to the webview.
        *   `panel.webview.onDidReceiveMessage` listens for data from the webview.

2.  **Svelte App Structure and View Management:**
    Your Svelte application will have a main `App.svelte` component that conditionally renders `SetupView.svelte` or `QueryView.svelte` based on a Svelte store.
    *   **File:** `webview/src/lib/stores/viewStore.ts` (New File)
    *   **Code Example:**
        ```typescript
        import { writable } from 'svelte/store';

        // Defines the current view of the webview: 'setup' or 'query'
        export const currentView = writable<'setup' | 'query'>('setup');
        ```
    *   **File:** `webview/src/App.svelte` (Main Svelte component)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';

            onMount(() => {
                // Listen for messages from the VS Code extension
                window.addEventListener('message', event => {
                    const message = event.data; // The JSON data that the extension sent
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        // Add cases for other messages from extension (e.g., backend status updates)
                    }
                });
            });
        </script>

        <main>
            {#if $currentView === 'setup'}
                <SetupView />
            {:else if $currentView === 'query'}
                <QueryView />
            {/if}
        </main>

        <style>
            /* Global styles for your Svelte app */
            body {
                margin: 0;
                padding: 0;
                background-color: var(--vscode-editor-background);
                color: var(--vscode-editor-foreground);
            }
            /* You can use VS Code CSS variables for theming */
        </style>
        ```
    *   **Guidance:** The `onMount` lifecycle hook is used to set up the message listener. The `{#if}` block conditionally renders components.

3.  **Implement `SetupView.svelte`:**
    This component will contain the UI elements for selecting database/embedding providers and the "Start Local" buttons.
    *   **File:** `webview/src/lib/components/SetupView.svelte` (New File)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            import { postMessageToVsCode } from '../utils/vscode'; // Utility to send messages to extension

            let selectedDatabase: string = 'qdrant'; // Default selection
            let selectedEmbeddingProvider: string = 'ollama'; // Default selection

            function handleStartLocalService(service: string) {
                // Send a message to the VS Code extension to execute the Docker command
                postMessageToVsCode('startDocker', { service });
            }

            function handleSaveAndIndex() {
                // Send configuration to extension to save and trigger indexing
                postMessageToVsCode('saveConfigAndIndex', {
                    database: selectedDatabase,
                    embeddingProvider: selectedEmbeddingProvider
                });
            }
        </script>

        <div class="setup-container">
            <h1>Code Context Setup</h1>

            <section>
                <h2>Database Configuration</h2>
                <label for="database-select">Select Database:</label>
                <select id="database-select" bind:value={selectedDatabase}>
                    <option value="qdrant">Qdrant (Local)</option>
                    <!-- Add more database options here as they are supported -->
                </select>
                <button on:click={() => handleStartLocalService('qdrant')}>Start Local Qdrant</button>
                <!-- Future: Add status indicator (e.g., "Running", "Stopped") -->
            </section>

            <section>
                <h2>Embedding Provider Configuration</h2>
                <label for="embedding-select">Select Embedding Provider:</label>
                <select id="embedding-select" bind:value={selectedEmbeddingProvider}>
                    <option value="ollama">Ollama (Local)</option>
                    <!-- Add more embedding provider options here -->
                </select>
                <button on:click={() => handleStartLocalService('ollama')}>Start Local Ollama</button>
                <!-- Future: Add status indicator -->
            </section>

            <button on:click={handleSaveAndIndex}>Save & Index</button>
        </div>

        <style>
            /* Basic styling for the setup view */
            .setup-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            section {
                margin-bottom: 20px;
                border: 1px solid var(--vscode-panel-border);
                padding: 15px;
                border-radius: 5px;
                background-color: var(--vscode-editorGroup-background);
            }
            label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            select, button {
                margin-right: 10px;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                cursor: pointer;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
        </style>
        ```
    *   **Guidance:** `bind:value` creates two-way data binding for select elements. `postMessageToVsCode` is a custom utility.

4.  **Create `postMessageToVsCode` Utility:**
    This simple utility abstracts the `acquireVsCodeApi()` call, making it easier to send messages from Svelte to the extension.
    *   **File:** `webview/src/lib/utils/vscode.ts` (New File)
    *   **Code Example:**
        ```typescript
        // This function is provided by VS Code to webviews to communicate back to the extension.
        // It must be called exactly once per webview panel.
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        /**
         * Sends a message from the Svelte webview to the VS Code extension.
         * @param command The command string (e.g., 'startDocker', 'saveConfig').
         * @param data Any additional data to send with the command.
         */
        export function postMessageToVsCode(command: string, data: any) {
            vscode.postMessage({ command, ...data });
        }
        ```
    *   **Guidance:** `acquireVsCodeApi()` is a global function available in webview contexts.

5.  **Implement `handleStartDockerCommand` in Extension:**
    This function in `extension.ts` will receive messages from the webview and execute the appropriate Docker commands in a new VS Code terminal.
    *   **File:** `extension.ts`
    *   **Code Example (add as a new function):**
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        function handleStartDockerCommand(service: string, context: vscode.ExtensionContext) {
            let command: string;
            let terminalName: string;
            let cwd: string | undefined; // Current working directory for the terminal

            // Assuming docker-compose files are in a 'docker' sub-directory of the extension
            const dockerComposeDir = path.join(context.extensionPath, 'docker');

            switch (service) {
                case 'qdrant':
                    command = 'docker-compose -f docker-compose.qdrant.yml up -d';
                    terminalName = 'Code Context: Qdrant';
                    cwd = dockerComposeDir; // Run docker-compose from its directory
                    break;
                case 'ollama':
                    // Example Ollama command to run it as a detached container
                    command = 'docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama';
                    terminalName = 'Code Context: Ollama';
                    // Ollama command can be run from any directory, no specific cwd needed
                    break;
                default:
                    vscode.window.showErrorMessage(`Unknown service to start: ${service}`);
                    return;
            }

            const terminal = vscode.window.createTerminal({
                name: terminalName,
                cwd: cwd // Set the working directory for the terminal
            });
            terminal.show(); // Show the terminal panel
            terminal.sendText(command); // Send the command to the terminal

            vscode.window.showInformationMessage(`Attempting to start ${service} via Docker. Check '${terminalName}' terminal for status.`);
            // In a real scenario, you'd also want to poll the health of these services
            // and update the UI status in SetupView.svelte.
        }
        ```
    *   **Guidance:**
        *   `vscode.window.createTerminal()` creates a new integrated terminal.
        *   `terminal.show()` brings the terminal into focus.
        *   `terminal.sendText()` sends the command to be executed in the terminal.
        *   Consider adding a `docker-compose.qdrant.yml` file in a `docker` directory within your extension for Qdrant.

6.  **Create Placeholder `QueryView.svelte`:**
    This component will be displayed when a `code-context.json` file is found, indicating the project is already set up.
    *   **File:** `webview/src/lib/components/QueryView.svelte` (New File)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            // This component will be developed in a later sprint for querying functionality.
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <p>Your project is configured. Query functionality will be available here soon!</p>
            <!-- Future: Input box for queries, display area for results -->
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
        </style>
        ```
    *   **Guidance:** This is a minimal placeholder for now.

**Verification:**

*   **Build Svelte App:** Before testing, navigate to your `webview` directory and run `npm install` and then `npm run build` to compile your Svelte app into the `dist` folder.
*   **VS Code Testing:**
    1.  Open VS Code with an empty folder (no `.vscode/code-context.json`). Activate your extension. Verify that the "Code Context" webview panel appears and displays the `SetupView` with dropdowns and buttons.
    2.  Create an empty file at `.vscode/code-context.json` in your workspace root. Reload the VS Code window (Ctrl+R or Cmd+R). Verify that the webview now displays the `QueryView` placeholder.
    3.  Go back to the `SetupView` (by deleting `.vscode/code-context.json` and reloading). Click the "Start Local Qdrant" button. Verify a new VS Code terminal opens and the `docker-compose` command is executed. Repeat for "Start Local Ollama".
</file>

<file path="docs/todo/fe/implementation_sprint_5_concrete_client_implementation.md">
### How to Implement Sprint 5: Concrete Client Implementation (C#)

This sprint is about bringing our abstract interfaces to life by implementing concrete clients for Qdrant (vector database) and Ollama (embedding provider). We will also introduce the core indexing logic that orchestrates the parsing, embedding, and storage of code context.

**Key Technologies and Concepts:**

*   **Qdrant.Client NuGet Package:** The official .NET client library for interacting with Qdrant.
*   **`HttpClient` (C#):** For making HTTP requests to the Ollama API.
*   **`System.Text.Json`:** For JSON serialization and deserialization when communicating with Ollama.
*   **Abstract Syntax Tree (AST) Parsing:** The process of analyzing source code to build a tree-like representation of its structure. For C#, `Microsoft.CodeAnalysis` (Roslyn) is the standard. For other languages, you'd use appropriate libraries.
*   **Dependency Injection (DI):** Continues to be crucial for injecting our new concrete clients and services.
*   **`IConfiguration`:** For reading settings like API URLs and model names from `appsettings.json`.

**Detailed Implementation Steps and Code Examples:**

1.  **Add Qdrant.Client NuGet Package:**
    Install the official Qdrant .NET client library into your `CodeContext.Infrastructure` project.
    *   **Command:**
        ```bash
        dotnet add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj package Qdrant.Client
        ```
    *   **Guidance:** Always check NuGet.org for the latest stable version.

2.  **Implement `QdrantClient` Class:**
    Create a class that implements `IVectorDatabaseClient` and uses the `Qdrant.Client` library to perform upsert and query operations.
    *   **File:** `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IVectorDatabaseClient, VectorData, QueryResult
        using Qdrant.Client;
        using Qdrant.Client.Grpc; // For PointStruct, VectorParams, Distance, etc.

        namespace CodeContext.Infrastructure.DatabaseClients
        {
            public class QdrantClient : IVectorDatabaseClient
            {
                private readonly QdrantGrpcClient _client;
                private readonly string _collectionName; // Default collection name

                public QdrantClient(string host, int port, string collectionName = "code_context_collection")
                {
                    _client = new QdrantGrpcClient(host, port);
                    _collectionName = collectionName;
                }

                public async Task UpsertAsync(string collectionName, List<VectorData> vectors)
                {
                    if (!vectors.Any()) return;

                    // Ensure collection exists or create it.
                    // In a production app, you might check this once on startup or have a dedicated migration.
                    var collections = await _client.Collections.ListAsync();
                    if (!collections.Any(c => c.Name == collectionName))
                    {
                        // Assuming all vectors have the same dimension (size) and cosine distance
                        await _client.Collections.CreateAsync(
                            collectionName,
                            new VectorParams { Size = (ulong)vectors.First().Vector.Length, Distance = Distance.Cosine }
                        );
                    }

                    // Convert our generic VectorData to Qdrant's PointStruct
                    var points = vectors.Select(v => new PointStruct
                    {
                        Id = v.Id, // Qdrant uses string IDs
                        Vectors = v.Vector.ToList(), // Convert float[] to List<float>
                        Payload = v.Payload.ToDictionary(
                            p => p.Key,
                            p => Value.From(p.Value) // Convert generic object to Qdrant's Value type
                        )
                    }).ToList();

                    // Perform the upsert operation
                    await _client.Points.UpsertAsync(collectionName, points);
                }

                public async Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK)
                {
                    var searchResult = await _client.Points.SearchAsync(
                        collectionName,
                        vector.ToList(), // Convert float[] to List<float>
                        limit: (ulong)topK
                    );

                    // Convert Qdrant's SearchPoint to our generic QueryResult
                    return searchResult.Select(s => new QueryResult
                    {
                        Id = s.Id,
                        Score = s.Score,
                        Payload = s.Payload.ToDictionary(
                            p => p.Key,
                            p => p.Value.ToValue() // Convert Qdrant's Value back to generic object
                        )
                    }).ToList();
                }
            }
        }
        ```
    *   **Guidance:**
        *   `QdrantGrpcClient`: The main client for gRPC communication with Qdrant.
        *   `Value.From(object)` and `Value.ToValue()`: Helper methods for converting between C# objects and Qdrant's internal `Value` type for payload data.
        *   Collection creation: The example includes logic to create the collection if it doesn't exist. In a real application, this might be handled during setup or migration.

3.  **Implement `OllamaProvider` Class:**
    Create a class that implements `IEmbeddingProvider` and makes HTTP POST requests to a local Ollama instance to generate embeddings.
    *   **File:** `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Net.Http;
        using System.Text;
        using System.Text.Json;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider

        namespace CodeContext.Infrastructure.EmbeddingProviders
        {
            public class OllamaProvider : IEmbeddingProvider
            {
                private readonly HttpClient _httpClient;
                private readonly string _ollamaApiUrl;
                private readonly string _modelName;

                public OllamaProvider(HttpClient httpClient, string ollamaApiUrl, string modelName)
                {
                    _httpClient = httpClient;
                    _ollamaApiUrl = ollamaApiUrl;
                    _modelName = modelName;
                }

                public async Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts)
                {
                    var embeddings = new List<float[]>();
                    foreach (var text in texts)
                    {
                        var requestBody = new
                        {
                            model = _modelName,
                            prompt = text,
                            // You might add options like "keep_alive" for performance
                            // options = new { temperature = 0.0 }
                        };

                        var json = JsonSerializer.Serialize(requestBody);
                        var content = new StringContent(json, Encoding.UTF8, "application/json");

                        var response = await _httpClient.PostAsync($"{_ollamaApiUrl}/api/embeddings", content);
                        response.EnsureSuccessStatusCode(); // Throws an exception for non-2xx status codes

                        var responseBody = await response.Content.ReadAsStringAsync();
                        using (JsonDocument jsonDoc = JsonDocument.Parse(responseBody))
                        {
                            var embeddingArray = jsonDoc.RootElement.GetProperty("embedding").EnumerateArray()
                                .Select(e => (float)e.GetDouble())
                                .ToArray();
                            embeddings.Add(embeddingArray);
                        }
                    }
                    return embeddings;
                }
            }
        }
        ```
    *   **Guidance:**
        *   `HttpClient`: Best practice is to use `IHttpClientFactory` for managing `HttpClient` instances in ASP.NET Core. This is handled by `builder.Services.AddHttpClient<OllamaProvider>();` in `Program.cs`.
        *   Ollama API: The `/api/embeddings` endpoint expects a JSON payload with `model` and `prompt`.
        *   `JsonSerializer`: Used for serializing C# objects to JSON and deserializing JSON responses.

4.  **Add AST Parsing Logic (Placeholder):**
    Create a `ParsingService` that will eventually use an AST library to extract meaningful code snippets. For C#, `Microsoft.CodeAnalysis` (Roslyn) is the go-to.
    *   **File:** `CodeContext.Core/Services/ParsingService.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.IO;
        using System.Threading.Tasks;

        namespace CodeContext.Core.Services
        {
            public class ParsingService
            {
                /// <summary>
                /// Parses a code file and extracts relevant text snippets for embedding.
                /// This is a placeholder; actual implementation would use an AST library.
                /// </summary>
                /// <param name="filePath">The path to the code file.</param>
                /// <returns>A list of text snippets extracted from the file.</returns>
                public async Task<List<string>> ParseCodeFileAsync(string filePath)
                {
                    if (!File.Exists(filePath))
                    {
                        return new List<string>();
                    }

                    // For now, just return the entire file content as a single snippet.
                    // In a real implementation:
                    // - Use Roslyn for C# files (Microsoft.CodeAnalysis.CSharp)
                    // - Use other parsers for TypeScript, Python, etc.
                    // - Break down code into functions, classes, comments, etc.
                    var content = await File.ReadAllTextAsync(filePath);
                    return new List<string> { content };
                }
            }
        }
        ```
    *   **Guidance:** For C# parsing, you would add `Microsoft.CodeAnalysis.CSharp` NuGet package and use its APIs to traverse the syntax tree.

5.  **Create `IndexingService`:**
    This service orchestrates the entire indexing workflow: reading files, parsing them, generating embeddings, and upserting to the vector database.
    *   **File:** `CodeContext.Core/Services/IndexingService.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider, IVectorDatabaseClient, VectorData

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                private readonly ParsingService _parsingService;
                private readonly IEmbeddingProvider _embeddingProvider;
                private readonly IVectorDatabaseClient _vectorDatabaseClient;

                public IndexingService(
                    ParsingService parsingService,
                    IEmbeddingProvider embeddingProvider,
                    IVectorDatabaseClient vectorDatabaseClient)
                {
                    _parsingService = parsingService;
                    _embeddingProvider = embeddingProvider;
                    _vectorDatabaseClient = vectorDatabaseClient;
                }

                /// <summary>
                /// Indexes a given code repository by parsing files, generating embeddings,
                /// and storing them in the vector database.
                /// </summary>
                /// <param name="repositoryPath">The root path of the code repository.</param>
                /// <param name="collectionName">The name of the Qdrant collection to use.</param>
                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName)
                {
                    // TODO: Implement actual file enumeration (e.g., using Directory.EnumerateFiles)
                    // and filtering (e.g., .gitignore, file extensions).
                    var dummyFilePaths = new List<string> { 
                        Path.Combine(repositoryPath, "src", "Program.cs"), 
                        Path.Combine(repositoryPath, "src", "Utils.ts") 
                    };

                    foreach (var filePath in dummyFilePaths)
                    {
                        Console.WriteLine($"Indexing file: {filePath}"); // For logging progress
                        var codeSnippets = await _parsingService.ParseCodeFileAsync(filePath);

                        if (codeSnippets.Any())
                        {
                            var embeddings = await _embeddingProvider.GenerateEmbeddingsAsync(codeSnippets);

                            var vectorsToUpsert = new List<VectorData>();
                            for (int i = 0; i < embeddings.Count; i++)
                            {
                                vectorsToUpsert.Add(new VectorData
                                {
                                    Id = $"{filePath.Replace("\", "/")}_{i}", // Create a unique ID, normalize path
                                    Vector = embeddings[i],
                                    Payload = new Dictionary<string, object>
                                    {
                                        { "filePath", filePath },
                                        { "snippet", codeSnippets[i] }
                                    }
                                });
                            }
                            await _vectorDatabaseClient.UpsertAsync(collectionName, vectorsToUpsert);
                            Console.WriteLine($"Indexed {embeddings.Count} snippets from {filePath}");
                        }
                    }
                    Console.WriteLine("Indexing complete.");
                }
            }
        }
        ```
    *   **Guidance:** This service takes dependencies on `ParsingService`, `IEmbeddingProvider`, and `IVectorDatabaseClient`, which will be injected by DI.

6.  **Register Services with DI Container:**
    Update `Program.cs` in the API project to register all the new concrete implementations and services.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (within `builder.Services` section):**
        ```csharp
        using CodeContext.Core;
        using CodeContext.Core.Services;
        using CodeContext.Infrastructure.DatabaseClients;
        using CodeContext.Infrastructure.EmbeddingProviders;
        using Microsoft.Extensions.Configuration; // For IConfiguration
        using System.Net.Http; // For HttpClient

        // ... existing services ...

        // Register HttpClient for OllamaProvider (best practice for HttpClient management)
        builder.Services.AddHttpClient(); // Registers a default HttpClient

        // Register concrete client implementations as singletons
        builder.Services.AddSingleton<IVectorDatabaseClient>(sp =>
        {
            var configuration = sp.GetRequiredService<IConfiguration>();
            var qdrantHost = configuration["Qdrant:Host"] ?? "localhost";
            var qdrantPort = int.Parse(configuration["Qdrant:Port"] ?? "6334");
            var collectionName = configuration["Qdrant:CollectionName"] ?? "code_context_collection";
            return new QdrantClient(qdrantHost, qdrantPort, collectionName);
        });

        builder.Services.AddSingleton<IEmbeddingProvider>(sp =>
        {
            var configuration = sp.GetRequiredService<IConfiguration>();
            var ollamaApiUrl = configuration["Ollama:ApiUrl"] ?? "http://localhost:11434";
            var ollamaModel = configuration["Ollama:Model"] ?? "llama2"; // Default model
            var httpClientFactory = sp.GetRequiredService<IHttpClientFactory>();
            var httpClient = httpClientFactory.CreateClient(); // Get a named client if needed, or default
            return new OllamaProvider(httpClient, ollamaApiUrl, ollamaModel);
        });

        // Register core services
        builder.Services.AddSingleton<ParsingService>();
        builder.Services.AddSingleton<IndexingService>();

        // ... existing app.MapGet("/health") ...
        ```
    *   **Guidance:**
        *   `AddHttpClient()`: Registers `IHttpClientFactory`, which is used to create `HttpClient` instances.
        *   `IConfiguration`: You'll need to add `appsettings.json` to your `CodeContext.Api` project to configure Qdrant and Ollama settings.
            ```json
            // appsettings.json
            {
              "Logging": {
                "LogLevel": {
                  "Default": "Information",
                  "Microsoft.AspNetCore": "Warning"
                }
              },
              "AllowedHosts": "*",
              "Qdrant": {
                "Host": "localhost",
                "Port": 6334,
                "CollectionName": "code_context_collection"
              },
              "Ollama": {
                "ApiUrl": "http://localhost:11434",
                "Model": "llama2"
              }
            }
            ```

7.  **Create `/index` Endpoint:**
    Add a new minimal API endpoint that triggers the `IndexingService`.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add before `app.Run();`):**
        ```csharp
        // ... existing endpoints ...

        app.MapPost("/index", async (IndexingService indexingService) =>
        {
            // In a real application, the repository path would come from the request
            // or be managed by the extension. For now, use a hardcoded path or read from config.
            var repositoryPath = "/Users/bramburn/dev/bigcontext"; // Example: Use the current project root
            var collectionName = "code_context_collection"; // Should match Qdrant config

            try
            {
                await indexingService.IndexRepositoryAsync(repositoryPath, collectionName);
                return Results.Ok("Indexing process completed successfully.");
            }
            catch (Exception ex)
            {
                return Results.Problem($"Indexing failed: {ex.Message}", statusCode: 500);
            }
        });

        app.Run();
        ```
    *   **Guidance:** The `IndexingService` is automatically injected into the endpoint handler. Add error handling for robustness.

**Verification:**

*   **Prerequisites:** Ensure you have a local Qdrant instance running (e.g., via Docker) and Ollama installed with a model downloaded (e.g., `ollama run llama2`).
*   **Build and Run:** Build your C# solution (`dotnet build`) and run the API project (`dotnet run --project CodeContext.Api`).
*   **Test `/health`:** Confirm `http://localhost:<port>/health` returns 200 OK.
*   **Test `/index`:** Use a tool like Postman, Insomnia, or `curl` to send a `POST` request to `http://localhost:<port>/index`.
    *   `curl -X POST http://localhost:<port>/index`
*   **Observe Logs:** Check the console output of your running C# API for messages from `IndexingService` and any errors from Qdrant or Ollama communication.
*   **Verify Qdrant Data:** If successful, you should see new points (vectors) added to your Qdrant collection. You can use Qdrant's API or UI to verify this.
</file>

<file path="docs/todo/fe/implementation_sub_sprint_1_database_configuration_component.md">
# Implementation Guidance: Sub-Sprint 1 - Database Configuration Component

**Objective:** To provide detailed instructions for creating the `DatabaseSetup.svelte` component, handling user interaction, and communicating with the extension backend to manage the database service.

---

### 1. Component Structure (`DatabaseSetup.svelte`)

This component is responsible for the database section of the UI. It will contain a selector, a button, and a status indicator.

**File:** `webview/src/lib/components/DatabaseSetup.svelte`

```html
<script lang="ts">
  import { Button, Select } from '@svelte-fui/core';
  import { setupState } from '$lib/stores/setupStore';
  import { onMount } from 'svelte';

  // Acquire the vscode API only once
  const vscode = acquireVsCodeApi();

  function startDatabase() {
    // Disable button to prevent multiple clicks
    // You can add a 'loading' state here
    vscode.postMessage({ command: 'startDatabase' });
  }

  onMount(() => {
    const handleMessage = (event: MessageEvent) => {
      const message = event.data; // The JSON data from the extension
      if (message.command === 'databaseStatus') {
        console.log(`Received status: ${message.status}`);
        setupState.update(s => ({ ...s, databaseReady: message.status === 'running' }));
      }
    };

    window.addEventListener('message', handleMessage);

    // Cleanup listener when component is destroyed
    return () => {
      window.removeEventListener('message', handleMessage);
    };
  });
</script>

<div class="space-y-4 p-4 border rounded-md">
  <h3 class="text-lg font-semibold">Database Configuration</h3>
  <div class="flex items-center space-x-4">
    <Select items={['Qdrant']} placeholder="Select Database" class="flex-grow" />
    <Button variant="primary" on:click={startDatabase}>Start Local Qdrant</Button>
  </div>
  <div>
    <span>Status:</span>
    {#if $setupState.databaseReady}
      <span class="text-green-500">🟢 Running</span>
    {:else}
      <span class="text-gray-500">⚫ Not Running</span>
    {/if}
  </div>
</div>
```

### 2. Backend Logic (`src/extension.ts`)

The extension needs to listen for the `startDatabase` message and then perform two key actions:
1.  Run the Docker command.
2.  Poll a health check endpoint to verify the service is running.

```typescript
// src/extension.ts inside the onDidReceiveMessage handler

case 'startDatabase': {
    const terminal = vscode.window.createTerminal('Qdrant');
    // Assumes docker-compose.yml is in the root of the workspace
    terminal.sendText('docker-compose up');
    terminal.show();

    // Start polling for Qdrant health
    pollQdrantHealth(panel);
    return;
}

// ...

function pollQdrantHealth(panel: vscode.WebviewPanel) {
    let attempts = 0;
    const maxAttempts = 30; // Poll for 30 seconds (30 * 1000ms)
    const interval = 1000; // 1 second

    const intervalId = setInterval(async () => {
        if (attempts >= maxAttempts) {
            clearInterval(intervalId);
            vscode.window.showErrorMessage('Qdrant health check timed out.');
            // Optionally send a 'failed' status to the webview
            panel.webview.postMessage({ command: 'databaseStatus', status: 'failed' });
            return;
        }

        try {
            // Qdrant's default health check endpoint
            const response = await fetch('http://localhost:6333/healthz');
            if (response.ok) {
                clearInterval(intervalId);
                vscode.window.showInformationMessage('Qdrant is running!');
                panel.webview.postMessage({ command: 'databaseStatus', status: 'running' });
            }
        } catch (error) {
            // Ignore errors until timeout
            attempts++;
        }
    }, interval);
}
```

**Important Considerations:**
*   **Error Handling:** The `pollQdrantHealth` function should handle timeouts and fetch errors gracefully. It's crucial to inform the user if the database fails to start, perhaps with an error notification in VS Code.
*   **Hardcoded URL:** The URL `http://localhost:6333` is the default for Qdrant. For a more robust solution, this should be configurable.
*   **User Experience:** Provide feedback to the user that a health check is in progress (e.g., a "Checking..." status in the UI).

### 3. State Management (`setupStore.ts`)

The Svelte store remains simple for this sub-sprint. The `databaseReady` flag is the key piece of state managed here, which will be updated based on messages from the extension backend.

**File:** `webview/src/lib/stores/setupStore.ts`
```typescript
import { writable } from 'svelte/store';

export interface SetupState {
  databaseReady: boolean;
  providerSelected: string | null;
}

export const setupState = writable<SetupState>({
  databaseReady: false,
  providerSelected: null,
});
```
This typed store will help prevent errors and improve autocompletion in the Svelte components.
</file>

<file path="docs/todo/fe/prd.md">
<prd>Here is the software engineering roadmap based on your detailed project description.

| # | Theme | Milestone & Description | Timeframe | Assigned Team | Status |
| :- | :--- | :--- | :--- | :--- | :--- |
| 1 | **Backend Architecture** | **Develop C# Web API Foundation:** Build the initial ASP.NET Core Web API project, establishing the core service for the extension to communicate with. | Q1 2026 | Backend (C#) | Planned |
| 2 | **Backend Architecture** | **Implement Extensible Client Framework:** Use dependency injection and strategy patterns in C# to create abstract interfaces for various database clients and embedding providers. | Q1 2026 | Backend (C#) | Planned |
| 3 | **Extension Integration** | **Establish Extension-to-Backend Communication:** Implement logic in the TypeScript extension to manage (start/monitor) the C# backend process and communicate via local HTTP requests. | Q2 2026 | Frontend (TS/Svelte) | Not Started |
| 4 | **Onboarding & UI** | **Build Initial Setup & Indexing UI:** Create the Svelte UI that detects an un-indexed repository and presents the setup screen for database and embedding provider selection. | Q2 2026 | Frontend (TS/Svelte) | Not Started |
| 5 | **Core Functionality** | **Implement Qdrant & Ollama Clients:** Build the first concrete client implementations for the database (Qdrant) and embedding provider (Ollama) within the C# backend. | Q3 2026 | Backend (C#) | Not Started |
| 6 | **Onboarding & UI** | **Integrate Docker Helper Commands:** Connect the UI buttons to open a VS Code terminal and execute the required Docker commands for spinning up local databases. | Q3 2026 | Frontend (TS/Svelte) | Not Started |
| 7 | **Core Functionality** | **Develop End-to-End Indexing Workflow:** Connect the UI "Index" button to the C# API to trigger the full AST parsing, embedding, and vector storage process, showing progress in the UI. | Q4 2026 | Full Team | Not Started |
| 8 | **Core Functionality** | **Implement Core Query View:** Create the post-indexing UI with a simple input box for users to submit natural language queries to the C# backend for a response. | Q4 2026 | Full Team | Not Started |
| 9 | **Feature Enhancement** | **Build Settings Management & Re-Indexing:** Implement the settings (cog) icon functionality and the logic to trigger a full re-index when a user saves configuration changes. | Q1 2027 | Full Team | Not Started |

Of course. Let's continue with the detailed PRDs for the C\# backend and the UI onboarding, following the established roadmap.

-----

### **New Document: PRD 2: Backend Foundation - C\# Web API & Extensible Clients**

**1. Title & Overview**

  * **Project:** Code Context Engine - C\# Backend Foundation
  * **Summary:** This phase covers the creation of a robust, standalone C\# ASP.NET Core Web API. This backend service will handle all heavy lifting, including code parsing, vectorization, and database communication. The architecture will be designed for extensibility from day one, using dependency injection and abstract client interfaces to easily support various databases and embedding providers in the future.
  * **Dependencies:** Requires the .NET SDK and a C\# development environment (like VS Code with the C\# Dev Kit or Visual Studio).

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Decouple the core processing logic from the VS Code extension frontend, allowing for more robust and scalable development.
      * Create a flexible architecture that can adapt to new technologies (databases, embedding models) without significant refactoring.
  * **Developer & System Success Metrics:**
      * The C\# Web API project is successfully created and can be run locally.
      * A basic `/health` endpoint returns a `200 OK` status.
      * The service architecture correctly implements the strategy or factory pattern for database and embedding clients.
      * The solution includes separate class library projects for core logic, infrastructure, and the API, promoting clean architecture.
      * Unit tests are in place for the client abstraction layer.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha is responsible for building and maintaining the core indexing engine. She needs a well-structured, testable, and maintainable codebase that follows best practices for C\# development, such as dependency injection and clear separation of concerns.
  * **Devin (Developer - End User):** While Devin doesn't interact with this backend directly, he will benefit from its stability and performance. A well-architected backend ensures the indexing process is fast, reliable, and less prone to crashing.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Backend** | **Sprint 1: C\# Web API Boilerplate** | As Alisha, I want to create a new ASP.NET Core Web API project so we have the foundational service for our backend logic. | 1. A new .NET solution is created containing a Web API project.\<br/\>2. The API is configured to use minimal API syntax for endpoints.\<br/\>3. A basic `/health` endpoint is implemented that returns a success status.\<br/\>4. The project includes Swagger/OpenAPI support for API documentation and testing. | **2 Weeks** |
| | | As Alisha, I want to establish a clean architecture with separate projects for Core, Infrastructure, and API so that our codebase is organized and maintainable. | 1. The solution is organized into `CodeContext.Api`, `CodeContext.Core` (for domain logic/interfaces), and `CodeContext.Infrastructure` (for external clients).\<br/\>2. Project references are set up correctly (e.g., API depends on Core and Infrastructure).\<br/\>3. Basic folders and classes are created in each project to establish the structure. | |
| **Phase 2: Backend** | **Sprint 2: Extensible Client Framework** | As Alisha, I want to define abstract interfaces for database clients and embedding providers so we can easily add new implementations in the future. | 1. An `IEmbeddingProvider` interface with a `GenerateEmbeddingsAsync` method is created in `CodeContext.Core`.\<br/\>2. An `IVectorDatabaseClient` interface with `UpsertAsync` and `QueryAsync` methods is created in `CodeContext.Core`.\<br/\>3. These interfaces are agnostic of any specific technology (e.g., they use generic data types). | **2 Weeks** |
| | | As Alisha, I want to use dependency injection to register and resolve these clients so that the application is loosely coupled and testable. | 1. .NET's built-in dependency injection container is configured in `Program.cs`.\<br/\>2. A "factory" or "strategy" service is created that can resolve the correct client implementation based on a configuration string (e.g., "qdrant", "ollama").\<br/\>3. Unit tests are written to verify that the correct client is returned for a given configuration. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** C\# Web API Boilerplate (2 Weeks)
  * **Sprint 2:** Extensible Client Framework (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The development team is proficient in C\# and the .NET ecosystem.
  * **Risk:** Over-engineering the client framework. The initial design for the abstractions might be too complex for the immediate need.
      * **Mitigation:** Start with a simple interface and concrete implementation first (e.g., for Qdrant). Refactor to a more abstract factory pattern only when adding the second client (e.g., ChromaDB), following the rule of three.
  * **Risk:** Communication between the TypeScript extension and a C\# process can be complex to manage (e.g., starting, stopping, and handling errors).
      * **Mitigation:** This risk is primarily addressed in PRD 3, but in this phase, ensure the C\# API is simple and stateless (standard HTTP requests) to minimize integration complexity.

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - C\# Web API Boilerplate

**Goal:** To establish the foundational C\# ASP.NET Core Web API project with a clean architecture.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** | ☐ To Do | **Create .NET Solution & Projects:** Use the `dotnet new` CLI to create a solution file (`CodeContext.sln`) and three projects: `webapi`, `classlib` (for Core), and `classlib` (for Infrastructure). | `(Project Root)` |
| **1.2** | ☐ To Do | **Set Project References:** Configure the `.csproj` files so that the API project references the Core and Infrastructure projects. | `CodeContext.Api/CodeContext.Api.csproj` |
| **1.3** | ☐ To Do | **Implement Health Check Endpoint:** In the `Program.cs` of the API project, add a minimal API endpoint for `/health` that returns `Results.Ok()`. | `CodeContext.Api/Program.cs` |
| **1.4** | ☐ To Do | **Add Swagger/OpenAPI:** Configure the API to use Swashbuckle for generating an OpenAPI specification and a Swagger UI. | `CodeContext.Api/Program.cs` |
| **1.5** | ☐ To Do | **Define Core Interfaces:** In the Core project, create initial placeholder interfaces (`IEmbeddingProvider.cs`, `IVectorDatabaseClient.cs`). | `CodeContext.Core/` |
| **1.6** | ☐ To Do | **Define Infrastructure Placeholders:** In the Infrastructure project, create initial placeholder folders for `DatabaseClients` and `EmbeddingProviders`. | `CodeContext.Infrastructure/` |
| **1.7** | ☐ To Do | **Test API Launch:** Run the API project and ensure it starts correctly, and that you can access the `/health` endpoint and the `/swagger` UI in a browser. | `(Local Environment)` |

-----

### **New Document: PRD 3: VS Code Integration & UI Onboarding**

**1. Title & Overview**

  * **Project:** Code Context Engine - VS Code Integration & Onboarding
  * **Summary:** This phase focuses on the user's first experience. It involves building the Svelte UI for the initial setup and creating the TypeScript logic within the VS Code extension to manage the C\# backend process. This includes detecting when a repository hasn't been indexed, guiding the user through database and embedding model selection, and providing helper buttons to run Docker commands.
  * **Dependencies:** PRD 1 and PRD 2 must be complete. The C\# backend must be buildable and runnable from the command line.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Create a smooth and intuitive onboarding experience to maximize user activation.
      * Abstract away technical complexity (like running Docker) to make the tool accessible to a wider range of developers.
  * **Developer & System Success Metrics:**
      * The TypeScript extension can successfully spawn the C\# backend as a child process.
      * The extension can reliably check the health of the C\# backend by polling the `/health` endpoint.
      * The Svelte UI correctly displays the setup screen when no index configuration is found.
      * Clicking the "Start Database" button in the UI successfully opens a new VS Code terminal and runs the `docker-compose up` command.
      * The UI state updates correctly to show that the database is "running" after a successful health check.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: Integration & UI** | **Sprint 3: Backend Process Management** | As a developer, I want the VS Code extension to automatically start the C\# backend service when the extension is activated, so I don't have to run it manually. | 1. The extension uses Node.js's `child_process.spawn` to launch the compiled C\# executable.\<br/\>2. The extension correctly captures `stdout` and `stderr` from the C\# process for logging.\<br/\>3. The child process is automatically terminated when the extension is deactivated or VS Code is closed. | **2 Weeks** |
| | | As a developer, I want the extension to monitor the health of the C\# backend service so it can reliably send API requests. | 1. The extension periodically sends an HTTP GET request to the backend's `/health` endpoint.\<br/\>2. The UI state reflects whether the backend is "Starting", "Running", or "Error".\<br/\>3. If the health check fails multiple times, the process is restarted. | |
| **Phase 3: Integration & UI** | **Sprint 4: Onboarding & Setup UI** | As Devin, when I open a new project, I want the extension to check if it's been indexed and show me a setup screen if it hasn't. | 1. On activation, the extension looks for the `code-context.json` file in the `.vscode` directory.\<br/\>2. If the file is not found, the main webview panel displays the "Setup" component.\<br/\>3. If the file is found, the main webview panel displays the "Query" component (to be built later). | **2 Weeks** |
| | | As Devin, I want the setup screen to let me choose my database and embedding provider, with helper buttons to start any required local services. | 1. The UI presents dropdowns for selecting a database (Qdrant, etc.) and embedding provider (Ollama, etc.).\<br/\>2. A button next to the database selection ("Start Local Qdrant") is present.\<br/\>3. Clicking the button creates a new VS Code terminal and runs the appropriate `docker-compose` command.\<br/\>4. The UI shows a success indicator once the service is confirmed to be running via a health check. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 3:** Backend Process Management (2 Weeks)
  * **Sprint 4:** Onboarding & Setup UI (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The C\# backend executable can be reliably located and run from the TypeScript extension across different operating systems (Windows, macOS, Linux).
  * **Risk:** Managing the lifecycle of the child C\# process could be buggy, leading to orphaned processes that consume system resources.
      * **Mitigation:** Implement robust error handling and ensure the process is always killed in the `deactivate` function of the extension. Use libraries like `tree-kill` if necessary to ensure the entire process tree is terminated.
  * **Risk:** The user may not have Docker installed or running, causing the helper commands to fail.
      * **Mitigation:** Provide clear error messages in the UI and terminal. The UI should check for the `docker` command on the system's PATH and disable the button with a helpful tooltip if it's not found.

Of course. Here are the final PRDs and their associated task lists, completing the project roadmap.

-----

### **New Document: PRD 4: Core Functionality - End-to-End Indexing & Querying**

**1. Title & Overview**

  * **Project:** Code Context Engine - Core Functionality Implementation
  * **Summary:** This phase is about bringing the core user journey to life. It involves implementing the first concrete clients for Qdrant and Ollama within the C\# backend. We will then connect the UI to the backend to create a seamless, end-to-end indexing workflow. Finally, we will build the initial chat/query interface, allowing users to ask their first questions and receive contextually relevant answers from their indexed codebase.
  * **Dependencies:** PRD 3 must be complete. The extension must be able to manage the C\# backend process and display the initial setup UI.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Deliver the "Aha\!" moment for the user by providing the first tangible results from their indexed code.
      * Validate the end-to-end architecture, from UI interaction to backend processing and back.
  * **Developer & System Success Metrics:**
      * The C\# backend can successfully generate embeddings using a local Ollama instance and store them in a local Qdrant database.
      * The `IndexingService` in the C\# backend correctly orchestrates the full pipeline: AST parsing, embedding, and database upserting.
      * The UI's "Index Now" button successfully triggers the indexing process via an API call to the C\# backend.
      * The UI displays a real-time progress bar that accurately reflects the status sent from the backend.
      * A user can type a query into the main chat box, and the extension will return a list of relevant file paths based on a vector search.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin has just completed the initial setup. He now wants to see the extension in action. He needs a simple interface to start the indexing, see that it's working, and then ask a basic question to see if the tool can find relevant code for him.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 4: Core Functionality** | **Sprint 5: Concrete Client Implementation (C\#)** | As Alisha, I want to implement the concrete client for Qdrant so that the backend can communicate with the vector database. | 1. A `QdrantClient` class is created in the Infrastructure project that implements `IVectorDatabaseClient`.\<br/\>2. The client correctly connects to the Qdrant instance specified in the configuration.\<br/\>3. The `UpsertAsync` method successfully saves vectors and their payloads to the database. | **2 Weeks** |
| | | As Alisha, I want to implement the concrete client for Ollama so that the backend can generate embeddings. | 1. An `OllamaProvider` class is created that implements `IEmbeddingProvider`.\<br/\>2. The provider makes successful HTTP POST requests to a local Ollama `/api/embeddings` endpoint.\<br/\>3. The class correctly parses the response to extract the embedding vectors.\<br/\>4. The implementation is registered with the dependency injection container. | |
| **Phase 4: Core Functionality** | **Sprint 6: End-to-End Indexing & Query UI** | As Devin, I want to click the "Index Now" button and see a progress bar while my code is being indexed so I have clear feedback on the process. | 1. Clicking the "Index Now" button in the Svelte UI sends a `POST /index` request to the C\# backend.\<br/\>2. The backend streams progress updates (e.g., via Server-Sent Events or WebSockets) back to the UI.\<br/\>3. The Fluent UI progress bar in the Svelte component updates based on the events received from the backend.\<br/\>4. The UI transitions to the "Query" view upon receiving a "completed" event. | **2 Weeks** |
| | | As Devin, after indexing is complete, I want to see a chat input box where I can type a question to find relevant code. | 1. A new "Query" Svelte component is created, featuring a text input and a submit button.\<br/\>2. Typing a query and hitting Enter sends a `POST /query` request to the C\# backend with the query text.\<br/\>3. The backend performs a vector search using the query and returns a list of file paths.\<br/\>4. The UI displays the returned file paths as a simple list. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 5:** Concrete Client Implementation (C\#) (2 Weeks)
  * **Sprint 6:** End-to-End Indexing & Query UI (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The selected Ollama embedding model provides sufficiently accurate embeddings for code to yield relevant search results.
  * **Risk:** The real-time progress update mechanism (e.g., SSE or WebSockets) could be complex to implement between the C\# backend and the VS Code webview.
      * **Mitigation:** Start with a simpler polling mechanism if a streaming approach proves too difficult. The frontend can poll a `/index/status` endpoint on the backend every few seconds to get the progress.
  * **Risk:** The performance of the end-to-end indexing on a large repository might be slow, leading to a poor user experience.
      * **Mitigation:** Focus on optimizing the "hot path" in the C\# backend—specifically, batching requests to the embedding provider and the database client to improve throughput.

-----

### **New Document: tasklist\_sprint\_05.md**

# Task List: Sprint 5 - Concrete Client Implementation (C\#)

**Goal:** To build the first concrete implementations for the database and embedding provider clients in the C\# backend.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** | ☐ To Do | **Add Qdrant.Client NuGet Package:** Install the official Qdrant .NET client library into the `CodeContext.Infrastructure` project. | `CodeContext.Infrastructure/CodeContext.Infrastructure.csproj` |
| **5.2** | ☐ To Do | **Implement `QdrantClient` Class:** Create the class that implements `IVectorDatabaseClient`. Implement the `UpsertAsync` method using the NuGet package's API. | `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs` |
| **5.3** | ☐ To Do | **Implement `OllamaProvider` Class:** Create the class that implements `IEmbeddingProvider`. Use `HttpClient` to send requests to the Ollama API. | `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs` |
| **5.4** | ☐ To Do | **Add AST Parsing Logic:** Integrate a C\# AST parsing library (e.g., Roslyn for C\#, a community library for others) into a new `ParsingService`. | `CodeContext.Core/Services/ParsingService.cs` |
| **5.5** | ☐ To Do | **Create `IndexingService`:** Build the main service in `CodeContext.Core` that orchestrates the workflow: takes file paths, calls the `ParsingService`, the `IEmbeddingProvider`, and the `IVectorDatabaseClient`. | `CodeContext.Core/Services/IndexingService.cs` |
| **5.6** | ☐ To Do | **Register Services with DI:** In the API project's `Program.cs`, register all new services and clients with the dependency injection container. | `CodeContext.Api/Program.cs` |
| **5.7** | ☐ To Do | **Create `/index` Endpoint:** Create the initial API endpoint that will trigger the `IndexingService`. | `CodeContext.Api/Program.cs` |

-----

### **New Document: PRD 5: Feature Enhancement & Polish**

**1. Title & Overview**

  * **Project:** Code Context Engine - Settings & Release Readiness
  * **Summary:** This final phase focuses on polishing the user experience and preparing the extension for its first public release. It involves building the settings management UI, enabling users to change their configuration and trigger a re-index. It also includes creating essential user and contributor documentation and establishing a CI/CD pipeline to automate builds and deployments to the marketplace.
  * **Dependencies:** PRD 4 must be complete. The core indexing and querying loop must be functional.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Increase user trust and adoption through a professional and polished user experience.
      * Ensure the long-term maintainability and scalability of the project by automating the release process.
  * **Developer & System Success Metrics:**
      * The settings UI correctly reads from and writes to the extension's configuration.
      * Saving a new configuration (e.g., changing the embedding model) successfully triggers the re-indexing workflow.
      * A GitHub Actions workflow is in place that automatically builds and tests the extension on every pull request.
      * The extension is successfully published to the VS Code Marketplace via an automated pipeline.
      * The project's `README.md` provides clear instructions for installation and use.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 5: Polish** | **Sprint 7: Settings Management & Re-Indexing** | As Devin, I want a settings icon in the UI so I can go back and change my database or embedding provider at any time. | 1. A "cog" icon is added to the main UI panel.\<br/\>2. Clicking the icon navigates the webview to the "Setup" component, pre-filled with the current configuration.\<br/\>3. The current configuration is read from the `code-context.json` file. | **2 Weeks** |
| | | As Devin, when I save a change in the settings, I want the extension to automatically re-index my project so that my changes take effect. | 1. The "Save" button in the settings UI is relabeled "Save & Re-Index".\<br/\>2. Clicking the button first saves the new configuration to `code-context.json`.\<br/\>3. After saving, the extension automatically triggers the end-to-end indexing process.\<br/\>4. The UI displays the progress bar, and transitions back to the query view on completion. | |
| **Phase 5: Polish** | **Sprint 8: Documentation & Publishing** | As a project owner, I want a CI/CD pipeline to automate builds and testing so we can ensure code quality and release reliability. | 1. A GitHub Actions workflow is created to run on every pull request.\<br/\>2. The workflow includes steps to build the C\# backend and the SvelteKit frontend.\<br/\>3. The workflow runs all unit tests for both the backend and frontend.\<br/\>4. A separate, manually triggered "release" workflow is created to publish the extension. | **2 Weeks** |
| | | As Devin, I want clear documentation in the `README.md` file so I can easily understand how to install and use the extension. | 1. The `README.md` is updated with sections for "Features", "Installation", "Configuration", and a "Quick Start" guide.\<br/\>2. A short animated GIF is created to demonstrate the primary user workflow.\<br/\>3. A `CONTRIBUTING.md` file is added to guide potential contributors. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 7:** Settings Management & Re-Indexing (2 Weeks)
  * **Sprint 8:** Documentation & Publishing (2 Weeks)

-----

### **New Document: tasklist\_sprint\_06.md**

# Task List: Sprint 6 - End-to-End Indexing & Query UI

**Goal:** To connect the frontend and backend to create the core indexing and querying user workflows.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** | ☐ To Do | **Implement Progress Reporting:** In the C\# `IndexingService`, implement a mechanism (e.g., a callback or event bus) to report progress updates. | `CodeContext.Core/Services/IndexingService.cs` |
| **6.2** | ☐ To Do | **Create Progress Endpoint:** Expose progress updates via a WebSocket or Server-Sent Events (SSE) endpoint in the C\# API. | `CodeContext.Api/Program.cs` |
| **6.3** | ☐ To Do | **Connect UI to Progress Endpoint:** In the SvelteKit UI, connect to the progress endpoint after triggering an index and update the progress bar component. | `webview/src/lib/components/IndexingView.svelte` |
| **6.4** | ☐ To Do | **Create Query View Component:** Build the `QueryView.svelte` component with a text input for questions and an area to display results. | `webview/src/lib/components/QueryView.svelte` |
| **6.5** | ☐ To Do | **Implement `/query` Endpoint in C\#:** Create the API endpoint that takes a query string, generates an embedding for it, and uses the `IVectorDatabaseClient` to perform a similarity search. | `CodeContext.Api/Program.cs` |
| **6.6** | ☐ To Do | **Connect UI to `/query` Endpoint:** When the user submits a query in the UI, make a `POST` request to the `/query` endpoint and display the returned file paths. | `webview/src/lib/components/QueryView.svelte` |
| **6.7** | ☐ To Do | **Implement UI State Transition:** Manage the application's state to correctly switch from the `IndexingView` to the `QueryView` upon successful completion. | `webview/src/lib/stores/viewStore.ts` |

This completes the full set of Product Requirements Documents and their associated task lists for your project. You now have a comprehensive, strategic plan that takes you from the initial architectural decisions all the way to a polished, publishable VS Code extension.

Of course. Let's continue with the remaining PRDs and task lists to complete the UI/UX development plan for your extension.

-----

### **New Document: PRD 2: UI/UX - Indexing Progress View**

**1. Title & Overview**

  * **Project:** Code Context Engine - Indexing Progress UI
  * **Summary:** This phase is dedicated to building the UI that provides users with clear, real-time feedback while their repository is being indexed. A well-executed progress view is crucial for user trust, as it communicates that the extension is working and prevents the perception of it being frozen or broken during a potentially long-running task.
  * **Dependencies:** PRD 1 (Onboarding & Setup UI) must be complete. The C\# backend must provide an endpoint (either WebSocket or SSE) that streams progress updates.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Improve user retention during the initial, critical indexing phase by providing a transparent and informative experience.
      * Reduce user friction and prevent premature cancellation of the indexing process.
  * **User Success Metrics:**
      * The progress bar accurately reflects the real-world progress of the indexing job with less than a 5% margin of error.
      * The status text updates clearly, informing the user of the current stage (e.g., "Parsing files", "Generating embeddings").
      * User-initiated cancellations of the indexing process are below 10%.

-----

**3. User Personas**

  * **Devin (Developer - End User):** After clicking "Index Now," Devin expects immediate feedback. He wants to see that the process has started and get a reasonable estimate of how long it might take. Clear progress indicators give him the confidence to let the extension run while he works on other things.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Progress UI** | **Sprint 2: Progress View Implementation** | As Devin, after starting the indexing, I want to see a dedicated view with a progress bar so I know that the process is running. | 1. After the "startIndexing" message is sent, the webview immediately transitions to the `IndexingProgressView` component.\<br/\>2. A Fluent UI `<ProgressBar>` is prominently displayed.\<br/\>3. A text label below the bar shows the current percentage and a status message (e.g., "0% - Initializing..."). | **2 Weeks** |
| | | As Devin, I want the progress bar and status text to update in real-time as the indexing proceeds through different stages. | 1. The SvelteKit frontend successfully establishes a connection to the backend's progress streaming endpoint.\<br/\>2. The progress bar's value is reactively bound to the percentage received from the backend.\<br/\>3. The status text updates to reflect the messages sent from the backend (e.g., file names, current stage).\<br/\>4. The UI gracefully handles a dropped connection and attempts to reconnect. | |
| | | As Devin, I want the view to automatically switch to the main query interface once the indexing is complete. | 1. Upon receiving a "completed" event from the backend, the progress bar fills to 100%.\<br/\>2. A "Complete" message is briefly displayed.\<br/\>3. After a short delay (e.g., 1-2 seconds), the application state changes, and the `QueryView` component is rendered. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 2:** Progress View Implementation (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The backend can provide reasonably accurate progress percentages. If the backend can only provide status messages, the progress bar might need to be an indeterminate one.
  * **Risk:** A WebSocket or SSE connection between the VS Code webview and a local C\# process might be blocked by local firewall or security software.
      * **Mitigation:** Provide a fallback mechanism where the UI polls a standard HTTP endpoint (`GET /index/status`) every few seconds. This is less efficient but more reliable.
  * **Risk:** The UI might become unresponsive if it receives a very high frequency of progress updates from the backend.
      * **Mitigation:** Implement throttling or debouncing on the frontend to ensure the UI only re-renders at a reasonable interval (e.g., every 100-200ms).

-----

### **New Document: Sub-Sprint 3: Backend Connection for Progress Updates**

**Objective:**
To establish the communication channel from the SvelteKit frontend to the C\# backend to receive real-time progress events.

**Parent Sprint:**
PRD 2, Sprint 2: Progress View Implementation

**Tasks:**

1.  **Choose Streaming Technology:** Decide on the technology for real-time updates (WebSockets are a good choice for this).
2.  **Implement WebSocket Client:** In the SvelteKit app, create a service that connects to the C\# backend's WebSocket endpoint when the indexing view is loaded.
3.  **Create Progress Store:** Implement a new Svelte store (`progressStore.ts`) to hold the current percentage and status message.
4.  **Update Store on Message:** The WebSocket client, upon receiving a message from the backend, will parse the data and update the `progressStore`.

**Acceptance Criteria:**

  * The frontend successfully connects to the backend's WebSocket server.
  * Messages sent from the backend are correctly received and logged in the frontend's developer console.
  * The `progressStore` is accurately updated with the received data.

**Dependencies:**

  * The C\# backend must have a WebSocket or SSE endpoint that broadcasts progress.

**Timeline:**

  * **Start Date:** 2026-01-19
  * **End Date:** 2026-01-23

-----

### **New Document: Sub-Sprint 4: Svelte Progress UI Component**

**Objective:**
To build the user-facing Svelte component that displays the indexing progress.

**Parent Sprint:**
PRD 2, Sprint 2: Progress View Implementation

**Tasks:**

1.  **Create `IndexingProgressView.svelte`:** Build the main component for this view.
2.  **Add Fluent UI ProgressBar:** Integrate and style the `<ProgressBar>` component.
3.  **Subscribe to Progress Store:** In the component's script, subscribe to the `progressStore` to get live updates.
4.  **Bind UI to Store:** Reactively bind the `value` of the progress bar and the content of the status text label to the data from the store.
5.  **Implement Completion Logic:** Use a reactive statement (`$:`) to watch for when the progress percentage reaches 100, then trigger a state change to navigate to the query view.

**Acceptance Criteria:**

  * The progress bar visually updates as the value in the store changes.
  * The status text correctly displays the message from the store.
  * When progress hits 100, the UI automatically transitions to the next view.

**Dependencies:**

  * Sub-Sprint 3 must be complete.

**Timeline:**

  * **Start Date:** 2026-01-26
  * **End Date:** 2026-01-30

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Progress View Implementation

**Goal:** To build the UI for displaying real-time indexing progress to the user.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** | ☐ To Do | **Install WebSocket client library:** Add a library like `socket.io-client` or use the native browser `WebSocket` API. | `webview/package.json` |
| **2.2** | ☐ To Do | **Create `progressStore.ts`:** Define a new Svelte store with `percentage` and `message` properties. | `webview/src/lib/stores/progressStore.ts` |
| **2.3** | ☐ To Do | **Create `ProgressService.ts`:** Implement the client-side logic to connect to the backend WebSocket and update the `progressStore`. | `webview/src/lib/services/ProgressService.ts` |
| **2.4** | ☐ To Do | **Build `IndexingProgressView.svelte` component:** Add the Fluent UI progress bar and text labels. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.5** | ☐ To Do | **Connect Component to Store:** In the Svelte component, import and subscribe to the `progressStore`. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.6** | ☐ To Do | **Implement UI Bindings:** Bind the `value` of the progress bar and the text content of the label to the store's reactive variables. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.7** | ☐ To Do | **Implement View Transition Logic:** In the main view manager, listen for the "completion" state and switch the visible component to the `QueryView`. | `webview/src/lib/ViewManager.svelte` |
| **2.8** | ☐ To Do | **Test with Mock Backend:** Create a mock backend service that sends simulated progress updates to test the UI in isolation. | `webview/src/lib/mocks/mockProgressService.ts` |

-----

### **New Document: PRD 3: UI/UX - Main Query & Results View**

**1. Title & Overview**

  * **Project:** Code Context Engine - Main Query Interface
  * **Summary:** This phase covers the development of the primary user interface where developers will interact with the indexed codebase. The design will focus on simplicity and efficiency, providing a clean, chat-like experience for asking questions and receiving results. This view is the core of the product's day-to-day value.
  * **Dependencies:** The indexing process must be complete, and the C\# backend must expose a `/query` endpoint.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Drive daily active usage by providing a powerful and easy-to-use interface for code discovery.
      * Clearly demonstrate the value of the indexing process by providing fast, relevant search results.
  * **User Success Metrics:**
      * The time from submitting a query to seeing the first result is less than 2 seconds.
      * The UI for displaying results is clear and allows users to easily identify and navigate to the relevant files.
      * The settings icon is easily discoverable, allowing users to return to the configuration view when needed.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: Query UI** | **Sprint 3: Query & Results Implementation** | As Devin, after my project is indexed, I want to see a simple text box where I can type my question, so I can start searching immediately. | 1. The `QueryView` component is displayed after indexing is complete.\<br/\>2. A Fluent UI `<TextField>` is shown at the bottom of the view, styled like a chat input.\<br/\>3. A "Submit" button or icon is present, and pressing "Enter" also triggers a submission. | **2 Weeks** |
| | | As Devin, when I submit a query, I want to see the list of relevant files returned by the engine, so I can find the code I'm looking for. | 1. Submitting a query sends a `POST` request to the C\# backend's `/query` endpoint.\<br/\>2. While waiting for a response, a loading indicator is displayed.\<br/\>3. The returned list of file paths is displayed in a clean, scrollable list in the main view area.\<br/\>4. Each file path is a clickable link that opens the corresponding file in a new VS Code editor tab. | |
| | | As Devin, I want to be able to easily access the settings to re-configure my project, so I can change the embedding model or database later. | 1. A "cog" icon is displayed in the top-right corner of the view.\<br/\>2. Clicking the icon navigates the user back to the `SetupView` component.\<br/\>3. The `SetupView` is pre-populated with the project's current, saved configuration. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 3:** Query & Results Implementation (2 Weeks)

This completes the full set of Product Requirements Documents and associated task lists for the UI/UX of your extension. You now have a comprehensive plan covering the entire frontend user journey, from initial setup to actively querying the codebase.
</prd>
[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/ux/prd.md">
<prd>Of course. Here are the detailed PRDs focusing specifically on the frontend UI/UX development for your VS Code extension, broken down by each user-facing view.

-----

### **New Document: PRD 1: Foundational - Onboarding & Setup UI**

**1. Title & Overview**

  * **Project:** Code Context Engine - Onboarding UI/UX
  * **Summary:** This phase focuses on building the user's first interaction with the extension: the onboarding and setup view. This UI is critical for user activation and must clearly guide the user through configuring the necessary database and embedding providers for a new, un-indexed repository.
  * **Dependencies:** Requires the foundational SvelteKit and Fluent UI boilerplate (from the previous UI/UX roadmap) to be in place. The VS Code extension must be able to detect whether a repository has an existing configuration.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Maximize the rate of successful user onboarding (i.e., users who complete the setup and start indexing).
      * Minimize user confusion and support requests by making the setup process intuitive and self-explanatory.
  * **User Success Metrics:**
      * A new user can successfully configure and start the indexing process in under 2 minutes.
      * The UI provides clear feedback and status indicators (e.g., "database is running") to build user confidence.
      * The setup completion rate (users who click "Index Now") is above 85% for first-time users.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin has just installed the extension and opened a project. He needs a simple, step-by-step process to get started. He doesn't want to read lengthy documentation; the UI should guide him through the necessary choices and actions.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Onboarding** | **Sprint 1: Setup View Implementation** | As Devin, when I open an un-indexed project, I want to see a clear setup screen so I know what I need to do to get started. | 1. The extension correctly identifies when no `code-context.json` file is present and displays the `SetupView` component.\<br/\>2. The view contains distinct sections for "Database Configuration" and "Embedding Provider".\<br/\>3. The primary call-to-action button ("Index Now") is initially disabled. | **2 Weeks** |
| | | As Devin, I want to select my desired vector database and get help starting it if it's not running. | 1. A dropdown allows selecting "Qdrant".\<br/\>2. A button labeled "Start Local Qdrant" is visible.\<br/\>3. Clicking the button opens a new VS Code terminal and executes the `docker-compose up` command.\<br/\>4. A status icon next to the dropdown changes from "Not Running" to "Running" after a successful health check to the backend service. | |
| | | As Devin, I want to choose which embedding model to use for indexing my code. | 1. A dropdown allows selecting an embedding provider (e.g., "Ollama", "OpenAI").\<br/\>2. The "Index Now" button becomes enabled only after both the database is confirmed running and an embedding provider has been selected.\<br/\>3. The chosen configuration is saved to a state management store. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 1:** Setup View Implementation (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** Users will have Docker installed and running on their machine for local database setup.
  * **Risk:** The logic for detecting if a local service (like Qdrant) is running could be unreliable across different user machine setups.
      * **Mitigation:** Rely on the C\# backend to perform the health check and pass a simple boolean status to the frontend. This centralizes the logic and makes the UI's job simpler.
  * **Risk:** The user might be confused about what to do if the Docker command fails.
      * **Mitigation:** The TypeScript extension should monitor the terminal process it creates. If the process exits with a non-zero code, display a VS Code error notification with a link to a troubleshooting guide in the `README`.

-----

### **New Document: Sub-Sprint 1: Database Configuration Component**

**Objective:**
To build the Svelte component for the database selection and management part of the setup view.

**Parent Sprint:**
PRD 1, Sprint 1: Setup View Implementation

**Tasks:**

1.  **Create `DatabaseSetup.svelte` component:** Build the UI with a Fluent UI `<Select>` component for the database choice.
2.  **Implement "Start" button:** Add a Fluent UI `<Button>` that, when clicked, sends a message to the TypeScript extension backend to execute the Docker command.
3.  **Display Status Indicator:** Add a small status icon and text (e.g., "⚫ Not Running" / "🟢 Running") that is bound to a reactive variable from a Svelte store.
4.  **Backend Message Handling:** The TypeScript extension will listen for the "startDatabase" message, create a new VS Code `Terminal`, and run the command.

**Acceptance Criteria:**

  * The dropdown displays "Qdrant" as an option.
  * Clicking the button successfully opens a terminal and runs `docker-compose up`.
  * The UI status correctly reflects the health status received from the backend.

**Dependencies:**

  * VS Code extension boilerplate must be complete.
  * A `docker-compose.yml` file must exist in the project root.

**Timeline:**

  * **Start Date:** 2026-01-05
  * **End Date:** 2026-01-09

-----

### **New Document: Sub-Sprint 2: Embedding Provider & Workflow Logic**

**Objective:**
To build the embedding provider selection component and the final workflow logic to enable indexing.

**Parent Sprint:**
PRD 1, Sprint 1: Setup View Implementation

**Tasks:**

1.  **Create `EmbeddingSetup.svelte` component:** Build the UI with a Fluent UI `<Select>` to choose between "Ollama" and "OpenAI".
2.  **Implement Main "Index Now" Button:** Create the primary call-to-action button for the setup view.
3.  **Create Svelte Store for State:** Implement a Svelte writable store to manage the overall setup state (e.g., `databaseReady`, `providerSelected`).
4.  **Conditional Button Logic:** The "Index Now" button's `disabled` attribute should be reactively bound to the store's state, enabling only when all conditions are met.
5.  **Trigger Indexing:** When clicked, the button sends a "startIndexing" message to the backend with the selected configuration.

**Acceptance Criteria:**

  * The dropdown displays "Ollama" and "OpenAI" as options.
  * The "Index Now" button is disabled by default.
  * The button becomes enabled after the database is running AND a provider is selected.
  * Clicking the button successfully sends the configuration details to the extension backend.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2026-01-12
  * **End Date:** 2026-01-16

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Setup View Implementation

**Goal:** To build the complete user onboarding and setup UI within the VS Code extension's webview.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** | ☐ To Do | **Create `SetupView.svelte` main component:** This component will act as the container for the setup process. | `webview/src/lib/views/SetupView.svelte` |
| **1.2** | ☐ To Do | **Implement `DatabaseSetup.svelte` component:** Build the UI for database selection, the "Start" button, and status indicator. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.3** | ☐ To Do | **Implement `EmbeddingSetup.svelte` component:** Build the UI for embedding provider selection. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.4** | ☐ To Do | **Create `setupStore.ts`:** Define a Svelte store to manage the configuration state (`database`, `provider`, `isDbRunning`). | `webview/src/lib/stores/setupStore.ts` |
| **1.5** | ☐ To Do | **Add `runCommandInTerminal` to extension backend:** In `extension.ts`, create a handler that receives a command string from the webview and executes it in a new VS Code terminal. | `src/extension.ts` |
| **1.6** | ☐ To Do | **Implement state logic:** Connect the components to the store so that selecting options updates the state. | `webview/src/lib/views/SetupView.svelte` |
| **1.7** | ☐ To Do | **Bind "Index Now" button's disabled state:** Use a reactive statement in Svelte (`$:`) to derive the button's state from the store. | `webview/src/lib/views/SetupView.svelte` |
| **1.8** | ☐ To Do | **Test full UI flow:** Manually test the entire onboarding process: start database, select provider, and ensure the "Index Now" button enables correctly. | `(Manual Test)` |

</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="src/extension.ts">
import * as vscode from 'vscode';
import * as path from 'path';

let currentPanel: vscode.WebviewPanel | undefined = undefined;

export function activate(context: vscode.ExtensionContext) {
    console.log('Congratulations, your extension "code-context-engine" is now active!');

    // Register command to open main panel
    let openPanelDisposable = vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
        if (currentPanel) {
            currentPanel.reveal(vscode.ViewColumn.One);
        } else {
            currentPanel = vscode.window.createWebviewPanel(
                'codeContextEngine',
                'Code Context Engine',
                vscode.ViewColumn.One,
                {
                    enableScripts: true,
                    retainContextWhenHidden: true,
                    localResourceRoots: [
                        vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                    ]
                }
            );

            // Set the HTML content for the webview
            currentPanel.webview.html = getWebviewContent(currentPanel.webview, context.extensionPath);

            // Handle messages from the webview
            currentPanel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'startIndexing':
                            vscode.commands.executeCommand('code-context-engine.startIndexing');
                            return;
                    }
                },
                undefined,
                context.subscriptions
            );

            // Clean up when the panel is closed
            currentPanel.onDidDispose(
                () => {
                    currentPanel = undefined;
                },
                null,
                context.subscriptions
            );
        }
    });

    // Register command to start indexing
    let indexingDisposable = vscode.commands.registerCommand('code-context-engine.startIndexing', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            const workspaceRoot = workspaceFolders[0].uri.fsPath;
            
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: "Indexing Repository",
                cancellable: true
            }, async (progress, token) => {
                progress.report({ message: "Starting indexing process..." });
                
                // TODO: Implement actual indexing logic in future sprints
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                if (!token.isCancellationRequested) {
                    vscode.window.showInformationMessage('Indexing complete! (Placeholder implementation)');
                }
            });
        } else {
            vscode.window.showErrorMessage("Please open a folder or workspace to index.");
        }
    });

    context.subscriptions.push(openPanelDisposable, indexingDisposable);
}

function getWebviewContent(webview: vscode.Webview, extensionPath: string): string {
    // For now, return a simple HTML content
    // In the next task, we'll integrate SvelteKit
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Context Engine</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            padding: 20px;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        .button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 0;
        }
        .button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }
        .progress-container {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Code Context Engine</h1>
        <p>Welcome to the Code Context Engine! This extension helps you understand and navigate your codebase using AI-powered context analysis.</p>
        
        <div class="progress-container">
            <h3>Repository Indexing</h3>
            <p>Click the button below to start indexing your repository:</p>
            <button class="button" onclick="startIndexing()">Index Now</button>
            <div id="progress-bar" style="display: none;">
                <p>Indexing in progress...</p>
            </div>
        </div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();

        function startIndexing() {
            document.getElementById('progress-bar').style.display = 'block';
            vscode.postMessage({
                command: 'startIndexing'
            });
        }
    </script>
</body>
</html>`;
}

export function deactivate() {}
</file>

<file path="webview/src/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Context Engine</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .header {
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
        }
        .progress-section {
            display: none;
        }
        .progress-section.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Code Context Engine</h1>
            <p>AI-powered code context and search for your workspace</p>
        </div>

        <div class="section">
            <h2>Repository Indexing</h2>
            <p>Index your repository to enable AI-powered code search and context analysis.</p>
            <fluent-button id="index-button" appearance="accent">Index Repository</fluent-button>
            
            <div id="progress-section" class="progress-section">
                <h3>Indexing Progress</h3>
                <fluent-progress-ring id="progress-ring"></fluent-progress-ring>
                <p id="progress-text">Starting indexing process...</p>
            </div>
        </div>

        <div class="section">
            <h2>Search & Context</h2>
            <p>Search through your indexed code and get AI-powered context.</p>
            <fluent-text-field id="search-input" placeholder="Search your code..." style="width: 100%; margin-bottom: 10px;"></fluent-text-field>
            <fluent-button id="search-button">Search</fluent-button>
            
            <div id="search-results" style="margin-top: 20px;">
                <!-- Search results will be displayed here -->
            </div>
        </div>

        <div class="section">
            <h2>Settings</h2>
            <p>Configure your Code Context Engine preferences.</p>
            <fluent-button id="settings-button" appearance="stealth">Open Settings</fluent-button>
        </div>
    </div>
</body>
</html>
</file>

<file path="webview/src/index.ts">
import './styles.css';
import {
    provideFluentDesignSystem,
    fluentButton,
    fluentTextField,
    fluentProgressRing
} from '@fluentui/web-components';

// Register Fluent UI components
provideFluentDesignSystem()
    .register(
        fluentButton(),
        fluentTextField(),
        fluentProgressRing()
    );

// VS Code API interface
declare const acquireVsCodeApi: () => {
    postMessage: (message: any) => void;
    getState: () => any;
    setState: (state: any) => void;
};

class CodeContextWebview {
    private vscode: ReturnType<typeof acquireVsCodeApi>;
    private indexButton: HTMLElement | null;
    private progressSection: HTMLElement | null;
    private progressRing: HTMLElement | null;
    private progressText: HTMLElement | null;
    private searchButton: HTMLElement | null;
    private searchInput: HTMLElement | null;
    private searchResults: HTMLElement | null;
    private settingsButton: HTMLElement | null;

    constructor() {
        this.vscode = acquireVsCodeApi();
        this.initializeElements();
        this.setupEventListeners();
        this.setupMessageListener();
    }

    private initializeElements(): void {
        this.indexButton = document.getElementById('index-button');
        this.progressSection = document.getElementById('progress-section');
        this.progressRing = document.getElementById('progress-ring');
        this.progressText = document.getElementById('progress-text');
        this.searchButton = document.getElementById('search-button');
        this.searchInput = document.getElementById('search-input');
        this.searchResults = document.getElementById('search-results');
        this.settingsButton = document.getElementById('settings-button');
    }

    private setupEventListeners(): void {
        this.indexButton?.addEventListener('click', () => {
            this.startIndexing();
        });

        this.searchButton?.addEventListener('click', () => {
            this.performSearch();
        });

        this.searchInput?.addEventListener('keypress', (event) => {
            if ((event as KeyboardEvent).key === 'Enter') {
                this.performSearch();
            }
        });

        this.settingsButton?.addEventListener('click', () => {
            this.openSettings();
        });
    }

    private setupMessageListener(): void {
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'indexingProgress':
                    this.updateIndexingProgress(message.progress, message.message);
                    break;
                case 'indexingComplete':
                    this.indexingComplete();
                    break;
                case 'searchResults':
                    this.displaySearchResults(message.results);
                    break;
            }
        });
    }

    private startIndexing(): void {
        this.vscode.postMessage({
            command: 'startIndexing'
        });

        // Show progress section
        this.progressSection?.classList.add('visible');
        if (this.indexButton) {
            (this.indexButton as any).disabled = true;
        }
    }

    private updateIndexingProgress(progress: number, message: string): void {
        if (this.progressText) {
            this.progressText.textContent = message;
        }
        // Update progress ring if needed
    }

    private indexingComplete(): void {
        if (this.progressText) {
            this.progressText.textContent = 'Indexing complete!';
        }
        if (this.indexButton) {
            (this.indexButton as any).disabled = false;
        }
        
        // Hide progress section after a delay
        setTimeout(() => {
            this.progressSection?.classList.remove('visible');
        }, 2000);
    }

    private performSearch(): void {
        const searchTerm = (this.searchInput as any)?.value;
        if (!searchTerm) return;

        this.vscode.postMessage({
            command: 'search',
            query: searchTerm
        });

        // Show loading state
        if (this.searchResults) {
            this.searchResults.innerHTML = '<p>Searching...</p>';
        }
    }

    private displaySearchResults(results: any[]): void {
        if (!this.searchResults) return;

        if (results.length === 0) {
            this.searchResults.innerHTML = '<p>No results found.</p>';
            return;
        }

        const resultsHtml = results.map(result => `
            <div style="margin-bottom: 15px; padding: 10px; border: 1px solid var(--vscode-panel-border); border-radius: 4px;">
                <h4>${result.file}</h4>
                <p>${result.snippet}</p>
                <small>Line ${result.line}</small>
            </div>
        `).join('');

        this.searchResults.innerHTML = resultsHtml;
    }

    private openSettings(): void {
        this.vscode.postMessage({
            command: 'openSettings'
        });
    }
}

// Initialize the webview when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new CodeContextWebview();
});
</file>

<file path="webview/package.json">
{
  "name": "code-context-engine-webview",
  "version": "1.0.0",
  "description": "Webview for Code Context Engine VS Code Extension",
  "main": "dist/index.js",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack --mode development --watch",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "webpack": "^5.88.0",
    "webpack-cli": "^5.1.0",
    "ts-loader": "^9.4.0",
    "typescript": "^4.9.0",
    "css-loader": "^6.8.0",
    "style-loader": "^3.3.0",
    "html-webpack-plugin": "^5.5.0"
  },
  "dependencies": {
    "@fluentui/web-components": "^2.5.16"
  }
}
</file>

<file path="webview/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "DOM",
      "DOM.Iterable",
      "ES6"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": false,
    "declaration": true,
    "outDir": "./dist"
  },
  "include": [
    "src"
  ]
}
</file>

<file path="webview/webpack.config.js">
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.ts',
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html',
    }),
  ],
};
</file>

<file path=".eslintrc.json">
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 6,
        "sourceType": "module"
    },
    "plugins": [
        "@typescript-eslint"
    ],
    "rules": {
        "@typescript-eslint/naming-convention": [
            "warn",
            {
                "selector": "import",
                "format": [ "camelCase", "PascalCase" ]
            }
        ],
        "@typescript-eslint/semi": "warn",
        "curly": "warn",
        "eqeqeq": "warn",
        "no-throw-literal": "warn",
        "semi": "off"
    },
    "ignorePatterns": [
        "out",
        "dist",
        "**/*.d.ts"
    ]
}
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
</file>

<file path="package.json">
{
  "name": "code-context-engine",
  "displayName": "Code Context Engine",
  "description": "AI-powered code context and search extension for VS Code",
  "version": "0.0.1",
  "publisher": "bramburn",
  "engines": {
    "vscode": "^1.74.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onCommand:code-context-engine.openMainPanel",
    "onCommand:code-context-engine.startIndexing"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "code-context-engine.openMainPanel",
        "title": "Open Code Context Panel",
        "category": "Code Context"
      },
      {
        "command": "code-context-engine.startIndexing",
        "title": "Index Repository",
        "category": "Code Context"
      }
    ],
    "configuration": {
      "title": "Code Context Engine",
      "properties": {
        "code-context-engine.embeddingProvider": {
          "type": "string",
          "default": "ollama",
          "enum": ["ollama", "openai"],
          "description": "Embedding provider to use for vectorization"
        },
        "code-context-engine.databaseConnectionString": {
          "type": "string",
          "default": "http://localhost:6333",
          "description": "Qdrant database connection string"
        },
        "code-context-engine.openaiApiKey": {
          "type": "string",
          "default": "",
          "description": "OpenAI API key (stored securely)"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "pretest": "npm run compile && npm run lint",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js"
  },
  "devDependencies": {
    "@types/vscode": "^1.74.0",
    "@types/node": "16.x",
    "@typescript-eslint/eslint-plugin": "^5.45.0",
    "@typescript-eslint/parser": "^5.45.0",
    "eslint": "^8.28.0",
    "typescript": "^4.9.4"
  },
  "dependencies": {
    "tree-sitter": "^0.20.4",
    "tree-sitter-typescript": "^0.20.3",
    "tree-sitter-python": "^0.20.4",
    "tree-sitter-c-sharp": "^0.20.0",
    "glob": "^8.0.3",
    "ignore": "^5.2.4",
    "@qdrant/js-client-rest": "^1.7.0",
    "axios": "^1.6.0"
  }
}
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="tsconfig.json">
{
	"compilerOptions": {
		"module": "commonjs",
		"target": "ES2020",
		"outDir": "out",
		"lib": [
			"ES2020"
		],
		"sourceMap": true,
		"rootDir": "src",
		"strict": true
	}
}
</file>

<file path="docs/todo/setup/backlog_sprint_6_lsp_integration_devops.md">
### User Story 1: LSP Data Integration into Index

**As a** developer, **I want to** capture data from the Language Server Protocol (LSP) during indexing, **so that** the code context index includes rich relationship information (e.g., definitions, references).

**Actions to Undertake:**
1.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Modify the `IndexingService` to interact with the active LSP for supported languages.
    -   **Implementation**: (Add logic to query LSP for definitions and references for each code chunk)
        ```typescript
        // Inside IndexingService.startIndexing loop, after chunking:
        // For each chunk, query LSP for definitions/references
        const definitions = await vscode.commands.executeCommand(
            'vscode.executeDefinitionProvider',
            vscode.Uri.file(file),
            new vscode.Position(chunk.startLine, 0) // Adjust position as needed
        );
        // Process definitions and add to chunk metadata

        const references = await vscode.commands.executeCommand(
            'vscode.executeReferenceProvider',
            vscode.Uri.file(file),
            new vscode.Position(chunk.startLine, 0) // Adjust position as needed
        );
        // Process references and add to chunk metadata
        ```
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/db/qdrantService.ts`
    -   **Action**: Update the `QdrantService` to store the new LSP-derived relationship metadata alongside the vectors.
    -   **Implementation**: (Modify `upsertChunks` to accept and store additional payload fields for LSP data)
        ```typescript
        // In QdrantService.upsertChunks, modify payload:
        payload: {
            filePath: chunk.filePath,
            content: chunk.content,
            startLine: chunk.startLine,
            endLine: chunk.endLine,
            type: chunk.type,
            // New LSP metadata fields
            definitions: chunk.definitions, // Example
            references: chunk.references,   // Example
        },
        ```
    -   **Imports**: None.

### User Story 2: CI/CD Pipeline with GitHub Actions

**As a** developer, **I want to** set up a CI/CD pipeline using GitHub Actions, **so that** the build, test, and packaging process for the extension is automated.

**Actions to Undertake:**
1.  **Filepath**: `.github/workflows/ci.yml` (New File)
    -   **Action**: Create a new GitHub Actions workflow file.
    -   **Implementation**: (Initial workflow structure)
        ```yaml
        name: CI/CD

        on: [push, pull_request]

        jobs:
          build:
            runs-on: ubuntu-latest
            steps:
              - uses: actions/checkout@v3
              - name: Use Node.js
                uses: actions/setup-node@v3
                with:
                  node-version: '18'
              - name: Install dependencies
                run: npm install
              - name: Run lint
                run: npm run lint
              - name: Run tests
                run: npm test
              - name: Build VS Code Extension
                run: npm run vscode:prepublish
              - name: Upload artifact
                uses: actions/upload-artifact@v3
                with:
                  name: vsix-package
                  path: ./*.vsix
        ```
    -   **Imports**: None.
2.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Configure the workflow to be triggered on `push` and `pull_request` events.
    -   **Implementation**: (See `on` section in the YAML above)
    -   **Imports**: None.
3.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Add steps for installing dependencies, running linting, executing unit tests, and building the `.vsix` package.
    -   **Implementation**: (See `steps` section in the YAML above)
    -   **Imports**: None.

**Acceptance Criteria:**
-   The `IndexingService` successfully queries the LSP for definition and reference information for code chunks.
-   The `QdrantService` stores the LSP-derived metadata in Qdrant alongside the code chunk vectors.
-   A GitHub Actions workflow file (`.github/workflows/ci.yml`) is created and correctly configured.
-   Every push and pull request to the repository triggers the CI/CD workflow.
-   The workflow successfully installs dependencies, runs linting checks, executes unit tests, and builds the `.vsix` extension package.
-   The `.vsix` package is uploaded as a build artifact.

**Testing Plan:**
-   **Test Case 1**: Make a small code change that triggers the LSP (e.g., add a new function). Run the indexing process. Verify that the LSP data (definitions, references) is captured and stored in Qdrant (requires inspecting Qdrant data).
-   **Test Case 2**: Push a commit to a branch. Verify that a GitHub Actions workflow run is triggered.
-   **Test Case 3**: Create a pull request. Verify that a GitHub Actions workflow run is triggered for the pull request.
-   **Test Case 4**: Review the GitHub Actions workflow run logs to ensure all steps (install, lint, test, build) pass successfully.
-   **Test Case 5**: Verify that the `.vsix` package is available as a build artifact in the GitHub Actions run summary.
</file>

<file path="docs/todo/setup/backlog_sprint_7_documentation_publishing.md">
### User Story 1: Comprehensive User Documentation

**As a** user, **I want to** have clear and comprehensive documentation for the extension, **so that** I can easily install, configure, and use it.

**Actions to Undertake:**
1.  **Filepath**: `README.md`
    -   **Action**: Update the `README.md` file with a feature list, installation instructions, and a guide on configuring the settings.
    -   **Implementation**: (Write content for `README.md`)
        ```markdown
        # Code Context Engine VS Code Extension

        ## Features
        - Code indexing and semantic search
        - LSP integration for rich context
        - Customizable settings for embedding providers and database

        ## Installation
        1. Install from VS Code Marketplace (link to be added).
        2. Alternatively, clone this repository and run `vsce package` then `code --install-extension your-extension.vsix`.

        ## Configuration
        Access settings via `Ctrl+Shift+P` (Cmd+Shift+P) and search for "Code Context Engine: Open Settings".
        - **Embedding Provider**: Choose between Ollama, OpenAI, etc.
        - **Database Connection String**: Specify your Qdrant instance.

        ## Usage
        (Detailed steps on how to use the extension, e.g., how to trigger indexing, how to perform queries)
        ```
    -   **Imports**: None.
2.  **Filepath**: `assets/demo.gif` (New File)
    -   **Action**: Create an animated GIF demonstrating the core workflow of the extension.
    -   **Implementation**: (Use screen recording software to capture workflow and convert to optimized GIF)
        ```
        <!-- In README.md -->
        ![Demo GIF](assets/demo.gif)
        ```
    -   **Imports**: None.
3.  **Filepath**: `CONTRIBUTING.md` (New File)
    -   **Action**: Create a `CONTRIBUTING.md` file with guidelines for new developers.
    -   **Implementation**: (Write content for `CONTRIBUTING.md`)
        ```markdown
        # Contributing to Code Context Engine

        We welcome contributions! Here's how to get started:

        ## Setup
        1. Clone the repository.
        2. Run `npm install`.
        3. Open in VS Code.

        ## Running Tests
        `npm test`

        ## Submitting Changes
        - Fork the repository.
        - Create a new branch for your feature or bug fix.
        - Ensure your code adheres to our linting rules (`npm run lint`).
        - Write clear commit messages.
        - Open a pull request.
        ```
    -   **Imports**: None.

### User Story 2: Publish to VS Code Marketplace

**As a** project owner, **I want to** publish the extension to the VS Code Marketplace, **so that** it is easily discoverable and accessible to all users.

**Actions to Undertake:**
1.  **Filepath**: `(External)`
    -   **Action**: Create a publisher identity on the VS Code Marketplace.
    -   **Implementation**: (Follow instructions on VS Code Marketplace publisher creation)
    -   **Imports**: None.
2.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Update the GitHub Actions pipeline with a manual "release" trigger.
    -   **Implementation**: (Add `workflow_dispatch` to `on` section)
        ```yaml
        on:
          push:
            branches:
              - main
          pull_request:
            branches:
              - main
          workflow_dispatch: # Manual trigger
        ```
    -   **Imports**: None.
3.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Implement a job in the CI/CD pipeline that automatically packages and publishes the extension to the marketplace when triggered.
    -   **Implementation**: (Add a new job, potentially with `vsce publish` and secrets)
        ```yaml
        # ... existing build job ...

        release:
          needs: build # Ensure build job completes successfully first
          runs-on: ubuntu-latest
          if: github.event_name == 'workflow_dispatch' # Only run on manual trigger

          steps:
            - uses: actions/checkout@v3
            - name: Use Node.js
              uses: actions/setup-node@v3
              with:
                node-version: '18'
            - name: Install dependencies
              run: npm install
            - name: Download VSIX artifact
              uses: actions/download-artifact@v3
              with:
                name: vsix-package
            - name: Publish to VS Code Marketplace
              run: npx vsce publish -p ${{ secrets.VSCE_TOKEN }}
              env:
                VSCE_TOKEN: ${{ secrets.VSCE_TOKEN }}
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   The `README.md` file is updated with all required sections (features, installation, configuration, usage).
-   An animated GIF demonstrating the core workflow is present in the `assets` directory and linked in `README.md`.
-   A `CONTRIBUTING.md` file is created with clear guidelines for contributors.
-   A publisher identity is successfully created on the VS Code Marketplace.
-   The GitHub Actions workflow includes a manual trigger for publishing.
-   Triggering the release workflow successfully publishes the extension to the VS Code Marketplace.

**Testing Plan:**
-   **Test Case 1**: Review `README.md` and `CONTRIBUTING.md` for completeness, clarity, and accuracy.
-   **Test Case 2**: Verify the animated GIF plays correctly and effectively demonstrates the extension's functionality.
-   **Test Case 3**: Manually trigger the GitHub Actions release workflow. Monitor the workflow run for successful completion.
-   **Test Case 4**: After successful release, search for the extension on the VS Code Marketplace to confirm its presence and correct listing.
-   **Test Case 5**: Install the published extension in a fresh VS Code instance and verify its basic functionality.
</file>

<file path="docs/todo/setup/backlog_sub_sprint_1_vs_code_extension_boilerplate_setup.md">
### User Story 1: VS Code Extension Project Setup

**As a** developer, **I want to** set up a new VS Code extension project with a fundamental file structure and configuration, **so that** I have a clean and organized starting point for development.

**Actions to Undertake:**
1.  **Filepath**: `(Project Root)`
    -   **Action**: Generate a new TypeScript-based VS Code extension using `yo code`.
    -   **Implementation**: `npx yo code` (select "New Extension (TypeScript)")
    -   **Imports**: None.
2.  **Filepath**: `package.json`
    -   **Action**: Configure the extension's name, publisher, and activation events in `package.json`.
    -   **Implementation**: (Modify `name`, `publisher`, and `activationEvents` fields as per project requirements)
    -   **Imports**: None.
3.  **Filepath**: `(Project Root)`
    -   **Action**: Create separate directories for the `extension` (backend) and `webview` (frontend) source code.
    -   **Implementation**: `mkdir src/extension` and `mkdir src/webview` (or similar structure if `yo code` provides a different default)
    -   **Imports**: None.
4.  **Filepath**: `src/extension.ts`
    -   **Action**: Write the initial `extension.ts` file, including the `activate` and `deactivate` functions.
    -   **Implementation**: (Basic `activate` and `deactivate` functions with a sample command)
        ```typescript
        import * as vscode from 'vscode';

        export function activate(context: vscode.ExtensionContext) {
            console.log('Congratulations, your extension "your-extension-name" is now active!');

            let disposable = vscode.commands.registerCommand('your-extension-name.helloWorld', () => {
                vscode.window.showInformationMessage('Hello World from your-extension-name!');
            });

            context.subscriptions.push(disposable);
        }

        export function deactivate() {}
        ```
    -   **Imports**: `import * as vscode from 'vscode';`

**Acceptance Criteria:**
-   The extension can be launched in a VS Code development host.
-   A "Hello World" command from the extension can be successfully executed from the command palette.
-   The project structure is clean and logically separated, with distinct directories for backend and frontend concerns.

**Testing Plan:**
-   **Test Case 1**: Run the extension in a VS Code development host (`F5` in VS Code). Verify no errors occur on activation.
-   **Test Case 2**: Open the command palette (`Ctrl+Shift+P` or `Cmd+Shift+P`), search for "Hello World", and execute the command. Verify the "Hello World from your-extension-name!" information message appears.
-   **Test Case 3**: Inspect the project directory to confirm the presence of `src/extension` and `src/webview` (or equivalent) directories.
</file>

<file path="docs/todo/setup/backlog_sub_sprint_2_sveltekit_fluent_ui_integration.md">
### User Story 1: SvelteKit Webview Integration

**As a** developer, **I want to** integrate a SvelteKit application into a VS Code webview, **so that** I can build a rich and interactive user interface for the extension.

**Actions to Undertake:**
1.  **Filepath**: `webview/`
    -   **Action**: Initialize a new SvelteKit project within the `webview` directory.
    -   **Implementation**: `cd webview && npm create svelte@latest .` (select "Skeleton project", "TypeScript", "ESLint", "Prettier", "Vitest")
    -   **Imports**: None.
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Create the logic in `extension.ts` to render the SvelteKit app inside a VS Code webview panel.
    -   **Implementation**: (Add `createWebviewPanel` and `resolveWebviewView` logic, loading `index.html` from SvelteKit's build output)
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';

        export function activate(context: vscode.ExtensionContext) {
            // ... existing code ...

            let panel: vscode.WebviewPanel | undefined = undefined;

            context.subscriptions.push(
                vscode.commands.registerCommand('code-context-engine.openPanel', () => {
                    if (panel) {
                        panel.reveal(vscode.ViewColumn.One);
                    } else {
                        panel = vscode.window.createWebviewPanel(
                            'codeContextEngine',
                            'Code Context Engine',
                            vscode.ViewColumn.One,
                            {
                                enableScripts: true,
                                localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                            }
                        );

                        const svelteAppPath = vscode.Uri.file(
                            path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                        );
                        panel.webview.html = fs.readFileSync(svelteAppPath.fsPath, 'utf8');

                        panel.onDidDispose(
                            () => {
                                panel = undefined;
                            },
                            null,
                            context.subscriptions
                        );
                    }
                })
            );
        }

        // ... deactivate function ...
        ```
    -   **Imports**: `import * as path from 'path';`, `import * as fs from 'fs';` (need to import `fs` for `readFileSync`)

### User Story 2: Fluent UI Integration

**As a** developer, **I want to** integrate Microsoft's Fluent UI library into the SvelteKit project, **so that** I can build a consistent and professional-looking UI quickly.

**Actions to Undertake:**
1.  **Filepath**: `webview/package.json`
    -   **Action**: Add the Fluent UI Svelte library as a dependency to the SvelteKit project.
    -   **Implementation**: `cd webview && npm install @fluentui/web-components @fluentui/web-components-react @fluentui/react-components` (Note: The PRD mentions `svelte-fluent-ui`, but the official Fluent UI for web components is `@fluentui/web-components`. I will use the official one. If `svelte-fluent-ui` is a specific Svelte wrapper, it should be installed instead. I will assume the user meant the official Fluent UI components.)
    -   **Imports**: None.
2.  **Filepath**: `webview/src/routes/index.svelte` (or a new component like `MainPanel.svelte`)
    -   **Action**: Create a Svelte component for the main panel that includes an "Index Now" button and a placeholder for a progress bar from the Fluent UI library.
    -   **Implementation**: (Example using Fluent UI Web Components)
        ```html
        <script lang="ts">
          import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";

          provideFluentDesignSystem().register(
            fluentButton(),
            fluentProgressRing()
          );

          function handleIndexNow() {
            console.log("Index Now clicked!");
            // Logic to trigger indexing
          }
        </script>

        <main>
          <h1>Code Context Engine</h1>
          <fluent-button appearance="accent" @click="{handleIndexNow}">Index Now</fluent-button>
          <fluent-progress-ring style="margin-top: 20px;"></fluent-progress-ring>
        </main>

        <style>
          /* Basic styling */
          main {
            padding: 20px;
            font-family: sans-serif;
          }
        </style>
        ```
    -   **Imports**: `import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";`
3.  **Filepath**: `webview/src/app.html` (or global CSS)
    -   **Action**: Ensure the UI components automatically adapt to VS Code's light and dark themes.
    -   **Implementation**: (Utilize VS Code CSS variables for theming)
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <link rel="icon" href="/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            %sveltekit.head%
            <style>
              /* Apply VS Code theme colors */
              body {
                background-color: var(--vscode-editor-background);
                color: var(--vscode-editor-foreground);
              }
              /* Example for Fluent UI components */
              fluent-button {
                --accent-fill-rest: var(--vscode-button-background);
                --accent-fill-hover: var(--vscode-button-hoverBackground);
                --accent-fill-active: var(--vscode-button-background);
                --accent-foreground-rest: var(--vscode-button-foreground);
              }
              fluent-progress-ring {
                --accent-fill-rest: var(--vscode-progressBar-background);
              }
            </style>
          </head>
          <body data-sveltekit-preload-data="hover">
            <div style="display: contents">%sveltekit.body%</div>
          </body>
        </html>
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   The SvelteKit application renders correctly inside the VS Code extension panel when the command to open it is executed.
-   The "Index Now" button is visible and interactive (e.g., logs a message to the console when clicked).
-   UI components (button, progress bar) correctly reflect the active VS Code theme (light/dark) without manual intervention.

**Testing Plan:**
-   **Test Case 1**: Run the extension in a development host. Execute the command to open the webview panel. Verify the SvelteKit app loads and displays the "Index Now" button and progress bar.
-   **Test Case 2**: Click the "Index Now" button and check the VS Code developer console for the logged message.
-   **Test Case 3**: Change the VS Code theme (e.g., from Light to Dark) and observe if the Fluent UI components' styling (background, text color) adapts accordingly.
</file>

<file path="docs/todo/setup/backlog_sub_sprint_5_implement_context_query_api.md">
### User Story 1: Retrieve File Content via API

**As a** developer, **I want to** query the extension's backend to retrieve the content of a specific file, **so that** the frontend can display it to the user.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts` (New File)
    -   **Action**: Create a new `ContextService` class to encapsulate context retrieval logic.
    -   **Implementation**: 
        ```typescript
        import * as vscode from 'vscode';
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
        import { OllamaProvider } from '../embeddings/ollamaProvider'; // Example provider

        export class ContextService {
            private qdrantService: QdrantService;
            private embeddingProvider: IEmbeddingProvider;

            constructor() {
                this.qdrantService = new QdrantService();
                this.embeddingProvider = new OllamaProvider(); // This will be configurable later
            }

            public async getFileContent(filePathQuery: string): Promise<string | null> {
                // Placeholder: In a real scenario, you'd use embedding and Qdrant search
                // to find the most relevant file path based on the query.
                // For now, assume filePathQuery is an exact path for demonstration.
                try {
                    const uri = vscode.Uri.file(filePathQuery);
                    const contentBuffer = await vscode.workspace.fs.readFile(uri);
                    return contentBuffer.toString();
                } catch (error) {
                    console.error(`Error reading file ${filePathQuery}:`, error);
                    return null;
                }
            }

            public async findRelatedFiles(conceptOrFilePath: string, limit: number = 5): Promise<string[]> {
                // Placeholder: Implement actual vector search using embeddingProvider and QdrantService
                console.log(`Finding related files for: ${conceptOrFilePath}`);
                // Example: return dummy data
                return ["/path/to/related/file1.ts", "/path/to/related/file2.ts"];
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { QdrantService } from '../db/qdrantService';`, `import { IEmbeddingProvider } from '../embeddings/embeddingProvider';`, `import { OllamaProvider } from '../embeddings/ollamaProvider';`
2.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Implement the `getFileContent` method to read the content of a specified file from disk.
    -   **Implementation**: (See `getFileContent` in the `ContextService` implementation above)
    -   **Imports**: None.

### User Story 2: Find Related Files via API

**As a** developer, **I want to** query the extension's backend to find files related to a given concept or file path, **so that** the frontend can display relevant code context to the user.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Implement the `findRelatedFiles` method to perform a vector similarity search in Qdrant and return a list of relevant file paths.
    -   **Implementation**: (See `findRelatedFiles` in the `ContextService` implementation above. This will require actual integration with `embeddingProvider` and `qdrantService`.)
    -   **Imports**: None.

### User Story 3: Expose Backend API via Webview Message Passing

**As a** developer, **I want to** expose the `ContextService` methods to the SvelteKit frontend using VS Code's webview message passing, **so that** the frontend can interact with the backend API.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    -   **Action**: Set up a message listener on the webview panel to handle incoming requests from the frontend.
    -   **Implementation**: (Add `panel.webview.onDidReceiveMessage` handler)
        ```typescript
        // Inside activate function, after panel creation:
        panel.webview.onDidReceiveMessage(
            async message => {
                const contextService = new ContextService(); // Or pass an instance if already created
                switch (message.command) {
                    case 'getFileContent':
                        const fileContent = await contextService.getFileContent(message.filePath);
                        panel.webview.postMessage({ command: 'fileContentResult', content: fileContent });
                        return;
                    case 'findRelatedFiles':
                        const relatedFiles = await contextService.findRelatedFiles(message.query);
                        panel.webview.postMessage({ command: 'relatedFilesResult', files: relatedFiles });
                        return;
                }
            },
            undefined,
            context.subscriptions
        );
        ```
    -   **Imports**: `import { ContextService } from './context/contextService';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Route incoming messages to the appropriate `ContextService` method and send results back to the frontend.
    -   **Implementation**: (See `switch` statement and `panel.webview.postMessage` in the `onDidReceiveMessage` handler above)
    -   **Imports**: None.
3.  **Filepath**: `webview/src/lib/vscodeApi.ts` (New File)
    -   **Action**: Create a wrapper service in the SvelteKit app to simplify posting and listening for messages from the extension backend.
    -   **Implementation**: 
        ```typescript
        // webview/src/lib/vscodeApi.ts
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        export function postMessage(message: any) {
            vscode.postMessage(message);
        }

        export function onMessage(callback: (message: any) => void) {
            window.addEventListener('message', event => {
                callback(event.data);
            });
        }
        ```
    -   **Imports**: None.
4.  **Filepath**: `webview/src/routes/+page.svelte` (or relevant Svelte component)
    -   **Action**: Modify the frontend to send messages to the backend and handle responses.
    -   **Implementation**: 
        ```html
        <script lang="ts">
          import { postMessage, onMessage } from '../lib/vscodeApi';
          import { onMount } from 'svelte';

          let fileContent: string | null = null;
          let relatedFiles: string[] = [];

          onMount(() => {
            onMessage(message => {
              switch (message.command) {
                case 'fileContentResult':
                  fileContent = message.content;
                  break;
                case 'relatedFilesResult':
                  relatedFiles = message.files;
                  break;
              }
            });
          });

          function requestFileContent(filePath: string) {
            postMessage({ command: 'getFileContent', filePath });
          }

          function requestRelatedFiles(query: string) {
            postMessage({ command: 'findRelatedFiles', query });
          }
        </script>

        <button on:click={() => requestFileContent('/path/to/your/file.ts')}>Get File Content</button>
        {#if fileContent}
          <pre>{fileContent}</pre>
        {/if}

        <button on:click={() => requestRelatedFiles('authentication logic')}>Find Related Files</button>
        {#if relatedFiles.length > 0}
          <ul>
            {#each relatedFiles as file}
              <li>{file}</li>
            {/each}
          </ul>
        {/if}
        ```
    -   **Imports**: `import { postMessage, onMessage } from '../lib/vscodeApi';`, `import { onMount } from 'svelte';`

**Acceptance Criteria:**
-   When the frontend sends a `getFileContent` message with a valid file path, the backend responds with the correct file content.
-   When the frontend sends a `findRelatedFiles` message with a query, the backend responds with an array of relevant file paths.
-   The backend API gracefully handles cases where files are not found or no related files are identified, returning `null` or an empty array respectively.

**Testing Plan:**
-   **Test Case 1**: Manually trigger a `getFileContent` request from the frontend (e.g., via a button click). Verify that the correct file content is displayed in the webview.
-   **Test Case 2**: Manually trigger a `findRelatedFiles` request from the frontend. Verify that a list of related files is displayed.
-   **Test Case 3**: Test with a non-existent file path for `getFileContent` and verify the frontend handles the `null` response gracefully (e.g., displays an error message).
-   **Test Case 4**: Test with a query that yields no related files for `findRelatedFiles` and verify the frontend handles the empty array gracefully.
</file>

<file path="docs/todo/setup/backlog_sub_sprint_6_develop_settings_ui.md">
### User Story 1: Open Settings UI from Command Palette

**As a** user, **I want to** open the extension's settings UI from the VS Code Command Palette, **so that** I can easily access and configure the extension.

**Actions to Undertake:**
1.  **Filepath**: `package.json`
    -   **Action**: Define a new command in `package.json` to open the settings webview.
    -   **Implementation**: (Add to `contributes.commands` section)
        ```json
        {
            "command": "code-context-engine.openSettings",
            "title": "Code Context Engine: Open Settings"
        }
        ```
    -   **Imports**: None.
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Register the new command in `extension.ts` to create and show the settings webview panel.
    -   **Implementation**: (Add to `activate` function)
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';

        // ... existing activate function content ...

        let settingsPanel: vscode.WebviewPanel | undefined = undefined;

        context.subscriptions.push(
            vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                const columnToShowIn = vscode.window.activeTextEditor
                    ? vscode.window.activeTextEditor.viewColumn
                    : undefined;

                if (settingsPanel) {
                    settingsPanel.reveal(columnToShowIn);
                } else {
                    settingsPanel = vscode.window.createWebviewPanel(
                        'codeContextEngineSettings',
                        'Code Context Engine Settings',
                        columnToShowIn || vscode.ViewColumn.One,
                        {
                            enableScripts: true,
                            localResourceRoots: [
                                vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                            ]
                        }
                    );

                    const svelteAppPath = vscode.Uri.file(
                        path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                    );

                    let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');
                    htmlContent = htmlContent.replace(/\/\_app\//g, settingsPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                    settingsPanel.webview.html = htmlContent;

                    settingsPanel.onDidDispose(
                        () => {
                            settingsPanel = undefined;
                        },
                        null,
                        context.subscriptions
                    );
                }
            })
        );
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import * as path from 'path';`, `import * as fs from 'fs';`

### User Story 2: Display and Edit Settings in UI

**As a** user, **I want to** see and edit the extension's configuration settings (e.g., embedding provider, database connection string) in a dedicated UI, **so that** I can customize its behavior.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/routes/settings.svelte` (New File)
    -   **Action**: Create a new Svelte component for the settings UI, using Fluent UI components for input fields (e.g., `<fluent-select>`, `<fluent-text-field>`).
    -   **Implementation**: 
        ```html
        <script lang="ts">
          import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";
          import { onMount } from 'svelte';
          import { postMessage, onMessage } from '../lib/vscodeApi';

          provideFluentDesignSystem().register(
            fluentSelect(),
            fluentOption(),
            fluentTextField(),
            fluentButton()
          );

          let embeddingProvider: string = 'Ollama'; // Default value
          let databaseConnectionString: string = '';

          onMount(() => {
            // Request current settings from extension backend on component mount
            postMessage({ command: 'getSettings' });

            onMessage(message => {
              if (message.command === 'settingsResult') {
                embeddingProvider = message.settings.embeddingProvider || 'Ollama';
                databaseConnectionString = message.settings.databaseConnectionString || '';
              }
            });
          });

          function saveSettings() {
            const settings = {
              embeddingProvider,
              databaseConnectionString,
            };
            postMessage({ command: 'saveSettings', settings });
          }
        </script>

        <main>
          <h1>Extension Settings</h1>

          <fluent-text-field
            appearance="outline"
            placeholder="Database Connection String"
            bind:value={databaseConnectionString}
            style="width: 100%; margin-bottom: 15px;"
          >
            Database Connection String
          </fluent-text-field>

          <fluent-select
            appearance="outline"
            bind:value={embeddingProvider}
            style="width: 100%; margin-bottom: 20px;"
          >
            <fluent-option value="Ollama">Ollama</fluent-option>
            <fluent-option value="OpenAI">OpenAI</fluent-option>
            <!-- Add more options as needed -->
          </fluent-select>

          <fluent-button appearance="accent" @click={saveSettings}>Save Settings</fluent-button>
        </main>

        <style>
          main {
            padding: 20px;
            font-family: var(--vscode-font-family);
            color: var(--vscode-editor-foreground);
          }
          /* Basic styling for Fluent UI components to match VS Code theme */
          fluent-text-field,
          fluent-select {
            --neutral-fill-rest: var(--vscode-input-background);
            --neutral-foreground-rest: var(--vscode-input-foreground);
            --neutral-stroke-rest: var(--vscode-input-border);
            --neutral-fill-stealth-rest: var(--vscode-input-background);
            --neutral-fill-stealth-hover: var(--vscode-input-background);
            --neutral-fill-stealth-active: var(--vscode-input-background);
            --neutral-foreground-hover: var(--vscode-input-foreground);
            --neutral-foreground-active: var(--vscode-input-foreground);
            --neutral-stroke-hover: var(--vscode-input-border);
            --neutral-stroke-active: var(--vscode-input-border);
          }
          fluent-button {
            --accent-fill-rest: var(--vscode-button-background);
            --accent-foreground-rest: var(--vscode-button-foreground);
            --accent-fill-hover: var(--vscode-button-hoverBackground);
          }
        </style>
        ```
    -   **Imports**: `import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";`, `import { onMount } from 'svelte';`, `import { postMessage, onMessage } from '../lib/vscodeApi';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Implement a message handler in `extension.ts` to retrieve current settings from VS Code configuration and send them to the webview.
    -   **Implementation**: (Inside `onDidReceiveMessage` handler)
        ```typescript
        // ... existing message handling ...

        case 'getSettings':
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const currentSettings = {
                embeddingProvider: config.get('embeddingProvider'),
                databaseConnectionString: config.get('databaseConnectionString'),
            };
            settingsPanel?.webview.postMessage({ command: 'settingsResult', settings: currentSettings });
            return;
        ```
    -   **Imports**: None.

### User Story 3: Save Settings to VS Code Configuration

**As a** user, **I want to** save my changes to the extension's settings, **so that** my preferences are persisted across VS Code sessions.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    -   **Action**: Implement a message handler in `extension.ts` to receive updated settings from the webview and save them to VS Code workspace configuration.
    -   **Implementation**: (Inside `onDidReceiveMessage` handler)
        ```typescript
        // ... existing message handling ...

        case 'saveSettings':
            const newSettings = message.settings;
            const configToUpdate = vscode.workspace.getConfiguration('code-context-engine');
            await configToUpdate.update('embeddingProvider', newSettings.embeddingProvider, vscode.ConfigurationTarget.Global);
            await configToUpdate.update('databaseConnectionString', newSettings.databaseConnectionString, vscode.ConfigurationTarget.Global);
            vscode.window.showInformationMessage('Settings saved!');
            return;
        ```
    -   **Imports**: None.
2.  **Filepath**: `package.json`
    -   **Action**: Define the configuration schema in `package.json` under `contributes.configuration`.
    -   **Implementation**: (Add to `contributes` section)
        ```json
        "configuration": {
            "title": "Code Context Engine Configuration",
            "properties": {
                "code-context-engine.embeddingProvider": {
                    "type": "string",
                    "default": "Ollama",
                    "description": "Select the embedding provider to use (e.g., Ollama, OpenAI)."
                },
                "code-context-engine.databaseConnectionString": {
                    "type": "string",
                    "default": "http://localhost:6333",
                    "description": "Connection string for the Qdrant database."
                }
            }
        }
        ```
    -   **Imports**: None.

### User Story 4: Services Read from Configuration

**As a** developer, **I want to** ensure the extension's backend services (e.g., `IndexingService`, `QdrantService`) read their configuration from the VS Code workspace settings, **so that** user changes are applied correctly.

**Actions to Undertake:**
1.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Update `IndexingService` to read the selected embedding provider from the VS Code configuration.
    -   **Implementation**: (Modify constructor or relevant method)
        ```typescript
        // In IndexingService constructor or a setup method
        const config = vscode.workspace.getConfiguration('code-context-engine');
        const providerName = config.get<string>('embeddingProvider', 'Ollama');
        if (providerName === 'OpenAI') {
            this.embeddingProvider = new OpenAIProvider();
        } else {
            this.embeddingProvider = new OllamaProvider();
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { OpenAIProvider } from '../embeddings/openaiProvider';`, `import { OllamaProvider } from '../embeddings/ollamaProvider';`
2.  **Filepath**: `src/db/qdrantService.ts`
    -   **Action**: Update `QdrantService` to read the database connection string from the VS Code configuration.
    -   **Implementation**: (Modify constructor or client initialization)
        ```typescript
        // In QdrantService constructor
        const config = vscode.workspace.getConfiguration('code-context-engine');
        const connectionString = config.get<string>('databaseConnectionString', 'http://localhost:6333');
        this.client = new QdrantClient({ url: connectionString });
        ```
    -   **Imports**: `import * as vscode from 'vscode';`

**Acceptance Criteria:**
-   A new command "Code Context Engine: Open Settings" appears in the Command Palette.
-   Executing the command opens a new webview panel titled "Code Context Engine Settings".
-   The settings UI displays the default values for embedding provider and database connection string.
-   Changing values in the settings UI and clicking "Save Settings" updates the `settings.json` file (either user or workspace settings).
-   After saving, if the extension is reloaded or the relevant services are re-initialized, they pick up the new configuration values.

**Testing Plan:**
-   **Test Case 1**: Open the Command Palette, search for and execute "Code Context Engine: Open Settings". Verify the panel opens.
-   **Test Case 2**: Change the "Embedding Provider" to "OpenAI" and the "Database Connection String" to a custom value. Click "Save Settings". Close and reopen VS Code. Verify the settings persist.
-   **Test Case 3**: Verify that `IndexingService` and `QdrantService` instances (after re-initialization or extension reload) use the newly saved configuration values.
-   **Test Case 4**: Test with invalid connection strings or provider names to ensure graceful fallback to defaults or error handling.
</file>

<file path="docs/todo/setup/implementation_sprint_6_lsp_integration_devops.md">
### Implementation Guide: Sprint 6 - LSP Integration & DevOps

**Objective:** To enrich the index with LSP data and automate the build and test process.

#### **Analysis**

This sprint introduces two significant enhancements: integrating Language Server Protocol (LSP) data into the code context index and establishing a robust CI/CD pipeline using GitHub Actions. LSP integration will make the code context engine more intelligent by understanding semantic relationships within the code, going beyond mere syntactic parsing. The CI/CD pipeline will automate the build, test, and packaging process, ensuring code quality and a streamlined release workflow.

#### **Prerequisites and Setup**

1.  **Completed Indexing Pipeline:** Ensure the indexing, chunking, vectorization, and Qdrant storage (from Sprints 2 and 3) are fully functional.
2.  **GitHub Repository:** Your project must be hosted on GitHub to utilize GitHub Actions.

#### **Implementation Guide**

Here's a step-by-step guide to implementing LSP Integration and DevOps:

**1. LSP Data Integration into `IndexingService`**

To capture LSP data, you'll modify your `IndexingService` to programmatically query the active language server for information like definitions and references for each code chunk.

  *   **File:** `src/indexing/indexingService.ts`
  *   **API Information:**
      *   `vscode.commands.executeCommand()`: This is the key API to interact with VS Code's built-in commands, including those exposed by language servers.
      *   `vscode.executeDefinitionProvider`: Command to get definitions.
      *   `vscode.executeReferenceProvider`: Command to get references.
      *   `vscode.Position`: Represents a position in a text document.
      *   `vscode.Location`, `vscode.DefinitionLink`, `vscode.Reference`: Data structures returned by LSP commands.

  *   **Implementation Example (within `startIndexing` loop, after chunking):**
    ```typescript
    import * as vscode from 'vscode';
    // ... other imports

    export class IndexingService {
        // ... existing code ...

        private async processChunkWithLSP(fileUri: vscode.Uri, chunk: CodeChunk): Promise<void> {
            const position = new vscode.Position(chunk.startLine, 0); // Start of the chunk

            // Get Definitions
            try {
                const definitions = await vscode.commands.executeCommand<
                    vscode.Definition | vscode.DefinitionLink[]
                >('vscode.executeDefinitionProvider', fileUri, position);

                if (definitions) {
                    // Process definitions (e.g., extract URIs, ranges, etc.)
                    // Store relevant info in chunk.payload or a new property
                    // Example: chunk.lspDefinitions = definitions.map(d => ({ uri: d.uri.toString(), range: d.range }));
                }
            } catch (error) {
                console.warn(`LSP Definition Provider failed for ${fileUri.fsPath}:${chunk.startLine}:`, error);
            }

            // Get References
            try {
                const references = await vscode.commands.executeCommand<vscode.Reference[]>( 'vscode.executeReferenceProvider', fileUri, position);

                if (references) {
                    // Process references
                    // Example: chunk.lspReferences = references.map(r => ({ uri: r.uri.toString(), range: r.range }));
                }
            } catch (error) {
                console.warn(`LSP Reference Provider failed for ${fileUri.fsPath}:${chunk.startLine}:`, error);
            }
        }

        public async startIndexing(): Promise<void> {
            // ... existing file walking, parsing, chunking logic ...

            for (const file of files) {
                // ... existing parsing and chunking ...
                const fileUri = vscode.Uri.file(file);
                if (language) {
                    const tree = this.astParser.parse(language, content);
                    const chunks = this.chunker.chunk(file, tree, content);

                    for (const chunk of chunks) {
                        await this.processChunkWithLSP(fileUri, chunk); // Call LSP processing for each chunk
                        allChunks.push(chunk);
                    }
                }
            }
            // ... rest of indexing (embedding, Qdrant upsert) ...
        }
    }
    ```

**2. Extend Qdrant Metadata in `QdrantService`**

Modify your `QdrantService` to accept and store the new LSP-derived metadata as part of the payload when upserting chunks into Qdrant.

  *   **File:** `src/db/qdrantService.ts`
  *   **Key Concept:** Qdrant allows arbitrary JSON payloads to be stored alongside vectors. This is where you'll put your LSP data.

  *   **Implementation Example (modify `upsertChunks` method):**
    ```typescript
    import { QdrantClient } from '@qdrant/js-client-rest';
    import type { CodeChunk } from '../parsing/chunker';

    // Extend CodeChunk interface if not already done to include LSP data
    // declare module '../parsing/chunker' {
    //     interface CodeChunk {
    //         lspDefinitions?: { uri: string; range: any; }[];
    //         lspReferences?: { uri: string; range: any; }[];
    //     }
    // }

    export class QdrantService {
        // ... existing code ...

        public async upsertChunks(collectionName: string, chunks: CodeChunk[], vectors: number[][]): Promise<void> {
            const points = chunks.map((chunk, i) => ({
                id: `${chunk.filePath}:${chunk.startLine}-${chunk.endLine}`,
                vector: vectors[i],
                payload: {
                    filePath: chunk.filePath,
                    content: chunk.content,
                    startLine: chunk.startLine,
                    endLine: chunk.endLine,
                    type: chunk.type,
                    // Add LSP metadata to payload
                    lspDefinitions: chunk.lspDefinitions || [],
                    lspReferences: chunk.lspReferences || [],
                },
            }));

            await this.client.upsert(collectionName, {
                wait: true,
                points,
            });
        }
    }
    ```

**3. Create GitHub Actions Workflow**

Set up a new workflow file in your `.github/workflows/` directory. This file defines the automated steps for your CI/CD pipeline.

  *   **File:** `.github/workflows/ci.yml` (New File)
  *   **Key Concepts:**
      *   `on`: Defines when the workflow runs (e.g., `push`, `pull_request`).
      *   `jobs`: A workflow run is made up of one or more jobs.
      *   `runs-on`: The type of machine to run the job on.
      *   `steps`: A sequence of tasks to be executed.
      *   `actions/checkout`: Action to check out your repository.
      *   `actions/setup-node`: Action to set up Node.js environment.
      *   `npm install`, `npm run lint`, `npm test`, `npm run vscode:prepublish`: Standard commands for VS Code extension development.
      *   `actions/upload-artifact`: To save build artifacts.

  *   **Implementation Example:**
    ```yaml
    name: CI/CD

    on:
      push:
        branches:
          - main
      pull_request:
        branches:
          - main

    jobs:
      build:
        runs-on: ubuntu-latest

        steps:
          - name: Checkout repository
            uses: actions/checkout@v3

          - name: Set up Node.js
            uses: actions/setup-node@v3
            with:
              node-version: '18' # Or your project's Node.js version

          - name: Install dependencies
            run: npm install

          - name: Run lint
            run: npm run lint

          - name: Run tests
            run: npm test

          - name: Build VS Code Extension
            run: npm run vscode:prepublish # This command typically builds the .vsix

          - name: Upload VSIX artifact
            uses: actions/upload-artifact@v3
            with:
              name: vsix-package
              path: '*.vsix' # Adjust if your .vsix is in a different location
    ```

**4. Configure Linting, Testing, and Build Steps**

Ensure your `package.json` has the necessary scripts for linting, testing, and building, which the GitHub Actions workflow will then call.

  *   **File:** `package.json`
  *   **Key Concepts:**
      *   `"lint"`: Script for running your linter (e.g., ESLint).
      *   `"test"`: Script for running your unit tests (e.g., Vitest, Mocha).
      *   `"vscode:prepublish"`: Standard script for preparing your extension for publishing, which typically includes compiling TypeScript and packaging.

  *   **Example `scripts` section in `package.json`:**
    ```json
    "scripts": {
        "vscode:prepublish": "npm run compile",
        "compile": "tsc -p ./",
        "watch": "tsc -watch -p ./",
        "pretest": "npm run compile",
        "test": "node ./out/test/runTest.js",
        "lint": "eslint src --ext ts"
    },
    ```
    *Note: Adjust these scripts based on your actual project setup (e.g., if you use `vitest` directly, your `test` script would be `vitest`).*

This completes the implementation guide for Sprint 6. You now have a more intelligent indexing process leveraging LSP data and an automated CI/CD pipeline to ensure continuous quality and efficient development.
</file>

<file path="docs/todo/setup/implementation_sprint_7_documentation_publishing.md">
### Implementation Guide: Sprint 7 - Documentation & Publishing

**Objective:** To create high-quality documentation and publish the extension to the marketplace.

#### **Analysis**

This final sprint focuses on the crucial aspects of product delivery: comprehensive documentation and marketplace publishing. Effective documentation (README, contributing guide) is vital for user adoption and community engagement. Publishing to the VS Code Marketplace makes the extension discoverable and easily installable. Automating the publishing process via GitHub Actions ensures consistency and reduces manual errors.

#### **Prerequisites and Setup**

1.  **Completed Extension:** The extension should be fully functional and tested from previous sprints.
2.  **GitHub Repository:** Your project must be hosted on GitHub.
3.  **VS Code Extension Publisher Account:** You will need to create one on the Azure DevOps organization for VS Code publishers.
4.  **`vsce` (Visual Studio Code Extension Manager):** This tool is used for packaging and publishing VS Code extensions.
    ```bash
    npm install -g vsce
    ```

#### **Implementation Guide**

Here's a step-by-step guide to creating documentation and publishing your extension:

**1. Write `README.md` Content**

The `README.md` is the first thing users see. It should clearly explain what your extension does, how to install it, configure it, and use it.

  *   **File:** `README.md`
  *   **Key Sections to Include:**
      *   **Title and Overview:** A clear, concise description of the extension.
      *   **Features:** A bulleted list of key functionalities.
      *   **Installation:** Step-by-step instructions for installing from the Marketplace or manually.
      *   **Configuration:** How to access and change settings, with examples.
      *   **Usage:** A guide on how to use the extension's core features.
      *   **Screenshots/GIFs:** Visual aids are highly recommended.
      *   **Contributing (Optional):** Link to `CONTRIBUTING.md`.
      *   **License:** Information about the extension's license.

  *   **Example Structure:**
    ```markdown
    # Code Context Engine VS Code Extension

    ![Demo GIF](assets/demo.gif) <!-- Link to your demo GIF -->

    A powerful VS Code extension that helps developers understand their codebase by providing contextual information through semantic search and LSP integration.

    ## Features
    - Intelligent code indexing using AST parsing and LSP data.
    - Semantic search for related files and code snippets.
    - Customizable embedding providers (Ollama, OpenAI).
    - Local Qdrant vector database integration.
    - Intuitive settings UI for easy configuration.

    ## Installation
    1.  **From VS Code Marketplace:** Search for "Code Context Engine" in the Extensions view (`Ctrl+Shift+X` or `Cmd+Shift+X`) and click "Install".
    2.  **Manual Installation:**
        a.  Clone this repository: `git clone https://github.com/your-username/code-context-engine.git`
        b.  Navigate to the project root: `cd code-context-engine`
        c.  Package the extension: `vsce package`
        d.  Install the `.vsix` file: Open VS Code, go to Extensions view, click `...` (More Actions) -> `Install from VSIX...` and select the generated `.vsix` file.

    ## Configuration
    To configure the extension, open the Command Palette (`Ctrl+Shift+P` or `Cmd+Shift+P`) and search for "Code Context Engine: Open Settings".

    -   **Embedding Provider:** Select your preferred embedding model (e.g., Ollama for local models, OpenAI for cloud-based).
    -   **Database Connection String:** Specify the URL for your Qdrant instance (e.g., `http://localhost:6333`).

    ## Usage
    1.  **Index Your Repository:** Open the Code Context Engine panel (View -> Open View -> Code Context Engine) and click "Index Now".
    2.  **Query Context:** Use the search bar in the panel to ask questions about your codebase (e.g., "Show me authentication logic", "Find files related to user profiles").

    ## Contributing
    We welcome contributions! Please see our [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

    ## License
    [Your License Here]
    ```

**2. Create Demo GIF**

A short, animated GIF demonstrating the core functionality of your extension can significantly improve user understanding and engagement.

  *   **Tool:** Use screen recording software (e.g., OBS Studio, ShareX, macOS built-in recorder) to capture your workflow. Then, use a GIF converter (e.g., online tools, FFmpeg) to create an optimized GIF.
  *   **File:** `assets/demo.gif` (or similar path, referenced in `README.md`)
  *   **Tips:**
      *   Keep it short and focused (10-30 seconds).
      *   Highlight the most impactful features.
      *   Ensure good resolution and clear text.
      *   Optimize file size for faster loading.

**3. Write `CONTRIBUTING.md`**

This file provides guidelines for potential contributors, making it easier for others to get involved with your project.

  *   **File:** `CONTRIBUTING.md`
  *   **Key Sections to Include:**
      *   **How to Contribute:** General overview.
      *   **Local Development Setup:** Instructions for cloning, installing dependencies, and running the project locally.
      *   **Running Tests:** How to execute unit and integration tests.
      *   **Code Style and Linting:** Any specific coding conventions or tools.
      *   **Submitting Changes:** Guidelines for pull requests (e.g., branch naming, commit message format).
      *   **Reporting Bugs/Suggesting Features:** How to open issues.

  *   **Example Structure:**
    ```markdown
    # Contributing to Code Context Engine

    We welcome and appreciate contributions to the Code Context Engine VS Code extension! By contributing, you help us make this tool better for everyone.

    ## How to Get Started

    1.  **Fork the Repository:** Start by forking the `code-context-engine` repository on GitHub.
    2.  **Clone Your Fork:** `git clone https://github.com/your-username/code-context-engine.git`
    3.  **Install Dependencies:** Navigate to the project root and install all necessary dependencies:
        ```bash
        npm install
        ```
    4.  **Open in VS Code:** Open the cloned project in Visual Studio Code.

    ## Local Development

    -   **Run Extension:** Press `F5` in VS Code to launch a new Extension Development Host window with your extension loaded.
    -   **Build Webview:** If you make changes to the SvelteKit webview, navigate to the `webview` directory and run `npm run build` to compile the changes.

    ## Running Tests

    To run the project's tests:

    ```bash
    npm test
    ```

    ## Code Style and Linting

    We use ESLint and Prettier to maintain code quality and consistency. Please ensure your code passes linting checks before submitting a pull request:

    ```bash
    npm run lint
    ```

    ## Submitting Changes (Pull Requests)

    1.  **Create a Branch:** Create a new branch for your feature or bug fix:
        `git checkout -b feature/your-feature-name` or `git checkout -b bugfix/issue-number`
    2.  **Make Your Changes:** Implement your feature or fix the bug.
    3.  **Write Tests:** Ensure your changes are covered by appropriate unit or integration tests.
    4.  **Commit Your Changes:** Write clear, concise commit messages that explain *what* and *why*.
    5.  **Push to Your Fork:** `git push origin your-branch-name`
    6.  **Open a Pull Request:** Go to the original `code-context-engine` repository on GitHub and open a new pull request from your branch.

    ## Reporting Issues / Suggesting Features

    If you find a bug or have a feature request, please open an issue on our [GitHub Issues page](https://github.com/your-username/code-context-engine/issues).
    ```

**4. Create Marketplace Publisher Identity**

To publish your extension, you need a publisher ID. This is done through Azure DevOps.

  *   **Action:** Follow the official VS Code documentation to create a publisher. This typically involves:
      1.  Going to the Azure DevOps organization for VS Code publishers.
      2.  Creating a new organization if you don't have one.
      3.  Creating a Personal Access Token (PAT) with `Marketplace (Publish)` scope.
  *   **Reference:** [Publishing Extensions - Visual Studio Code](https://code.visualstudio.com/api/references/publishing-extensions)

**5. Update GitHub Actions for Manual Release Trigger**

Modify your `ci.yml` workflow to include a `workflow_dispatch` event, allowing you to manually trigger the release job from the GitHub Actions UI.

  *   **File:** `.github/workflows/ci.yml`
  *   **Key Concept:** `workflow_dispatch` enables manual triggering of workflows.

  *   **Implementation Example (add to `on` section):**
    ```yaml
    on:
      push:
        branches:
          - main
      pull_request:
        branches:
          - main
      workflow_dispatch: # This enables manual triggering
    ```

**6. Implement Publishing Step in CI/CD Pipeline**

Add a new job to your `ci.yml` that will execute the `vsce publish` command. This job should depend on the `build` job and use a GitHub Secret to store your `vsce` Personal Access Token (PAT).

  *   **File:** `.github/workflows/ci.yml`
  *   **Key Concepts:**
      *   `needs`: Specifies that a job depends on the successful completion of another job.
      *   `if`: Conditional execution of a job.
      *   `secrets`: Securely store sensitive information like API keys.
      *   `vsce publish -p <token>`: Command to publish the extension.

  *   **Implementation Example (add a new job after `build` job):**
    ```yaml
    # ... (existing build job)

    release:
      needs: build # This job depends on the 'build' job completing successfully
      runs-on: ubuntu-latest
      if: github.event_name == 'workflow_dispatch' # Only run this job when manually triggered

      steps:
        - name: Checkout repository
          uses: actions/checkout@v3

        - name: Set up Node.js
          uses: actions/setup-node@v3
          with:
            node-version: '18' # Or your project's Node.js version

        - name: Install vsce
          run: npm install -g vsce

        - name: Download VSIX artifact
          uses: actions/download-artifact@v3
          with:
            name: vsix-package
            path: .

        - name: Publish to VS Code Marketplace
          run: vsce publish -p ${{ secrets.VSCE_TOKEN }}
          env:
            VSCE_TOKEN: ${{ secrets.VSCE_TOKEN }} # Pass the token as an environment variable
    ```
    *   **Important:** You must add `VSCE_TOKEN` as a repository secret in your GitHub repository settings (Settings -> Secrets and variables -> Actions -> New repository secret).

**7. Test the Release Process**

After setting up the workflow, perform a test release to ensure everything works as expected.

  *   **Action:**
      1.  Go to your GitHub repository -> Actions tab.
      2.  Select your `CI/CD` workflow.
      3.  Click `Run workflow` button (usually on the right side).
      4.  Select the `main` branch and click `Run workflow`.
      5.  Monitor the workflow run for success.
      6.  Check the VS Code Marketplace for your published extension.

This completes the implementation guide for Sprint 7. You now have a well-documented extension and an automated process for publishing it to the VS Code Marketplace, making it accessible to a wider audience.
</file>

<file path="docs/todo/setup/implementation_sub_sprint_1_vs_code_extension_boilerplate_setup.md">
### Implementation Guide: Sub-Sprint 1 - VS Code Extension Boilerplate Setup

**Objective:** To create the fundamental file structure and configuration for a new VS Code extension using TypeScript.

#### **Analysis**

Since a `repomix-roocode.xml` or similar comprehensive code structure file was not provided for this specific sub-sprint, the analysis is based on the general requirements for a VS Code extension and best practices for project setup. The goal is to establish a clean, maintainable, and standard TypeScript-based extension project.

#### **Prerequisites and Setup**

Before starting, ensure you have the following installed:

1.  **Node.js and npm/yarn:** Essential for JavaScript/TypeScript development.
2.  **VS Code Extension Generator (`yo code`):** This Yeoman generator scaffolds new VS Code extension projects.
    ```bash
    npm install -g yo generator-code
    ```

#### **Implementation Guide**

Here's a step-by-step guide to setting up the VS Code extension boilerplate:

**1. Generate the VS Code Extension Project**

Use the `yo code` generator to create the initial project structure. This command will prompt you with several questions to configure your extension.

  *   **Command:**
    ```bash
    npx yo code
    ```
  *   **Prompts to select:**
      *   `? What type of extension do you want to create?` -> `New Extension (TypeScript)`
      *   `? What is the name of your extension?` -> `CodeContextEngine` (or a suitable name)
      *   `? What is the identifier of your extension?` -> `code-context-engine`
      *   `? What is the description of your extension?` -> (Provide a brief description)
      *   `? Enable TypeScript checking and linting?` -> `Yes`
      *   `? Initialize a git repository?` -> `Yes` (Recommended)
      *   `? Do you want to open the new folder with VS Code?` -> `Yes`

  *   **API Information:** The `yo code` generator uses the VS Code Extension API internally to set up the `package.json`, `src/extension.ts`, and other configuration files.

**2. Configure `package.json`**

The `package.json` file is crucial for defining your extension's metadata, commands, and activation events. Review and adjust the generated file.

  *   **File:** `package.json`
  *   **Key fields to review/modify:**
      *   `name`: The unique identifier for your extension.
      *   `displayName`: The name displayed in the VS Code Marketplace.
      *   `description`: A brief summary of your extension.
      *   `publisher`: Your VS Code Marketplace publisher ID.
      *   `activationEvents`: Defines when your extension is activated (e.g., `onCommand:your-extension.helloWorld`).
      *   `main`: The entry point of your extension (usually `out/extension.js`).
      *   `contributes`: This section is where you declare commands, views, keybindings, etc.

  *   **Example `activationEvents` (if not already present):**
    ```json
    "activationEvents": [
        "onCommand:code-context-engine.helloWorld"
    ],
    ```

**3. Establish Project Structure**

The `yo code` generator provides a basic structure. For a SvelteKit frontend, it's good practice to separate the backend (extension) and frontend (webview) code. You'll typically have a `src` directory for your main extension code and a separate directory for your SvelteKit project.

  *   **Action:** Create a `webview` directory at the root level (or within `src` if preferred) to house your SvelteKit application.
  *   **Command:**
    ```bash
    mkdir webview
    ```
  *   **Resulting structure (example):**
    ```
    your-extension-name/
    ├── .vscode/
    ├── src/
    │   └── extension.ts
    ├── webview/  <-- New directory for SvelteKit
    ├── package.json
    ├── tsconfig.json
    ├── .gitignore
    └── ...
    ```

**4. Initial Backend Logic (`extension.ts`)**

The `extension.ts` file is the main entry point for your VS Code extension. It contains the `activate` function, which is called when your extension is activated, and the `deactivate` function, called when your extension is deactivated.

  *   **File:** `src/extension.ts`
  *   **Key concepts:**
      *   `activate(context: vscode.ExtensionContext)`: This is where you register commands, create webviews, and set up event listeners.
      *   `deactivate()`: Used for cleanup, like disposing of resources.
      *   `vscode.commands.registerCommand()`: Registers a command that can be invoked by the user (e.g., from the Command Palette).
      *   `vscode.window.showInformationMessage()`: Displays a message to the user.
      *   `context.subscriptions.push()`: Adds disposables (objects with a `dispose` method) to the extension's context, ensuring they are cleaned up when the extension is deactivated.

  *   **Example `src/extension.ts` (as generated by `yo code` and slightly modified for clarity):**
    ```typescript
    import * as vscode from 'vscode';

    /**
     * This method is called when your extension is activated.
     * The extension is activated the very first time the command is executed.
     */
    export function activate(context: vscode.ExtensionContext) {

        // Use the console to output diagnostic information (console.log) and errors (console.error)
        // This line of code will only be executed once when your extension is activated
        console.log('Congratulations, your extension "code-context-engine" is now active!');

        // The command has been defined in the package.json file
        // Now provide the implementation of the command with registerCommand
        // The commandId parameter must match the command field in package.json
        let disposable = vscode.commands.registerCommand('code-context-engine.helloWorld', () => {
            // The code you place here will be executed every time your command is executed
            // Display a message box to the user
            vscode.window.showInformationMessage('Hello World from Code Context Engine!');
        });

        context.subscriptions.push(disposable);
    }

    /**
     * This method is called when your extension is deactivated
     */
    export function deactivate() {}
    ```

This completes the foundational setup for your VS Code extension. You now have a runnable project with a basic command, ready for further development in subsequent sprints.
</file>

<file path="docs/todo/setup/implementation_sub_sprint_2_sveltekit_fluent_ui_integration.md">
### Implementation Guide: Sub-Sprint 2 - SvelteKit and Fluent UI Integration

**Objective:** To set up the SvelteKit frontend and integrate the Fluent UI component library, creating the initial user interface.

#### **Analysis**

This sub-sprint focuses on the frontend development of the VS Code extension. The core idea is to leverage SvelteKit for building a modern, reactive UI within a VS Code webview. Fluent UI is chosen for its consistency with Microsoft's design language, ensuring a native feel within VS Code. The integration requires careful handling of webview communication and theme adaptation.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 1 Completion:** Ensure the basic VS Code extension boilerplate is set up as per Sub-Sprint 1's guide.
2.  **Node.js and npm/yarn:** Already installed from previous steps.

#### **Implementation Guide**

Here's a step-by-step guide to integrating SvelteKit and Fluent UI:

**1. Initialize SvelteKit Project within `webview` Directory**

Navigate into the `webview` directory you created in Sub-Sprint 1 and initialize a new SvelteKit project. Choose the "Skeleton project" and enable TypeScript, ESLint, Prettier, and Vitest for a robust development environment.

  *   **Command:**
    ```bash
    cd webview
    npm create svelte@latest .
    ```
  *   **Prompts to select:**
      *   `? Which Svelte project template?` -> `Skeleton project`
      *   `? Add TypeScript?` -> `Yes, using TypeScript syntax`
      *   `? Add ESLint for code linting?` -> `Yes`
      *   `? Add Prettier for code formatting?` -> `Yes`
      *   `? Add Playwright for browser testing?` -> `No` (or Yes, if desired for e2e)
      *   `? Add Vitest for unit testing?` -> `Yes`

  *   **Install dependencies:**
    ```bash
    npm install
    ```

**2. Configure Webview in `extension.ts` to Load SvelteKit App**

Your `extension.ts` needs to create a `WebviewPanel` and load the compiled SvelteKit application's `index.html` into it. SvelteKit builds to a `dist` folder by default.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.window.createWebviewPanel()`: Creates and shows a new webview panel.
      *   `panel.webview.html`: Sets the HTML content of the webview.
      *   `panel.webview.options.localResourceRoots`: Allows the webview to load local resources (like CSS/JS from your SvelteKit build).
      *   `vscode.Uri.file()` and `path.join()`: Used to construct absolute paths to your SvelteKit build assets.
      *   `fs.readFileSync()`: Node.js file system module to read the `index.html` file. You might need to add `import * as fs from 'fs';` at the top of `extension.ts`.

  *   **Implementation Example:**
    ```typescript
    import * as vscode from 'vscode';
    import * as path from 'path';
    import * as fs from 'fs'; // Add this import

    export function activate(context: vscode.ExtensionContext) {
        console.log('Congratulations, your extension "code-context-engine" is now active!');

        let currentPanel: vscode.WebviewPanel | undefined = undefined;

        context.subscriptions.push(
            vscode.commands.registerCommand('code-context-engine.openSveltePanel', () => {
                const columnToShowIn = vscode.window.activeTextEditor
                    ? vscode.window.activeTextEditor.viewColumn
                    : undefined;

                if (currentPanel) {
                    currentPanel.reveal(columnToShowIn);
                } else {
                    currentPanel = vscode.window.createWebviewPanel(
                        'codeContextEngine',
                        'Code Context Engine',
                        columnToShowIn || vscode.ViewColumn.One,
                        {
                            enableScripts: true,
                            localResourceRoots: [
                                vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                            ]
                        }
                    );

                    const svelteAppPath = vscode.Uri.file(
                        path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                    );

                    // Read the SvelteKit index.html and set it as the webview content
                    let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');

                    // Important: Replace relative paths with webview-specific URIs
                    // This ensures that SvelteKit's JS/CSS assets are loaded correctly
                    htmlContent = htmlContent.replace(/\/\_app\//g, currentPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                    currentPanel.webview.html = htmlContent;

                    currentPanel.onDidDispose(
                        () => {
                            currentPanel = undefined;
                        },
                        null,
                        context.subscriptions
                    );
                }
            })
        );
    }

    export function deactivate() {}
    ```
    *   **Note on `htmlContent.replace`**: SvelteKit generates paths like `/_app/`. You need to convert these to `webview-uri`s so the webview can load them. The regex ` /\/_app\//g` targets these paths.

**3. Install Fluent UI Svelte Library**

While the PRD mentioned `svelte-fluent-ui`, the official Fluent UI components are often used as web components or React components. For Svelte, you can use the `@fluentui/web-components` directly or a community-maintained Svelte wrapper if available and preferred. For this guide, I will use the official web components as they are framework-agnostic.

  *   **Command (from `webview` directory):**
    ```bash
    cd webview
    npm install @fluentui/web-components
    ```

**4. Implement UI with Fluent UI Components**

Create your main Svelte component (e.g., `src/routes/+page.svelte` or a new component like `src/lib/MainPanel.svelte`) and use Fluent UI components.

  *   **File:** `webview/src/routes/+page.svelte` (or `webview/src/lib/MainPanel.svelte`)
  *   **API Information:**
      *   `provideFluentDesignSystem().register(...)`: Registers the Fluent UI web components for use.
      *   `<fluent-button>`: Fluent UI button component.
      *   `<fluent-progress-ring>`: Fluent UI progress indicator.

  *   **Implementation Example (`webview/src/routes/+page.svelte`):**
    ```html
    <script lang="ts">
      import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";

      // Register Fluent UI components
      provideFluentDesignSystem().register(
        fluentButton(),
        fluentProgressRing()
      );

      function handleIndexNow() {
        console.log("Index Now button clicked!");
        // In a real scenario, this would trigger the backend indexing process
      }
    </script>

    <main>
      <h1>Code Context Engine</h1>
      <p>Click the button to start indexing your repository.</p>
      <fluent-button appearance="accent" @click="{handleIndexNow}">Index Now</fluent-button>
      <div style="margin-top: 20px;">
        <p>Indexing Progress:</p>
        <fluent-progress-ring></fluent-progress-ring>
      </div>
    </main>

    <style>
      /* Basic styling for the page */
      main {
        padding: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        line-height: 1.5;
      }

      h1 {
        color: var(--vscode-editor-foreground);
      }

      p {
        color: var(--vscode-editor-foreground);
      }

      /* Ensure Fluent UI components inherit VS Code theme colors */
      fluent-button {
        --accent-fill-rest: var(--vscode-button-background);
        --accent-fill-hover: var(--vscode-button-hoverBackground);
        --accent-fill-active: var(--vscode-button-background);
        --accent-foreground-rest: var(--vscode-button-foreground);
        --neutral-fill-rest: var(--vscode-button-background);
        --neutral-fill-hover: var(--vscode-button-hoverBackground);
        --neutral-fill-active: var(--vscode-button-background);
        --neutral-foreground-rest: var(--vscode-button-foreground);
      }

      fluent-progress-ring {
        --accent-fill-rest: var(--vscode-progressBar-background);
      }
    </style>
    ```

**5. Theme Integration**

VS Code exposes its theme colors as CSS variables. You can use these variables in your SvelteKit application's global CSS or directly within components to ensure your UI adapts to the user's chosen theme.

  *   **File:** `webview/src/app.css` (or directly in your Svelte components' `<style>` tags)
  *   **API Information:** VS Code CSS Variables (e.g., `--vscode-editor-background`, `--vscode-editor-foreground`, `--vscode-button-background`).

  *   **Implementation Example (`webview/src/app.css`):**
    ```css
    /* Global styles for the webview */
    body {
      background-color: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
    }

    /* Example of applying VS Code theme colors to Fluent UI components */
    fluent-button {
      --accent-fill-rest: var(--vscode-button-background);
      --accent-fill-hover: var(--vscode-button-hoverBackground);
      --accent-fill-active: var(--vscode-button-background);
      --accent-foreground-rest: var(--vscode-button-foreground);
    }

    fluent-progress-ring {
      --accent-fill-rest: var(--vscode-progressBar-background);
    }
    ```

**Build the SvelteKit App:**

Before running the extension, you need to build your SvelteKit application so that `extension.ts` can load the `index.html` and other assets from the `dist` folder.

  *   **Command (from `webview` directory):**
    ```bash
    cd webview
    npm run build
    ```

This completes the integration of SvelteKit and Fluent UI into your VS Code extension. You now have a visually consistent and interactive frontend ready to communicate with your extension's backend.
</file>

<file path="docs/todo/setup/implementation_sub_sprint_5_implement_context_query_api.md">
### Implementation Guide: Sub-Sprint 5 - Implement Context Query API

**Objective:** To build the internal backend API that will allow the frontend to query the indexed codebase.

#### **Analysis**

This sub-sprint is critical for enabling the core functionality of the extension: allowing users to query their codebase for contextual information. It involves creating a backend service (`ContextService`) that orchestrates interactions with the Qdrant vector database and an embedding provider. Communication between the SvelteKit frontend and this backend service will occur via VS Code's webview message passing API. The design emphasizes modularity, with clear separation of concerns between file system operations, embedding generation, and vector database interactions.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 3 Completion:** Ensure that the Qdrant service and embedding providers (Ollama/OpenAI) are set up and functional, as this sprint relies heavily on them.
2.  **VS Code Extension Project:** A working VS Code extension project with a SvelteKit webview integrated (from previous sprints).

#### **Implementation Guide**

Here's a step-by-step guide to implementing the Context Query API:

**1. Create `ContextService`**

This service will act as the orchestrator for all context-related queries. It will depend on the `QdrantService` (for database interactions) and an `IEmbeddingProvider` (for generating embeddings).

  *   **File:** `src/context/contextService.ts` (New File)
  *   **Key Concepts:**
      *   **Dependency Injection (Basic):** The `ContextService` will instantiate `QdrantService` and an `IEmbeddingProvider`. In a more complex application, these might be passed in via a dependency injection framework.
      *   **Orchestration:** This service will coordinate calls to the embedding provider and Qdrant to fulfill queries.

  *   **Implementation Example:**
    ```typescript
    import * as vscode from 'vscode';
    import { QdrantService } from '../db/qdrantService';
    import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
    import { OllamaProvider } from '../embeddings/ollamaProvider'; // Default or configurable provider
    import { CodeChunk } from '../parsing/chunker'; // Assuming CodeChunk interface is available

    export class ContextService {
        private qdrantService: QdrantService;
        private embeddingProvider: IEmbeddingProvider;
        private collectionName: string; // Qdrant collection name, typically workspace-specific

        constructor(workspaceRoot: string) {
            this.qdrantService = new QdrantService();
            this.embeddingProvider = new OllamaProvider(); // TODO: Make this configurable via settings
            this.collectionName = vscode.workspace.name || 'default_collection'; // Use workspace name as collection
        }

        /**
         * Retrieves the content of a specific file based on a query.
         * In a real scenario, this would involve vector search to find the most relevant file.
         * For now, it directly reads the file if the path is exact.
         */
        public async getFileContent(filePath: string): Promise<string | null> {
            try {
                const uri = vscode.Uri.file(filePath);
                const contentBuffer = await vscode.workspace.fs.readFile(uri);
                return contentBuffer.toString();
            } catch (error) {
                vscode.window.showErrorMessage(`Error reading file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
                console.error(`Error reading file ${filePath}:`, error);
                return null;
            }
        }

        /**
         * Finds files related to a given concept or file path using vector similarity search.
         */
        public async findRelatedFiles(query: string, limit: number = 5): Promise<string[]> {
            try {
                // 1. Generate embedding for the query
                const queryEmbedding = (await this.embeddingProvider.generateEmbeddings([query]))[0];
                if (!queryEmbedding) {
                    vscode.window.showWarningMessage("Could not generate embedding for the query.");
                    return [];
                }

                // 2. Perform similarity search in Qdrant
                const searchResult = await this.qdrantService.search(this.collectionName, queryEmbedding, limit);

                // 3. Extract unique file paths from the search results
                const relatedFilePaths = new Set<string>();
                for (const hit of searchResult) {
                    if (hit.payload && hit.payload.filePath) {
                        relatedFilePaths.add(hit.payload.filePath as string);
                    }
                }
                return Array.from(relatedFilePaths);

            } catch (error) {
                vscode.window.showErrorMessage(`Error finding related files: ${error instanceof Error ? error.message : String(error)}`);
                console.error("Error in findRelatedFiles:", error);
                return [];
            }
        }
    }
    ```

**2. Implement `getFileContent` and `findRelatedFiles`**

These methods are the core of your context API. `getFileContent` will directly read from the file system (or eventually use vector search to resolve a path), while `findRelatedFiles` will leverage your embedding provider and Qdrant.

  *   **File:** `src/context/contextService.ts`
  *   **API Information:**
      *   `vscode.workspace.fs.readFile()`: VS Code API for reading file content.
      *   `this.embeddingProvider.generateEmbeddings()`: Your custom method from Sub-Sprint 3 to get vector representations of text.
      *   `this.qdrantService.search()`: Your custom method from Sub-Sprint 3 to query the Qdrant database.

  *   **Implementation:** (See `ContextService` example above. Ensure `QdrantService` has a `search` method and `IEmbeddingProvider` has `generateEmbeddings`.)

**3. Expose via Message Passing in `extension.ts`**

Your `extension.ts` will act as the bridge between the webview (frontend) and your backend `ContextService`. It will listen for messages from the webview, call the appropriate `ContextService` method, and send the results back.

  *   **File:** `src/extension.ts`
  *   **Key Concepts:**
      *   `panel.webview.onDidReceiveMessage()`: Event listener for messages from the webview.
      *   `panel.webview.postMessage()`: Sends messages back to the webview.
      *   **Message Structure:** Define a clear message structure (e.g., `{ command: string, payload: any }`) for both incoming and outgoing messages.

  *   **Implementation Example (within `activate` function, after `panel` creation):**
    ```typescript
    // Assuming `currentPanel` is your WebviewPanel instance
    const contextService = new ContextService(vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '');

    currentPanel.webview.onDidReceiveMessage(
        async message => {
            switch (message.command) {
                case 'getFileContent':
                    const fileContent = await contextService.getFileContent(message.filePath);
                    currentPanel?.webview.postMessage({ command: 'fileContentResult', content: fileContent });
                    return;
                case 'findRelatedFiles':
                    const relatedFiles = await contextService.findRelatedFiles(message.query);
                    currentPanel?.webview.postMessage({ command: 'relatedFilesResult', files: relatedFiles });
                    return;
                // Add other commands as needed
            }
        },
        undefined,
        context.subscriptions
    );
    ```

**4. Create Frontend API Client (`webview/src/lib/vscodeApi.ts`)**

To simplify communication from the SvelteKit frontend, create a small wrapper that abstracts the `acquireVsCodeApi()` and message posting/listening.

  *   **File:** `webview/src/lib/vscodeApi.ts` (New File)
  *   **Key Concepts:**
      *   `acquireVsCodeApi()`: Global function provided by VS Code to webviews to get a reference to the VS Code API.
      *   `vscode.postMessage()`: Sends a message from the webview to the extension.
      *   `window.addEventListener('message', ...)`: Listens for messages sent from the extension to the webview.

  *   **Implementation Example:**
    ```typescript
    // webview/src/lib/vscodeApi.ts
    declare const acquireVsCodeApi: any; // Declare to avoid TypeScript errors
    const vscode = acquireVsCodeApi();

    /**
     * Sends a message from the webview to the VS Code extension backend.
     * @param message The message payload.
     */
    export function postMessage(message: any) {
        vscode.postMessage(message);
    }

    /**
     * Registers a callback to listen for messages from the VS Code extension backend.
     * @param callback The function to call when a message is received.
     */
    export function onMessage(callback: (message: any) => void) {
        window.addEventListener('message', event => {
            callback(event.data);
        });
    }
    ```

**5. Integrate Frontend with API Client**

Modify your Svelte components to use the `vscodeApi.ts` client to send requests and handle responses.

  *   **File:** `webview/src/routes/+page.svelte` (or other relevant Svelte components)
  *   **Key Concepts:**
      *   `onMount`: Svelte lifecycle hook to run code when the component is first mounted.
      *   Reactive variables: Svelte's way of updating the UI when data changes.

  *   **Implementation Example (simplified):**
    ```html
    <script lang="ts">
      import { onMount } from 'svelte';
      import { postMessage, onMessage } from '../lib/vscodeApi';

      let fileContent: string | null = null;
      let relatedFiles: string[] = [];
      let queryInput: string = '';
      let filePathInput: string = '';

      onMount(() => {
        onMessage(message => {
          switch (message.command) {
            case 'fileContentResult':
              fileContent = message.content;
              if (fileContent === null) {
                alert("File not found or could not be read.");
              }
              break;
            case 'relatedFilesResult':
              relatedFiles = message.files;
              if (relatedFiles.length === 0) {
                alert("No related files found.");
              }
              break;
            // Handle other message types
          }
        });
      });

      function handleGetFileContent() {
        if (filePathInput) {
          postMessage({ command: 'getFileContent', filePath: filePathInput });
        }
      }

      function handleFindRelatedFiles() {
        if (queryInput) {
          postMessage({ command: 'findRelatedFiles', query: queryInput });
        }
      }
    </script>

    <main>
      <h1>Context Query API Demo</h1>

      <h2>Get File Content</h2>
      <input type="text" bind:value={filePathInput} placeholder="Enter file path (e.g., /src/extension.ts)" style="width: 300px;" />
      <button on:click={handleGetFileContent}>Get Content</button>
      {#if fileContent !== null}
        <h3>File Content:</h3>
        <pre style="white-space: pre-wrap; word-break: break-all; max-height: 300px; overflow-y: auto; background-color: var(--vscode-editor-background); color: var(--vscode-editor-foreground); padding: 10px; border: 1px solid var(--vscode-editorWidget-border);">{fileContent}</pre>
      {/if}

      <h2>Find Related Files</h2>
      <input type="text" bind:value={queryInput} placeholder="Enter concept or file path (e.g., authentication logic)" style="width: 300px;" />
      <button on:click={handleFindRelatedFiles}>Find Related</button>
      {#if relatedFiles.length > 0}
        <h3>Related Files:</h3>
        <ul>
          {#each relatedFiles as file}
            <li>{file}</li>
          {/each}
        </ul>
      {/if}
    </main>

    <style>
      /* Add basic styling for inputs and buttons to match VS Code theme */
      input[type="text"] {
        background-color: var(--vscode-input-background);
        color: var(--vscode-input-foreground);
        border: 1px solid var(--vscode-input-border);
        padding: 5px;
        margin-right: 10px;
      }
      button {
        background-color: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
        border: none;
        padding: 8px 12px;
        cursor: pointer;
      }
      button:hover {
        background-color: var(--vscode-button-hoverBackground);
      }
    </style>
    ```

This completes the implementation guide for Sub-Sprint 5. You now have a functional backend API for querying code context and a frontend capable of interacting with it.
</file>

<file path="docs/todo/setup/implementation_sub_sprint_6_develop_settings_ui.md">
### Implementation Guide: Sub-Sprint 6 - Develop Settings UI

**Objective:** To create the user-facing settings panel where users can configure the extension's behavior.

#### **Analysis**

This sub-sprint focuses on providing a user-friendly interface for configuring the extension. It involves extending the `package.json` to declare new configuration properties and a command to open the settings UI. The settings UI itself will be a SvelteKit webview, leveraging Fluent UI components for a consistent look and feel. Crucially, the UI will interact with the VS Code configuration API to read and write settings, ensuring persistence and proper application of user preferences across the extension's backend services.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 2 Completion:** A working SvelteKit webview integrated into the VS Code extension.
2.  **Sub-Sprint 5 Completion:** The backend services are in place, which will eventually consume these settings.
3.  **Fluent UI Web Components:** Ensure `@fluentui/web-components` is installed in your `webview` project.

#### **Implementation Guide**

Here's a step-by-step guide to developing the Settings UI:

**1. Register Settings Command in `package.json`**

First, define a new command that users can execute from the VS Code Command Palette to open your settings UI.

  *   **File:** `package.json`
  *   **Key Concept:** The `contributes.commands` section in `package.json` is used to declare commands that your extension provides.

  *   **Implementation Example (add to `contributes.commands` array):**
    ```json
    {
        "command": "code-context-engine.openSettings",
        "title": "Code Context Engine: Open Settings",
        "category": "Code Context Engine"
    }
    ```

**2. Create and Show Settings Webview in `extension.ts`**

Implement the logic in your main extension file (`extension.ts`) to handle the `openSettings` command. This will involve creating a new `WebviewPanel` specifically for your settings UI.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.commands.registerCommand()`: To link your declared command to a function.
      *   `vscode.window.createWebviewPanel()`: To create the webview instance.
      *   `panel.webview.html`: To load the SvelteKit app into the webview.
      *   `path.join()` and `vscode.Uri.file()`: For constructing correct paths to your SvelteKit build output.

  *   **Implementation Example (within `activate` function):**
    ```typescript
    import * as vscode from 'vscode';
    import * as path from 'path';
    import * as fs from 'fs';

    // ... (existing code for main panel, if any)

    let settingsPanel: vscode.WebviewPanel | undefined; // Declare a variable to hold the settings panel instance

    context.subscriptions.push(
        vscode.commands.registerCommand('code-context-engine.openSettings', () => {
            const columnToShowIn = vscode.window.activeTextEditor
                ? vscode.window.activeTextEditor.viewColumn
                : undefined;

            if (settingsPanel) {
                settingsPanel.reveal(columnToShowIn); // If panel already exists, just reveal it
            } else {
                // Create a new webview panel
                settingsPanel = vscode.window.createWebviewPanel(
                    'codeContextEngineSettings', // Unique ID
                    'Code Context Engine Settings', // Title
                    columnToShowIn || vscode.ViewColumn.One, // Column to show in
                    {
                        enableScripts: true,
                        localResourceRoots: [
                            vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                        ]
                    }
                );

                // Get path to SvelteKit's built index.html
                const svelteAppPath = vscode.Uri.file(
                    path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                );

                // Read and set the HTML content
                let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');
                // Important: Adjust paths for webview to load SvelteKit assets correctly
                htmlContent = htmlContent.replace(/\/\_app\//g, settingsPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                settingsPanel.webview.html = htmlContent;

                // Handle panel disposal (e.g., when user closes it)
                settingsPanel.onDidDispose(
                    () => {
                        settingsPanel = undefined;
                    },
                    null,
                    context.subscriptions
                );
            }
        })
    );
    ```

**3. Build Svelte UI for Settings**

Create a new Svelte component (e.g., `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte`) that will serve as your settings page. Use Fluent UI components for input fields.

  *   **File:** `webview/src/routes/settings/+page.svelte` (or similar)
  *   **API Information:**
      *   `@fluentui/web-components`: Provides `<fluent-select>`, `<fluent-option>`, `<fluent-text-field>`, `<fluent-button>`.
      *   `bind:value`: Svelte directive for two-way data binding with input elements.
      *   `onMount`: Svelte lifecycle hook to run code after the component is first rendered.
      *   `postMessage`, `onMessage` (from `vscodeApi.ts`): For communication with the extension backend.

  *   **Implementation Example:**
    ```html
    <script lang="ts">
      import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";
      import { onMount } from 'svelte';
      import { postMessage, onMessage } from '../../lib/vscodeApi'; // Adjust path as needed

      // Register Fluent UI components
      provideFluentDesignSystem().register(
        fluentSelect(),
        fluentOption(),
        fluentTextField(),
        fluentButton()
      );

      let embeddingProvider: string = 'Ollama'; // Default value, will be overwritten by loaded settings
      let databaseConnectionString: string = '';

      onMount(() => {
        // Request current settings from extension backend on component mount
        postMessage({ command: 'getSettings' });

        // Listen for settings data from the extension backend
        onMessage(message => {
          if (message.command === 'settingsResult') {
            embeddingProvider = message.settings.embeddingProvider || 'Ollama';
            databaseConnectionString = message.settings.databaseConnectionString || '';
          }
        });
      });

      function saveSettings() {
        const settings = {
          embeddingProvider,
          databaseConnectionString,
        };
        // Send updated settings to the extension backend to be saved
        postMessage({ command: 'saveSettings', settings });
      }
    </script>

    <main>
      <h1>Extension Settings</h1>

      <fluent-text-field
        appearance="outline"
        placeholder="Database Connection String"
        bind:value={databaseConnectionString}
        style="width: 100%; margin-bottom: 15px;"
      >
        Database Connection String
      </fluent-text-field>

      <fluent-select
        appearance="outline"
        bind:value={embeddingProvider}
        style="width: 100%; margin-bottom: 20px;"
      >
        <fluent-option value="Ollama">Ollama</fluent-option>
        <fluent-option value="OpenAI">OpenAI</fluent-option>
        <!-- Add more options as needed -->
      </fluent-select>

      <fluent-button appearance="accent" @click={saveSettings}>Save Settings</fluent-button>
    </main>

    <style>
      /* Basic styling for the page and Fluent UI components to match VS Code theme */
      main {
        padding: 20px;
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
      }
      h1 {
        color: var(--vscode-editor-foreground);
      }
      fluent-text-field,
      fluent-select {
        --neutral-fill-rest: var(--vscode-input-background);
        --neutral-foreground-rest: var(--vscode-input-foreground);
        --neutral-stroke-rest: var(--vscode-input-border);
        --neutral-fill-stealth-rest: var(--vscode-input-background);
        --neutral-fill-stealth-hover: var(--vscode-input-background);
        --neutral-fill-stealth-active: var(--vscode-input-background);
        --neutral-foreground-hover: var(--vscode-input-foreground);
        --neutral-foreground-active: var(--vscode-input-foreground);
        --neutral-stroke-hover: var(--vscode-input-border);
        --neutral-stroke-active: var(--vscode-input-border);
      }
      fluent-button {
        --accent-fill-rest: var(--vscode-button-background);
        --accent-foreground-rest: var(--vscode-button-foreground);
        --accent-fill-hover: var(--vscode-button-hoverBackground);
      }
    </style>
    ```

**4. Implement State Management and VS Code Configuration Interaction**

This is the core of saving and loading settings. You'll use VS Code's `workspace.getConfiguration()` API.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.workspace.getConfiguration('your-extension-id')`: Gets a configuration object for your extension.
      *   `config.get<T>(key, defaultValue)`: Reads a setting.
      *   `config.update(key, value, target)`: Writes a setting. `target` can be `vscode.ConfigurationTarget.Global`, `Workspace`, or `WorkspaceFolder`.
      *   `panel.webview.postMessage()` and `panel.webview.onDidReceiveMessage()`: For communication between extension and webview.

  *   **Implementation Example (within `extension.ts` `onDidReceiveMessage` handler for `settingsPanel`):**
    ```typescript
    // ... (inside settingsPanel.webview.onDidReceiveMessage)
    switch (message.command) {
        case 'getSettings':
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const currentSettings = {
                embeddingProvider: config.get<string>('embeddingProvider', 'Ollama'),
                databaseConnectionString: config.get<string>('databaseConnectionString', 'http://localhost:6333'),
            };
            settingsPanel?.webview.postMessage({ command: 'settingsResult', settings: currentSettings });
            return;

        case 'saveSettings':
            const newSettings = message.settings;
            const configToUpdate = vscode.workspace.getConfiguration('code-context-engine');
            
            // Update settings. Use Global target for user-level settings, or Workspace for workspace-specific
            await configToUpdate.update('embeddingProvider', newSettings.embeddingProvider, vscode.ConfigurationTarget.Global);
            await configToUpdate.update('databaseConnectionString', newSettings.databaseConnectionString, vscode.ConfigurationTarget.Global);
            
            vscode.window.showInformationMessage('Code Context Engine settings saved!');
            return;
    }
    ```

**5. Define Configuration Schema in `package.json`**

To make your settings discoverable and provide type-checking and descriptions in VS Code's built-in settings UI, you must define them in `package.json`.

  *   **File:** `package.json`
  *   **Key Concept:** The `contributes.configuration` section defines the properties for your extension's settings.

  *   **Implementation Example (add to `contributes` section):**
    ```json
    "configuration": {
        "title": "Code Context Engine Configuration",
        "properties": {
            "code-context-engine.embeddingProvider": {
                "type": "string",
                "enum": ["Ollama", "OpenAI"],
                "default": "Ollama",
                "description": "Select the embedding provider to use for generating code embeddings."
            },
            "code-context-engine.databaseConnectionString": {
                "type": "string",
                "default": "http://localhost:6333",
                "description": "The connection string for the Qdrant vector database."
            }
        }
    }
    ```

**6. Refactor Services to Use Configuration**

Finally, ensure your `IndexingService` and `QdrantService` (and any other services that need configuration) read their values from the VS Code configuration instead of hardcoded defaults.

  *   **File:** `src/indexing/indexingService.ts`, `src/db/qdrantService.ts`
  *   **API Information:** `vscode.workspace.getConfiguration('your-extension-id').get<T>(key, defaultValue)`.

  *   **Implementation Example (`src/indexing/indexingService.ts` constructor):**
    ```typescript
    import * as vscode from 'vscode';
    // ... other imports

    export class IndexingService {
        // ... other properties
        private embeddingProvider: IEmbeddingProvider;

        constructor(private workspaceRoot: string) {
            // ...
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const providerName = config.get<string>('embeddingProvider', 'Ollama');

            if (providerName === 'OpenAI') {
                this.embeddingProvider = new OpenAIProvider(); // Assuming OpenAIProvider exists
            } else {
                this.embeddingProvider = new OllamaProvider(); // Assuming OllamaProvider exists
            }
        }
        // ...
    }
    ```

  *   **Implementation Example (`src/db/qdrantService.ts` constructor):**
    ```typescript
    import { QdrantClient } from '@qdrant/js-client-rest';
    import * as vscode from 'vscode';

    export class QdrantService {
        private client: QdrantClient;

        constructor() {
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const connectionString = config.get<string>('databaseConnectionString', 'http://localhost:6333');
            this.client = new QdrantClient({ url: connectionString });
        }
        // ...
    }
    ```

This completes the implementation guide for Sub-Sprint 6. You now have a fully functional settings UI that allows users to configure your extension, with those settings being correctly consumed by your backend services.
</file>

<file path="docs/todo/setup/prd.md">
<prd>Of course. I've analyzed the roadmap and will now generate the detailed Product Requirements Documents (PRDs) for each phase of the VS Code extension project.

Here is the first PRD, which covers the foundational setup of the extension.

-----

### **New Document: PRD 1: Foundational - Extension Boilerplate & UI Setup**

**1. Title & Overview**

  * **Project:** Code Context Engine - VS Code Extension
  * **Summary:** This phase establishes the core technical foundation for the VS Code extension. It includes setting up the project with the chosen technology stack (SvelteKit and TypeScript), creating the basic user interface using Microsoft's Fluent UI, and ensuring the basic extension can be loaded and run within a VS Code development environment.
  * **Dependencies:** Requires Node.js, npm/yarn, and the VS Code Extension Development Kit.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Rapidly create a tangible, runnable prototype to validate the chosen technology stack.
      * Establish a solid foundation for the user interface that can be easily extended in future phases.
  * **Developer & System Success Metrics:**
      * The VS Code extension can be successfully compiled, loaded, and activated in a development host.
      * The main SvelteKit-based UI panel renders correctly within VS Code.
      * Core UI components (buttons, progress bars) from the Fluent UI library are successfully integrated and functional.
      * The project structure is well-organized, with clear separation between the extension's backend (TypeScript) and frontend (SvelteKit) concerns.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin works on large, complex codebases and needs a tool to help him quickly understand code context. He expects a clean, intuitive, and responsive user interface that feels native to the VS Code environment.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Foundation** | **Sprint 1: Boilerplate & UI Scaffolding** | As a developer, I want a VS Code extension project set up with SvelteKit for the UI and TypeScript for the backend logic, so we have a standard, modern technology stack. | 1. A new VS Code extension project is generated using the official templates.\<br\>2. SvelteKit is successfully integrated as the webview provider for the extension's UI.\<br\>3. TypeScript is configured for both the extension's main process (backend) and the SvelteKit frontend.\<br\>4. The project can be compiled and run without errors. | **2 Weeks** |
| | | As Devin, I want to see a main panel for the extension with a clear "Index Now" button, so I know how to start the core process. | 1. The extension contributes a new view/panel to the VS Code UI.\<br\>2. This panel renders a SvelteKit component.\<br\>3. The component displays a prominent button with the text "Index Now" using a Fluent UI `Button` component.\<br\>4. A placeholder for a progress bar is visible on the UI. | |
| | | As a developer, I want to integrate Microsoft's Fluent UI library into the SvelteKit project, so we can build a consistent and professional-looking UI quickly. | 1. The Fluent UI Svelte library is added as a project dependency.\<br\>2. A sample Fluent UI component (e.g., a button or card) is successfully rendered within the extension's webview.\<br\>3. The styling of the Fluent UI components matches the user's current VS Code theme (light/dark). | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 1:** Boilerplate & UI Scaffolding (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** SvelteKit can be integrated smoothly as a webview UI for a VS Code extension without significant compatibility issues.
  * **Risk:** Integrating Fluent UI with SvelteKit might have unforeseen styling conflicts or component incompatibilities.
      * **Mitigation:** Dedicate early time in the sprint to create a small proof-of-concept integrating a few key Fluent UI components to identify and resolve any issues.
  * **Risk:** The initial project setup and build configuration for a hybrid TypeScript/SvelteKit extension might be more complex than anticipated.
      * **Mitigation:** Allocate sufficient time for research and follow best practices from official documentation and community examples.

-----

### **New Document: Sub-Sprint 1: VS Code Extension Boilerplate Setup**

**Objective:**
To create the fundamental file structure and configuration for a new VS Code extension using TypeScript.

**Parent Sprint:**
PRD 1, Sprint 1: Boilerplate & UI Scaffolding

**Tasks:**

1.  **Generate Extension:** Use `yo code` to generate a new TypeScript-based VS Code extension.
2.  **Configure `package.json`:** Define the extension's name, publisher, and activation events.
3.  **Establish Project Structure:** Create separate directories for the `extension` (backend) and `webview` (frontend) source code.
4.  **Initial Backend Logic:** Write the initial `extension.ts` file, including the `activate` and `deactivate` functions.

**Acceptance Criteria:**

  * The extension can be launched in a VS Code development host.
  * A "Hello World" command from the extension can be successfully executed from the command palette.
  * The project structure is clean and logically separated.

**Dependencies:**

  * Node.js and `yo code` generator installed.

**Timeline:**

  * **Start Date:** 2025-10-27
  * **End Date:** 2025-10-31

-----

### **New Document: Sub-Sprint 2: SvelteKit and Fluent UI Integration**

**Objective:**
To set up the SvelteKit frontend and integrate the Fluent UI component library, creating the initial user interface.

**Parent Sprint:**
PRD 1, Sprint 1: Boilerplate & UI Scaffolding

**Tasks:**

1.  **Initialize SvelteKit:** Set up a new SvelteKit project within the `webview` directory.
2.  **Configure Webview:** In `extension.ts`, create the logic to render the SvelteKit app inside a VS Code webview panel.
3.  **Install Fluent UI:** Add the Fluent UI Svelte library as a dependency to the SvelteKit project.
4.  **Implement UI:** Create a Svelte component for the main panel that includes an "Index Now" button and a progress bar from the Fluent UI library.
5.  **Theme Integration:** Ensure the UI components automatically adapt to VS Code's light and dark themes.

**Acceptance Criteria:**

  * The SvelteKit application renders correctly inside the VS Code extension panel.
  * The "Index Now" button is visible and interactive.
  * UI components correctly reflect the active VS Code theme.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2025-11-03
  * **End Date:** 2025-11-07

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Boilerplate & UI Scaffolding

**Goal:** To establish the project's foundation by setting up the VS Code extension with a SvelteKit frontend and Fluent UI.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** | ☐ To Do | **Generate VS Code Extension:** Run `npx yo code` and select "New Extension (TypeScript)". | `(Project Root)` |
| **1.2** | ☐ To Do | **Initialize SvelteKit Project:** In a new `webview` directory, run `npm create svelte@latest .` and configure it for a single-page app. | `webview/` |
| **1.3** | ☐ To Do | **Install Dependencies:** Add `svelte-fluent-ui` to the `webview`'s `package.json` and install. | `webview/package.json` |
| **1.4** | ☐ To Do | **Create Webview Panel Logic:** In `extension.ts`, write the TypeScript code to create and manage a `WebviewPanel`. | `src/extension.ts` |
| **1.5** | ☐ To Do | **Load Svelte App in Webview:** Configure the webview to load the compiled `index.html` from the SvelteKit `build` directory. | `src/extension.ts` |
| **1.6** | ☐ To Do | **Build Main UI Component:** Create a `MainPanel.svelte` component displaying a `<Button>` and `<ProgressBar>` from Fluent UI. | `webview/src/lib/MainPanel.svelte` |
| **1.7** | ☐ To Do | **Implement Theme Handling:** Use VS Code theme CSS variables to ensure Fluent UI components adapt to light/dark modes. | `webview/src/app.html` |
| **1.8** | ☐ To Do | **Test Extension:** Run the extension in a development host to verify the UI panel opens and displays the SvelteKit app correctly. | `(Launch Configuration)` |

Of course. Here are the final PRDs and task lists to complete the project plan for your VS Code extension.

-----

### **New Document: PRD 3: Context Engine API & Feature Enhancement**

**1. Title & Overview**

  * **Project:** Code Context Engine - API & Settings
  * **Summary:** This phase focuses on exposing the indexed data through an internal API and building the user-facing settings UI. This will enable the core functionality of the extension—querying the codebase for context—and allow users to configure the extension to their specific needs, such as changing the database connection or selecting a different embedding provider.
  * **Dependencies:** PRD 2 must be complete. The codebase must be successfully indexed and stored in a Qdrant instance.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Deliver the primary value proposition of the extension by allowing users to query their code contextually.
      * Increase user retention and satisfaction by providing customization options.
  * **Developer & System Success Metrics:**
      * The internal API successfully handles queries like "list files related to X" and "get content of Y" by performing a vector search.
      * API response times for typical queries are under 500ms.
      * The settings UI correctly reads from and writes to the VS Code workspace configuration.
      * Changing a setting (e.g., the embedding provider) is correctly reflected in the indexing service on the next run.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin wants to ask his codebase questions in plain English. He needs to be able to ask for the content of a specific file or find other files related to the one he's working on to speed up his development workflow. He also wants to easily configure the extension to use his preferred embedding model.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: API & Settings** | **Sprint 4: Context Query API** | As Devin, I want to be able to ask the extension to retrieve the content of a specific file so I can view it without having to manually search for it. | 1. An internal API endpoint is created to handle "get file content" requests.\<br/\>2. The API performs a search in the vector index to find the most likely file matching the query.\<br/\>3. The full, up-to-date content of the identified file is returned. | **2 Weeks** |
| | | As Devin, I want to ask for a list of files related to a specific file or concept so I can understand the connections within my codebase. | 1. An internal API endpoint is created for "find related files" requests.\<br/\>2. The API vectorizes the input query and performs a similarity search in Qdrant.\<br/\>3. A ranked list of the top 5 most relevant file paths is returned based on the search results. | |
| **Phase 3: API & Settings** | **Sprint 5: Settings UI & Configuration** | As Devin, I want a dedicated settings page for the extension so I can configure the database and embedding provider for each of my projects. | 1. A new webview panel is created for the extension's settings.\<br/\>2. The UI includes a dropdown to select an embedding provider (Ollama, OpenAI, etc.).\<br/\>3. The UI includes a text input for the database connection string.\<br/\>4. The settings are saved to the workspace's `settings.json` file under a unique extension-specific key. | **2 Weeks** |
| | | As a developer, I want the extension's backend services to read their configuration from the workspace settings so that user changes are applied correctly. | 1. The `IndexingService` reads the selected embedding provider from the VS Code workspace configuration.\<br/\>2. The `QdrantService` reads the database connection string from the configuration.\<br/\>3. The extension gracefully handles missing or invalid configuration values by falling back to sensible defaults. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 4:** Context Query API (2 Weeks)
  * **Sprint 5:** Settings UI & Configuration (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** Simple vector similarity search will be sufficient to find "related" files accurately for the initial version.
  * **Risk:** The quality of search results might be poor if the user's query is ambiguous, leading to user frustration.
      * **Mitigation:** For the initial version, focus on clear query patterns. In a future phase, introduce an LLM to refine user queries before they are sent to the vector search.
  * **Risk:** Securely storing and handling user-provided secrets (like an OpenAI API key) is critical.
      * **Mitigation:** Use VS Code's official `SecretStorage` API for any sensitive information instead of storing it in plain text in the settings file.

-----

### **New Document: Sub-Sprint 5: Implement Context Query API**

**Objective:**
To build the internal backend API that will allow the frontend to query the indexed codebase.

**Parent Sprint:**
PRD 3, Sprint 4: Context Query API

**Tasks:**

1.  **Create `ContextService`:** Develop a new service in the TypeScript backend to orchestrate context retrieval.
2.  **Implement `getFileContent`:** Create a method that takes a file path query, uses the embedding provider and Qdrant client to find the best match, and then reads the file content from the disk.
3.  **Implement `findRelatedFiles`:** Create a method that takes a concept or file path, generates an embedding for it, and performs a vector similarity search in Qdrant to find the top N most similar file chunks.
4.  **Expose via Message Passing:** Use the standard VS Code webview message passing interface to allow the SvelteKit frontend to call these backend service methods.

**Acceptance Criteria:**

  * Sending a "getFileContent" message from the webview returns the correct file's content.
  * Sending a "findRelatedFiles" message returns an array of relevant file paths.
  * The API handles cases where no relevant files are found gracefully.

**Dependencies:**

  * PRD 2 must be complete.

**Timeline:**

  * **Start Date:** 2025-11-24
  * **End Date:** 2025-11-28

-----

### **New Document: Sub-Sprint 6: Develop Settings UI**

**Objective:**
To create the user-facing settings panel where users can configure the extension's behavior.

**Parent Sprint:**
PRD 3, Sprint 5: Settings UI & Configuration

**Tasks:**

1.  **Register Settings Command:** Add a new command to `package.json` that will open the settings webview.
2.  **Create Settings Webview:** Develop the TypeScript logic in `extension.ts` to create and show a new webview panel for settings.
3.  **Build Svelte UI:** Create a `Settings.svelte` component using Fluent UI components (`<Select>`, `<TextField>`) for the provider and database configuration.
4.  **Implement State Management:** The Svelte component should read the current configuration from VS Code settings on load and use message passing to send updated values back to the extension backend to be saved.

**Acceptance Criteria:**

  * A new command in the command palette successfully opens the settings UI.
  * The UI correctly displays the currently saved settings.
  * Changing a value in the UI and clicking "Save" correctly updates the workspace `settings.json` file.

**Dependencies:**

  * Sub-Sprint 5 must be complete.

**Timeline:**

  * **Start Date:** 2025-12-01
  * **End Date:** 2025-12-05

-----

### **New Document: tasklist\_sprint\_04.md**

# Task List: Sprint 4 - Context Query API

**Goal:** To build and expose the internal API for querying the indexed code context.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** | ☐ To Do | **Create `ContextService`:** In the backend, create a new `contextService.ts` file to house the query logic. | `src/context/contextService.ts` |
| **4.2** | ☐ To Do | **Implement `getFileContent` method:** Add logic to perform a vector search for the file path and then read the content from disk using `vscode.workspace.fs`. | `src/context/contextService.ts` |
| **4.3** | ☐ To Do | **Implement `findRelatedFiles` method:** Add logic to perform a similarity search in Qdrant and return a list of unique file paths from the results. | `src/context/contextService.ts` |
| **4.4** | ☐ To Do | **Set up Webview Message Handling:** In `extension.ts`, add a `message` listener to the webview panel to handle incoming requests from the frontend. | `src/extension.ts` |
| **4.5** | ☐ To Do | **Route API Calls:** In the message handler, create a `switch` statement to route requests (e.g., `'getFileContent'`) to the appropriate method in `ContextService`. | `src/extension.ts` |
| **4.6** | ☐ To Do | **Send Results to Frontend:** Use the `webview.postMessage` method to send the results from the service back to the SvelteKit UI. | `src/extension.ts` |
| **4.7** | ☐ To Do | **Create Frontend API Client:** In the SvelteKit app, create a wrapper service (`vscodeApi.ts`) that simplifies posting and listening for messages from the extension backend. | `webview/src/lib/vscodeApi.ts` |

-----

### **New Document: tasklist\_sprint\_05.md**

# Task List: Sprint 5 - Settings UI & Configuration

**Goal:** To build the settings UI and connect it to the VS Code configuration system.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** | ☐ To Do | **Define Configuration Schema:** In `package.json`, under the `contributes.configuration` section, define the properties for the settings (e.g., `code-context.embeddingProvider`). | `package.json` |
| **5.2** | ☐ To Do | **Register `openSettings` command:** In `package.json`, add a new command to the `contributes.commands` section. | `package.json` |
| **5.3** | ☐ To Do | **Implement command in `extension.ts`:** Register the command to create and show the settings webview panel. | `src/extension.ts` |
| **5.4** | ☐ To Do | **Create `Settings.svelte` component:** Build the UI with a `<Select>` for providers and a `<TextField>` for the database URI. | `webview/src/routes/settings.svelte` |
| **5.5** | ☐ To Do | **Load Initial Settings:** In the Svelte component, use the `vscodeApi` service to request the current configuration when the component mounts. | `webview/src/routes/settings.svelte` |
| **5.6** | ☐ To Do | **Save Settings:** On button click, send a message with the updated settings object to the extension backend. | `webview/src/routes/settings.svelte` |
| **5.7** | ☐ To Do | **Implement `saveConfiguration` handler:** In the backend message listener, handle the "saveSettings" message by calling `vscode.workspace.getConfiguration().update()`. | `src/extension.ts` |
| **5.8** | ☐ To Do | **Refactor Services to Use Config:** Update `IndexingService` and `QdrantService` to read their settings from `vscode.workspace.getConfiguration()` instead of hardcoded values. | `src/indexing/indexingService.ts`, `src/db/qdrantService.ts` |

-----

### **New Document: PRD 4: Advanced Features & Polish**

**1. Title & Overview**

  * **Project:** Code Context Engine - Advanced Indexing & Publishing
  * **Summary:** This final phase focuses on enhancing the quality of the index by integrating data from the Language Server Protocol (LSP), establishing a professional release process with a CI/CD pipeline, and creating comprehensive documentation to support users and future contributors.
  * **Dependencies:** PRD 3 must be complete.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Gain a competitive advantage by creating a more intelligent and contextually-aware index than simple AST parsing can provide.
      * Ensure long-term project health and user trust through a reliable release process and clear documentation.
  * **Developer & System Success Metrics:**
      * The indexing process can successfully capture and store LSP data like "go to definition" and "find all references" links between code chunks.
      * A GitHub Actions workflow is created that automatically builds, lints, tests, and packages the extension on every push to the `main` branch.
      * The extension is successfully published to the Visual Studio Code Marketplace.
      * A `README.md` and contributing guide are created that meet open-source community standards.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 4: Polish** | **Sprint 6: LSP Integration & DevOps** | As Alisha, I want to enhance the index by capturing data from the Language Server Protocol (LSP) so that we can understand relationships between code. | 1. The extension can programmatically access the active LSP for supported languages.\<br/\>2. During indexing, the system queries the LSP for information like definitions and references for each code chunk.\<br/\>3. This relationship data is stored as metadata alongside the vectors in Qdrant. | **2 Weeks** |
| | | As Alisha, I want to create a CI/CD pipeline using GitHub Actions so that we can automate the build, test, and release process. | 1. A new GitHub Actions workflow file is created.\<br/\>2. The workflow is triggered on pushes and pull requests.\<br/\>3. The workflow includes stages for installing dependencies, linting, running unit tests, and building the extension package (`.vsix`). | |
| **Phase 4: Polish** | **Sprint 7: Documentation & Publishing** | As Devin, I want clear, comprehensive documentation for the extension so that I know how to install, configure, and use it effectively. | 1. The `README.md` file is updated with a feature list, installation instructions, and a guide on configuring the settings.\<br/\>2. An animated GIF is included in the README to demonstrate the core workflow.\<br/\>3. A `CONTRIBUTING.md` file is created with guidelines for new developers. | **2 Weeks** |
| | | As a project owner, I want to publish the extension to the VS Code Marketplace so that it is easily discoverable and accessible to all users. | 1. A publisher identity is created on the VS Code Marketplace.\<br/\>2. The GitHub Actions pipeline is updated with a manual "release" trigger.\<br/\>3. When triggered, the pipeline automatically packages and publishes the latest version of the extension to the marketplace. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 6:** LSP Integration & DevOps (2 Weeks)
  * **Sprint 7:** Documentation & Publishing (2 Weeks)

-----

### **New Document: tasklist\_sprint\_06.md**

# Task List: Sprint 6 - LSP Integration & DevOps

**Goal:** To enrich the index with LSP data and automate the build and test process.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** | ☐ To Do | **Research LSP Interaction:** Investigate how to programmatically interact with a language server using the `vscode.lsp` API. | `(Documentation)` |
| **6.2** | ☐ To Do | **Update `IndexingService` for LSP:** Modify the service to, for each chunk, invoke LSP commands like `vscode.executeDefinitionProvider` to find related symbols. | `src/indexing/indexingService.ts` |
| **6.3** | ☐ To Do | **Extend Qdrant Metadata:** Update the `QdrantService` to store the new relationship metadata (e.g., `definesSymbol`, `referencesSymbol`) along with the vector. | `src/db/qdrantService.ts` |
| **6.4** | ☐ To Do | **Create GitHub Actions Workflow:** Create a `.github/workflows/ci.yml` file. | `.github/workflows/ci.yml` |
| **6.5** | ☐ To Do | **Add Linting and Testing Steps:** Add jobs to the workflow for running `eslint` and `vitest`. | `.github/workflows/ci.yml` |
| **6.6** | ☐ To Do | **Add Build Step:** Add a job that runs `vsce package` to create the `.vsix` extension file and uploads it as a build artifact. | `.github/workflows/ci.yml` |

-----

### **New Document: tasklist\_sprint\_07.md**

# Task List: Sprint 7 - Documentation & Publishing

**Goal:** To create high-quality documentation and publish the extension to the marketplace.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **7.1** | ☐ To Do | **Write `README.md` Content:** Draft the main sections: Features, Requirements, Installation, and Configuration. | `README.md` |
| **7.2** | ☐ To Do | **Create Demo GIF:** Use screen recording software to capture the indexing and querying workflow and save it as an optimized GIF. | `assets/demo.gif` |
| **7.3** | ☐ To Do | **Write `CONTRIBUTING.md`:** Create a guide for developers on how to set up the project, run tests, and submit pull requests. | `CONTRIBUTING.md` |
| **7.4** | ☐ To Do | **Create Marketplace Publisher:** Register a new publisher ID in the Microsoft Partner Center. | `(External)` |
| **7.5** | ☐ To Do | **Add Release Workflow:** Update the `ci.yml` file to include a manually triggered `release` job. | `.github/workflows/ci.yml` |
| **7.6** | ☐ To Do | **Implement Publishing Step:** The `release` job should use `vsce publish` with a personal access token (stored as a GitHub secret) to upload the extension. | `.github/workflows/ci.yml` |
| **7.7** | ☐ To Do | **Test the Release:** Manually trigger the release workflow for a `v1.0.0` tag and verify that the extension appears on the VS Code Marketplace. | `(External)` |

This completes the full set of PRDs and task lists for the Code Context Engine project. You now have a comprehensive, phased plan to guide you from the initial boilerplate to a published and feature-rich VS Code extension.

Of course. Here is a comprehensive guide to implementing Sprint 2: "AST Parser & Code Chunking" for your VS Code extension. This guide includes analysis, code examples, and API information based on the PRD and my research.

### **Analysis of `repomix-roocode.xml`**

The provided `repomix-roocode.xml` file confirms that the project is a standard SvelteKit application using TypeScript and Vitest for testing. The presence of `setup.ts` with JSDOM mocks indicates a robust testing environment. The project structure appears to be conventional, which makes integrating the new services straightforward. The key takeaway is that the new backend services should be written in TypeScript and can be unit-tested using the existing Vitest setup.

-----

### **Prerequisites and Setup**

Before you start coding, you'll need to add a few dependencies to your project for file parsing and AST manipulation.

**1. Install `tree-sitter` and Language Grammars:**

`tree-sitter` is a powerful parser generator tool. You'll need the core library and the specific grammar for each language you want to support.

```bash
npm install tree-sitter tree-sitter-typescript tree-sitter-python tree-sitter-c-sharp
```

**2. Install Helper Libraries:**

You'll also need a library to handle `.gitignore` files and another for efficient file system traversal.

```bash
npm install glob ignore
```

-----

### **Implementation Guide**

Here's a step-by-step guide to building the services outlined in `tasklist_sprint_02.md`.

#### **1. The `FileWalker` Service**

This service is responsible for finding all the files in the workspace that need to be indexed, while respecting the rules in `.gitignore`.

**API Information:**

  * **`vscode.workspace.fs`:** The official VS Code API for reading files and directories. It's asynchronous and designed to work with virtual file systems.
  * **`glob` package:** A library for matching files using patterns.
  * **`ignore` package:** A high-performance library for parsing `.gitignore` files.

**Code Example (`src/indexing/fileWalker.ts`):**

```typescript
import * as vscode from 'vscode';
import { glob } from 'glob';
import { promises as fs } from 'fs';
import path from 'path';
import ignore from 'ignore';

export class FileWalker {
    private ig = ignore();

    constructor(private workspaceRoot: string) {}

    private async loadGitignore(): Promise<void> {
        try {
            const gitignorePath = path.join(this.workspaceRoot, '.gitignore');
            const gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');
            this.ig.add(gitignoreContent);
        } catch (error) {
            console.log("No .gitignore file found or could not be read.");
        }
    }

    public async findAllFiles(): Promise<string[]> {
        await this.loadGitignore();
        const files = await glob('**/*.{ts,js,py,cs}', {
            cwd: this.workspaceRoot,
            nodir: true,
            absolute: true,
        });

        return files.filter(file => !this.ig.ignores(path.relative(this.workspaceRoot, file)));
    }
}
```

#### **2. The `AstParser` Service**

This service takes a file and its content, and using `tree-sitter`, parses it into an Abstract Syntax Tree (AST).

**API Information:**

  * **`tree-sitter` package:** The core library for parsing.
  * **Language-specific `tree-sitter` packages:** (e.g., `tree-sitter-typescript`) provide the grammars.

**Code Example (`src/parsing/astParser.ts`):**

```typescript
import Parser from 'tree-sitter';
import TypeScript from 'tree-sitter-typescript';
import Python from 'tree-sitter-python';
import CSharp from 'tree-sitter-c-sharp';

export class AstParser {
    private parser = new Parser();

    public parse(language: 'typescript' | 'python' | 'csharp', code: string): Parser.Tree {
        switch (language) {
            case 'typescript':
                this.parser.setLanguage(TypeScript.typescript);
                break;
            case 'python':
                this.parser.setLanguage(Python);
                break;
            case 'csharp':
                this.parser.setLanguage(CSharp);
                break;
        }
        return this.parser.parse(code);
    }
}
```

#### **3. The `Chunker` Service**

This service takes an AST and chunks the code into meaningful segments (e.g., functions, classes).

**API Information:**

  * **`tree-sitter` `Query` API:** This allows you to find specific nodes in the AST using a LISP-like query language.

**Code Example (`src/parsing/chunker.ts`):**

```typescript
import Parser from 'tree-sitter';

export interface CodeChunk {
    filePath: string;
    content: string;
    startLine: number;
    endLine: number;
    type: string;
}

export class Chunker {
    public chunk(filePath: string, tree: Parser.Tree, code: string): CodeChunk[] {
        const query = new Parser.Query(tree.getLanguage(), `
            (function_declaration) @function
            (class_declaration) @class
            (method_declaration) @method
        `);

        const matches = query.matches(tree.rootNode);
        const chunks: CodeChunk[] = [];

        for (const match of matches) {
            for (const capture of match.captures) {
                const node = capture.node;
                chunks.push({
                    filePath,
                    content: node.text,
                    startLine: node.startPosition.row,
                    endLine: node.endPosition.row,
                    type: capture.name,
                });
            }
        }
        return chunks;
    }
}
```

#### **4. The `IndexingService` (Orchestrator)**

This service brings everything together. It uses the `FileWalker` to get the files, the `AstParser` to parse them, and the `Chunker` to create the final code chunks.

**API Information:**

  * **`vscode.window.withProgress`:** A VS Code API for showing progress notifications to the user.

**Code Example (`src/indexing/indexingService.ts`):**

```typescript
import * as vscode from 'vscode';
import { FileWalker } from './fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker, CodeChunk } from '../parsing/chunker';

export class IndexingService {
    private fileWalker: FileWalker;
    private astParser = new AstParser();
    private chunker = new Chunker();

    constructor(private workspaceRoot: string) {
        this.fileWalker = new FileWalker(workspaceRoot);
    }

    public async startIndexing(): Promise<CodeChunk[]> {
        return vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Indexing Repository",
            cancellable: true
        }, async (progress, token) => {
            if (token.isCancellationRequested) {
                return [];
            }

            progress.report({ message: "Discovering files..." });
            const files = await this.fileWalker.findAllFiles();
            const totalFiles = files.length;
            let indexedFiles = 0;
            const allChunks: CodeChunk[] = [];

            for (const file of files) {
                if (token.isCancellationRequested) {
                    break;
                }

                indexedFiles++;
                progress.report({
                    message: `Parsing ${file}`,
                    increment: (1 / totalFiles) * 100
                });

                const content = await vscode.workspace.fs.readFile(vscode.Uri.file(file)).then(buffer => buffer.toString());
                const language = this.getLanguage(file);
                if (language) {
                    const tree = this.astParser.parse(language, content);
                    const chunks = this.chunker.chunk(file, tree, content);
                    allChunks.push(...chunks);
                }
            }

            return allChunks;
        });
    }

    private getLanguage(filePath: string): 'typescript' | 'python' | 'csharp' | null {
        if (filePath.endsWith('.ts') || filePath.endsWith('.js')) {
            return 'typescript';
        }
        if (filePath.endsWith('.py')) {
            return 'python';
        }
        if (filePath.endsWith('.cs')) {
            return 'csharp';
        }
        return null;
    }
}
```

### **Putting It All Together**

You would trigger the `IndexingService` from your main `extension.ts` file, likely when the user clicks the "Index Now" button you created in Sprint 1.

**Code Example (`src/extension.ts`):**

```typescript
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';

export function activate(context: vscode.ExtensionContext) {
    // ... other activation code

    let disposable = vscode.commands.registerCommand('your-extension.startIndexing', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            const workspaceRoot = workspaceFolders[0].uri.fsPath;
            const indexingService = new IndexingService(workspaceRoot);
            const chunks = await indexingService.startIndexing();
            console.log(`Indexing complete. Found ${chunks.length} chunks.`);
            // Here you would proceed to Sprint 3: Vectorization & DB Integration
        } else {
            vscode.window.showErrorMessage("Please open a folder or workspace to index.");
        }
    });

    context.subscriptions.push(disposable);
}
```

This guide provides the core implementation for Sprint 2. You now have a robust system for walking the file tree, parsing code with `tree-sitter`, and chunking it into meaningful segments. The next step will be to take these chunks and vectorize them for storage in Qdrant, as outlined in Sprint 3.

Of course. Here is the implementation guide for Sprint 3, which focuses on vectorizing the code chunks and storing them in the Qdrant database.

### **Analysis of `repomix-roocode.xml`**

The `repomix-roocode.xml` file shows a standard SvelteKit project setup. The key takeaway is that the project is well-structured, uses TypeScript, and has a testing framework in place. This means that the new services for vectorization and database interaction can be seamlessly integrated and tested within the existing architecture. The presence of a `setup.ts` file for tests also indicates that we can easily mock external services like Ollama, OpenAI, and the Qdrant client for robust unit testing.

-----

### **Prerequisites and Setup**

Before you begin, you need to set up the necessary tools and dependencies for this sprint.

**1. Install Docker:**

If you don't already have it, install **Docker Desktop** on your development machine. This is required to run the Qdrant vector database locally.

**2. Install Dependencies:**

You'll need the official Qdrant client and a library for making HTTP requests to Ollama or other embedding providers.

```bash
npm install @qdrant/js-client-rest axios
```

**3. Set up a `.env` file (Optional but Recommended):**

Create a `.env` file in the root of your project to store API keys and other secrets. Make sure to add `.env` to your `.gitignore` file.

```
OPENAI_API_KEY="your-openai-api-key"
```

-----

### **Implementation Guide**

Here's a step-by-step guide to building the services outlined in `tasklist_sprint_03.md`.

#### **1. Docker Compose for Qdrant**

Create a `docker-compose.yml` file in the root of your project. This will allow you to easily start and stop the Qdrant database.

**Code Example (`docker-compose.yml`):**

```yaml
version: '3.8'
services:
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - ./qdrant_storage:/qdrant/storage
```

You can now start Qdrant by running `docker-compose up` in your terminal.

#### **2. The `QdrantService`**

This service will handle all communication with the Qdrant database, including creating collections and upserting data.

**API Information:**

  * **`@qdrant/js-client-rest` package:** The official JavaScript/TypeScript client for Qdrant.
  * **Key methods:**
      * `QdrantClient`: The main class for interacting with the Qdrant API.
      * `client.getCollections()`: Lists all available collections.
      * `client.createCollection()`: Creates a new collection with a specified schema.
      * `client.upsert()`: Inserts or updates points (vectors and their payloads) in a collection.

**Code Example (`src/db/qdrantService.ts`):**

```typescript
import { QdrantClient } from '@qdrant/js-client-rest';
import type { CodeChunk } from '../parsing/chunker';

export class QdrantService {
    private client = new QdrantClient({ url: 'http://localhost:6333' });

    public async createCollectionIfNotExists(collectionName: string): Promise<void> {
        const collections = await this.client.getCollections();
        if (!collections.collections.find(c => c.name === collectionName)) {
            await this.client.createCollection(collectionName, {
                vectors: { size: 768, distance: 'Cosine' }, // Adjust size based on your embedding model
            });
        }
    }

    public async upsertChunks(collectionName: string, chunks: CodeChunk[], vectors: number[][]): Promise<void> {
        const points = chunks.map((chunk, i) => ({
            id: `${chunk.filePath}:${chunk.startLine}-${chunk.endLine}`,
            vector: vectors[i],
            payload: {
                filePath: chunk.filePath,
                content: chunk.content,
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                type: chunk.type,
            },
        }));

        await this.client.upsert(collectionName, {
            wait: true,
            points,
        });
    }
}
```

#### **3. The Embedding Provider Interface and Implementations**

To keep the code clean and extensible, you'll create an interface for embedding providers and then implement it for Ollama and OpenAI.

**Code Example (`src/embeddings/embeddingProvider.ts`):**

```typescript
export interface IEmbeddingProvider {
    generateEmbeddings(chunks: string[]): Promise<number[][]>;
}
```

**Code Example (`src/embeddings/ollamaProvider.ts`):**

```typescript
import axios from 'axios';
import { IEmbeddingProvider } from './embeddingProvider';

export class OllamaProvider implements IEmbeddingProvider {
    public async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        const embeddings: number[][] = [];
        for (const chunk of chunks) {
            const response = await axios.post('http://localhost:11434/api/embeddings', {
                model: 'nomic-embed-text', // Or your preferred model
                prompt: chunk,
            });
            embeddings.push(response.data.embedding);
        }
        return embeddings;
    }
}
```

**Code Example (`src/embeddings/openaiProvider.ts`):**

```typescript
import axios from 'axios';
import { IEmbeddingProvider } from './embeddingProvider';
import * as vscode from 'vscode';


export class OpenAIProvider implements IEmbeddingProvider {
    private apiKey: string | undefined;

    constructor() {
        this.apiKey = vscode.workspace.getConfiguration('your-extension').get('openaiApiKey');
    }

    public async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        if (!this.apiKey) {
            vscode.window.showErrorMessage("OpenAI API key not found. Please set it in the extension settings.");
            return [];
        }

        const response = await axios.post('https://api.openai.com/v1/embeddings', {
            model: 'text-embedding-ada-002',
            input: chunks,
        }, {
            headers: {
                'Authorization': `Bearer ${this.apiKey}`,
            },
        });

        return response.data.data.map((item: any) => item.embedding);
    }
}
```

#### **4. Updating the `IndexingService`**

Finally, you'll update the `IndexingService` to use the new `QdrantService` and an embedding provider to complete the indexing process.

**Code Example (`src/indexing/indexingService.ts`):**

```typescript
import * as vscode from 'vscode';
import { FileWalker } from './fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker, CodeChunk } from '../parsing/chunker';
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { OllamaProvider } from '../embeddings/ollamaProvider'; // Default provider

export class IndexingService {
    private fileWalker: FileWalker;
    private astParser = new AstParser();
    private chunker = new Chunker();
    private qdrantService = new QdrantService();
    private embeddingProvider: IEmbeddingProvider;

    constructor(private workspaceRoot: string) {
        this.fileWalker = new FileWalker(workspaceRoot);
        // This will be updated in a later sprint to be configurable
        this.embeddingProvider = new OllamaProvider();
    }

    public async startIndexing(): Promise<void> {
        return vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Indexing Repository",
            cancellable: true
        }, async (progress, token) => {
            // ... (file walking, parsing, and chunking logic from Sprint 2)

            const allChunks: CodeChunk[] = []; // Assume this is populated

            progress.report({ message: "Generating embeddings..." });
            const contents = allChunks.map(chunk => chunk.content);
            const vectors = await this.embeddingProvider.generateEmbeddings(contents);

            progress.report({ message: "Storing in vector database..." });
            const collectionName = path.basename(this.workspaceRoot);
            await this.qdrantService.createCollectionIfNotExists(collectionName);
            await this.qdrantService.upsertChunks(collectionName, allChunks, vectors);

            vscode.window.showInformationMessage("Indexing complete!");
        });
    }

    // ... (getLanguage method from Sprint 2)
}
```

This completes the implementation guide for Sprint 3. You now have a complete pipeline for finding, parsing, chunking, vectorizing, and storing your code. The next logical step is to build the API and UI to actually *use* this indexed data, as outlined in the subsequent PRDs.
</prd>


[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/setup/tasklist_sprint_01.md">
# Task List: Sprint 1 - Boilerplate & UI Scaffolding

**Goal:** To establish the project's foundation by setting up the VS Code extension with a SvelteKit frontend and Fluent UI.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** | ☐ To Do | **Generate VS Code Extension:** Run `npx yo code` in your project's root directory. When prompted, select "New Extension (TypeScript)", provide a suitable name (e.g., "Code Context Engine"), and accept default configurations for linting and Git initialization. | `(Project Root)` |
| **1.2** | ☐ To Do | **Initialize SvelteKit Project:** Navigate into the newly created `webview` directory (e.g., `cd webview`). Run `npm create svelte@latest .` and select "Skeleton project", "TypeScript", "ESLint", "Prettier", and "Vitest" when prompted. | `webview/` |
| **1.3** | ☐ To Do | **Install SvelteKit Dependencies:** After initializing SvelteKit, run `npm install` inside the `webview` directory to install its dependencies. | `webview/package.json` |
| **1.4** | ☐ To Do | **Install Fluent UI Dependencies:** While still in the `webview` directory, install the Fluent UI web components: `npm install @fluentui/web-components`. | `webview/package.json` |
| **1.5** | ☐ To Do | **Create Webview Panel Logic:** Open `src/extension.ts`. Add TypeScript code within the `activate` function to create and manage a `WebviewPanel` that will host the SvelteKit application. This involves using `vscode.window.createWebviewPanel` and setting `enableScripts: true`. | `src/extension.ts` |
| **1.6** | ☐ To Do | **Load Svelte App in Webview:** In `src/extension.ts`, configure the webview to load the compiled `index.html` from the SvelteKit `dist` directory. Ensure you use `vscode.Uri.file` and `path.join` to construct the correct absolute path, and handle relative paths for SvelteKit assets (e.g., `/_app/`) by converting them to `webview.asWebviewUri`. | `src/extension.ts` |
| **1.7** | ☐ To Do | **Build SvelteKit App:** Navigate to the `webview` directory (`cd webview`) and run `npm run build` to compile the SvelteKit application into the `dist` folder. This step must be completed before the extension can load the webview. | `webview/` |
| **1.8** | ☐ To Do | **Build Main UI Component:** Create a new Svelte component (e.g., `webview/src/routes/+page.svelte` or `webview/src/lib/MainPanel.svelte`). Implement a basic UI displaying a `<fluent-button>` with the text "Index Now" and a `<fluent-progress-ring>` from the Fluent UI library. Register the Fluent UI components using `provideFluentDesignSystem().register()`. | `webview/src/routes/+page.svelte` or `webview/src/lib/MainPanel.svelte` |
| **1.9** | ☐ To Do | **Implement Theme Handling:** In `webview/src/app.css` (or within your Svelte component's `<style>` tags), use VS Code theme CSS variables (e.g., `--vscode-editor-background`, `--vscode-button-background`) to ensure Fluent UI components automatically adapt to light/dark modes. Apply these to the `body` and relevant Fluent UI custom properties. | `webview/src/app.css` or `webview/src/routes/+page.svelte` |
| **1.10** | ☐ To Do | **Test Extension:** Press `F5` in VS Code to run the extension in a development host. Execute the command to open your extension's UI panel. Verify that the SvelteKit app loads correctly, the "Index Now" button and progress bar are visible, and the UI adapts to theme changes. | `(Launch Configuration)` |
</file>

<file path="docs/todo/setup/tasklist_sprint_02.md">
# Task List: Sprint 2 - AST Parser & Code Chunking

**Goal:** To implement the core logic for parsing code into Abstract Syntax Trees (ASTs) and chunking them into meaningful segments.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** | ☐ To Do | **Install Tree-sitter and Language Grammars:** In your project's root directory, run `npm install tree-sitter tree-sitter-typescript tree-sitter-python tree-sitter-c-sharp` to install the core parser and necessary language grammars. | `package.json` |
| **2.2** | ☐ To Do | **Install File System Helper Libraries:** In your project's root directory, run `npm install glob ignore` to install libraries for file matching and `.gitignore` parsing. | `package.json` |
| **2.3** | ☐ To Do | **Create `FileWalker` Service File:** Create a new TypeScript file at `src/indexing/fileWalker.ts`. | `src/indexing/fileWalker.ts` |
| **2.4** | ☐ To Do | **Implement `FileWalker` Constructor:** In `src/indexing/fileWalker.ts`, add a constructor that takes `workspaceRoot: string` and initializes an `ignore` instance. | `src/indexing/fileWalker.ts` |
| **2.5** | ☐ To Do | **Implement `FileWalker.loadGitignore` Method:** In `src/indexing/fileWalker.ts`, add an asynchronous private method `loadGitignore` that reads the `.gitignore` file from `workspaceRoot` and adds its patterns to the `ignore` instance. Handle cases where `.gitignore` is not found. | `src/indexing/fileWalker.ts` |
| **2.6** | ☐ To Do | **Implement `FileWalker.findAllFiles` Method:** In `src/indexing/fileWalker.ts`, add an asynchronous public method `findAllFiles` that first calls `loadGitignore`, then uses `glob` to find all relevant code files (e.g., `**/*.{ts,js,py,cs}`), and finally filters them using the `ignore` instance. | `src/indexing/fileWalker.ts` |
| **2.7** | ☐ To Do | **Create `AstParser` Service File:** Create a new TypeScript file at `src/parsing/astParser.ts`. | `src/parsing/astParser.ts` |
| **2.8** | ☐ To Do | **Implement `AstParser` Constructor:** In `src/parsing/astParser.ts`, add a constructor that initializes a `tree-sitter` `Parser` instance. | `src/parsing/astParser.ts` |
| **2.9** | ☐ To Do | **Implement `AstParser.parse` Method:** In `src/parsing/astParser.ts`, add a public method `parse` that takes `language: 'typescript' | 'python' | 'csharp'` and `code: string`. Use a `switch` statement to set the correct `tree-sitter` language grammar and then parse the provided `code` into an AST, returning the `Parser.Tree`. | `src/parsing/astParser.ts` |
| **2.10** | ☐ To Do | **Create `Chunker` Service File:** Create a new TypeScript file at `src/parsing/chunker.ts`. Define the `CodeChunk` interface within this file, including `filePath`, `content`, `startLine`, `endLine`, and `type`. | `src/parsing/chunker.ts` |
| **2.11** | ☐ To Do | **Implement `Chunker.chunk` Method:** In `src/parsing/chunker.ts`, add a public method `chunk` that takes `filePath: string`, `tree: Parser.Tree`, and `code: string`. Use `tree-sitter`'s `Query` API to find specific nodes (e.g., function declarations, class declarations) in the AST. Iterate through matches and create `CodeChunk` objects, populating their properties from the AST nodes. | `src/parsing/chunker.ts` |
| **2.12** | ☐ To Do | **Update `IndexingService` File:** Open `src/indexing/indexingService.ts`. If it doesn't exist, create it. This file will orchestrate the `FileWalker`, `AstParser`, and `Chunker`. | `src/indexing/indexingService.ts` |
| **2.13** | ☐ To Do | **Implement `IndexingService` Constructor:** In `src/indexing/indexingService.ts`, add a constructor that takes `workspaceRoot: string` and initializes instances of `FileWalker`, `AstParser`, and `Chunker`. | `src/indexing/indexingService.ts` |
| **2.14** | ☐ To Do | **Implement `IndexingService.startIndexing` Method:** In `src/indexing/indexingService.ts`, add an asynchronous public method `startIndexing`. This method should use `vscode.window.withProgress` to show a progress notification. Inside, call `fileWalker.findAllFiles()`. For each file, read its content using `vscode.workspace.fs.readFile`, determine its language, parse it with `astParser.parse()`, and then chunk it with `chunker.chunk()`. Collect all generated `CodeChunk` objects. | `src/indexing/indexingService.ts` |
| **2.15** | ☐ To Do | **Implement `IndexingService.getLanguage` Method:** In `src/indexing/indexingService.ts`, add a private helper method `getLanguage` that takes a `filePath` and returns the corresponding language (e.g., 'typescript', 'python', 'csharp') or `null` based on the file extension. | `src/indexing/indexingService.ts` |
| **2.16** | ☐ To Do | **Integrate `IndexingService` into `extension.ts`:** In `src/extension.ts`, modify the `activate` function to instantiate `IndexingService` and call `startIndexing` when a specific command (e.g., "Index Now") is executed. Ensure proper error handling and user feedback (e.g., `vscode.window.showInformationMessage`). | `src/extension.ts` |
</file>

<file path="docs/todo/setup/tasklist_sprint_03.md">
# Task List: Sprint 3 - Vectorization & DB Integration

**Goal:** To vectorize the code chunks and store them in the Qdrant database.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** | ☐ To Do | **Install Qdrant Client and Axios:** In your project's root directory, run `npm install @qdrant/js-client-rest axios` to install the Qdrant JavaScript client and an HTTP client for embedding providers. | `package.json` |
| **3.2** | ☐ To Do | **Create Docker Compose File for Qdrant:** In your project's root directory, create a new file named `docker-compose.yml`. | `docker-compose.yml` |
| **3.3** | ☐ To Do | **Add Qdrant Service Definition to Docker Compose:** In `docker-compose.yml`, define the Qdrant service, specifying the `qdrant/qdrant:latest` image, port mappings (`6333:6333`, `6334:6334`), and a volume for persistent storage (`./qdrant_storage:/qdrant/storage`). | `docker-compose.yml` |
| **3.4** | ☐ To Do | **Start Qdrant Container:** From your project's root directory, run `docker-compose up -d` to start the Qdrant database in the background. | `(Terminal Command)` |
| **3.5** | ☐ To Do | **Create `QdrantService` File:** Create a new TypeScript file at `src/db/qdrantService.ts`. | `src/db/qdrantService.ts` |
| **3.6** | ☐ To Do | **Implement `QdrantService` Constructor:** In `src/db/qdrantService.ts`, add a constructor that initializes a `QdrantClient` instance, connecting to the local Qdrant instance (e.g., `http://localhost:6333`). | `src/db/qdrantService.ts` |
| **3.7** | ☐ To Do | **Implement `QdrantService.createCollectionIfNotExists` Method:** In `src/db/qdrantService.ts`, add an asynchronous public method `createCollectionIfNotExists` that takes `collectionName: string`. This method should check if the collection already exists using `client.getCollections()` and, if not, create it using `client.createCollection()` with appropriate vector size and distance (e.g., `size: 768, distance: 'Cosine'`). | `src/db/qdrantService.ts` |
| **3.8** | ☐ To Do | **Implement `QdrantService.upsertChunks` Method:** In `src/db/qdrantService.ts`, add an asynchronous public method `upsertChunks` that takes `collectionName: string`, `chunks: CodeChunk[]`, and `vectors: number[][]`. This method should map `CodeChunk` and `vector` data into `PointStruct` objects and then use `client.upsert()` to insert or update them in the specified collection. | `src/db/qdrantService.ts` |
| **3.9** | ☐ To Do | **Create `IEmbeddingProvider` Interface File:** Create a new TypeScript file at `src/embeddings/embeddingProvider.ts`. Define the `IEmbeddingProvider` interface with a `generateEmbeddings(chunks: string[]): Promise<number[][]>` method. | `src/embeddings/embeddingProvider.ts` |
| **3.10** | ☐ To Do | **Create `OllamaProvider` File:** Create a new TypeScript file at `src/embeddings/ollamaProvider.ts`. | `src/embeddings/ollamaProvider.ts` |
| **3.11** | ☐ To Do | **Implement `OllamaProvider`:** In `src/embeddings/ollamaProvider.ts`, implement the `IEmbeddingProvider` interface. The `generateEmbeddings` method should make HTTP POST requests to the local Ollama API (`http://localhost:11434/api/embeddings`) for each chunk, using a specified model (e.g., `nomic-embed-text`), and return the generated embeddings. | `src/embeddings/ollamaProvider.ts` |
| **3.12** | ☐ To Do | **Create `OpenAIProvider` File:** Create a new TypeScript file at `src/embeddings/openaiProvider.ts`. | `src/embeddings/openaiProvider.ts` |
| **3.13** | ☐ To Do | **Implement `OpenAIProvider`:** In `src/embeddings/openaiProvider.ts`, implement the `IEmbeddingProvider` interface. The `generateEmbeddings` method should make HTTP POST requests to the OpenAI embeddings API (`https://api.openai.com/v1/embeddings`), using a specified model (e.g., `text-embedding-ada-002`), and include the API key from VS Code settings in the authorization header. Handle cases where the API key is missing. | `src/embeddings/openaiProvider.ts` |
| **3.14** | ☐ To Do | **Update `IndexingService` to Use Embedding Provider and Qdrant:** Open `src/indexing/indexingService.ts`. Modify the `IndexingService` to include instances of `QdrantService` and `IEmbeddingProvider`. | `src/indexing/indexingService.ts` |
| **3.15** | ☐ To Do | **Modify `IndexingService.startIndexing` Method:** In `src/indexing/indexingService.ts`, after chunking is complete, add steps to: 1) Extract content from all chunks, 2) Call `embeddingProvider.generateEmbeddings()` to get vectors, 3) Determine a collection name (e.g., based on workspace root), 4) Call `qdrantService.createCollectionIfNotExists()`, and 5) Call `qdrantService.upsertChunks()` to store the chunks and vectors in Qdrant. | `src/indexing/indexingService.ts` |
| **3.16** | ☐ To Do | **Add Progress Reporting for Embedding and Storage:** In `IndexingService.startIndexing`, update `vscode.window.withProgress` to report progress messages for "Generating embeddings..." and "Storing in vector database...". | `src/indexing/indexingService.ts` |
| **3.17** | ☐ To Do | **Add Completion Message:** In `IndexingService.startIndexing`, after successful storage, display a completion message using `vscode.window.showInformationMessage("Indexing complete!")`. | `src/indexing/indexingService.Service` |
</file>

<file path="docs/todo/setup/tasklist_sprint_04.md">
# Task List: Sprint 4 - Context Query API

**Goal:** To build and expose the internal API for querying the indexed code context.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** | ☐ To Do | **Create `ContextService`:** In the backend, create a new `contextService.ts` file at `src/context/contextService.ts` to house the query logic. | `src/context/contextService.ts` |
| **4.2** | ☐ To Do | **Implement `getFileContent` method:** In `src/context/contextService.ts`, add logic to perform a vector search for the file path (using embedding provider and Qdrant) and then read the content from disk using `vscode.workspace.fs.readFile`. | `src/context/contextService.ts` |
| **4.3** | ☐ To Do | **Implement `findRelatedFiles` method:** In `src/context/contextService.ts`, add logic to perform a similarity search in Qdrant (using embedding provider) and return a list of unique file paths from the results. | `src/context/contextService.ts` |
| **4.4** | ☐ To Do | **Set up Webview Message Handling:** In `src/extension.ts`, add a `panel.webview.onDidReceiveMessage` listener to the webview panel to handle incoming requests from the frontend. | `src/extension.ts` |
| **4.5** | ☐ To Do | **Route API Calls:** In the message handler within `src/extension.ts`, create a `switch` statement to route requests (e.g., `'getFileContent'`, `'findRelatedFiles'`) to the appropriate method in `ContextService`. | `src/extension.ts` |
| **4.6** | ☐ To Do | **Send Results to Frontend:** In `src/extension.ts`, use the `webview.postMessage` method to send the results from the `ContextService` back to the SvelteKit UI. | `src/extension.ts` |
| **4.7** | ☐ To Do | **Create Frontend API Client:** In the SvelteKit app, create a wrapper service (`webview/src/lib/vscodeApi.ts`) that simplifies posting and listening for messages from the extension backend using `acquireVsCodeApi()`. | `webview/src/lib/vscodeApi.ts` |
| **4.8** | ☐ To Do | **Integrate Frontend with API Client:** In your Svelte components (e.g., `webview/src/routes/+page.svelte`), use the `vscodeApi.ts` client to send requests (e.g., for file content or related files) and handle the responses received from the extension backend. | `webview/src/routes/+page.svelte` |
</file>

<file path="docs/todo/setup/tasklist_sprint_05.md">
# Task List: Sprint 5 - Settings UI & Configuration

**Goal:** To build the settings UI and connect it to the VS Code configuration system.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** | ☐ To Do | **Define Configuration Schema:** In `package.json`, under the `contributes.configuration` section, define the properties for the settings (e.g., `code-context.embeddingProvider`, `code-context.databaseConnectionString`), including their types, defaults, and descriptions. | `package.json` |
| **5.2** | ☐ To Do | **Register `openSettings` command:** In `package.json`, add a new command to the `contributes.commands` section (e.g., `code-context-engine.openSettings`) that will be used to open the settings UI. | `package.json` |
| **5.3** | ☐ To Do | **Implement command in `extension.ts`:** In `src/extension.ts`, register the `openSettings` command. The command handler should create and show a new `WebviewPanel` specifically for the settings UI, loading the SvelteKit app into it. | `src/extension.ts` |
| **5.4** | ☐ To Do | **Create `Settings.svelte` component:** Create a new Svelte component (e.g., `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte`). Build the UI using Fluent UI components like `<fluent-select>` for embedding providers and `<fluent-text-field>` for the database URI. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.5** | ☐ To Do | **Load Initial Settings:** In the `Settings.svelte` component, use the `onMount` lifecycle hook to send a message to the extension backend (via `vscodeApi.ts`) requesting the current configuration values. Listen for the response and populate the UI fields with the loaded settings. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.6** | ☐ To Do | **Implement `getSettings` handler in `extension.ts`:** In `src/extension.ts`, add a message handler for the `getSettings` command. This handler should read the current configuration values from `vscode.workspace.getConfiguration('code-context-engine')` and send them back to the webview. | `src/extension.ts` |
| **5.7** | ☐ To Do | **Save Settings from UI:** In the `Settings.svelte` component, add a button (e.g., "Save Settings"). On click, gather the current values from the UI fields and send them as a message (e.g., `saveSettings`) to the extension backend. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.8** | ☐ To Do | **Implement `saveConfiguration` handler in `extension.ts`:** In `src/extension.ts`, add a message handler for the `saveSettings` command. This handler should receive the updated settings from the webview and use `vscode.workspace.getConfiguration().update()` to persist them to the VS Code configuration (e.g., `vscode.ConfigurationTarget.Global`). | `src/extension.ts` |
| **5.9** | ☐ To Do | **Refactor Services to Use Config:** Update `src/indexing/indexingService.ts` and `src/db/qdrantService.ts` (and any other relevant services) to read their configuration (e.g., embedding provider, database connection string) from `vscode.workspace.getConfiguration('code-context-engine')` instead of hardcoded values. | `src/indexing/indexingService.ts`, `src/db/qdrantService.ts` |
</file>

<file path="docs/todo/setup/tasklist_sprint_06.md">
# Task List: Sprint 6 - LSP Integration & DevOps

**Goal:** To enrich the index with LSP data and automate the build and test process.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** | ☐ To Do | **Research LSP Interaction:** Investigate how to programmatically interact with a language server using the `vscode.commands.executeCommand` API for LSP-related commands (e.g., `vscode.executeDefinitionProvider`, `vscode.executeReferenceProvider`). Understand the expected input parameters (URI, Position) and output formats. | `(Documentation)` |
| **6.2** | ☐ To Do | **Update `IndexingService` for LSP:** In `src/indexing/indexingService.ts`, modify the `startIndexing` method (or create a helper method like `processChunkWithLSP`). For each code chunk, call the relevant `vscode.commands.executeCommand` for LSP data (definitions, references) using the chunk's file URI and start position. | `src/indexing/indexingService.ts` |
| **6.3** | ☐ To Do | **Process LSP Results:** Within `IndexingService`, parse the results from the LSP commands. Extract relevant information (e.g., target URIs, ranges, symbol names) and structure it into a suitable format to be stored as metadata. | `src/indexing/indexingService.ts` |
| **6.4** | ☐ To Do | **Extend `CodeChunk` Interface:** If not already done, update the `CodeChunk` interface (e.g., in `src/parsing/chunker.ts`) to include new properties for LSP-derived metadata (e.g., `lspDefinitions`, `lspReferences`). | `src/parsing/chunker.ts` |
| **6.5** | ☐ To Do | **Extend Qdrant Metadata:** In `src/db/qdrantService.ts`, modify the `upsertChunks` method. Ensure that the `payload` object sent to Qdrant includes the newly added LSP metadata from the `CodeChunk` objects. | `src/db/qdrantService.ts` |
| **6.6** | ☐ To Do | **Create GitHub Actions Workflow File:** In your project's root directory, create a new directory `.github/workflows/` if it doesn't exist. Inside this directory, create a new YAML file named `ci.yml`. | `.github/workflows/ci.yml` |
| **6.7** | ☐ To Do | **Configure Workflow Triggers:** In `.github/workflows/ci.yml`, set the `on` section to trigger the workflow on `push` events to the `main` branch and on `pull_request` events targeting the `main` branch. | `.github/workflows/ci.yml` |
| **6.8** | ☐ To Do | **Define Build Job:** In `.github/workflows/ci.yml`, define a `build` job that runs on `ubuntu-latest`. | `.github/workflows/ci.yml` |
| **6.9** | ☐ To Do | **Add Checkout Step:** In the `build` job, add a step to `uses: actions/checkout@v3` to check out the repository code. | `.github/workflows/ci.yml` |
| **6.10** | ☐ To Do | **Add Node.js Setup Step:** In the `build` job, add a step to `uses: actions/setup-node@v3` to set up the Node.js environment (specify your project's Node.js version, e.g., `node-version: '18'`). | `.github/workflows/ci.yml` |
| **6.11** | ☐ To Do | **Add Install Dependencies Step:** In the `build` job, add a step to run `npm install` to install all project dependencies. | `.github/workflows/ci.yml` |
| **6.12** | ☐ To Do | **Add Linting Step:** In the `build` job, add a step to run your project's linting command (e.g., `npm run lint`). | `.github/workflows/ci.yml` |
| **6.13** | ☐ To Do | **Add Testing Step:** In the `build` job, add a step to run your project's test command (e.g., `npm test`). | `.github/workflows/ci.yml` |
| **6.14** | ☐ To Do | **Add Build Extension Step:** In the `build` job, add a step to run the command that builds your VS Code extension package (e.g., `npm run vscode:prepublish` or `vsce package`). | `.github/workflows/ci.yml` |
| **6.15** | ☐ To Do | **Add Upload Artifact Step:** In the `build` job, add a step to `uses: actions/upload-artifact@v3` to upload the generated `.vsix` file as a build artifact (e.g., `name: vsix-package`, `path: '*.vsix'`). | `.github/workflows/ci.yml` |
</file>

<file path="docs/todo/setup/tasklist_sprint_07.md">
# Task List: Sprint 7 - Documentation & Publishing

**Goal:** To create high-quality documentation and publish the extension to the marketplace.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **7.1** | ☐ To Do | **Write `README.md` Content:** Open `README.md` in the project root. Draft the main sections: Features, Requirements, Installation, Configuration, and Usage. Ensure clear and concise language. | `README.md` |
| **7.2** | ☐ To Do | **Create Demo GIF:** Use screen recording software to capture the core indexing and querying workflow of the extension. Optimize the recording and convert it into an animated GIF (e.g., `assets/demo.gif`). | `assets/demo.gif` |
| **7.3** | ☐ To Do | **Embed GIF in `README.md`:** In `README.md`, add markdown syntax to display the `demo.gif` at an appropriate location (e.g., `![Demo GIF](assets/demo.gif)`). | `README.md` |
| **7.4** | ☐ To Do | **Write `CONTRIBUTING.md`:** Create a new file named `CONTRIBUTING.md` in the project root. Write a guide for developers on how to set up the project, run tests, adhere to code style, and submit pull requests. | `CONTRIBUTING.md` |
| **7.5** | ☐ To Do | **Create Marketplace Publisher:** Follow the official VS Code documentation to create a publisher identity on the Visual Studio Code Marketplace. This involves setting up an Azure DevOps organization and generating a Personal Access Token (PAT) with `Marketplace (Publish)` scope. | `(External - VS Code Marketplace)` |
| **7.6** | ☐ To Do | **Add `VSCE_TOKEN` as GitHub Secret:** In your GitHub repository settings, navigate to `Settings` -> `Secrets and variables` -> `Actions`. Add a new repository secret named `VSCE_TOKEN` and paste the PAT generated in the previous step as its value. | `(GitHub Repository Settings)` |
| **7.7** | ☐ To Do | **Add Manual Release Trigger to CI Workflow:** Open `.github/workflows/ci.yml`. In the `on` section, add `workflow_dispatch:` to enable manual triggering of the workflow from the GitHub Actions UI. | `.github/workflows/ci.yml` |
| **7.8** | ☐ To Do | **Define Release Job in CI Workflow:** In `.github/workflows/ci.yml`, add a new job named `release` after the `build` job. This job should `needs: build` and run conditionally `if: github.event_name == 'workflow_dispatch'`. | `.github/workflows/ci.yml` |
| **7.9** | ☐ To Do | **Add Steps to Release Job:** In the `release` job, add steps to: checkout the repository, set up Node.js, install `vsce` globally (`npm install -g vsce`), download the `.vsix` artifact from the `build` job, and finally run `vsce publish -p ${{ secrets.VSCE_TOKEN }}` to publish the extension. | `.github/workflows/ci.yml` |
| **7.10** | ☐ To Do | **Test the Release Process:** Go to your GitHub repository's `Actions` tab. Select the `CI/CD` workflow and click `Run workflow`. Choose the `main` branch and click `Run workflow`. Monitor the job execution to ensure it completes successfully. | `(GitHub Actions UI)` |
| **7.11** | ☐ To Do | **Verify Publication:** After the release workflow completes, search for your extension on the Visual Studio Code Marketplace to confirm it has been successfully published and is publicly accessible. | `(External - VS Code Marketplace)` |
</file>

<file path=".gitignore">
.codersinflow
.vscode
node_modules
.env
.venv
.codex
out
dist
*.vsix
.claude
CLAUDE.md
.DS_Store
.git
*.log
*.tmp
__pycache__
*.pyc
.env.local
.next
.github
</file>

</files>
