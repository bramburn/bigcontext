This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  completed/
    extension/
      backlog_sub_sprint_1_dependency_injection_centralized_config.md
      backlog_sub_sprint_2_extension_command_managers.md
      backlog_sub_sprint_3_centralized_webview_management.md
      backlog_sub_sprint_4_message_routing_state.md
      implementation_sub_sprint_1_dependency_injection_centralized_config.md
      implementation_sub_sprint_2_extension_command_managers.md
      implementation_sub_sprint_3_centralized_webview_management.md
      implementation_sub_sprint_4_message_routing_state.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
      tasklist_sprint_03.md
      tasklist_sprint_04.md
    extension2/
      backlog_sprint_1_webview_panel_lifecycle.md
      backlog_sprint_2_message_routing_api.md
      implementation_sprint_1_webview_panel_lifecycle.md
      prd.md
    fe/
      backlog_sprint_1_setup_view_implementation.md
      backlog_sprint_1_web_api_boilerplate.md
      backlog_sprint_2_extensible_client_framework.md
      backlog_sprint_3_backend_process_management.md
      backlog_sprint_4_onboarding_setup_ui.md
      backlog_sprint_5_concrete_client_implementation.md
      backlog_sprint_6_end_to_end_indexing_query_ui.md
      backlog_sub_sprint_1_database_configuration_component.md
      backlog_sub_sprint_2_embedding_provider_workflow_logic.md
      implementation_sprint_1_setup_view_implementation.md
      implementation_sprint_1_web_api_boilerplate.md
      implementation_sprint_2_extensible_client_framework.md
      implementation_sprint_3_backend_process_management.md
      implementation_sprint_4_onboarding_setup_ui.md
      implementation_sprint_5_concrete_client_implementation.md
      implementation_sub_sprint_1_database_configuration_component.md
      implementation_sub_sprint_2_embedding_provider_workflow_logic.md
      prd.md
    setup/
      backlog_sprint_6_lsp_integration_devops.md
      backlog_sprint_7_documentation_publishing.md
      backlog_sub_sprint_1_vs_code_extension_boilerplate_setup.md
      backlog_sub_sprint_2_sveltekit_fluent_ui_integration.md
      backlog_sub_sprint_5_implement_context_query_api.md
      backlog_sub_sprint_6_develop_settings_ui.md
      implementation_sprint_6_lsp_integration_devops.md
      implementation_sprint_7_documentation_publishing.md
      implementation_sub_sprint_1_vs_code_extension_boilerplate_setup.md
      implementation_sub_sprint_2_sveltekit_fluent_ui_integration.md
      implementation_sub_sprint_5_implement_context_query_api.md
      implementation_sub_sprint_6_develop_settings_ui.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
      tasklist_sprint_03.md
      tasklist_sprint_04.md
      tasklist_sprint_05.md
      tasklist_sprint_06.md
      tasklist_sprint_07.md
    svelte-continue/
      backlog_sub_sprint_1_sveltekit_project_scaffolding.md
      backlog_sub_sprint_2_recreate_ui_as_svelte_components.md
      backlog_sub_sprint_3_centralized_webview_management.md
      backlog_sub_sprint_4_message_routing_state.md
      implementation_sub_sprint_1_sveltekit_project_scaffolding.md
      implementation_sub_sprint_2_recreate_ui_as_svelte_components.md
      implementation_sub_sprint_3_centralized_webview_management.md
      implementation_sub_sprint_4_message_routing_state.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
      tasklist_sprint_03.md
      tasklist_sprint_04.md
    ux/
      prd.md
      tasklist_sprint_01.md
    ux2/
      backlog_sub_sprint_1_hotkey_native_settings.md
      backlog_sub_sprint_2_diagnostics_view.md
      implementation_sub_sprint_1_hotkey_native_settings.md
      implementation_sub_sprint_2_diagnostics_view.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
  todo/
    missing/
      backlog_sub_sprint_1_sveltekit_migration.md
      backlog_sub_sprint_2_diagnostics_view.md
      backlog_sub_sprint_2_native_settings_hotkeys_state_management.md
      implementation_sub_sprint_1_sveltekit_migration.md
      implementation_sub_sprint_2_diagnostics_view.md
      implementation_sub_sprint_2_native_settings_hotkeys_state_management.md
      prd.md
      tasklist_sub_sprint_01.md
      tasklist_sub_sprint_02.md
      tasklist_sub_sprint_03.md
    missing2/
      backlog_sprint_1_sveltekit_migration_componentization.md
      backlog_sprint_2_intuitive_settings_diagnostics_ui.md
      backlog_sprint_3_advanced_search_ui_logic.md
      backlog_sprint_4_xml_result_formatting.md
      backlog_sprint_5_state_management_hotkeys.md
      backlog_sprint_6_cicd_pipeline_documentation.md
      implementation_sprint_1_sveltekit_migration_componentization.md
      implementation_sprint_2_intuitive_settings_diagnostics_ui.md
      implementation_sprint_3_advanced_search_ui_logic.md
      implementation_sprint_4_xml_result_formatting.md
      implementation_sprint_5_state_management_hotkeys.md
      implementation_sprint_6_cicd_pipeline_documentation.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
      tasklist_sprint_03.md
      tasklist_sprint_04.md
      tasklist_sprint_05.md
      tasklist_sprint_06.md
  sprint3-usage.md
  sprint4-usage.md
src/
  configuration/
    configurationManager.ts
    configurationSchema.ts
  context/
    contextService.ts
  db/
    qdrantService.ts
  embeddings/
    embeddingProvider.ts
    ollamaProvider.ts
    openaiProvider.ts
  indexing/
    fileWalker.ts
    indexingService.ts
  lsp/
    lspService.ts
  parsing/
    astParser.ts
    chunker.ts
  test/
    suite/
      configService.test.ts
      dependencyInjection.test.ts
      index.ts
    mocks.ts
    runTest.ts
  types/
    tree-sitter-languages.d.ts
  validation/
    systemValidator.ts
    troubleshootingGuide.ts
  commandManager.ts
  configService.ts
  configurationManager.ts
  extension.ts
  extensionManager.ts
  messageRouter.ts
  performanceManager.ts
  searchManager.ts
  stateManager.ts
  webviewManager.ts
webview/
  e2e/
    demo.test.ts
  src/
    lib/
      assets/
        favicon.svg
      components/
        ConnectionTester.svelte
        DiagnosticsView.svelte
        ErrorBoundary.svelte
        IndexingView.svelte
        QueryView.svelte
        SetupView.svelte
        ValidatedInput.svelte
        ValidatedInput.test.ts
        ValidationMessage.svelte
      stores/
        appStore.test.ts
        appStore.ts
        persistence.ts
        viewStore.ts
      utils/
        animations.ts
        connectionTesting.ts
        fluentUI.ts
        performance.ts
        validation.test.ts
        validation.ts
      index.ts
      vscodeApi.ts
    routes/
      +layout.svelte
      +page.svelte
      page.svelte.spec.ts
    test/
      setup.ts
    app.css
    app.d.ts
    app.html
    demo.spec.ts
  static/
    robots.txt
  .gitignore
  .npmrc
  .prettierignore
  .prettierrc
  package.json
  playwright.config.ts
  README.md
  svelte.config.js
  tsconfig.json
  vite.config.ts
  vitest-setup-client.ts
  vitest.config.ts
webview-backup-20250826-101914/
  src/
    lib/
      components/
        ChromaDBConfig.js
        ChromaDBConfig.js.map
        ChromaDBConfig.ts
        ConfigurationManagement.js
        ConfigurationManagement.js.map
        ConfigurationManagement.ts
        DatabaseSetup.js
        DatabaseSetup.js.map
        DatabaseSetup.ts
        EmbeddingSetup.js
        EmbeddingSetup.js.map
        EmbeddingSetup.ts
        OllamaConfig.js
        OllamaConfig.js.map
        OllamaConfig.ts
        OpenAIConfig.js
        OpenAIConfig.js.map
        OpenAIConfig.ts
        PineconeConfig.js
        PineconeConfig.js.map
        PineconeConfig.ts
        SystemValidation.js
        SystemValidation.js.map
        SystemValidation.ts
      stores/
        setupStore.js
        setupStore.js.map
        setupStore.ts
      views/
        SetupView.js
        SetupView.js.map
        SetupView.ts
      vscodeApi.js
      vscodeApi.js.map
      vscodeApi.ts
    index.html
    index.js
    index.js.map
    index.ts
    styles.css
  package.json
  tsconfig.json
  webpack.config.js
.eslintrc.json
.gitignore
.repomixignore
.vscodeignore
docker-compose.yml
package.json
README.md
repomix.config.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/completed/svelte-continue/backlog_sub_sprint_1_sveltekit_project_scaffolding.md">
# Backlog: Sub-Sprint 1 - SvelteKit Project Scaffolding

**Objective:** To replace the existing `webview/` content with a new, properly configured SvelteKit project and add the Fluent UI component library.

**Parent Sprint:** PRD 1, Sprint 1: SvelteKit Scaffolding & UI Components

---

### User Story 1: Setup SvelteKit Foundation
**As a** Frontend Developer (Frank), **I want to** initialize a new SvelteKit project in the `webview/` directory, **so that** I have a modern, standardized, and scalable foundation for building the extension's user interface.

**Actions to Undertake:**
1.  **Filepath**: `webview/`
    -   **Action**: **Clear Existing Content**: Remove all files and folders from the `webview/` directory to ensure a clean slate.
    -   **Implementation**: `rm -rf webview/*` or manual deletion.
    -   **Imports**: N/A.
2.  **Filepath**: `(root)`
    -   **Action**: **Scaffold SvelteKit Project**: Run the SvelteKit creation command to generate a new "Skeleton project" with TypeScript support inside the `webview/` directory.
    -   **Implementation**: `npm create svelte@latest webview` (Select "Skeleton project", "TypeScript").
    -   **Imports**: N/A.
3.  **Filepath**: `webview/package.json`
    -   **Action**: **Install Static Adapter**: Add the `@sveltejs/adapter-static` package as a development dependency to enable static site generation.
    -   **Implementation**: `npm install -D @sveltejs/adapter-static` (run inside `webview/` directory).
    -   **Imports**: N/A.
4.  **Filepath**: `webview/package.json`
    -   **Action**: **Install Fluent UI**: Add the `@fluentui/web-components` package as a dependency to make the Fluent UI component library available to the project.
    -   **Implementation**: `npm install @fluentui/web-components` (run inside `webview/` directory).
    -   **Imports**: N/A.

**Acceptance Criteria:**
-   The `webview/` directory is completely replaced by a new SvelteKit project structure.
-   `@sveltejs/adapter-static` is listed as a `devDependency` in `webview/package.json`.
-   `@fluentui/web-components` is listed as a `dependency` in `webview/package.json`.

**Testing Plan:**
-   **Test Case 1**: Navigate into the `webview/` directory and run `npm install`. The command should complete without errors.
-   **Test Case 2**: Verify that the `node_modules` directory is created inside `webview/` and contains the new dependencies.

---

### User Story 2: Configure Static Build
**As a** Backend Developer (Alisha), **I want** the SvelteKit project to be configured to output a static `index.html` file, **so that** the VS Code extension can load it directly into a webview without needing a running dev server.

**Actions to Undertake:**
1.  **Filepath**: `webview/svelte.config.js`
    -   **Action**: **Configure Static Adapter**: Modify the SvelteKit configuration to import and use `adapter-static`. The configuration should specify `build` as the output directory and set a fallback page to handle client-side routing within the webview.
    -   **Implementation**:
        ```javascript
        import adapter from '@sveltejs/adapter-static';

        /** @type {import('@sveltejs/kit').Config} */
        const config = {
          kit: {
            adapter: adapter({
              pages: 'build',
              assets: 'build',
              fallback: 'index.html', // Use index.html as the fallback for SPA-like behavior
              precompress: false,
              strict: true
            })
          }
        };

        export default config;
        ```
    -   **Imports**: `import adapter from '@sveltejs/adapter-static';`

**Acceptance Criteria:**
-   The `webview/svelte.config.js` file correctly imports and configures `@sveltejs/adapter-static`.
-   Running `npm run build` inside the `webview/` directory successfully generates a `build/` folder.
-   The `webview/build/` folder contains an `index.html` file.

**Testing Plan:**
-   **Test Case 1**: Navigate into the `webview/` directory and run `npm run build`. The command must complete successfully.
-   **Test Case 2**: Verify that the `webview/build/index.html` file has been created.
-   **Test Case 3**: Open the generated `webview/build/index.html` in a web browser. It should render the basic SvelteKit welcome page.
</file>

<file path="docs/completed/svelte-continue/backlog_sub_sprint_2_recreate_ui_as_svelte_components.md">
# Backlog: Sub-Sprint 2 - Recreate UI as Svelte Components

**Objective:** To build the three primary UI views as distinct Svelte components, replicating the functionality and layout from the original inline HTML.

**Parent Sprint:** PRD 1, Sprint 1: SvelteKit Scaffolding & UI Components

---

### User Story 1: Create Core View Components
**As a** Frontend Developer (Frank), **I want to** create separate Svelte components for each of the main UI views (Setup, Indexing, Query), **so that** the UI is modular, maintainable, and easy to manage.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/SetupView.svelte` (New File)
    -   **Action**: **Create SetupView Component**: Create a new Svelte component and transfer the relevant HTML structure from the `getSetupWebviewContent` function in `src/extension.ts`. Replace standard HTML elements with corresponding Fluent UI components (e.g., `<fluent-select>`, `<fluent-text-field>`, `<fluent-button>`).
    -   **Implementation**: See implementation guide for code structure.
    -   **Imports**: `import "@fluentui/web-components";`
2.  **Filepath**: `webview/src/lib/components/IndexingView.svelte` (New File)
    -   **Action**: **Create IndexingView Component**: Create a new Svelte component for the indexing progress view. This includes the progress bar/ring and status text area from the `getWebviewContent` function.
    -   **Implementation**: See implementation guide for code structure.
    -   **Imports**: `import "@fluentui/web-components";`
3.  **Filepath**: `webview/src/lib/components/QueryView.svelte` (New File)
    -   **Action**: **Create QueryView Component**: Create a new Svelte component for the search/query interface. This includes the search input field, search button, and results area from the `getWebviewContent` function.
    -   **Implementation**: See implementation guide for code structure.
    -   **Imports**: `import "@fluentui/web-components";`

**Acceptance Criteria:**
-   Three new files exist: `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte`.
-   Each file contains the basic UI structure corresponding to its purpose, derived from `extension.ts`.
-   The components use Fluent UI web components for their interactive elements.

**Testing Plan:**
-   **Test Case 1**: Manually inspect each component file to ensure it contains the correct HTML structure and Fluent UI tags.
-   **Test Case 2**: Ensure the project still builds successfully with `npm run build` after creating these components.

---

### User Story 2: Implement View Management
**As a** Frontend Developer (Frank), **I want** a centralized state management system to control which view is currently visible, **so that** the application can easily switch between the Setup, Indexing, and Query states.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/stores/viewStore.ts` (New File)
    -   **Action**: **Create View State Store**: Create a new file to house a Svelte writable store. This store will hold a string value representing the current view state (e.g., 'setup', 'indexing', 'query').
    -   **Implementation**: `import { writable } from 'svelte/store'; export const currentView = writable('setup');`
    -   **Imports**: `import { writable } from 'svelte/store';`
2.  **Filepath**: `webview/src/routes/+page.svelte`
    -   **Action**: **Create View Manager**: Modify the main page component to act as a view controller. It should import the three view components and the `viewStore`.
    -   **Implementation**: Use an `{#if ... else if ...}` block that subscribes to the `currentView` store and conditionally renders the correct view component based on the store's value.
    -   **Imports**: `import SetupView from '$lib/components/SetupView.svelte';`, `import IndexingView from '$lib/components/IndexingView.svelte';`, `import QueryView from '$lib/components/QueryView.svelte';`, `import { currentView } from '$lib/stores/viewStore';`

**Acceptance Criteria:**
-   A `viewStore.ts` file exists and exports a writable Svelte store.
-   The main `+page.svelte` correctly imports and uses the store.
-   Changing the value of the store (e.g., via browser devtools) correctly switches the rendered component in the UI.

**Testing Plan:**
-   **Test Case 1**: Run the app using `npm run dev`. Verify the default view (`SetupView`) is displayed.
-   **Test Case 2**: Use the browser's JavaScript console to import the store and set its value (e.g., `window.currentView.set('query')`). Verify the UI correctly updates to show the `QueryView` component.
</file>

<file path="docs/completed/svelte-continue/backlog_sub_sprint_3_centralized_webview_management.md">
# Backlog: Sub-Sprint 3 - Centralized Webview Management

**Objective:** To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, cleaning up the command handlers and `extension.ts`.

**Parent Sprint:** PRD 2, Sprint 3: Webview Management

---

### User Story 1: Centralize Webview Creation
**As a** Developer, **I want to** create a `WebviewManager` class that handles the creation and lifecycle of webview panels, **so that** webview logic is centralized, reusable, and decoupled from command handlers.

**Actions to Undertake:**
1.  **Filepath**: `src/webviewManager.ts` (New File)
    -   **Action**: **Create WebviewManager Class**: Define a new class named `WebviewManager`. It should have a private constructor, a static property to hold the panel instance (e.g., `public static currentPanel`), and a static `createOrShow` method.
    -   **Implementation**: See implementation guide for the full class structure.
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Implement Singleton Pattern**: The `createOrShow` method should check if `currentPanel` already exists. If it does, it should call `.reveal()` on the existing panel. If not, it should create a new `vscode.WebviewPanel` and instantiate `WebviewManager`.
    -   **Implementation**: `if (WebviewManager.currentPanel) { WebviewManager.currentPanel._panel.reveal(); return; }`
    -   **Imports**: N/A.
3.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Handle Panel Disposal**: In the private constructor, set up an `onDidDispose` listener for the webview panel. This listener must clean up resources and set the static `currentPanel` reference back to `undefined`.
    -   **Implementation**: `this._panel.onDidDispose(() => this.dispose(), null, this._disposables);`
    -   **Imports**: N/A.

**Acceptance Criteria:**
-   A new `WebviewManager.ts` file exists with a class that properly implements the singleton pattern for a `WebviewPanel`.
-   Calling the `createOrShow` method multiple times results in only one panel being created, with subsequent calls bringing the existing panel to the front.
-   Closing the webview panel correctly disposes of the panel object and allows a new one to be created on the next call.

**Testing Plan:**
-   **Test Case 1**: Trigger the command to open the webview. Verify the panel appears.
-   **Test Case 2**: Trigger the command again. Verify that a new panel does *not* appear, but the existing one remains or regains focus.
-   **Test Case 3**: Close the panel and trigger the command again. Verify a new panel appears successfully.

---

### User Story 2: Refactor Commands to Use WebviewManager
**As a** Developer, **I want to** refactor the existing command handlers to use the new `WebviewManager`, **so that** `extension.ts` and `commandManager.ts` are no longer directly responsible for creating webviews.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts` or `src/commandManager.ts`
    -   **Action**: **Update `openMainPanel` Command**: Locate the command registration for `code-context-engine.openMainPanel`. Replace the entire `vscode.window.createWebviewPanel` logic with a single call to `WebviewManager.createOrShow(context.extensionUri)`.
    -   **Implementation**: `vscode.commands.registerCommand('code-context-engine.openMainPanel', () => { WebviewManager.createOrShow(context.extensionUri); });`
    -   **Imports**: `import { WebviewManager } from './webviewManager';`
2.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Implement HTML Content Loading**: Create a private method within `WebviewManager` (e.g., `_getHtmlForWebview`) that is responsible for reading the `index.html` from the SvelteKit build output (`webview/build/index.html`).
    -   **Implementation**: Use `fs.readFileSync` to get the HTML content.
    -   **Imports**: `import * as fs from 'fs';`, `import * as path from 'path';`
3.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Implement Asset Path Rewriting**: Within the `_getHtmlForWebview` method, use `webview.asWebviewUri` to correctly transform the paths for CSS and JS files referenced in the `index.html` (e.g., paths starting with `/_app/`).
    -   **Implementation**: Use string replacement or a regular expression to find and replace asset URIs.
    -   **Imports**: N/A.

**Acceptance Criteria:**
-   The `createWebviewPanel` logic is completely removed from `extension.ts` and/or `commandManager.ts`.
-   The `openMainPanel` command successfully opens the webview using the `WebviewManager`.
-   The SvelteKit application loads correctly inside the webview, including all its CSS and JavaScript assets, proving the path rewriting is working.

**Testing Plan:**
-   **Test Case 1**: Run the extension and trigger the `openMainPanel` command. Verify the SvelteKit UI renders correctly.
-   **Test Case 2**: Check the developer tools console for the webview to ensure there are no 404 errors for CSS or JS files.
</file>

<file path="docs/completed/svelte-continue/backlog_sub_sprint_4_message_routing_state.md">
# Backlog: Sub-Sprint 4 - Message Routing & State

**Objective:** To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

**Parent Sprint:** PRD 2, Sprint 4: Communication & State Mgmt

---

### User Story 1: Centralize Global State
**As a** Developer (Alisha), **I want to** create a `StateManager` class, **so that** I have a single, reliable source of truth for the global state of the extension (e.g., whether indexing is in progress).

**Actions to Undertake:**
1.  **Filepath**: `src/stateManager.ts` (New File)
    -   **Action**: **Create StateManager Class**: Define a new `StateManager` class. It should contain private properties for state flags (e.g., `private _isIndexing = false;`).
    -   **Implementation**: See implementation guide.
    -   **Imports**: N/A.
2.  **Filepath**: `src/stateManager.ts`
    -   **Action**: **Implement Getters and Setters**: For each state property, create public getter (e.g., `public isIndexing()`) and setter (e.g., `public setIndexing(state: boolean)`) methods.
    -   **Implementation**: `public isIndexing() { return this._isIndexing; }`
    -   **Imports**: N/A.
3.  **Filepath**: `src/extensionManager.ts`
    -   **Action**: **Instantiate StateManager**: In the `ExtensionManager` constructor, create a public instance of the `StateManager` so it can be injected into other services.
    -   **Implementation**: `this.stateManager = new StateManager();`
    -   **Imports**: `import { StateManager } from './stateManager';`

**Acceptance Criteria:**
-   A new `StateManager.ts` file exists with a class that encapsulates state properties.
-   The `ExtensionManager` creates and holds a single instance of the `StateManager`.
-   Other services can access state via the manager (e.g., `this.extensionManager.stateManager.isIndexing()`).

**Testing Plan:**
-   **Test Case 1**: Verify that services requiring state can be instantiated correctly with the `StateManager` passed into their constructors.

---

### User Story 2: Decouple Message Handling
**As a** Developer, **I want to** create a `MessageRouter` class to handle all incoming messages from the webview, **so that** communication logic is cleanly separated from webview lifecycle management.

**Actions to Undertake:**
1.  **Filepath**: `src/messageRouter.ts` (New File)
    -   **Action**: **Create MessageRouter Class**: Define a new `MessageRouter` class. Its constructor should accept the `ExtensionManager` and the `vscode.Webview` instance.
    -   **Implementation**: See implementation guide.
    -   **Imports**: `import * as vscode from 'vscode';`, `import { ExtensionManager } from './extensionManager';`
2.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: **Implement Message Listener**: In the constructor, set up the `webview.onDidReceiveMessage` listener to call a private `_routeMessage` method.
    -   **Implementation**: `this._webview.onDidReceiveMessage(this._routeMessage, this, this._disposables);`
    -   **Imports**: N/A.
3.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: **Implement `_routeMessage` Method**: Move the large `switch` statement for handling messages from its current location (`extension.ts` or `webviewManager.ts`) into the `_routeMessage` method.
    -   **Implementation**: `private async _routeMessage(message: any) { switch (message.command) { ... } }`
    -   **Imports**: N/A.
4.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Integrate MessageRouter**: In the `WebviewManager` constructor, instead of handling messages directly, instantiate the new `MessageRouter`.
    -   **Implementation**: `new MessageRouter(this._extensionManager, this._panel.webview);`
    -   **Imports**: `import { MessageRouter } from './messageRouter';`
5.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: **Update Service to Use StateManager**: Inject the `StateManager` into the `IndexingService`. Call `this.stateManager.setIndexing(true)` at the beginning of the `startIndexing` method and `this.stateManager.setIndexing(false)` in a `finally` block to ensure it is always reset.
    -   **Implementation**: `startIndexing() { this.stateManager.setIndexing(true); try { ... } finally { this.stateManager.setIndexing(false); } }`
    -   **Imports**: `import { StateManager } from '../stateManager';`

**Acceptance Criteria:**
-   The `onDidReceiveMessage` listener in `WebviewManager` is now a single line that instantiates the `MessageRouter`.
-   The `MessageRouter` correctly routes commands from the webview to the appropriate services.
-   The `IndexingService` correctly updates the `StateManager` before and after indexing.
-   Attempting to start a new indexing job while one is already running is gracefully handled by checking the state in the `MessageRouter`, and an appropriate error is sent to the UI.

**Testing Plan:**
-   **Test Case 1**: Verify that all previous UI interactions (e.g., starting a search) still work correctly, confirming the router is delegating properly.
-   **Test Case 2**: Start an indexing process. While it is running, try to start it again. Verify that the second request is rejected and a message is sent to the webview indicating that indexing is already in progress.
</file>

<file path="docs/completed/svelte-continue/implementation_sub_sprint_1_sveltekit_project_scaffolding.md">
hat# Implementation Guidance: Sub-Sprint 1 - SvelteKit Project Scaffolding

**Objective:** To replace the existing `webview/` content with a new, properly configured SvelteKit project and add the Fluent UI component library.

---

### 1. Overview

This guide provides the technical steps to scaffold a new SvelteKit project within the `webview` directory. The goal is to create a modern frontend foundation that builds to a static site, which can be loaded directly by the VS Code extension's webview panel.

### 2. Step-by-Step Implementation

#### Step 2.1: Clear and Initialize the SvelteKit Project

First, ensure the `webview/` directory is empty. Then, use the official SvelteKit scaffolding tool to create a new project.

```bash
# Navigate to the project root
# Make sure the webview directory is empty
rm -rf webview/*

# Run the SvelteKit initializer
npm create svelte@latest webview
```

When prompted by the `create-svelte` wizard, choose the following options:
-   **Which Svelte app template?** `Skeleton project`
-   **Add type checking with TypeScript?** `Yes`
-   **Select additional options:** (You can skip ESLint, Prettier, etc. for now if desired)

#### Step 2.2: Install Dependencies

Navigate into the newly created `webview` directory and install the necessary dependencies for static site generation and the Fluent UI component library.

```bash
# Navigate into the new webview directory
cd webview

# Install the static adapter for SvelteKit
npm install -D @sveltejs/adapter-static

# Install the Fluent UI web components library
npm install @fluentui/web-components
```

#### Step 2.3: Configure the Static Adapter

Modify the `svelte.config.js` file to use the static adapter. This is critical for ensuring the SvelteKit application builds into a set of static files that the VS Code extension can serve.

**File:** `webview/svelte.config.js`
```javascript
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: vitePreprocess(),

  kit: {
    adapter: adapter({
      // The output directory for the build.
      pages: 'build',
      assets: 'build',

      // A fallback page is crucial for SPA-like behavior in a webview.
      // It ensures that all routes are directed to index.html.
      fallback: 'index.html',

      precompress: false,
      strict: true
    }),
    // This is important for VS Code webviews to correctly resolve asset paths.
    // It tells SvelteKit that all paths are relative to the root.
    paths: {
      relative: true
    }
  }
};

export default config;
```
**Note on `paths: { relative: true }`**: While the PRD doesn't explicitly mention this, using relative paths is often a good practice for webviews to avoid issues with `file://` protocols or custom URI schemes used by VS Code. However, the ultimate solution in Sprint 2 will involve the extension rewriting paths, so this can be considered a preliminary setup.

### 3. Integrating Fluent UI

With `@fluentui/web-components` installed, you can begin using its components in your Svelte files. Fluent UI Web Components are standard Custom Elements, so they can be used directly in your markup.

You may need to define the custom elements in a root layout or component. A common practice is to import the necessary component definitions in your main `+layout.svelte` or `+page.svelte`.

**Example:** `webview/src/routes/+layout.svelte`
```html
<script>
  import { provideFluentDesignSystem, fluentButton, fluentTextField } from "@fluentui/web-components";
  import { onMount } from "svelte";

  // It's good practice to only interact with the design system after the component has mounted.
  onMount(() => {
    provideFluentDesignSystem().register(fluentButton(), fluentTextField());
  });
</script>

<slot></slot>

<style>
  /* Add any global styles here */
</style>
```

### 4. External Resources

-   **SvelteKit Static Adapter:** [Official Documentation](https://kit.svelte.dev/docs/adapter-static)
-   **Fluent UI Web Components:** [Official Documentation & Storybook](https://fluentui.dev/)

After completing these steps, you can run `npm run build` inside the `webview` directory to generate the static output in the `webview/build` folder, verifying the setup is correct.
</file>

<file path="docs/completed/svelte-continue/implementation_sub_sprint_2_recreate_ui_as_svelte_components.md">
# Implementation Guidance: Sub-Sprint 2 - Recreate UI as Svelte Components

**Objective:** To build the three primary UI views as distinct Svelte components, replicating the functionality and layout from the original inline HTML.

---

### 1. Overview

This guide details how to translate the raw HTML found in `src/extension.ts` into modular and reusable Svelte components. This is a foundational step in decoupling the frontend from the backend. We will create three core components and a simple state management system to control which component is visible.

### 2. Step-by-Step Implementation

#### Step 2.1: Create the View State Store

First, create a centralized store to manage the application's current state. This allows components to be decoupled while sharing the global state of which view should be active.

**File:** `webview/src/lib/stores/viewStore.ts` (New File)
```typescript
import { writable } from 'svelte/store';

// This type definition ensures we only use valid view names
export type View = 'setup' | 'indexing' | 'query';

// The store holds the current active view. 'setup' is the default.
export const currentView = writable<View>('setup');
```

#### Step 2.2: Create the Svelte View Components

Next, create the three Svelte components. For each component, you will copy the relevant HTML structure from `src/extension.ts` and convert it to Svelte syntax, using Fluent UI components.

**1. Setup View**

This component replicates the UI from the `getSetupWebviewContent` function.

**File:** `webview/src/lib/components/SetupView.svelte` (New File)
```html
<script lang="ts">
  // Import specific Fluent UI components you will use
  import { fluentSelect, fluentTextField, fluentButton } from "@fluentui/web-components";
  import { onMount } from "svelte";

  onMount(() => {
    // Register components with the Fluent Design System
    fluentSelect();
    fluentTextField();
    fluentButton();
  });

  // In future sprints, you will add logic here to handle button clicks
  // and post messages to the VS Code extension.
</script>

<div class="setup-step">
    <h3>Step 1: Vector Database Configuration</h3>
    <fluent-select id="databaseType">
        <fluent-option value="qdrant">Qdrant (Recommended)</fluent-option>
    </fluent-select>
    <fluent-text-field id="databaseConnectionString" value="http://localhost:6333" placeholder="http://localhost:6333">Connection String</fluent-text-field>
    <fluent-button appearance="secondary">Start Local Qdrant</fluent-button>
</div>

<div class="setup-step">
    <h3>Step 2: Embedding Provider Configuration</h3>
    <fluent-select id="embeddingProvider">
        <fluent-option value="ollama">Ollama (Local)</fluent-option>
        <fluent-option value="openai">OpenAI (Cloud)</fluent-option>
    </fluent-select>
</div>

<div class="final-step">
    <h3>Ready to Index?</h3>
    <fluent-button appearance="accent">Save & Start Indexing</fluent-button>
</div>

<style>
  .setup-step, .final-step {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 8px;
  }
  h3 {
    margin-top: 0;
  }
</style>
```

**2. Indexing View**

This component shows the progress of an indexing operation, taken from the `getWebviewContent` function.

**File:** `webview/src/lib/components/IndexingView.svelte` (New File)
```html
<script lang="ts">
  import { fluentProgress, fluentProgressBar } from "@fluentui/web-components";
  import { onMount } from "svelte";

  onMount(() => {
    fluentProgress();
    fluentProgressBar();
  });

  // This will be driven by messages from the extension in a future sprint
  export let progress = 50; // Example progress value
  export let statusText = "Indexing file_name.ts...";
</script>

<div class="section">
    <h2>Repository Indexing</h2>
    <p>Please wait while your repository is being indexed.</p>
    
    <fluent-progress-bar value={progress}></fluent-progress-bar>
    <p>{statusText}</p>
</div>

<style>
  .section {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
  }
</style>
```

**3. Query View**

This component provides the main search interface, also from `getWebviewContent`.

**File:** `webview/src/lib/components/QueryView.svelte` (New File)
```html
<script lang="ts">
  import { fluentTextField, fluentButton } from "@fluentui/web-components";
  import { onMount } from "svelte";

  onMount(() => {
    fluentTextField();
    fluentButton();
  });
</script>

<div class="section">
    <h2>Search & Context</h2>
    <p>Search through your indexed code and get AI-powered context.</p>
    <fluent-text-field placeholder="Search your code..." style="width: 100%; margin-bottom: 10px;"></fluent-text-field>
    <fluent-button appearance="accent">Search</fluent-button>

    <div id="search-results" style="margin-top: 20px;">
        <!-- Search results will be rendered here based on extension messages -->
    </div>
</div>

<style>
  .section {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
  }
</style>
```

#### Step 2.3: Create the View Manager

Finally, update the main `+page.svelte` to act as a controller that renders the correct view based on the state in `viewStore`.

**File:** `webview/src/routes/+page.svelte` (Modify)
```html
<script lang="ts">
  import SetupView from '$lib/components/SetupView.svelte';
  import IndexingView from '$lib/components/IndexingView.svelte';
  import QueryView from '$lib/components/QueryView.svelte';
  import { currentView } from '$lib/stores/viewStore';

  // To test, you can expose the store to the window object
  import { onMount } from 'svelte';
  onMount(() => {
    if (typeof window !== 'undefined') {
      (window as any).currentView = currentView;
    }
  });
</script>

<main>
  {#if $currentView === 'setup'}
    <SetupView />
  {:else if $currentView === 'indexing'}
    <IndexingView />
  {:else if $currentView === 'query'}
    <QueryView />
  {/if}
</main>

<style>
  main {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }
</style>
```

### 3. Verification

After creating these files, run the SvelteKit development server from within the `webview` directory:

```bash
cd webview
npm run dev
```

Open your browser to the specified localhost address. You should see the `SetupView` component rendered by default. You can test the view switching by opening the browser's developer console and running `window.currentView.set('query')` or `window.currentView.set('indexing')`. The UI should update instantly to show the corresponding component.
</file>

<file path="docs/completed/svelte-continue/implementation_sub_sprint_3_centralized_webview_management.md">
# Implementation Guidance: Sub-Sprint 3 - Centralized Webview Management

**Objective:** To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, centralizing control and cleaning up the extension's entry point.

---

### 1. Overview

This guide provides a step-by-step walkthrough for creating a `WebviewManager` class. This class will act as a singleton manager for our main webview panel, ensuring that only one instance of the panel exists at any time. This pattern is a best practice for managing resource-intensive webviews in VS Code extensions.

We will follow the singleton pattern where the class manages its own instance via a static property and a static creation method.

### 2. Step-by-Step Implementation

#### Step 2.1: Create the `WebviewManager.ts` File

First, create the new file that will house our manager class.

**File:** `src/webviewManager.ts` (New File)

#### Step 2.2: Implement the WebviewManager Class

Populate the new file with the following class structure. This code is adapted from VS Code extension best practices for singleton webview management.

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export class WebviewManager {
    // Static property to hold the single instance of the panel
    public static currentPanel: WebviewManager | undefined;

    private readonly _panel: vscode.WebviewPanel;
    private readonly _extensionUri: vscode.Uri;
    private _disposables: vscode.Disposable[] = [];

    /**
     * Creates or shows a webview panel.
     * @param extensionUri The URI of the extension.
     */
    public static createOrShow(extensionUri: vscode.Uri) {
        const column = vscode.window.activeTextEditor
            ? vscode.window.activeTextEditor.viewColumn
            : undefined;

        // If we already have a panel, show it.
        if (WebviewManager.currentPanel) {
            WebviewManager.currentPanel._panel.reveal(column);
            return;
        }

        // Otherwise, create a new panel.
        const panel = vscode.window.createWebviewPanel(
            'codeContextEngine', // Internal ID for the webview type
            'Code Context Engine', // Title of the panel displayed to the user
            column || vscode.ViewColumn.One,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [
                    vscode.Uri.joinPath(extensionUri, 'webview', 'build')
                ]
            }
        );

        WebviewManager.currentPanel = new WebviewManager(panel, extensionUri);
    }

    private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
        this._panel = panel;
        this._extensionUri = extensionUri;

        // Set the webview's initial HTML content
        this._update();

        // Listen for when the panel is disposed (i.e., when the user closes it)
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

        // TODO: In Sprint 4, the message handler will be moved here.
        // this._panel.webview.onDidReceiveMessage(...);
    }

    /**
     * Cleans up all disposables and resets the current panel instance.
     */
    public dispose() {
        WebviewManager.currentPanel = undefined;

        // Dispose of the panel
        this._panel.dispose();

        // Dispose of all disposables
        while (this._disposables.length) {
            const x = this._disposables.pop();
            if (x) {
                x.dispose();
            }
        }
    }

    /**
     * Sets the HTML content for the webview panel.
     */
    private _update() {
        const webview = this._panel.webview;
        this._panel.webview.html = this._getHtmlForWebview(webview);
    }

    /**
     * Reads the SvelteKit build output and prepares it for the webview.
     */
    private _getHtmlForWebview(webview: vscode.Webview): string {
        const buildPath = path.join(this._extensionUri.fsPath, 'webview', 'build');
        const indexPath = path.join(buildPath, 'index.html');
        let html = fs.readFileSync(indexPath, 'utf-8');

        // Replace asset paths with webview-compatible URIs
        html = html.replace(/<(script|link).*?(src|href)="(.*?)"/g,
            (match, tag, attribute, src) => {
                const resourcePath = path.join(buildPath, src);
                const resourceUri = webview.asWebviewUri(vscode.Uri.file(resourcePath));
                return `<${tag} ${attribute}="${resourceUri}"`;
            });

        return html;
    }
}
```

#### Step 2.3: Refactor the `openMainPanel` Command

Now, go back to `src/extension.ts` (or `src/commandManager.ts` if you have it) and replace the old `createWebviewPanel` logic with a simple call to your new manager.

**File:** `src/extension.ts` (or `src/commandManager.ts`)
```typescript
// At the top of the file
import { WebviewManager } from './webviewManager';

// Inside the activate function or command registration
// ...

const openPanelDisposable = vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
    // This single line replaces all the previous panel creation logic
    WebviewManager.createOrShow(context.extensionUri);
});

// ...
```

### 3. Key Concepts in this Implementation

-   **Singleton Pattern**: The `currentPanel` static property ensures only one `WebviewManager` instance exists. The `createOrShow` static method is the single entry point for creating or revealing the panel.
-   **Lifecycle Management**: The `onDidDispose` event is critical. When the user closes the panel, we clean up by calling `dispose()` and, most importantly, setting `WebviewManager.currentPanel = undefined`. This allows a new panel to be created next time the command is run.
-   **Asset Path Rewriting**: The `_getHtmlForWebview` method is now the single source of truth for loading the UI. It reads the `index.html` from the SvelteKit build output and uses a regular expression to find all `src` and `href` attributes. It then uses `webview.asWebviewUri` to convert the file paths into special URIs that the webview can securely access. This is the standard and required way to load local resources.

### 4. Verification

1.  Run the extension from the debug panel.
2.  Execute the `Code Context Engine: Open Main Panel` command from the command palette.
3.  The webview should open and display your SvelteKit application.
4.  Run the command again. A new panel should **not** be created; the existing one should just regain focus.
5.  Close the panel and run the command one more time. A new panel should be created successfully.
6.  Check the webview developer tools (`Developer: Open Webview Developer Tools`) to ensure there are no errors related to loading scripts or stylesheets.
</file>

<file path="docs/completed/svelte-continue/implementation_sub_sprint_4_message_routing_state.md">
# Implementation Guidance: Sub-Sprint 4 - Message Routing & State

**Objective:** To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

---

### 1. Overview

This guide covers the final refactoring steps to fully decouple the extension's components. We will create two classes:
1.  `StateManager`: A simple, centralized store for global extension state, such as whether an indexing operation is currently active.
2.  `MessageRouter`: A dedicated class whose sole responsibility is to listen for messages from a webview and route them to the appropriate service.

This separation of concerns makes the codebase cleaner, more testable, and easier to maintain.

### 2. Step-by-Step Implementation

#### Step 2.1: Create the `StateManager`

This class will be a simple property bag with getters and setters to prevent direct modification of state properties from outside the class.

**File:** `src/stateManager.ts` (New File)
```typescript
/**
 * Manages the global state of the extension.
 */
export class StateManager {
    private _isIndexing = false;
    private _isBackendHealthy = true; // Example of another potential state

    // --- isIndexing State ---

    public isIndexing(): boolean {
        return this._isIndexing;
    }

    public setIndexing(state: boolean): void {
        this._isIndexing = state;
        // In the future, we could add an event emitter here to notify other parts
        // of the extension about state changes.
    }

    // --- isBackendHealthy State ---

    public isBackendHealthy(): boolean {
        return this._isBackendHealthy;
    }

    public setBackendHealthy(state: boolean): void {
        this._isBackendHealthy = state;
    }
}
```

#### Step 2.2: Instantiate `StateManager` in `ExtensionManager`

The `ExtensionManager` should create and hold the single instance of the `StateManager`.

**File:** `src/extensionManager.ts` (Modify)
```typescript
// Add the import
import { StateManager } from './stateManager';

export class ExtensionManager {
    public readonly stateManager: StateManager;
    // ... other properties

    constructor(context: vscode.ExtensionContext) {
        this.stateManager = new StateManager();
        // ... other initializations
    }

    // ...
}
```

#### Step 2.3: Create the `MessageRouter`

This class will listen for webview messages and delegate them. It requires access to the `ExtensionManager` to get to all the services and managers.

**File:** `src/messageRouter.ts` (New File)
```typescript
import * as vscode from 'vscode';
import { ExtensionManager } from './extensionManager';

/**
 * Handles all incoming messages from a webview and routes them to the appropriate service.
 */
export class MessageRouter {
    private _disposables: vscode.Disposable[] = [];

    constructor(
        private readonly _extensionManager: ExtensionManager,
        private readonly _webview: vscode.Webview
    ) {
        this._webview.onDidReceiveMessage(
            this._routeMessage, 
            this, 
            this._disposables
        );
    }

    private async _routeMessage(message: { command: string; [key: string]: any }) {
        const { command, ...rest } = message;

        // Example of using the StateManager as a guard
        if (command === 'startIndexing' && this._extensionManager.stateManager.isIndexing()) {
            this._webview.postMessage({
                command: 'indexingError',
                error: 'An indexing process is already running.'
            });
            return;
        }

        // The main switch statement for routing commands
        switch (command) {
            case 'startIndexing':
                // Delegate to the command manager or directly to the service
                vscode.commands.executeCommand('code-context-engine.startIndexing');
                break;

            case 'search':
                const searchManager = this._extensionManager.getSearchManager();
                await searchManager.performSearch(rest.query, this._webview);
                break;

            // ... add all other cases from the old switch statement

            default:
                console.warn(`Unknown command received: ${command}`);
        }
    }

    public dispose() {
        while (this._disposables.length) {
            const x = this._disposables.pop();
            if (x) {
                x.dispose();
            }
        }
    }
}
```

#### Step 2.4: Integrate `MessageRouter` into `WebviewManager`

Now, simplify the `WebviewManager` by removing the message handling logic and replacing it with an instantiation of the `MessageRouter`.

**File:** `src/webviewManager.ts` (Modify)
```typescript
// Add the new imports
import { MessageRouter } from './messageRouter';
import { ExtensionManager } from './extensionManager'; // Assuming you pass this in

export class WebviewManager {
    // ... (currentPanel, _panel, _extensionUri, _disposables)

    // The constructor should now accept the ExtensionManager
    private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri, extensionManager: ExtensionManager) {
        this._panel = panel;
        this._extensionUri = extensionUri;

        this._update();

        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

        // This is the key change: instantiate the router and let it handle messages.
        // The router will add its own disposables to this._disposables.
        const router = new MessageRouter(extensionManager, this._panel.webview);
        this._disposables.push(router);
    }

    // The createOrShow method will also need to accept the ExtensionManager
    public static createOrShow(extensionUri: vscode.Uri, extensionManager: ExtensionManager) {
        // ... (existing singleton logic)

        // Pass extensionManager to the constructor
        WebviewManager.currentPanel = new WebviewManager(panel, extensionUri, extensionManager);
    }
    
    // ... (rest of the class)
}
```

#### Step 2.5: Update a Service to Use the `StateManager`

Finally, update a service like `IndexingService` to report its status.

**File:** `src/indexing/indexingService.ts` (Modify)
```typescript
import { StateManager } from '../stateManager';

export class IndexingService {
    // The constructor now needs the StateManager
    constructor(private readonly stateManager: StateManager) {}

    public async startIndexing(/*...args...*/) {
        if (this.stateManager.isIndexing()) {
            console.warn("Indexing already in progress.");
            return;
        }

        this.stateManager.setIndexing(true);
        try {
            // ... your existing indexing logic ...
        } catch (error) {
            console.error("Indexing failed", error);
        } finally {
            // This `finally` block ensures the state is always reset, even if an error occurs.
            this.stateManager.setIndexing(false);
        }
    }
}
```

### 3. Verification

After this refactoring, run the extension and test all the webview functionality. The primary test is to confirm that a user cannot start a second indexing process while one is already running. The UI should receive and display the error message sent from the `MessageRouter`'s guard clause.
</file>

<file path="docs/completed/svelte-continue/prd.md">
<prd>Of course. You've correctly identified a significant architectural issue. Hardcoding the entire frontend within HTML strings in `extension.ts` is not scalable or maintainable.

My analysis of the `repomix-output.xml` file confirms your assessment. The functions `getWebviewContent`, `getSettingsWebviewContent`, and `getSetupWebviewContent` in `src/extension.ts` contain large blocks of HTML and inline JavaScript. The current `webview` directory has a basic webpack setup but isn't a proper SvelteKit application.

To address this technical debt, I've created a foundational PRD focused on migrating this inline HTML into a dedicated and properly structured SvelteKit application. This will establish a clean separation between the extension's backend logic and its frontend UI.

-----

### **New Document: PRD 1: Foundational - SvelteKit Webview Migration**

**1. Title & Overview**

  * **Project:** Code Context Engine - SvelteKit Webview Migration
  * **Summary:** This phase focuses on refactoring the entire frontend from inline HTML strings within `extension.ts` into a dedicated SvelteKit application in the `webview/` directory. This will create a clean, modern, and maintainable frontend architecture, enabling faster development and better organization of UI components and logic.
  * **Dependencies:** The existing `extension.ts` file serves as the functional specification for the UI.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Significantly improve developer velocity and maintainability for all future frontend work.
      * Establish a professional and scalable frontend architecture that separates UI from backend logic.
  * **Developer & System Success Metrics:**
      * All UI-related HTML and inline JavaScript is removed from `src/extension.ts`.
      * The `webview/` directory contains a fully functional SvelteKit application.
      * The SvelteKit application is built into a static `dist` or `build` directory.
      * The `extension.ts` file now only loads the `index.html` from the SvelteKit build output.
      * All previous UI functionality (buttons, inputs, status updates) is replicated in the new SvelteKit application and communicates with `extension.ts` via a standardized message-passing API.

-----

**3. User Personas**

  * **Frank (Frontend Developer):** Frank is currently unable to work efficiently because all UI code is tangled inside a TypeScript file. He needs a proper frontend development environment with Svelte components, state management, and a standard build process to create and iterate on the UI effectively.
  * **Alisha (Backend Developer):** Alisha wants to focus on the extension's core logic without having to modify large HTML strings in `extension.ts`. A clean separation allows her to work on the backend without impacting the UI, and vice-versa.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Migration** | **Sprint 1: SvelteKit Scaffolding & UI Components** | As Frank, I want to set up a new SvelteKit project in the `webview/` directory configured with a static adapter, so I have a proper foundation for the UI. | 1. The `webview/` directory is replaced with a new SvelteKit skeleton project.\<br/\>2. The project is configured to use `@sveltejs/adapter-static`.\<br/\>3. Fluent UI web components are installed as a dependency.\<br/\>4. The project can be successfully built using `npm run build`. | **2 Weeks** |
| | | As Frank, I want to recreate the three main UI views (Setup, Indexing, Query) as separate Svelte components based on the existing HTML in `extension.ts`. | 1. A `SetupView.svelte` component is created, replicating the database and provider selection UI.\<br/\>2. An `IndexingView.svelte` component is created with a progress bar and status text.\<br/\>3. A `QueryView.svelte` component is created with the search input and results area.\<br/\>4. A main `+page.svelte` or `ViewManager.svelte` component is created to conditionally render the correct view based on application state. | |
| **Phase 1: Migration** | **Sprint 2: Extension Integration & Communication** | As Alisha, I want to refactor `extension.ts` to load the SvelteKit application instead of generating inline HTML, so that the UI is fully decoupled. | 1. The `getWebviewContent` and similar functions in `extension.ts` are removed.\<br/\>2. A new, simpler function reads the `index.html` from the SvelteKit build directory.\<br/\>3. The function correctly rewrites asset paths (`/_app/...`) using `webview.asWebviewUri` to ensure JS and CSS load.\<br/\>4. The extension successfully loads and renders the SvelteKit application in the webview panel. | **2 Weeks** |
| | | As Frank, I want a standardized API client (`vscodeApi.ts`) in the SvelteKit app for communicating with the extension, so I don't have to use the global `acquireVsCodeApi` in every component. | 1. A `vscodeApi.ts` module is created that wraps `acquireVsCodeApi`.\<br/\>2. It provides simple `postMessage` and `onMessage` functions.\<br/\>3. The client handles request-response pairing using a unique `requestId` for asynchronous operations.\<br/\>4. All Svelte components use this new module for communication instead of the raw API. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** SvelteKit Scaffolding & UI Components (2 Weeks)
  * **Sprint 2:** Extension Integration & Communication (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The existing UI functionality described in the `extension.ts` HTML is the complete and desired feature set for the initial version.
  * **Risk:** The path rewriting logic to load SvelteKit's static assets (`/_app/...`) in a webview can be tricky and may require adjustments based on the SvelteKit version.
      * **Mitigation:** Dedicate a specific task to creating a robust path-rewriting function and test it thoroughly across different asset types (JS, CSS, fonts).
  * **Risk:** Migrating the inline JavaScript logic to a proper Svelte state management and message-passing system might reveal inconsistencies in the original implementation.
      * **Mitigation:** Create a clear mapping of all existing `postMessage` calls and event listeners before starting the Svelte implementation. Use a Svelte store for managing shared UI state.

-----

### **New Document: Sub-Sprint 1: SvelteKit Project Scaffolding**

**Objective:**
To replace the existing `webview/` content with a new, properly configured SvelteKit project and add the Fluent UI component library.

**Parent Sprint:**
PRD 1, Sprint 1: SvelteKit Scaffolding & UI Components

**Tasks:**

1.  **Clear Existing `webview/`:** Remove the current webpack-based content from the `webview/` directory.
2.  **Initialize SvelteKit:** Run `npm create svelte@latest webview` to scaffold a new SvelteKit "Skeleton project" with TypeScript support.
3.  **Install Static Adapter:** Add `@sveltejs/adapter-static` as a dev dependency.
4.  **Configure `svelte.config.js`:** Update the config file to use the static adapter, setting the output directory to `build` and the fallback to `index.html`.
5.  **Install Fluent UI:** Add `@fluentui/web-components` as a dependency.

**Acceptance Criteria:**

  * The `webview/` directory contains a clean SvelteKit project.
  * Running `npm run build` inside `webview/` successfully generates a static site in `webview/build/`.
  * Fluent UI is listed as a dependency.

**Dependencies:**

  * Node.js and npm installed.

**Timeline:**

  * **Start Date:** 2025-08-25
  * **End Date:** 2025-08-29

-----

### **New Document: Sub-Sprint 2: Recreate UI as Svelte Components**

**Objective:**
To build the three primary UI views as distinct Svelte components, replicating the functionality and layout from the original inline HTML.

**Parent Sprint:**
PRD 1, Sprint 1: SvelteKit Scaffolding & UI Components

**Tasks:**

1.  **Create View Components:** Create `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte` inside `webview/src/lib/components/`.
2.  **Translate HTML to Svelte:** For each component, translate the corresponding HTML structure from `extension.ts` into Svelte syntax, replacing standard HTML elements with Fluent UI components (e.g., `<fluent-button>`, `<fluent-progress-bar>`).
3.  **Create State Store:** Create a `viewStore.ts` to manage the current visible view (e.g., `'setup' | 'indexing' | 'query'`).
4.  **Create View Manager:** Build a main component (`+page.svelte`) that imports the three views and uses the state store to conditionally render the active one.

**Acceptance Criteria:**

  * The three core view components exist and contain the correct UI elements.
  * The application renders one of the three views based on the value in a central store.
  * The UI layout and elements closely match the original design specified in `extension.ts`.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2025-09-01
  * **End Date:** 2025-09-05

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - SvelteKit Scaffolding & UI Components

**Goal:** To establish the new SvelteKit frontend project and recreate the existing UI with modular components.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Clear and Re-initialize Project:** Delete the contents of `webview/` and run `npm create svelte@latest webview` to create a new SvelteKit project with TypeScript. | `webview/` |
| **1.2** |  To Do | **Install Static Adapter:** In the `webview/` directory, run `npm install -D @sveltejs/adapter-static`. | `webview/package.json` |
| **1.3** |  To Do | **Configure Static Build:** Modify `webview/svelte.config.js` to import and use `adapter-static`, setting the output to a `build` directory. | `webview/svelte.config.js` |
| **1.4** |  To Do | **Install Fluent UI:** In the `webview/` directory, run `npm install @fluentui/web-components`. | `webview/package.json` |
| **1.5** |  To Do | **Create State Store:** Create a new file `webview/src/lib/stores/viewStore.ts` and use Svelte's `writable` to manage the current view state. | `webview/src/lib/stores/viewStore.ts` |
| **1.6** |  To Do | **Create View Components:** Create the files `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte` in `webview/src/lib/components/`. | `webview/src/lib/components/` |
| **1.7** |  To Do | **Implement `SetupView` UI:** Replicate the setup form from `getSetupWebviewContent` in `extension.ts` using Fluent UI components. | `webview/src/lib/components/SetupView.svelte` |
| **1.8** |  To Do | **Implement `IndexingView` UI:** Replicate the progress bar UI from `getWebviewContent` in `extension.ts`. | `webview/src/lib/components/IndexingView.svelte` |
| **1.9** |  To Do | **Implement `QueryView` UI:** Replicate the search input and results area from `getWebviewContent` in `extension.ts`. | `webview/src/lib/components/QueryView.svelte` |
| **1.10**|  To Do | **Create Main Page:** In `webview/src/routes/+page.svelte`, import the view components and the store, and use an `{#if}` block to render the correct view based on the store's value. | `webview/src/routes/+page.svelte` |

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Extension Integration & Communication

**Goal:** To connect the new SvelteKit application to the extension backend and re-establish all communication logic.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Refactor `getWebviewContent`:** Remove the large HTML string from `getWebviewContent` in `extension.ts`. | `src/extension.ts` |
| **2.2** |  To Do | **Implement Static HTML Loading:** The new `getWebviewContent` should read `webview/build/index.html` using `fs.readFileSync`. | `src/extension.ts` |
| **2.3** |  To Do | **Implement Asset Path Rewriting:** In `getWebviewContent`, use a regular expression to find all `/_app/...` asset paths and replace them with the correct `webview.asWebviewUri` version. | `src/extension.ts` |
| **2.4** |  To Do | **Test Webview Loading:** Run the extension and confirm the SvelteKit application loads correctly, including all CSS and JavaScript assets. | `(Manual Test)` |
| **2.5** |  To Do | **Create `vscodeApi.ts`:** Create a new file `webview/src/lib/vscodeApi.ts` to wrap the `acquireVsCodeApi()` call. | `webview/src/lib/vscodeApi.ts` |
| **2.6** |  To Do | **Implement `postMessage` Wrapper:** In `vscodeApi.ts`, create a simple function that calls `vscode.postMessage(message)`. | `webview/src/lib/vscodeApi.ts` |
| **2.7** |  To Do | **Implement `onMessage` Wrapper:** In `vscodeApi.ts`, create a function that adds a listener to `window.addEventListener('message', ...)`. | `webview/src/lib/vscodeApi.ts` |
| **2.8** |  To Do | **Refactor Components to Use `vscodeApi`:** Update all Svelte components to import from `vscodeApi.ts` for all communication. | `webview/src/lib/components/*.svelte` |
| **2.9** |  To Do | **Re-implement "Start Database" Action:** Connect the button's `on:click` event in `SetupView.svelte` to send a `startDatabase` message using `vscodeApi.postMessage`. | `webview/src/lib/components/SetupView.svelte` |
| **2.10**|  To Do | **Re-implement `databaseStatus` Listener:** In `SetupView.svelte`, use `vscodeApi.onMessage` to listen for `databaseStatus` messages and update the UI accordingly. | `webview/src/lib/components/SetupView.svelte` |
| **2.11**|  To Do | **Verify End-to-End Communication:** Manually test that clicking the "Start Database" button in the Svelte UI correctly triggers the terminal command in the extension backend. | `(Manual Test)` |


Of course. Here is the final PRD to complete the technical debt and refactoring initiative.

-----

### **New Document: PRD 2: Advanced Refactoring - Webview & Communication**

**1. Title & Overview**

  * **Project:** Code Context Engine - Webview & Communication Refactoring
  * **Summary:** This phase completes the decoupling of `extension.ts` by creating dedicated managers for webview lifecycle and message routing. A `WebviewManager` will centralize the logic for creating, showing, and disposing of all webview panels. A `MessageRouter` will handle all communication between the webview and the extension's backend services, creating a clean and robust communication layer.
  * **Dependencies:** PRD 1 (Backend Decoupling & Refactoring) must be complete. The `ExtensionManager` and `CommandManager` should be in place.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Finalize the architectural refactoring to create a fully modular, scalable, and maintainable codebase.
      * Improve the reliability of the UI and its communication with the backend, leading to a better user experience.
  * **Developer & System Success Metrics:**
      * `extension.ts` is purely an activator and contains no direct webview or message handling logic.
      * All webview panel creation and management logic is consolidated within the `WebviewManager`.
      * The large `switch` statement for message handling is replaced by the `MessageRouter`, which cleanly delegates tasks to the appropriate services.
      * Adding a new webview or a new message command is a simple, low-risk operation that requires changes in only one or two focused files.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha can now add new commands and backend logic without ever needing to touch the UI or communication layers. Her work is isolated to the services she owns.
  * **Frank (Frontend Developer):** Frank works on the SvelteKit UI. He now has a single, predictable `MessageRouter` to interact with. He doesn't need to know which backend service implements a feature; he just sends a command, and the router handles the rest.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Refactoring** | **Sprint 3: Webview Management** | As a developer, I want to create a `WebviewManager` to handle the lifecycle of all webview panels so that UI creation logic is centralized and reusable. | 1. A new `WebviewManager` class is created. \<br/\> 2. All `vscode.window.createWebviewPanel` logic is moved from `extension.ts` (or `CommandManager`) into the `WebviewManager`. \<br/\> 3. The manager handles showing the main panel and the settings panel, ensuring only one of each can exist at a time. \<br/\> 4. The manager is responsible for panel disposal and is properly disposed of by the `ExtensionManager`. | **2 Weeks** |
| | | As Frank, I want the `WebviewManager` to be responsible for providing the correct HTML content so that the webview loading process is standardized. | 1. The logic for reading the `index.html` file from the `webview/dist` directory is moved into a private method in `WebviewManager`. \<br/\> 2. The method correctly replaces asset paths with `webview.asWebviewUri` to ensure CSS and JS files load correctly. \<br/\> 3. The `showMainPanel` and `showSettingsPanel` methods use this helper to set the panel's HTML. | |
| **Phase 2: Refactoring** | **Sprint 4: Communication & State Mgmt** | As a developer, I want to create a `MessageRouter` to handle all incoming messages from the webview so that communication logic is decoupled and clean. | 1. A new `MessageRouter` class is created. \<br/\> 2. The `onDidReceiveMessage` listener for each webview is set up to delegate to an instance of the `MessageRouter`. \<br/\> 3. The `MessageRouter`'s `routeMessage` method contains the `switch` statement that calls the appropriate service based on the message command. \<br/\> 4. The router sends results back to the webview with a consistent response format (e.g., `{ command, requestId, result, error }`). | **2 Weeks** |
| | | As Alisha, I want to introduce a basic `StateManager` to track the global state of the extension so that services don't need to communicate directly with each other for status updates. | 1. A new `StateManager` class is created to hold simple boolean flags (e.g., `isIndexing`, `isBackendHealthy`). \<br/\> 2. Services can update the state via the manager (e.g., `stateManager.setIndexing(true)`). \<br/\> 3. The `MessageRouter` can query the state to prevent conflicting actions (e.g., don't start a new index if `isIndexing` is true). | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 3:** Webview Management (2 Weeks)
  * **Sprint 4:** Communication & State Management (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The message-passing API between the webview and the extension is stable and performant enough for all communication needs.
  * **Risk:** Incorrectly managing panel/webview lifecycles in the `WebviewManager` could lead to memory leaks or "ghost" panels that are not properly disposed of.
      * **Mitigation:** Ensure that the `onDidDispose` event for every created panel is correctly handled and that all disposables are added to the extension's context subscriptions.
  * **Risk:** The `StateManager` could become a complex bottleneck if too much logic is added to it.
      * **Mitigation:** Keep the initial `StateManager` extremely simple, holding only essential, global boolean flags. Avoid putting business logic into the state manager itself; its only job is to store and retrieve state.

-----

### **New Document: Sub-Sprint 3: Centralized Webview Management**

**Objective:**
To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, cleaning up the command handlers and `extension.ts`.

**Parent Sprint:**
PRD 2, Sprint 3: Webview Management

**Tasks:**

1.  **Create `WebviewManager.ts`:** Develop the new class with a constructor that accepts the `vscode.ExtensionContext`.
2.  **Implement `showMainPanel`:** Create a method that contains the logic for creating and showing the main webview panel. It should ensure only one instance of the main panel can exist.
3.  **Implement `showSettingsPanel`:** Create a method that contains the logic for creating and showing the settings webview panel.
4.  **Implement `getWebviewContent`:** Create a private helper method that reads the `index.html`, prepares it with the correct URIs for webview assets, and returns the HTML string.
5.  **Refactor `CommandManager`:** Update the callbacks for the `openMainPanel` and `openSettings` commands to simply call the appropriate methods on the `WebviewManager` instance.

**Acceptance Criteria:**

  * All `vscode.window.createWebviewPanel` calls are located exclusively within `WebviewManager.ts`.
  * The `openMainPanel` and `openSettings` commands correctly open their respective UIs.
  * Attempting to open a panel that is already open simply brings the existing panel into focus.

**Dependencies:**

  * `CommandManager` from PRD 1 must be implemented.

**Timeline:**

  * **Start Date:** 2025-09-22
  * **End Date:** 2025-10-03

-----

### **New Document: Sub-Sprint 4: Message Routing & State**

**Objective:**
To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

**Parent Sprint:**
PRD 2, Sprint 4: Communication & State Mgmt

**Tasks:**

1.  **Create `StateManager.ts`:** Develop a simple class with private properties (e.g., `_isIndexing = false`) and public getter/setter methods.
2.  **Create `MessageRouter.ts`:** Develop the class with a constructor that accepts the `ExtensionManager` (to access all services and managers) and the `vscode.Webview`. The constructor will set up the `onDidReceiveMessage` listener.
3.  **Implement `routeMessage` method:** Move the message-handling `switch` statement from `extension.ts` into this private method within the `MessageRouter`.
4.  **Integrate `StateManager`:** In the `MessageRouter`, check the state before delegating actions. For example: `if (this.stateManager.isIndexing) { /* return error */ }`.
5.  **Update Services:** Modify services like `IndexingService` to update the central state (e.g., `this.stateManager.setIndexing(true)` at the start and `false` at the end).
6.  **Integrate `MessageRouter`:** In `WebviewManager`, when a panel is created, instantiate a `MessageRouter` for it, passing in the necessary dependencies.

**Acceptance Criteria:**

  * The `onDidReceiveMessage` listener in `WebviewManager` is a single line that instantiates and uses the `MessageRouter`.
  * The `MessageRouter` correctly routes commands to the appropriate services.
  * Attempting to start a new indexing job while one is already running is gracefully rejected with an error message sent back to the UI.

**Dependencies:**

  * Sub-Sprint 3 must be complete.

**Timeline:**

  * **Start Date:** 2025-10-06
  * **End Date:** 2025-10-17

-----

### **New Document: tasklist\_sprint\_03.md**

# Task List: Sprint 3 - Webview Management

**Goal:** To centralize all webview creation and lifecycle logic into a dedicated `WebviewManager` class.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Create `WebviewManager.ts`:** Create the new file and the `WebviewManager` class structure with a constructor and a `dispose` method. | `src/webviewManager.ts` (New) |
| **3.2** |  To Do | **Implement `getWebviewContent`:** Create a private helper method that takes a webview instance, reads `webview/dist/index.html`, replaces asset paths using `webview.asWebviewUri`, and returns the final HTML string. | `src/webviewManager.ts` |
| **3.3** |  To Do | **Implement `showMainPanel`:** Create a public method that checks if a main panel instance already exists. If not, it calls `vscode.window.createWebviewPanel`, sets its HTML using the helper, and stores the instance. If it exists, it calls `.reveal()`. | `src/webviewManager.ts` |
| **3.4** |  To Do | **Implement `showSettingsPanel`:** Create a public method with the same logic as `showMainPanel`, but for the settings UI, using a different panel ID and title. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Handle Panel Disposal:** In the `show...` methods, add the `onDidDispose` listener to the created panel to nullify the stored instance variable (e.g., `this.mainPanel = undefined`). | `src/webviewManager.ts` |
| **3.6** |  To Do | **Update `ExtensionManager`:** Instantiate the `WebviewManager` in the `ExtensionManager`'s constructor. | `src/extensionManager.ts` |
| **3.7** |  To Do | **Refactor `CommandManager`:** Change the `openMainPanel` and `openSettings` command callbacks to call `extensionManager.webviewManager.showMainPanel()` and `showSettingsPanel()` respectively. | `src/commandManager.ts` |

-----

### **New Document: tasklist\_sprint\_04.md**

# Task List: Sprint 4 - Communication & State Mgmt

**Goal:** To formalize the webview communication layer with a `MessageRouter` and centralize global state with a `StateManager`.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `StateManager.ts`:** Create the new file and a simple `StateManager` class. Add a private boolean `_isIndexing` and public `isIndexing()` getter and `setIndexing(state: boolean)` setter. | `src/stateManager.ts` (New) |
| **4.2** |  To Do | **Create `MessageRouter.ts`:** Create the new file and the `MessageRouter` class. Its constructor will accept the `ExtensionManager` and `vscode.Webview`. | `src/messageRouter.ts` (New) |
| **4.3** |  To Do | **Implement `routeMessage`:** Move the message handling `switch` statement into a private `async routeMessage` method in `MessageRouter`. | `src/messageRouter.ts` |
| **4.4** |  To Do | **Integrate State Check:** In `routeMessage`, before the `startIndexing` case, add a check: `if (this.extensionManager.stateManager.isIndexing()) { ... post error message ... }`. | `src/messageRouter.ts` |
| **4.5** |  To Do | **Update `IndexingService`:** Inject the `StateManager` instance into the `IndexingService`. Call `this.stateManager.setIndexing(true)` at the beginning of `startIndexing` and `false` in a `finally` block at the end. | `src/indexing/indexingService.ts` |
| **4.6** |  To Do | **Instantiate `MessageRouter`:** In `WebviewManager`, when a panel is created, remove the old `onDidReceiveMessage` logic and replace it with `new MessageRouter(this.extensionManager, this.mainPanel.webview)`. | `src/webviewManager.ts` |
| **4.7** |  To Do | **Instantiate `StateManager`:** In `ExtensionManager`, create a public instance of the `StateManager` so it can be accessed by other services. | `src/extensionManager.ts` |
| **4.8** |  To Do | **Update Service Constructors:** Update the constructors of services (like `IndexingService`) that now need the `StateManager`, and update the instantiation logic in `ExtensionManager`. | `src/extensionManager.ts`, `src/indexing/indexingService.ts` |

This completes the full set of PRDs for the refactoring initiative. You now have a comprehensive plan to transform your extension's architecture into a more robust, maintainable, and scalable system.</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/completed/svelte-continue/tasklist_sprint_01.md">
# Task List: Sprint 01 - SvelteKit Scaffolding & UI Components

**Goal:** To replace the legacy webview implementation with a new, properly structured SvelteKit application and recreate the core UI views as modular components.

**Methodology:** These tasks are sequential. Each step should be completed before moving to the next. TDD is encouraged: for logic-heavy parts like the state store, consider writing a test first.

---

### **Part 1: Project Scaffolding**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Backup & Clean `webview` Directory:** Before deleting, make a backup of the existing `webview/` directory to another location, then delete all contents within `webview/`. | `webview/` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** In the root directory, run `npm create svelte@latest webview`. Select the `Skeleton project` template and choose `Yes` for TypeScript support. | `webview/` (New project) |
| **1.3** |  To Do | **Install Static Adapter:** `cd` into the `webview` directory. Run `npm install -D @sveltejs/adapter-static`. This is required to build the SvelteKit app into static files the extension can load. | `webview/package.json` |
| **1.4** |  To Do | **Configure Static Adapter:** Modify `webview/svelte.config.js` to import and use the static adapter. Set the output `pages` and `assets` directory to `build` and set `fallback` to `index.html`. | `webview/svelte.config.js` |
| **1.5** |  To Do | **Install Fluent UI Components:** In the `webview/` directory, run `npm install @fluentui/web-components` to add the UI component library. | `webview/package.json` |
| **1.6** |  To Do | **Verify Build:** In the `webview/` directory, run `npm run build`. Ensure a `build` directory is created inside `webview/` and that it contains an `index.html` file. | `webview/build/` |

---

### **Part 2: UI Component Creation**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.7** |  To Do | **Create View State Store:** Create a new file for a Svelte writable store to manage the currently active view. The default value should be `'setup'`. | `webview/src/lib/stores/viewStore.ts` (New) |
| **1.8** |  To Do | **Create `SetupView` Component:** Create the file for the Setup view. Copy the HTML structure from the `getSetupWebviewContent` function in `src/extension.ts` and convert it to Svelte syntax using Fluent UI components. | `webview/src/lib/components/SetupView.svelte` (New) |
| **1.9** |  To Do | **Create `IndexingView` Component:** Create the file for the Indexing view. Replicate the progress bar and status text UI from `getWebviewContent` in `src/extension.ts`. | `webview/src/lib/components/IndexingView.svelte` (New) |
| **1.10**|  To Do | **Create `QueryView` Component:** Create the file for the Query view. Replicate the search input and results area from `getWebviewContent` in `src/extension.ts`. | `webview/src/lib/components/QueryView.svelte` (New) |
| **1.11**|  To Do | **Create Main Page Layout:** In the main Svelte page, import the three view components and the `viewStore`. Use an `{#if}` block to conditionally render the correct view based on the store's value. | `webview/src/routes/+page.svelte` |
| **1.12**|  To Do | **Verify View Switching:** Run the dev server with `npm run dev` in `webview/`. Open the browser console and manually set the store's value (e.g., `(await import('./src/lib/stores/viewStore.ts')).currentView.set('query')`) to confirm the view changes. | `(Manual Test)` |
</file>

<file path="docs/completed/svelte-continue/tasklist_sprint_02.md">
# Task List: Sprint 02 - Extension Integration & Communication

**Goal:** To decouple the extension from the old inline HTML by loading the new SvelteKit application into the webview and establishing a robust, standardized communication channel between the extension and the UI.

**Methodology:** These tasks are sequential. The focus is on refactoring the extension's backend to serve the static UI and creating a clean API for frontend-backend communication.

---

### **Part 1: Loading the SvelteKit Application**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Remove Old HTML Generation:** In `src/extension.ts`, delete the entire `getWebviewContent`, `getSettingsWebviewContent`, and `getSetupWebviewContent` functions. | `src/extension.ts` |
| **2.2** |  To Do | **Create New `getWebviewContent`:** Create a new, single `getWebviewContent` function that takes the `webview` and `extensionUri` as arguments. | `src/extension.ts` |
| **2.3** |  To Do | **Read `index.html`:** Inside the new function, use `fs.readFileSync` to read the contents of `webview/build/index.html`. | `src/extension.ts` |
| **2.4** |  To Do | **Implement Asset Path Rewriting:** Use `webview.asWebviewUri` to generate correct, secure URIs for all JS and CSS assets referenced in the `index.html`. A regular expression is best for finding all `src` and `href` attributes. | `src/extension.ts` |
| **2.5** |  To Do | **Update Panel Creation:** In the `openMainPanel` command logic, replace the old call to `getWebviewContent` with a call to the new one. | `src/extension.ts` |
| **2.6** |  To Do | **Verify UI Loading:** Run the extension and open the main panel. The SvelteKit UI should load correctly. Use the webview developer tools to verify there are no 404 errors for assets. | `(Manual Test)` |

---

### **Part 2: Standardized Communication API**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.7** |  To Do | **Create `vscodeApi` Wrapper:** Create a new file to encapsulate the `acquireVsCodeApi()` call. This avoids calling it in every component and provides a single, typed interface for communication. | `webview/src/lib/vscodeApi.ts` (New) |
| **2.8** |  To Do | **Implement `postMessage` Wrapper:** In `vscodeApi.ts`, export a function `postMessage(command, data)` that calls `vscode.postMessage({ command, ...data })`. | `webview/src/lib/vscodeApi.ts` |
| **2.9** |  To Do | **Implement `onMessage` Wrapper:** In `vscodeApi.ts`, export a function `onMessage(callback)` that adds a listener to `window.addEventListener('message', ...)` and handles routing messages to the provided callback. | `webview/src/lib/vscodeApi.ts` |
| **2.10**|  To Do | **Refactor Components to Use `vscodeApi`:** Go through all Svelte components (`SetupView`, etc.) and replace any direct `postMessage` or `addEventListener` calls with the new wrapper functions from `vscodeApi.ts`. | `webview/src/lib/components/*.svelte` |
| **2.11**|  To Do | **Re-implement "Start Database" Action:** In `SetupView.svelte`, ensure the button's `on:click` event calls `postMessage('startDatabase', { ... })` using the new API wrapper. | `webview/src/lib/components/SetupView.svelte` |
| **2.12**|  To Do | **Re-implement `databaseStatus` Listener:** In `SetupView.svelte`, use the `onMessage` wrapper to listen for `databaseStatus` messages from the extension and update the UI accordingly. | `webview/src/lib/components/SetupView.svelte` |
| **2.13**|  To Do | **Verify End-to-End Communication:** Manually test that clicking the "Start Database" button in the UI correctly triggers the `handleStartDatabase` function in `extension.ts` and that the UI updates with the response. | `(Manual Test)` |
</file>

<file path="docs/completed/svelte-continue/tasklist_sprint_03.md">
# Task List: Sprint 03 - Webview Management

**Goal:** To centralize all webview creation and lifecycle logic into a dedicated `WebviewManager` class, fully decoupling panel management from command handlers and the main extension file.

**Methodology:** This sprint is a pure refactoring effort. The external behavior of the extension should not change, but the internal architecture will be significantly cleaner. Each step builds on the previous one.

---

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Create `WebviewManager.ts` File:** Create the new file and a `WebviewManager` class shell with a private constructor, a `dispose` method, and a public static `currentPanel` property. | `src/webviewManager.ts` (New) |
| **3.2** |  To Do | **Implement `createOrShow` Static Method:** Add a public static `createOrShow` method. This method will contain the singleton logic: if `currentPanel` exists, call `.reveal()` on it; otherwise, create a new `WebviewPanel` and a new `WebviewManager` instance. | `src/webviewManager.ts` |
| **3.3** |  To Do | **Move `getWebviewContent` Logic:** Move the `getWebviewContent` function (created in Sprint 2) into `WebviewManager` as a private helper method (`_getHtmlForWebview`). | `src/webviewManager.ts`, `src/extension.ts` |
| **3.4** |  To Do | **Implement Panel Disposal:** In the `WebviewManager` constructor, add an `onDidDispose` listener to the panel. This listener must call the manager's `dispose` method, which should nullify the static `currentPanel` reference and clean up any other disposables. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Instantiate in `ExtensionManager`:** In `src/extensionManager.ts`, add a new public property `webviewManager` and instantiate your new `WebviewManager` in the constructor. | `src/extensionManager.ts` |
| **3.6** |  To Do | **Refactor `openMainPanel` Command:** In `src/commandManager.ts` (or `extension.ts`), find the `openMainPanel` command registration. Replace its entire body with a single call to `this.extensionManager.webviewManager.createOrShow()`. | `src/commandManager.ts` |
| **3.7** |  To Do | **Refactor `openSettingsPanel` Command:** Do the same for the `openSettingsPanel` command, creating a corresponding `createOrShowSettings` method in the `WebviewManager` if necessary to handle a separate settings panel singleton. | `src/commandManager.ts`, `src/webviewManager.ts` |
| **3.8** |  To Do | **Verify Functionality:** Thoroughly test opening, closing, and re-opening both the main and settings panels. Confirm that the singleton pattern is working correctly and that no new panels are created when one is already open. | `(Manual Test)` |
</file>

<file path="docs/completed/svelte-continue/tasklist_sprint_04.md">
# Task List: Sprint 04 - Communication & State Management

**Goal:** To formalize the webview communication layer with a `MessageRouter` and centralize global application state with a `StateManager`, completing the major architectural refactoring.

**Methodology:** This sprint finalizes the separation of concerns. The `StateManager` introduces a predictable state container, while the `MessageRouter` decouples message handling from the UI lifecycle.

---

### **Part 1: State Management**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `StateManager.ts` File:** Create the new file and a `StateManager` class. Add a private boolean `_isIndexing` property with a default of `false`. | `src/stateManager.ts` (New) |
| **4.2** |  To Do | **Add State Getters/Setters:** In `StateManager`, create a public getter `isIndexing()` and a public setter `setIndexing(state: boolean)`. | `src/stateManager.ts` |
| **4.3** |  To Do | **Instantiate `StateManager`:** In `ExtensionManager`, create and expose a public, readonly instance of the `StateManager`. | `src/extensionManager.ts` |
| **4.4** |  To Do | **Inject `StateManager` into `IndexingService`:** Update the `IndexingService` constructor to accept the `StateManager`. Update its instantiation in `ExtensionManager` to pass the manager instance. | `src/indexing/indexingService.ts`, `src/extensionManager.ts` |
| **4.5** |  To Do | **Update `IndexingService` Logic:** In `IndexingService`, call `this.stateManager.setIndexing(true)` at the very beginning of the `startIndexing` method and `this.stateManager.setIndexing(false)` inside a `finally` block to ensure it's always reset. | `src/indexing/indexingService.ts` |

---

### **Part 2: Message Routing**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.6** |  To Do | **Create `MessageRouter.ts` File:** Create the new file and a `MessageRouter` class. The constructor should accept the `ExtensionManager` and the `vscode.Webview` instance. | `src/messageRouter.ts` (New) |
| **4.7** |  To Do | **Implement Message Listener:** In the `MessageRouter` constructor, subscribe to the `webview.onDidReceiveMessage` event and bind it to a private `_routeMessage` method. | `src/messageRouter.ts` |
| **4.8** |  To Do | **Move Message `switch` Statement:** Move the entire `switch` statement for message handling from `extension.ts` into the `_routeMessage` method. | `src/messageRouter.ts`, `src/extension.ts` |
| **4.9** |  To Do | **Integrate `MessageRouter` into `WebviewManager`:** In the `WebviewManager` constructor, remove the old `onDidReceiveMessage` logic and replace it with `new MessageRouter(this.extensionManager, this.mainPanel.webview)`. | `src/webviewManager.ts` |
| **4.10**|  To Do | **Integrate State Check:** In the `MessageRouter`'s `_routeMessage` method, add a guard clause at the top of the `startIndexing` case: `if (this.extensionManager.stateManager.isIndexing()) { ... post error message ...; return; }`. | `src/messageRouter.ts` |
| **4.11**|  To Do | **Verify Full Functionality:** Test all webview interactions. Specifically, start an indexing job and immediately try to start another. Verify the second attempt is gracefully rejected with an error message in the UI. | `(Manual Test)` |
</file>

<file path="docs/todo/missing2/backlog_sprint_1_sveltekit_migration_componentization.md">
### User Story 1: SvelteKit Project Setup
**As a** Frontend Developer, **I want to** replace the current webview implementation with a SvelteKit application configured with a static adapter, **so that** I have a proper foundation for the UI.

**Actions to Undertake:**
1.  **Filepath**: `webview/`
    -   **Action**: Backup the existing `webview/` directory to `webview-backup-YYYYMMDD-HHMMSS`.
    -   **Implementation**: Use shell command: `mv webview webview-backup-$(date +%Y%m%d-%H%M%S)`
    -   **Imports**: N/A
2.  **Filepath**: `webview/` (new)
    -   **Action**: Initialize a new SvelteKit project.
    -   **Implementation**: Run `npm create svelte@latest webview` and select "Skeleton project", "TypeScript", "ESLint", and "Prettier".
    -   **Imports**: N/A
3.  **Filepath**: `webview/package.json`
    -   **Action**: Install necessary dependencies for static site generation and UI components.
    -   **Implementation**: In the `webview` directory, run `npm install -D @sveltejs/adapter-static` and `npm install @fluentui/web-components`.
    -   **Imports**: N/A
4.  **Filepath**: `webview/svelte.config.js`
    -   **Action**: Configure the SvelteKit project to use the static adapter and output to a `build` directory.
    -   **Implementation**: 
        ```javascript
        import adapter from '@sveltejs/adapter-static';

        /** @type {import('@sveltejs/kit').Config} */
        const config = {
          kit: {
            adapter: adapter({
              pages: 'build',
              assets: 'build',
              fallback: 'index.html',
              precompress: false
            }),
            prerender: {
              entries: ['*']
            }
          }
        };

        export default config;
        ```
    -   **Imports**: `import adapter from '@sveltejs/adapter-static';`
5.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: Update the `getWebviewContent` method to load the `index.html` from the new SvelteKit build output and correctly rewrite asset paths.
    -   **Implementation**: Modify the method to point to `webview/build/index.html` and use `webview.asWebviewUri` for all local script and link tags.
    -   **Imports**: `import * as path from 'path';`, `import * as fs from 'fs';`

**Acceptance Criteria:**
-   The `webview/` directory is a valid SvelteKit project.
-   Running `npm run build` inside `webview/` generates static files in a `webview/build` directory.
-   The extension's main webview panel loads the `index.html` from the `build` directory without errors.
-   All CSS and JS assets are loaded correctly in the webview.

**Testing Plan:**
-   **Test Case 1**: Run `npm run build` in `webview/` and verify the `build` directory is created with `index.html` and an `_app` subdirectory.
-   **Test Case 2**: Launch the VS Code extension and open the main panel. Verify the default SvelteKit welcome page is displayed.
-   **Test Case 3**: Use VS Code's developer tools to check the webview's console for any 404 errors related to assets.

---

### User Story 2: UI Componentization
**As a** Frontend Developer, **I want to** recreate the `Setup`, `Indexing`, and `Query` views as modular Svelte components, **so that** the UI is organized and state-driven.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/stores/viewStore.ts` (New File)
    -   **Action**: Create a Svelte store to manage which view is currently active.
    -   **Implementation**: 
        ```typescript
        import { writable } from 'svelte/store';

        export type View = 'setup' | 'indexing' | 'query';

        export const currentView = writable<View>('setup');
        ```
    -   **Imports**: `import { writable } from 'svelte/store';`
2.  **Filepath**: `webview/src/lib/components/SetupView.svelte` (New File)
    -   **Action**: Create a placeholder component for the Setup view.
    -   **Implementation**: `<div id="setup-view"><h1>Setup</h1><!-- Configuration form will go here --></div>`
    -   **Imports**: N/A
3.  **Filepath**: `webview/src/lib/components/IndexingView.svelte` (New File)
    -   **Action**: Create a placeholder component for the Indexing view.
    -   **Implementation**: `<div id="indexing-view"><h1>Indexing Progress</h1><!-- Progress bar and logs will go here --></div>`
    -   **Imports**: N/A
4.  **Filepath**: `webview/src/lib/components/QueryView.svelte` (New File)
    -   **Action**: Create a placeholder component for the Query view.
    -   **Implementation**: `<div id="query-view"><h1>Context Query</h1><!-- Query input and results will go here --></div>`
    -   **Imports**: N/A
5.  **Filepath**: `webview/src/routes/+page.svelte`
    -   **Action**: Implement the main page to conditionally render the active view based on the `viewStore`.
    -   **Implementation**:
        ```html
        <script lang="ts">
          import { currentView } from '$lib/stores/viewStore';
          import SetupView from '$lib/components/SetupView.svelte';
          import IndexingView from '$lib/components/IndexingView.svelte';
          import QueryView from '$lib/components/QueryView.svelte';
        </script>

        <main>
          {#if $currentView === 'setup'}
            <SetupView />
          {:else if $currentView === 'indexing'}
            <IndexingView />
          {:else if $currentView === 'query'}
            <QueryView />
          {/if}
        </main>
        ```
    -   **Imports**: `import { currentView } from '$lib/stores/viewStore';`, etc.

**Acceptance Criteria:**
-   `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte` files are created.
-   A `viewStore.ts` file exists and exports a writable Svelte store.
-   The main page (`+page.svelte`) correctly displays the `SetupView` component by default.
-   Changing the value of the `currentView` store programmatically causes the displayed component to change.

**Testing Plan:**
-   **Test Case 1**: Verify the `SetupView` is shown when the webview first loads.
-   **Test Case 2**: Use browser developer tools to execute `$currentView.set('query')` in the console and verify the `QueryView` component is rendered.
-   **Test Case 3**: Ensure no console errors appear when switching between views.
</file>

<file path="docs/todo/missing2/backlog_sprint_2_intuitive_settings_diagnostics_ui.md">
### User Story 1: Interactive Configuration UI
**As a** developer (Devin), **I want** a single, intuitive setup page that validates my system and lets me configure and test my database and provider connections in one place, **so that** I can be confident my setup is correct before starting a long indexing process.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/ValidatedInput.svelte` (New File)
    -   **Action**: Create a reusable Svelte component for form inputs that provides real-time validation feedback.
    -   **Implementation**:
        ```html
        <script lang="ts">
          export let value: string;
          export let label: string;
          export let validator: (val: string) => string | null;
          let error: string | null = null;

          function validate() {
            error = validator(value);
          }
        </script>

        <div>
          <label>{label}</label>
          <input bind:value on:blur={validate} />
          {#if error}
            <p class="error">{error}</p>
          {/if}
        </div>
        ```
    -   **Imports**: N/A
2.  **Filepath**: `webview/src/lib/components/ConnectionTester.svelte` (New File)
    -   **Action**: Create a component that can test a given configuration and display the status (success, error, latency).
    -   **Implementation**:
        ```html
        <script lang="ts">
          import { onMount } from 'svelte';

          export let testFunction: () => Promise<{ok: boolean, message: string, latency?: number}>;
          let status: 'idle' | 'testing' | 'success' | 'error' = 'idle';
          let resultMessage: string = '';

          async function runTest() {
            status = 'testing';
            const result = await testFunction();
            status = result.ok ? 'success' : 'error';
            resultMessage = result.message + (result.latency ? ` (${result.latency}ms)` : '');
          }
        </script>

        <button on:click={runTest} disabled={status === 'testing'}>
          Test Connection
        </button>
        {#if status === 'success' || status === 'error'}
          <p class={status}>{resultMessage}</p>
        {/if}
        ```
    -   **Imports**: `import { onMount } from 'svelte';`
3.  **Filepath**: `webview/src/lib/components/SetupView.svelte`
    -   **Action**: Enhance the `SetupView` to use the new `ValidatedInput` and `ConnectionTester` components for database and provider configuration.
    -   **Implementation**: Import and integrate the new components within the setup form, binding them to configuration stores and backend test functions.
    -   **Imports**: `import ValidatedInput from './ValidatedInput.svelte';`, `import ConnectionTester from './ConnectionTester.svelte';`

**Acceptance Criteria:**
-   The `SetupView` contains input fields for database connection string and provider API keys.
-   Input fields show validation errors on blur if the format is incorrect (e.g., invalid URL).
-   A "Test Connection" button exists for the database and embedding provider.
-   Clicking the test button provides visual feedback (e.g., "Success", "Error: Connection refused").

**Testing Plan:**
-   **Test Case 1**: Enter an invalid URL in the database connection string field and verify an error message appears.
-   **Test Case 2**: With a valid but incorrect database URL, click "Test Connection" and verify a connection error is displayed.
-   **Test Case 3**: With a correct database URL, click "Test Connection" and verify a success message and latency are shown.

---

### User Story 2: Automated System Prerequisite Checks
**As a** developer (Devin), **I want** the extension to automatically check my system for prerequisites like Docker before I start the setup, **so that** I know if my environment is ready.

**Actions to Undertake:**
1.  **Filepath**: `src/validation/systemValidator.ts` (New File)
    -   **Action**: Create a new service in the extension backend to check for system prerequisites.
    -   **Implementation**:
        ```typescript
        import { exec } from 'child_process';

        export class SystemValidator {
          public async checkDocker(): Promise<{installed: boolean, version: string}> {
            return new Promise((resolve) => {
              exec('docker --version', (error, stdout) => {
                if (error) {
                  return resolve({ installed: false, version: '' });
                }
                resolve({ installed: true, version: stdout.trim() });
              });
            });
          }
        }
        ```
    -   **Imports**: `import { exec } from 'child_process';`
2.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: Add a new message handler to expose the `SystemValidator`'s functionality to the webview.
    -   **Implementation**: Add a case for `validateSystem` that calls the `systemValidator.checkAll()` method and posts the results back to the webview.
    -   **Imports**: `import { SystemValidator } from './validation/systemValidator';`
3.  **Filepath**: `webview/src/lib/components/SystemValidation.svelte` (New File)
    -   **Action**: Create a UI component to display the results of the system validation checks.
    -   **Implementation**: The component will message the backend on mount to get validation status and display a list of checks and their results (e.g., "Docker: Found (version 20.10.7)").
    -   **Imports**: `import { onMount } from 'svelte';`
4.  **Filepath**: `webview/src/lib/components/SetupView.svelte`
    -   **Action**: Integrate the `SystemValidation` component at the top of the `SetupView`.
    -   **Implementation**: `<SystemValidation />`
    -   **Imports**: `import SystemValidation from './SystemValidation.svelte';`

**Acceptance Criteria:**
-   A `SystemValidator.ts` service exists in the backend.
-   When the `SetupView` loads, it automatically displays a list of prerequisite checks (e.g., Docker).
-   The UI correctly shows whether each prerequisite is met or not.

**Testing Plan:**
-   **Test Case 1**: On a machine with Docker installed, load the `SetupView` and verify it shows a success status for Docker.
-   **Test Case 2**: On a machine without Docker installed, load the `SetupView` and verify it shows a failure/warning status for Docker.
</file>

<file path="docs/todo/missing2/backlog_sprint_3_advanced_search_ui_logic.md">
### User Story 1: Advanced Search Controls
**As a** developer (Devin), **I want** UI controls to specify the number of search results and to choose whether to include file content, **so that** I can fine-tune my queries to get the most relevant information.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/QueryView.svelte`
    -   **Action**: Add a number input for "Max Results" and a checkbox for "Include file content" to the search form.
    -   **Implementation**:
        ```html
        <script lang="ts">
          let maxResults = 20;
          let includeContent = false;
          // ... existing script
        </script>

        <form on:submit|preventDefault={runQuery}>
          <!-- existing query input -->
          <div class="controls">
            <label>Max Results: <input type="number" bind:value={maxResults} min="1" max="100" /></label>
            <label><input type="checkbox" bind:checked={includeContent} /> Include file content</label>
          </div>
          <button type="submit">Query</button>
        </form>
        ```
    -   **Imports**: N/A
2.  **Filepath**: `webview/src/lib/components/QueryView.svelte`
    -   **Action**: Update the `runQuery` function to include the new control values in the message sent to the backend.
    -   **Implementation**:
        ```typescript
        function runQuery() {
          vscode.postMessage({
            command: 'queryContext',
            payload: {
              query: searchQuery,
              maxResults: maxResults,
              includeContent: includeContent
            }
          });
        }
        ```
    -   **Imports**: N/A

**Acceptance Criteria:**
-   The search UI has a number input to limit results and a checkbox to include file content.
-   The values from these controls are successfully sent to the backend when a query is executed.
-   The backend respects these values when returning results.

**Testing Plan:**
-   **Test Case 1**: Set "Max Results" to 5, run a query, and verify that no more than 5 file results are returned.
-   **Test Case 2**: Uncheck "Include file content", run a query, and verify the XML output contains `<file>` tags with no content inside.
-   **Test Case 3**: Check "Include file content", run a query, and verify the XML output contains file content wrapped in CDATA sections.

---

### User Story 2: Backend Result Deduplication
**As a** backend developer (Alisha), **I want** the backend to process search results to return only unique file paths, **so that** the user isn't shown duplicate entries for the same file.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Modify the `queryContext` method signature to accept `maxResults` and `includeContent` parameters.
    -   **Implementation**: `public async queryContext(query: string, maxResults: number, includeContent: boolean): Promise<QueryResult[]>`
    -   **Imports**: N/A
2.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Implement the core deduplication logic within `queryContext`.
    -   **Implementation**:
        ```typescript
        const rawResults = await this.qdrantService.search(query, { limit: maxResults * 5 }); // Fetch more to have enough for deduplication
        const uniqueFiles = new Map<string, QueryResult>();

        for (const result of rawResults) {
          const existing = uniqueFiles.get(result.filePath);
          if (!existing || result.score > existing.score) {
            uniqueFiles.set(result.filePath, result);
          }
        }
        ```
    -   **Imports**: `QueryResult` type if not already imported.
3.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Sort the unique results by score, limit them, and conditionally read file content.
    -   **Implementation**:
        ```typescript
        let finalResults = Array.from(uniqueFiles.values())
          .sort((a, b) => b.score - a.score)
          .slice(0, maxResults);

        if (includeContent) {
          for (const result of finalResults) {
            result.content = await fs.promises.readFile(result.filePath, 'utf-8');
          }
        }
        return finalResults;
        ```
    -   **Imports**: `import * as fs from 'fs';`
4.  **Filepath**: `src/test/suite/contextService.test.ts` (New or Existing)
    -   **Action**: Write a unit test to verify the deduplication logic.
    -   **Implementation**: Create a test case that provides a mock response from the Qdrant service containing multiple chunks from the same file. Assert that the final result from `queryContext` contains only one entry for that file, and that it has the highest score.
    -   **Imports**: Mocking library (e.g., `sinon`), `assert`.

**Acceptance Criteria:**
-   The `queryContext` method correctly deduplicates results from the vector database.
-   The final list of results contains only one entry per unique file path.
-   The entry for a given file path corresponds to the chunk with the highest similarity score.
-   The number of returned results does not exceed the `maxResults` parameter.

**Testing Plan:**
-   **Unit Test**: Create a test for `queryContext` with a mock Qdrant response containing 3 results for `fileA.ts` (scores 0.8, 0.9, 0.85) and 2 for `fileB.ts` (scores 0.7, 0.75). Verify the output contains one result for `fileA.ts` with score 0.9 and one for `fileB.ts` with score 0.75.
-   **Integration Test**: Run a real query known to match multiple chunks in a single file. Verify the UI displays only one result for that file.
</file>

<file path="docs/todo/missing2/backlog_sprint_4_xml_result_formatting.md">
### User Story 1: XML Output Generation
**As a** backend developer (Alisha), **I want to** create an `XmlFormatterService` that transforms search results into a `repomix`-style XML string, **so that** the output is consistent and machine-readable for use in other AI workflows.

**Actions to Undertake:**
1.  **Filepath**: `package.json`
    -   **Action**: Add a robust XML building library to the project's dependencies.
    -   **Implementation**: Run `npm install xmlbuilder2`.
    -   **Imports**: N/A
2.  **Filepath**: `src/formatting/XmlFormatterService.ts` (New File)
    -   **Action**: Create a new service dedicated to formatting search results into XML.
    -   **Implementation**: Define a class `XmlFormatterService` with a public method `formatResults`.
    -   **Imports**: `import { create } from 'xmlbuilder2';`, `import { QueryResult } from '../types';`
3.  **Filepath**: `src/formatting/XmlFormatterService.ts`
    -   **Action**: Implement the `formatResults` method to build the XML structure.
    -   **Implementation**:
        ```typescript
        public formatResults(results: QueryResult[]): string {
          const root = create({ version: '1.0' }).ele('files');
          for (const result of results) {
            const fileEle = root.ele('file', { path: result.filePath });
            // CDATA section will be added in the next story
          }
          return root.end({ prettyPrint: true });
        }
        ```
    -   **Imports**: `import { create } from 'xmlbuilder2';`
4.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: Integrate the `XmlFormatterService` into the message handling flow.
    -   **Implementation**: After receiving results from `ContextService`, pass them to the `XmlFormatterService` and send the resulting XML string to the webview in the `queryResult` message.
    -   **Imports**: `import { XmlFormatterService } from './formatting/XmlFormatterService';`
5.  **Filepath**: `webview/src/lib/components/QueryView.svelte`
    -   **Action**: Update the results display area to render the raw XML string inside a `<pre><code>` block for proper formatting.
    -   **Implementation**: `<pre><code>{xmlResult}</code></pre>`
    -   **Imports**: N/A

**Acceptance Criteria:**
-   A query to the backend returns a valid XML string.
-   The XML has a root `<files>` element.
-   Each search result corresponds to a `<file>` element with a `path` attribute.
-   The webview correctly displays the formatted XML output.

**Testing Plan:**
-   **Test Case 1**: Run a query and verify the response received by the webview is a string starting with `<?xml version="1.0"?>` and containing a `<files>` root element.
-   **Unit Test**: Write a test for `formatResults` that passes an array of mock `QueryResult` objects and asserts the output XML has the correct structure and attributes.

---

### User Story 2: Preserve Code with CDATA
**As a** backend developer (Alisha), **I want** the `XmlFormatterService` to wrap all file content in `<![CDATA[...]]>` sections, **so that** special characters like `<` and `&` in the source code are preserved correctly and do not break the XML structure.

**Actions to Undertake:**
1.  **Filepath**: `src/formatting/XmlFormatterService.ts`
    -   **Action**: Modify the `formatResults` method to wrap file content in a `CDATA` section.
    -   **Implementation**:
        ```typescript
        // ... inside the for loop
        const fileEle = root.ele('file', { path: result.filePath });
        if (result.content) {
          fileEle.dat(result.content);
        }
        ```
    -   **Imports**: N/A
2.  **Filepath**: `src/test/suite/xmlFormatterService.test.ts` (New File)
    -   **Action**: Write a unit test that specifically validates the correct use of CDATA for special characters.
    -   **Implementation**: Create a test case where the mock `QueryResult` content includes characters like `<script>`, `&amp;`, and `&&`. Assert that the output XML is well-formed and that the content inside the CDATA section is identical to the input, without any XML escaping.
    -   **Imports**: `import * as assert from 'assert';`, `import { XmlFormatterService } from '../../formatting/XmlFormatterService';`

**Acceptance Criteria:**
-   When a search result includes file content, that content is enclosed within a `<![CDATA[...]]>` section in the final XML.
-   The generated XML is valid and can be parsed by a standard XML parser, even if the source code contains special XML characters.
-   Characters like `<`, `>`, and `&` within the code are not escaped (e.g., `&` is not converted to `&amp;`).

**Testing Plan:**
-   **Unit Test**: Create a test for `formatResults` with content `const x = a < b && c > d;`. Verify the output XML contains `<![CDATA[const x = a < b && c > d;]]>` exactly.
-   **Integration Test**: Run a query that returns a file containing HTML or XML-like syntax. Copy the resulting XML output and validate it using an online XML validator to ensure it is well-formed.
</file>

<file path="docs/todo/missing2/backlog_sprint_5_state_management_hotkeys.md">
### User Story 1: Robust State Management
**As a** backend developer (Alisha), **I want to** implement a `StateManager` to prevent concurrent operations, like running two indexing jobs at once, **so that** the extension is more robust and less prone to errors.

**Actions to Undertake:**
1.  **Filepath**: `src/stateManager.ts` (New File)
    -   **Action**: Create a new service to hold the global state of the extension.
    -   **Implementation**:
        ```typescript
        export class StateManager {
          private _isIndexing: boolean = false;

          public get isIndexing(): boolean {
            return this._isIndexing;
          }

          public setIndexing(status: boolean): void {
            this._isIndexing = status;
            // In the future, this could emit an event to the webview
          }
        }
        ```
    -   **Imports**: N/A
2.  **Filepath**: `src/extensionManager.ts`
    -   **Action**: Create a single instance of `StateManager` and inject it into the services that require it.
    -   **Implementation**: Instantiate `StateManager` in the `ExtensionManager` constructor and pass the instance to the constructors of `IndexingService` and `MessageRouter`.
    -   **Imports**: `import { StateManager } from './stateManager';`
3.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Modify the `startIndexing` method to update the shared state.
    -   **Implementation**:
        ```typescript
        public async startIndexing() {
          if (this.stateManager.isIndexing) { return; }
          try {
            this.stateManager.setIndexing(true);
            // ... existing indexing logic
          } finally {
            this.stateManager.setIndexing(false);
          }
        }
        ```
    -   **Imports**: `import { StateManager } from '../stateManager';`
4.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: Add a guard clause to the `startIndexing` message handler to prevent new jobs from starting if one is already running.
    -   **Implementation**:
        ```typescript
        case 'startIndexing':
          if (this.stateManager.isIndexing()) {
            webview.postMessage({ command: 'error', message: 'An indexing process is already running.' });
            return;
          }
          await this.indexingService.startIndexing();
          break;
        ```
    -   **Imports**: `import { StateManager } from '../stateManager';`

**Acceptance Criteria:**
-   The `IndexingService` correctly sets an `isIndexing` flag to `true` when it starts and `false` when it finishes or errors.
-   If an indexing job is running, any subsequent requests to start indexing (from the UI or a command) are rejected.
-   The UI receives and displays a notification when a concurrent indexing request is blocked.

**Testing Plan:**
-   **Manual Test**: Start an indexing process on a large folder. While it is running, attempt to start another indexing process from the command palette or UI. Verify that the second process does not start and that an error message is shown in the webview.

---

### User Story 2: Keyboard Shortcuts (Hotkeys)
**As a** developer (Devin), **I want to** use keyboard shortcuts to open the main panel and start indexing, **so that** I can work more efficiently without using the mouse.

**Actions to Undertake:**
1.  **Filepath**: `package.json`
    -   **Action**: Add a `contributes.keybindings` section to define default keyboard shortcuts for key commands.
    -   **Implementation**:
        ```json
        "contributes": {
          "keybindings": [
            {
              "command": "code-context-engine.openMainPanel",
              "key": "ctrl+alt+c",
              "mac": "cmd+alt+c",
              "when": "editorTextFocus"
            },
            {
              "command": "code-context-engine.startIndexing",
              "key": "ctrl+alt+i",
              "mac": "cmd+alt+i",
              "when": "editorTextFocus"
            }
          ]
        }
        ```
    -   **Imports**: N/A
2.  **Filepath**: `README.md`
    -   **Action**: Document the new default shortcuts so users are aware of them.
    -   **Implementation**: Add a "Shortcuts" section to the `README.md` file listing the new keybindings.
    -   **Imports**: N/A

**Acceptance Criteria:**
-   The `package.json` file contains definitions for at least two keyboard shortcuts.
-   Pressing the defined key combination for `openMainPanel` opens the webview panel.
-   Pressing the defined key combination for `startIndexing` triggers the indexing process (subject to the state manager guard clause).
-   The shortcuts are documented for users.

**Testing Plan:**
-   **Manual Test 1**: Close the webview panel. Press `Cmd+Alt+C` (or `Ctrl+Alt+C`) and verify the panel opens.
-   **Manual Test 2**: With the extension active, press `Cmd+Alt+I` (or `Ctrl+Alt+I`) and verify the indexing process begins (or is blocked if already running).
</file>

<file path="docs/todo/missing2/backlog_sprint_6_cicd_pipeline_documentation.md">
### User Story 1: CI/CD Automation
**As a** backend developer (Alisha), **I want** a CI/CD pipeline using GitHub Actions to automate builds and testing, **so that** we can ensure code quality, catch regressions early, and streamline the release process.

**Actions to Undertake:**
1.  **Filepath**: `.github/workflows/ci.yml` (New File)
    -   **Action**: Create a new GitHub Actions workflow file to define the Continuous Integration process.
    -   **Implementation**: Define the workflow name and the triggers (`push` to `main` and `pull_request`).
    -   **Imports**: N/A
2.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Define the `build-and-test` job with the necessary steps for validation.
    -   **Implementation**:
        ```yaml
        jobs:
          build-and-test:
            runs-on: ubuntu-latest
            steps:
              - uses: actions/checkout@v3
              - uses: actions/setup-node@v3
                with:
                  node-version: '18'
              - run: npm install
              - run: npm install
                working-directory: ./webview
              - run: npm run lint
              - run: npm run test
        ```
    -   **Imports**: N/A
3.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Add steps to build the extension package (`.vsix`) and upload it as a build artifact.
    -   **Implementation**:
        ```yaml
        # (Add to the end of the steps list)
              - name: Build VSIX Package
                run: npm run vscode:prepublish
              - name: Upload VSIX Artifact
                uses: actions/upload-artifact@v3
                with:
                  name: extension-vsix
                  path: "*.vsix"
        ```
    -   **Imports**: N/A

**Acceptance Criteria:**
-   A workflow file exists at `.github/workflows/ci.yml`.
-   The workflow automatically runs on every pull request and push to the `main` branch.
-   The workflow successfully installs all dependencies, runs the linter, and executes tests.
-   If all previous steps pass, the workflow builds the `.vsix` package and saves it as a downloadable artifact named `extension-vsix`.
-   A failing test or linting error causes the workflow to fail.

**Testing Plan:**
-   **Integration Test 1**: Open a new pull request with a minor change. Verify that the GitHub Action is triggered and completes successfully.
-   **Integration Test 2**: Open a pull request that intentionally introduces a linting error. Verify that the workflow fails at the "lint" step.
-   **Integration Test 3**: After a successful run, go to the "Actions" tab in the GitHub repository, select the workflow run, and verify that a `.vsix` file can be downloaded from the "Artifacts" section.

---

### User Story 2: Comprehensive Documentation
**As a** developer (Devin), **I want** clear, comprehensive documentation for the extension, **so that** I know how to install, configure, and use it effectively, and other developers know how to contribute.

**Actions to Undertake:**
1.  **Filepath**: `README.md`
    -   **Action**: Overhaul the `README.md` to be a comprehensive user guide.
    -   **Implementation**: Add sections for Features, Installation, Configuration (detailing the settings in `package.json`), Commands, and default Keyboard Shortcuts.
    -   **Imports**: N/A
2.  **Filepath**: `assets/demo.gif` (New File)
    -   **Action**: Create a short animated GIF demonstrating the core workflow (e.g., setup, index, query).
    -   **Implementation**: Use a screen recording tool (e.g., Kap, LICEcap) to capture the workflow, save it as a GIF, and place it in a new `assets` directory.
    -   **Imports**: N/A
3.  **Filepath**: `README.md`
    -   **Action**: Embed the new demo GIF into the `README.md`.
    -   **Implementation**: `![Code Context Engine Demo](assets/demo.gif)`
    -   **Imports**: N/A
4.  **Filepath**: `CONTRIBUTING.md` (New File)
    -   **Action**: Create a new document with guidelines for developers who want to contribute to the project.
    -   **Implementation**: Add sections for "Setting Up the Development Environment", "Running Tests", and "Submitting a Pull Request".
    -   **Imports**: N/A

**Acceptance Criteria:**
-   The `README.md` file is well-structured and contains all necessary information for an end-user.
-   A `CONTRIBUTING.md` file exists and provides clear instructions for new contributors.
-   A demo GIF is present and correctly displayed in the `README.md`.

**Testing Plan:**
-   **Manual Test 1**: Ask a new user to read the `README.md` and attempt to install and configure the extension. Verify they can do so without assistance.
-   **Manual Test 2**: Ask a developer to follow the `CONTRIBUTING.md` guide to set up the project locally. Verify they can successfully run the tests.
</file>

<file path="docs/todo/missing2/implementation_sprint_1_sveltekit_migration_componentization.md">
This guide provides implementation details for Sprint 1: SvelteKit Migration & Componentization.

### 1. Scaffolding the SvelteKit Project

The PRD requires replacing the existing webview with a new SvelteKit project. The `webview-backup-20250826-101914` directory suggests this may have already been done. If starting from scratch:

1.  **Backup**: `mv webview webview-backup-$(date +%Y%m%d-%H%M%S)`
2.  **Initialize**: Run `npm create svelte@latest webview`.
    -   Select: **Skeleton project**
    -   Select: **Yes, using TypeScript syntax**
    -   Select: **Add ESLint for code linting**
    -   Select: **Add Prettier for code formatting**

### 2. Configuring the Static Adapter

To ensure the SvelteKit app can be loaded as a set of static files in a VS Code webview, we must use `@sveltejs/adapter-static`.

**Installation**:
```bash
npm i -D @sveltejs/adapter-static
```

**`webview/svelte.config.js` Configuration**:

```javascript
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
    preprocess: vitePreprocess(),

    kit: {
        adapter: adapter({
            // Default is pages: 'build', assets: 'build'
            pages: 'build',
            assets: 'build',
            // The fallback is crucial for SPA-like behavior in the webview
            fallback: 'index.html',
            precompress: false,
            strict: true
        }),
        // Ensure all pages are prerendered
        prerender: {
            entries: ['*']
        },
        // App-relative paths are needed for VS Code webviews
        paths: {
            base: '.',
            relative: true
        }
    }
};

export default config;
```

### 3. Integrating Fluent UI Web Components

Fluent UI provides a professional look and feel. It can be integrated by registering the desired components.

**Installation**:
```bash
npm i @fluentui/web-components
```

**Usage**: A good place to register global components is in the root layout file `webview/src/routes/+layout.svelte`.

```html
<script lang="ts">
  import { onMount } from 'svelte';
  import { provideFluentDesignSystem, fluentCard, fluentButton } from '@fluentui/web-components';

  onMount(() => {
    // Registering components makes them available throughout the app
    provideFluentDesignSystem().register(fluentCard(), fluentButton());
  });
</script>

<slot></slot>
```

### 4. State Management with Svelte Stores

Svelte stores are the idiomatic way to handle shared state. For managing the current view, a writable store is perfect.

**`webview/src/lib/stores/viewStore.ts`**:
```typescript
import { writable } from 'svelte/store';

// Define the possible views for type safety
export type View = 'setup' | 'indexing' | 'query';

// Export a writable store with a default value
export const currentView = writable<View>('setup');
```

This store can now be imported into any component to read its value or set a new one.

### 5. Updating `WebviewManager.ts`

The `WebviewManager` must be updated to serve the built SvelteKit application. The existing code in `src/webviewManager.ts` already contains logic for this, which can be adapted.

**Key changes in `getWebviewContent`**:

1.  **Path Correction**: The path to `index.html` must point to `webview/build/index.html`.
2.  **Asset Path Rewriting**: The regex for rewriting asset paths is critical. The existing implementation is a good starting point, but ensure it correctly handles paths generated by SvelteKit.

**Example `getWebviewContent` in `src/webviewManager.ts`**:

```typescript
private getWebviewContent(webview: vscode.Webview, panelName: string): string {
    try {
        const buildPath = vscode.Uri.joinPath(this.context.extensionUri, 'webview', 'build');
        const indexPath = vscode.Uri.joinPath(buildPath, 'index.html');
        let html = fs.readFileSync(indexPath.fsPath, 'utf8');

        // Replace asset paths with webview-compatible URIs
        html = html.replace(/<(script|link|img)([^>]+)(src|href)="([^"]+)"/g,
            (match, tag, attrs, attrName, src) => {
                const assetPath = vscode.Uri.joinPath(buildPath, src);
                const assetUri = webview.asWebviewUri(assetPath);
                return `<${tag}${attrs}${attrName}="${assetUri}"`;
            });

        return html;
    } catch (error) {
        console.error('WebviewManager: Error loading webview content:', error);
        return `<html><body>Error: ${error.message}</body></html>`;
    }
}
```

This updated logic ensures that when the webview loads `index.html`, all relative paths to JavaScript, CSS, or image files are correctly translated into URIs that the webview can access.
</file>

<file path="docs/todo/missing2/implementation_sprint_2_intuitive_settings_diagnostics_ui.md">
This guide provides implementation details for Sprint 2: Intuitive Settings & Diagnostics UI.

### 1. Backend: `SystemValidator.ts` Service

This service will live in the extension's backend and be responsible for checking for third-party dependencies on the user's machine.

**Location**: `src/validation/systemValidator.ts`

**Implementation Strategy**:
Use Node's built-in `child_process` module to execute shell commands and check for the presence and version of required tools. This is more reliable than checking for file paths.

**Example `SystemValidator.ts`**:
```typescript
import { exec } from 'child_process';
import * as util from 'util';

// Promisify exec for async/await usage
const execPromise = util.promisify(exec);

export interface ValidationResult {
  name: string;
  success: boolean;
  message: string;
}

export class SystemValidator {
  public async checkAll(): Promise<ValidationResult[]> {
    const results = await Promise.all([
      this.checkDocker(),
      this.checkNetwork(),
    ]);
    return results;
  }

  private async checkDocker(): Promise<ValidationResult> {
    try {
      const { stdout } = await execPromise('docker --version');
      return {
        name: 'Docker',
        success: true,
        message: stdout.trim(),
      };
    } catch (error) {
      return {
        name: 'Docker',
        success: false,
        message: 'Docker not found. Please install it to use local services.',
      };
    }
  }

  private async checkNetwork(): Promise<ValidationResult> {
    try {
      // A simple check against a reliable host
      await execPromise('ping -c 1 8.8.8.8');
      return {
        name: 'Internet Connectivity',
        success: true,
        message: 'Connected',
      };
    } catch (error) {
      return {
        name: 'Internet Connectivity',
        success: false,
        message: 'No internet connection detected.',
      };
    }
  }
}
```

### 2. Frontend-Backend Communication

Communication between the SvelteKit UI and the VS Code extension backend is handled via a message-passing interface.

1.  **Frontend (`.svelte` component)**: Uses `const vscode = acquireVsCodeApi();` and `vscode.postMessage({ command: 'myCommand' });` to send requests.
2.  **Backend (`MessageRouter.ts`)**: Listens for messages and routes them to the appropriate service.

**Adding a `validateSystem` command to `MessageRouter.ts`**:
```typescript
// In MessageRouter.ts, assuming you have a systemValidator instance
case 'validateSystem':
  const validationResults = await this.systemValidator.checkAll();
  webview.postMessage({
    command: 'systemValidationResult',
    payload: validationResults,
  });
  break;
```

### 3. Frontend: Reusable Svelte Components

Building small, reusable components is a core principle of Svelte.

**`ValidatedInput.svelte`**
This component encapsulates the logic for an input field with a label and validation.

**API Search**: A web search for "Svelte form validation" reveals common patterns like using a `validator` function prop and displaying conditional error messages, which is the approach adopted here.

**Example Usage**:
```html
<script lang="ts">
  import ValidatedInput from './ValidatedInput.svelte';
  let url = 'http://localhost:6333';
  const urlValidator = (val: string) => {
    try {
      new URL(val);
      return null; // a null error means valid
    } catch {
      return 'Invalid URL format';
    }
  };
</script>

<ValidatedInput label="Database URL" bind:value={url} validator={urlValidator} />
```

**`ConnectionTester.svelte`**
This component provides a button to trigger a backend test and displays the result.

**Implementation Strategy**:
-   The component takes a `testFunction` prop, which should be an `async` function that calls the backend via `postMessage` and waits for the result.
-   It manages its own state (`idle`, `testing`, `success`, `error`) to provide clear UI feedback.

**Example Usage in `SetupView.svelte`**:
```html
<script lang="ts">
  import ConnectionTester from './ConnectionTester.svelte';
  const vscode = acquireVsCodeApi();

  async function testDbConnection() {
    vscode.postMessage({ command: 'testDatabaseConnection' });
    // This requires a listener for the 'databaseConnectionResult' message
    return new Promise(resolve => {
      window.addEventListener('message', event => {
        if (event.data.command === 'databaseConnectionResult') {
          resolve(event.data.payload);
        }
      }, { once: true });
    });
  }
</script>

<ConnectionTester testFunction={testDbConnection} />
```

### 4. Assembling the `SetupView.svelte`

The final step is to combine these components into a single, user-friendly setup screen.

**`SetupView.svelte` Structure**:
```html
<script lang="ts">
  import SystemValidation from './SystemValidation.svelte';
  import ValidatedInput from './ValidatedInput.svelte';
  import ConnectionTester from './ConnectionTester.svelte';
  // ... other imports and logic
</script>

<div class="setup-container">
  <h2>1. System Checks</h2>
  <SystemValidation />

  <h2>2. Database Configuration</h2>
  <ValidatedInput ... />
  <ConnectionTester ... />

  <h2>3. Embedding Provider</h2>
  <!-- More inputs and testers here -->
</div>
```
This structure provides a clear, step-by-step process for the user, guided by automated checks and interactive testers.
</file>

<file path="docs/todo/missing2/implementation_sprint_3_advanced_search_ui_logic.md">
This guide provides implementation details for Sprint 3: Advanced Search UI & Logic.

### 1. Frontend: Enhancing `QueryView.svelte`

The goal is to add controls for `maxResults` and `includeContent` and pass these values to the backend.

**Location**: `webview/src/lib/components/QueryView.svelte`

**Implementation Strategy**:
Use Svelte's two-way data binding (`bind:value` and `bind:checked`) to link UI controls directly to component state variables. These variables are then included in the `postMessage` payload.

**Example `QueryView.svelte`**:
```html
<script lang="ts">
  import { onMount } from 'svelte';

  const vscode = acquireVsCodeApi();

  let searchQuery = '';
  let maxResults = 20;
  let includeContent = false;
  let results = '';

  function runQuery() {
    vscode.postMessage({
      command: 'queryContext',
      payload: {
        query: searchQuery,
        maxResults: maxResults,
        includeContent: includeContent
      }
    });
  }

  onMount(() => {
    window.addEventListener('message', event => {
      if (event.data.command === 'queryResult') {
        results = event.data.payload;
      }
    });
  });
</script>

<form on:submit|preventDefault={runQuery}>
  <textarea bind:value={searchQuery} placeholder="Enter your context query..."></textarea>
  
  <div class="controls">
    <div>
      <label for="max-results">Max Results</label>
      <input id="max-results" type="number" bind:value={maxResults} min="1" max="100" />
    </div>
    <div>
      <label for="include-content">Include file content</label>
      <input id="include-content" type="checkbox" bind:checked={includeContent} />
    </div>
  </div>

  <button type="submit">Query</button>
</form>

{#if results}
  <pre><code>{results}</code></pre>
{/if}
```

### 2. Backend: Deduplication Logic in `ContextService`

This is the core of the sprint. The `queryContext` method must be updated to handle deduplication, sorting, and conditional content loading.

**Location**: `src/context/contextService.ts`

**API/Library Research**: A web search for "typescript group by and get max" confirms that using a `Map` is a standard and efficient pattern for this task. It avoids nested loops and provides a clean way to store unique items by a key.

**Full `queryContext` Method Implementation**:
```typescript
import * as fs from 'fs';
// Assuming QueryResult and QdrantService are defined elsewhere
// import { QdrantService } from '../db/qdrantService';
// import { QueryResult } from '../types';

export class ContextService {
  private qdrantService: QdrantService;

  constructor(qdrantService: QdrantService) {
    this.qdrantService = qdrantService;
  }

  public async queryContext(
    query: string, 
    maxResults: number = 20, 
    includeContent: boolean = false
  ): Promise<QueryResult[]> {
    
    // 1. Fetch a larger number of results to have a good pool for deduplication.
    // A 5x multiplier is a reasonable heuristic.
    const rawResults = await this.qdrantService.search(query, { limit: maxResults * 5 });

    // 2. Use a Map to store the best (highest score) result for each unique file path.
    const uniqueFiles = new Map<string, QueryResult>();

    for (const result of rawResults) {
      const existing = uniqueFiles.get(result.filePath);
      // If we haven't seen this file, or the new result has a higher score, store it.
      if (!existing || result.score > existing.score) {
        uniqueFiles.set(result.filePath, result);
      }
    }

    // 3. Convert the Map values to an array, sort by score descending, and slice to maxResults.
    let finalResults = Array.from(uniqueFiles.values())
      .sort((a, b) => b.score - a.score)
      .slice(0, maxResults);

    // 4. If requested, read the file content for the final list of files.
    // Use Promise.all for efficient, parallel file reading.
    if (includeContent) {
      await Promise.all(finalResults.map(async (result) => {
        try {
          // We only need the content, not the other fields from the result.
          const content = await fs.promises.readFile(result.filePath, 'utf-8');
          result.content = content;
        } catch (error) {
          console.error(`Error reading file ${result.filePath}:`, error);
          result.content = `Error reading file: ${error.message}`;
        }
      }));
    }

    return finalResults;
  }
}
```

### 3. Unit Testing the Deduplication Logic

To ensure the logic is sound, a unit test is essential. This test should not make real service calls but should instead use mock data.

**Location**: `src/test/suite/contextService.test.ts`

**Example Test Case**:
```typescript
import * as assert from 'assert';
import { ContextService } from '../../context/contextService';
import { QdrantService } from '../../db/qdrantService';
import * as sinon from 'sinon';

suite('ContextService Test Suite', () => {
  let qdrantServiceStub: sinon.SinonStubbedInstance<QdrantService>;
  let contextService: ContextService;

  setup(() => {
    // Create a stub for QdrantService to avoid real DB calls
    qdrantServiceStub = sinon.createStubInstance(QdrantService);
    contextService = new ContextService(qdrantServiceStub);
  });

  test('queryContext should deduplicate results and return the highest score per file', async () => {
    // Arrange: Mock data with duplicates
    const mockResults = [
      { id: '1', score: 0.9, filePath: 'fileA.ts', content: '' },
      { id: '2', score: 0.8, filePath: 'fileB.ts', content: '' },
      { id: '3', score: 0.85, filePath: 'fileA.ts', content: '' }, // Duplicate of fileA
      { id: '4', score: 0.95, filePath: 'fileC.ts', content: '' },
      { id: '5', score: 0.7, filePath: 'fileB.ts', content: '' }, // Duplicate of fileB
    ];
    qdrantServiceStub.search.resolves(mockResults);

    // Act: Call the method with maxResults = 3
    const results = await contextService.queryContext('test query', 3, false);

    // Assert
    assert.strictEqual(results.length, 3, 'Should return 3 results');
    assert.strictEqual(results[0].filePath, 'fileC.ts', 'First result should be fileC with highest score');
    assert.strictEqual(results[0].score, 0.95, 'Score for fileC should be 0.95');
    assert.strictEqual(results[1].filePath, 'fileA.ts', 'Second result should be fileA');
    assert.strictEqual(results[1].score, 0.9, 'Score for fileA should be the max of duplicates: 0.9');
    assert.strictEqual(results[2].filePath, 'fileB.ts', 'Third result should be fileB');
    assert.strictEqual(results[2].score, 0.8, 'Score for fileB should be the max of duplicates: 0.8');
  });
});
```
</file>

<file path="docs/todo/missing2/implementation_sprint_4_xml_result_formatting.md">
This guide provides implementation details for Sprint 4: XML Result Formatting.

### 1. Choosing and Installing an XML Builder Library

While the PRD mentions `xml-builder-js`, a more modern and powerful choice is **`xmlbuilder2`**. It's a successor to `xmlbuilder.js` and provides a robust API for creating complex XML documents, including excellent support for CDATA sections.

**Installation**:
```bash
npm install xmlbuilder2
```

This library will prevent common errors associated with manual string concatenation for XML, such as improper character escaping.

### 2. Implementing the `XmlFormatterService`

This new service will be solely responsible for converting the array of search results into the final XML string.

**Location**: `src/formatting/XmlFormatterService.ts`

**Full `XmlFormatterService.ts` Implementation**:
```typescript
import { create } from 'xmlbuilder2';
import { QueryResult } from '../types'; // Assuming QueryResult type definition

export class XmlFormatterService {
  /**
   * Formats an array of search results into a repomix-style XML string.
   * @param results - The array of QueryResult objects.
   * @returns A pretty-printed XML string.
   */
  public formatResults(results: QueryResult[]): string {
    // Initialize the XML document with a root <files> element
    const root = create({ version: '1.0', encoding: 'UTF-8' }).ele('files');

    // Loop through each result to create a <file> element
    for (const result of results) {
      const fileEle = root.ele('file', { path: result.filePath });

      // If content exists, wrap it in a CDATA section to preserve special characters
      if (result.content) {
        fileEle.dat(result.content);
      }
    }

    // Convert the XML object to a string with indentation
    return root.end({ prettyPrint: true });
  }
}
```

**Key API Points from `xmlbuilder2`**:
-   `create()`: Starts a new XML document.
-   `.ele('name', { attr: 'value' })`: Creates a new element, optionally with attributes.
-   `.dat('content')`: Creates a `<![CDATA[...]]>` section. This is critical for safely embedding source code.
-   `.end({ prettyPrint: true })`: Finalizes the document and converts it to a formatted string.

### 3. Integrating into `MessageRouter.ts`

The `MessageRouter` must be updated to use the new service before sending the results back to the UI.

**Location**: `src/messageRouter.ts`

**Integration Steps**:
1.  Ensure an instance of `XmlFormatterService` is created in `ExtensionManager` and passed to `MessageRouter`.
2.  Modify the `queryContext` message handler:

```typescript
// In MessageRouter.ts -> handleMessage method

// ... assuming xmlFormatterService is available as this.xmlFormatterService

case 'queryContext':
  try {
    // 1. Get the deduplicated results from the ContextService
    const results = await this.contextService.queryContext(
      message.payload.query,
      message.payload.maxResults,
      message.payload.includeContent
    );

    // 2. Format the results into an XML string using the new service
    const xmlOutput = this.xmlFormatterService.formatResults(results);

    // 3. Post the final XML string back to the webview
    webview.postMessage({
      command: 'queryResult',
      payload: xmlOutput
    });
  } catch (error) {
    // ... error handling
  }
  break;
```

### 4. Unit Testing the `XmlFormatterService`

A focused unit test will confirm that the XML generation is correct, especially the handling of CDATA.

**Location**: `src/test/suite/xmlFormatterService.test.ts`

**Example Test Case**:
```typescript
import * as assert from 'assert';
import { XmlFormatterService } from '../../formatting/XmlFormatterService';
import { QueryResult } from '../../types';

suite('XmlFormatterService Test Suite', () => {
  let formatter: XmlFormatterService;

  setup(() => {
    formatter = new XmlFormatterService();
  });

  test('should format results with content and special characters into XML with CDATA', () => {
    // Arrange: Mock data with special XML characters
    const mockResults: QueryResult[] = [
      {
        id: '1',
        score: 0.9,
        filePath: 'src/test.ts',
        content: 'const check = 1 < 2 && "hello";'
      },
      {
        id: '2',
        score: 0.8,
        filePath: 'src/another.ts',
        // This result has no content
      }
    ];

    // Act
    const xmlString = formatter.formatResults(mockResults);

    // Assert: Check for exact CDATA block and overall structure
    const expectedContent = '<![CDATA[const check = 1 < 2 && "hello";]]>';
    assert.ok(xmlString.includes(expectedContent), 'Content should be wrapped in CDATA');
    assert.ok(xmlString.includes('<file path="src/test.ts">'), 'Should contain first file element');
    assert.ok(xmlString.includes('<file path="src/another.ts"/>'), 'Should contain second, self-closing file element');
  });
});
```
</file>

<file path="docs/todo/missing2/implementation_sprint_5_state_management_hotkeys.md">
This guide provides implementation details for Sprint 5: State Management & Hotkeys.

### 1. Implementing the `StateManager`

The `StateManager` is a simple class that acts as a single source of truth for global states, such as whether an indexing process is active. It should be instantiated once and shared across services.

**Location**: `src/stateManager.ts`

**Full `StateManager.ts` Implementation**:
```typescript
/**
 * Manages the global state of the extension.
 * This class is intended to be a singleton, instantiated once in ExtensionManager.
 */
export class StateManager {
  // Use a private property with a public getter to control write access.
  private _isIndexing: boolean = false;

  public get isIndexing(): boolean {
    return this._isIndexing;
  }

  /**
   * Sets the indexing status and can be extended to notify the webview.
   * @param status The new indexing status.
   */
  public setIndexing(status: boolean): void {
    if (this._isIndexing !== status) {
      this._isIndexing = status;
      // FUTURE: Post a message to the webview to update UI state, e.g.,
      // this.webviewManager.getPanel()?.webview.postMessage({ command: 'indexingStatusChanged', status });
    }
  }
}
```

### 2. Dependency Injection via `ExtensionManager`

To ensure all services share the *same* state, the `StateManager` instance must be created in a central location (`ExtensionManager`) and passed to the constructors of other services.

**Location**: `src/extensionManager.ts`

**Example of `ExtensionManager` modifications**:
```typescript
// ... other imports
import { StateManager } from './stateManager';
import { IndexingService } from './indexing/indexingService';
import { MessageRouter } from './messageRouter';

export class ExtensionManager {
  private stateManager: StateManager;
  private indexingService: IndexingService;
  private messageRouter: MessageRouter;
  // ... other services

  constructor(context: vscode.ExtensionContext) {
    // 1. Create the single instance of the StateManager.
    this.stateManager = new StateManager();

    // 2. Inject the instance into the constructors of dependent services.
    // Note: The constructors for these services must be updated to accept the StateManager.
    this.indexingService = new IndexingService(context, this.stateManager);
    this.messageRouter = new MessageRouter(context, this.indexingService, this.stateManager);
    // ... initialize other services
  }
  // ... other methods
}
```

### 3. Safe State Updates in `IndexingService`

It is critical that the `isIndexing` state is reset correctly, even if an error occurs during indexing. A `try...finally` block is the perfect tool for this.

**Location**: `src/indexing/indexingService.ts`

**Updated `startIndexing` method**:
```typescript
// In IndexingService class

private stateManager: StateManager;

constructor(context: vscode.ExtensionContext, stateManager: StateManager) {
  this.context = context;
  this.stateManager = stateManager;
}

public async startIndexing(): Promise<void> {
  // Optional: Check state here as well for internal calls
  if (this.stateManager.isIndexing) {
    console.warn('Indexing already in progress. Aborting.');
    return;
  }

  try {
    // Set state to true at the very beginning
    this.stateManager.setIndexing(true);
    console.log('Indexing started...');
    
    // ... all existing indexing logic goes here ...

    console.log('Indexing finished successfully.');

  } catch (error) {
    console.error('An error occurred during indexing:', error);
    // Optionally, post an error message to the UI
  } finally {
    // ALWAYS set state to false when the process is complete, success or fail.
    this.stateManager.setIndexing(false);
    console.log('Indexing process ended.');
  }
}
```

### 4. Adding Keybindings to `package.json`

VS Code commands can be mapped to keyboard shortcuts via the `contributes.keybindings` section in `package.json`.

**Analysis**: The `package.json` file provided in the initial context already contains the required keybindings. This task is a matter of **verification**.

**Location**: `package.json`

**Verification Snippet**:
```json
{
  "contributes": {
    "commands": [
      // ... commands
    ],
    "keybindings": [
      {
        "command": "code-context-engine.openMainPanel",
        "key": "ctrl+alt+c",
        "mac": "cmd+alt+c",
        "when": "editorTextFocus"
      },
      {
        "command": "code-context-engine.startIndexing",
        "key": "ctrl+alt+i",
        "mac": "cmd+alt+i",
        "when": "editorTextFocus"
      }
    ]
  }
}
```

**Guidance**:
-   Confirm the `command` IDs match those registered in the extension.
-   The `when` clause (`editorTextFocus`) ensures the shortcut is only active when the user is in a text editor, which is a good default to avoid conflicts.
-   Ensure these shortcuts are documented in the `README.md` for user visibility.
</file>

<file path="docs/todo/missing2/implementation_sprint_6_cicd_pipeline_documentation.md">
This guide provides implementation details for Sprint 6: CI/CD Pipeline & Documentation.

### 1. Creating the GitHub Actions CI Workflow

A Continuous Integration (CI) workflow automates the testing and build process. GitHub Actions is the perfect tool for this, as it's integrated directly into the repository.

**Location**: `.github/workflows/ci.yml`

**Web Search/API Info**: A search for "github actions nodejs vscode extension" confirms the standard workflow: Checkout -> Setup Node -> Install -> Lint -> Test -> Build -> Upload Artifact. We will use official actions like `actions/checkout`, `actions/setup-node`, and `actions/upload-artifact`.

**Complete `ci.yml` Implementation**:
```yaml
name: Build and Test Extension

# Triggers the workflow on pushes to the main branch and on any pull request
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test:
    # Use the latest stable version of Ubuntu
    runs-on: ubuntu-latest

    steps:
      # 1. Check out the repository code
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. Set up the specific version of Node.js required by the project
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          cache: 'npm' # Cache npm dependencies for faster runs

      # 3. Install dependencies for the main extension
      - name: Install root dependencies
        run: npm install

      # 4. Install dependencies for the SvelteKit webview
      - name: Install webview dependencies
        run: npm install
        working-directory: ./webview # Run the command in the webview sub-folder

      # 5. Run the linter to check for code style issues
      - name: Lint source code
        run: npm run lint

      # 6. Run the automated test suite
      - name: Run tests
        run: npm run test

      # 7. Build the .vsix package if all previous steps passed
      - name: Build VSIX Package
        run: npm run vscode:prepublish

      # 8. Upload the generated .vsix file as a build artifact
      - name: Upload VSIX Artifact
        uses: actions/upload-artifact@v3
        with:
          name: extension-vsix-package # Name of the artifact
          path: "*.vsix" # Glob pattern to find the .vsix file
```

### 2. Creating High-Quality Documentation

Good documentation is essential for user adoption and community contributions.

#### `README.md` Structure

This is the front door for your project. It should be clear, concise, and provide all the key information a user needs.

**Recommended `README.md` Template**:
````markdown
# Code Context Engine

![Demo of the Code Context Engine](assets/demo.gif)

The Code Context Engine is a VS Code extension that uses AI to provide deep, context-aware search and analysis for your codebase.

## Features

*   **Vector-Based Search**: Find code based on conceptual meaning, not just keywords.
*   **Configurable Backend**: Supports local (Ollama) and remote (OpenAI) embedding providers.
*   **Machine-Readable Output**: Generates results in a `repomix`-style XML format for use in other AI pipelines.

## Installation

1.  Open **VS Code**.
2.  Navigate to the **Extensions** view (Cmd+Shift+X).
3.  Search for "**Code Context Engine**".
4.  Click **Install**.

## Configuration

The extension can be configured via the native VS Code settings (Cmd+,). Key settings include:

| Setting                                   | Description                                | Default                |
| ----------------------------------------- | ------------------------------------------ | ---------------------- |
| `code-context-engine.embeddingProvider`   | The embedding provider to use.             | `ollama`               |
| `code-context-engine.databaseConnectionString` | Connection string for the Qdrant database. | `http://localhost:6333`|
| `code-context-engine.maxSearchResults`    | The maximum number of results to return.   | `20`                   |

## Keyboard Shortcuts

| Command           | macOS       | Windows/Linux |
| ----------------- | ----------- | ------------- |
| Open Main Panel   | `Cmd+Alt+C` | `Ctrl+Alt+C`  |
| Start Indexing    | `Cmd+Alt+I` | `Ctrl+Alt+I`  |
````

#### `CONTRIBUTING.md` Structure

This file tells other developers how to get involved.

**Recommended `CONTRIBUTING.md` Template**:
````markdown
# Contributing to Code Context Engine

We welcome contributions from the community! Thank you for your interest.

## Development Environment Setup

1.  **Fork and Clone**: Fork the repository and clone it to your local machine.
    ```bash
    git clone https://github.com/YOUR_USERNAME/bigcontext.git
    ```

2.  **Install Dependencies**: This project has dependencies in both the root and the `webview` folder.
    ```bash
    # Install root dependencies
    npm install

    # Install webview dependencies
    cd webview
    npm install
    cd ..
    ```

3.  **Open in VS Code**: Open the project folder in VS Code. Press `F5` to start a new Extension Development Host window with the extension running.

## Running Tests

To run the automated test suite from the command line:

```bash
npm run test
```

## Pull Request Process

1.  Ensure any new code is accompanied by tests.
2.  Ensure the full test suite passes (`npm run test`).
3.  Create a pull request detailing your changes.
````

### 3. Creating a Demo GIF

A short, silent GIF is often more effective than a long video.

**Recommended Tools**:
-   **macOS**: [Kap](https://getkap.co/) (Free)
-   **Windows/macOS**: [LICEcap](https://www.cockos.com/licecap/) (Free)
-   **Linux**: [Peek](https://github.com/phw/peek) (Free)

**Recording Script**:
1.  Start with the main panel open.
2.  Briefly show the Diagnostics/Settings UI.
3.  Use the "Start Indexing" command.
4.  Switch to the "Indexing" view to show progress.
5.  Once done, switch to the "Query" view.
6.  Type a conceptual query (e.g., "how does the application handle user state?").
7.  Show the final XML results displayed in the view.
8.  Keep the GIF under 30 seconds.
</file>

<file path="docs/todo/missing2/prd.md">
<prd>Of course. I have conducted a comprehensive review of the entire codebase and all previously generated PRDs. The analysis reveals that while the backend has a solid, decoupled architecture, several key user-facing features and a critical frontend migration are still needed to complete the extension as planned.

The main gaps are:

1.  **The frontend is not yet a SvelteKit application.** It's currently built with plain TypeScript, which was identified as a major piece of technical debt.
2.  **The search and results UI is a basic placeholder.** It lacks the specific controls and output formatting you've requested.
3.  **The settings/onboarding UI needs to be more intuitive** and component-based, with clear sections for system validation, database setup, and provider configuration.

To address these gaps and deliver the full functionality, I have created a series of new, sequential PRDs.

-----

### **New Document: PRD 1: Foundational - SvelteKit UI Migration & Enhanced Settings**

**1. Title & Overview**

  * **Project:** Code Context Engine - SvelteKit UI Migration & Enhanced Onboarding
  * **Summary:** This foundational phase is focused on migrating the entire webview frontend from the current TypeScript DOM-manipulation approach to a modern, component-based SvelteKit application. We will also build a new, highly intuitive and user-friendly onboarding/settings view that incorporates system validation and connection testing to provide a seamless user experience.
  * **Dependencies:** The decoupled backend architecture (`ExtensionManager`, `MessageRouter`, etc.) is already in place and will be the communication target for the new SvelteKit UI.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Establish a modern, maintainable, and scalable frontend architecture to accelerate future UI development.
      * Create a best-in-class, frictionless onboarding experience that maximizes the number of users who successfully configure and index their first repository.
  * **Developer & System Success Metrics:**
      * The `webview/` directory is a fully functional SvelteKit project, and all UI views are rendered using `.svelte` components.
      * The new `SetupView` component provides clear, step-by-step guidance for database and provider configuration.
      * The UI includes interactive connection testers that give users real-time feedback on their configuration.
      * All UI state is managed within Svelte stores, eliminating direct DOM manipulation for state changes.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin has just installed the extension. He needs a setup process that is not just a form, but a guide. He wants to know if his system is compatible, get help starting local services, and be confident that his settings are correct *before* he starts a long indexing process.
  * **Frank (Frontend Developer):** Frank needs a proper SvelteKit development environment to efficiently build and maintain the UI. A component-based architecture allows him to create reusable and testable UI elements like `ValidatedInput` and `ConnectionTester`.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Svelte UI** | **Sprint 1: SvelteKit Migration & Componentization** | As Frank, I want to replace the current webview implementation with a SvelteKit application configured with a static adapter, so I have a proper foundation for the UI. | 1. The `webview/` directory is replaced with a new SvelteKit project.\<br/\>2. The project is configured with `@sveltejs/adapter-static` to build into a `build` directory.\<br/\>3. The `WebviewManager` is updated to load the `index.html` from the SvelteKit build output and correctly rewrite asset paths. | **2 Weeks** |
| | | As Frank, I want to recreate the `Setup`, `Indexing`, and `Query` views as modular Svelte components, so the UI is organized and state-driven. | 1. A `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte` component is created.\<br/\>2. The main page (`+page.svelte`) uses a Svelte store (`viewStore.ts`) to manage which of the three views is currently visible.\<br/\>3. The basic structure and layout of each view are implemented based on the existing HTML placeholders. | |
| **Phase 1: Svelte UI** | **Sprint 2: Intuitive Settings & Diagnostics UI** | As Devin, I want a single, intuitive setup page that validates my system and lets me configure and test my database and provider connections in one place. | 1. A new `ValidatedInput.svelte` component is created for text fields and dropdowns that provides real-time validation feedback.\<br/\>2. A new `ConnectionTester.svelte` component is created that can test a given configuration and display the status (success, error, latency).\<br/\>3. The `SetupView.svelte` component is enhanced to use these new components for a rich, interactive setup experience. | **2 Weeks** |
| | | As Devin, I want the extension to automatically check my system for prerequisites like Docker before I start the setup. | 1. A new `SystemValidator.ts` service is created in the extension backend to check for Docker, network connectivity, etc.\<br/\>2. A `SystemValidation.svelte` component is created in the UI to display the results of this check.\<br/\>3. The `SetupView` displays the system validation results at the top of the page. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** SvelteKit Migration & Componentization (2 Weeks)
  * **Sprint 2:** Intuitive Settings & Diagnostics UI (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The logic from the `webview-backup` components can be effectively translated into a modern SvelteKit component structure.
  * **Risk:** The real-time validation and connection testing might be complex to implement reliably, especially with varying user system configurations.
      * **Mitigation:** The `SystemValidator.ts` and `ConnectionTester.svelte` components should be developed with robust error handling and provide clear, actionable feedback to the user if a check fails.
  * **Risk:** A large, single `SetupView` component could become overly complex.
      * **Mitigation:** Break down the `SetupView` into smaller, self-contained child components (e.g., `DatabaseConfig.svelte`, `ProviderConfig.svelte`) to keep the codebase manageable.

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - SvelteKit Migration & Componentization

**Goal:** To migrate the existing webview from a plain TypeScript implementation to a modern SvelteKit application and structure the UI into modular components.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Backup and Clean `webview/`:** Make a backup of the current `webview/` directory, then delete its contents. | `webview/` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** Run `npm create svelte@latest webview` and select "Skeleton project" with TypeScript support. | `webview/` (New project) |
| **1.3** |  To Do | **Install Static Adapter & Dependencies:** In the `webview/` directory, run `npm install -D @sveltejs/adapter-static` and `npm install @fluentui/web-components`. | `webview/package.json` |
| **1.4** |  To Do | **Configure Static Build:** Modify `webview/svelte.config.js` to use the static adapter, outputting to a `build` directory with `index.html` as the fallback. | `webview/svelte.config.js` |
| **1.5** |  To Do | **Create State Stores:** Create `webview/src/lib/stores/viewStore.ts` to manage the active view and `webview/src/lib/stores/appStore.ts` for global app state. | `webview/src/lib/stores/` (New) |
| **1.6** |  To Do | **Create View Components:** Create the initial component files: `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte` in `webview/src/lib/components/`. | `webview/src/lib/components/` (New) |
| **1.7** |  To Do | **Create Main Page Layout:** In `webview/src/routes/+page.svelte`, import the view components and the `viewStore`. Use an `{#if}` block to conditionally render the correct view based on the store's value. | `webview/src/routes/+page.svelte` (New) |
| **1.8** |  To Do | **Update `WebviewManager`:** Modify the `getWebviewContent` method in `src/webviewManager.ts` to read `webview/build/index.html` and correctly rewrite asset paths using `asWebviewUri`. | `src/webviewManager.ts` |
| **1.9** |  To Do | **Test Build & Load:** Run `npm run build` in `webview/`. Launch the extension and verify that the default SvelteKit UI loads in the webview panel. | `(Manual Test)` |




Of course. Here are the remaining PRDs and task lists to complete the planned functionality for your VS Code extension.

-----

### **New Document: PRD 2: Core Functionality - Advanced Search & XML Output**

**1. Title & Overview**

  * **Project:** Code Context Engine - Advanced Search & XML Output
  * **Summary:** This phase focuses on delivering the core value proposition of the extension: a powerful, context-aware search with a specific, machine-readable output format. We will enhance the search UI with advanced controls, implement backend logic to refine search results, and create a new service to format the final output as a `repomix`-style XML document.
  * **Dependencies:** PRD 1 (SvelteKit UI Migration & Enhanced Settings) must be complete. The extension must have a functional SvelteKit frontend and a backend capable of performing a basic vector search.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Provide a unique and powerful search experience that differentiates the extension from standard text search tools.
      * Deliver a predictable, machine-consumable output format that can be used in other AI-driven workflows.
  * **Developer & System Success Metrics:**
      * The search UI includes controls for specifying the number of results and optionally including file content.
      * The backend successfully deduplicates search results to return only unique file paths.
      * A new `XmlFormatterService` correctly transforms search results into the specified XML format.
      * File content within the XML output is wrapped in `<![CDATA[...]]>` sections to prevent character escaping issues.
      * The end-to-end search-to-XML workflow is completed in under 5 seconds for typical queries.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin needs more control over his search. He wants to specify how many files he gets back and decide whether to immediately see the full content or just the file paths. When he gets the results, he wants to be able to easily copy the formatted XML for use in other tools or scripts.
  * **Alisha (Backend Developer):** Alisha needs to implement the logic that makes the search "smart." This includes handling the deduplication of results from the vector database and creating a reliable service that generates valid, well-formed XML.

-----

**4. Requirements Breakdown**

| Phase                  | Sprint                           | User Story                                                                                                                                              | Acceptance Criteria                                                                                                                                                                                                                                                                                                                         | Duration  |
| :--------------------- | :------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------- |
| **Phase 2: Core Search** | **Sprint 3: Advanced Search UI & Logic** | As Devin, I want UI controls to specify the number of search results and to include file content, so I can fine-tune my queries.                      | 1. The `QueryView.svelte` component is updated with a number input for "Max Results".\<br/\>2. A checkbox labeled "Include file content" is added to the `QueryView`.\<br/\>3. The values from these controls are sent to the backend as part of the `queryContext` message.                                                          | **2 Weeks** |
|                        |                                  | As Alisha, I want the backend to process search results to return only unique file paths, so the user isn't shown duplicate entries for the same file. | 1. The `ContextService`'s `queryContext` method is updated.\<br/\>2. It groups raw vector search hits by `filePath`.\<br/\>3. It returns a single, aggregated result for each unique file, using the highest similarity score from that file's chunks.\<br/\>4. The final result list respects the "Max Results" limit specified by the user. |           |
| **Phase 2: Core Search** | **Sprint 4: XML Result Formatting** | As Alisha, I want to create an `XmlFormatterService` that transforms search results into a `repomix`-style XML string, so the output is consistent and machine-readable. | 1. A new `XmlFormatterService.ts` is created in the extension backend.\<br/\>2. It has a method that accepts an array of search results.\<br/\>3. The method generates a valid XML string with a root `<files>` element and nested `<file path="...">` elements for each result.                                                        | **2 Weeks** |
|                        |                                  | As Alisha, I want the `XmlFormatterService` to wrap all file content in `<![CDATA[...]]>` sections, so that special characters like `&` and `<` are preserved correctly. | 1. When "Include file content" is true, the content of each file is placed inside a `CDATA` section within its `<file>` tag.\<br/\>2. The generated XML is parsed without errors by a standard XML parser.\<br/\>3. Special characters within the code are rendered verbatim in the final output.                                       |           |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 3:** Advanced Search UI & Logic (2 Weeks)
  * **Sprint 4:** XML Result Formatting (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The vector search will sometimes return multiple high-scoring chunks from the same file for a single query.
  * **Risk:** Reading the full content for a large number of files could be slow and negatively impact the user experience.
      * **Mitigation:** The file content should be read *after* the initial list of relevant files has been determined and deduplicated. Stream the results to the UI if possible, showing file paths first, then loading content asynchronously.
  * **Risk:** Manually building XML strings is error-prone.
      * **Mitigation:** Use a well-tested third-party library (e.g., `xml-builder-js` or similar) to generate the XML, which will handle character escaping and proper formatting automatically, reducing the risk of invalid output.

-----

### **New Document: tasklist\_sprint\_03.md**

# Task List: Sprint 3 - Advanced Search UI & Logic

**Goal:** To enhance the search UI with advanced controls and implement the backend logic for deduplicating results.

| Task ID | Status    | Task Description (Sequential & Atomic Steps)                                                                                                                            | File(s) To Modify                                    |
| :------ | :-------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------- |
| **3.1** |  To Do   | **Add UI Controls:** In `QueryView.svelte`, add a number input field for "Max Results" and a checkbox for "Include file content".                                       | `webview/src/lib/components/QueryView.svelte`        |
| **3.2** |  To Do   | **Update Svelte State:** Add properties to the component's state to hold the values for the new UI controls.                                                            | `webview/src/lib/components/QueryView.svelte`        |
| **3.3** |  To Do   | **Update Message Payload:** When the search button is clicked, include the values for `maxResults` and `includeContent` in the `queryContext` message sent to the backend. | `webview/src/lib/components/QueryView.svelte`        |
| **3.4** |  To Do   | **Update `ContextService` Method Signature:** Modify the `queryContext` method in `src/context/contextService.ts` to accept the new parameters.                   | `src/context/contextService.ts`                      |
| **3.5** |  To Do   | **Implement Deduplication Logic:** In `queryContext`, after receiving results from Qdrant, create a `Map` to group the results by `filePath`.                        | `src/context/contextService.ts`                      |
| **3.6** |  To Do   | **Aggregate Results:** For each file in the map, determine the highest similarity score among its chunks.                                                               | `src/context/contextService.ts`                      |
| **3.7** |  To Do   | **Limit Final Results:** After aggregation, sort the unique files by their highest score and use `.slice(0, maxResults)` to respect the user's limit.                  | `src/context/contextService.ts`                      |
| **3.8** |  To Do   | **Conditionally Read Content:** If `includeContent` is true, read the file content for the final, deduplicated list of files *before* returning the response.         | `src/context/contextService.ts`                      |
| **3.9** |  To Do   | **Test Deduplication:** Write a unit test for `ContextService` that provides a mock Qdrant response with duplicate files and asserts that the final result is unique.  | `src/test/suite/contextService.test.ts`              |

-----

### **New Document: tasklist\_sprint\_04.md**

# Task List: Sprint 4 - XML Result Formatting

**Goal:** To create a dedicated service for formatting the final, deduplicated search results into a `repomix`-style XML string.

| Task ID | Status    | Task Description (Sequential & Atomic Steps)                                                                                                                  | File(s) To Modify                                        |
| :------ | :-------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------- |
| **4.1** |  To Do   | **Install XML Builder Library:** Add a library like `xml-builder-js` to the extension's dependencies to handle XML creation safely.                                | `package.json`                                           |
| **4.2** |  To Do   | **Create `XmlFormatterService.ts`:** Create a new file for the service that will be responsible for all XML formatting.                                         | `src/formatting/XmlFormatterService.ts` (New)            |
| **4.3** |  To Do   | **Implement `formatResults` Method:** In the new service, create a public method that takes the array of search results and returns an XML string.                 | `src/formatting/XmlFormatterService.ts`                  |
| **4.4** |  To Do   | **Build XML Structure:** Inside `formatResults`, use the XML builder library to create the `<files>` root element and loop through the results to create `<file>` child elements. | `src/formatting/XmlFormatterService.ts`                  |
| **4.5** |  To Do   | **Add `path` Attribute:** For each `<file>` element, add the `path` attribute with the value of the file's path.                                                  | `src/formatting/XmlFormatterService.ts`                  |
| **4.6** |  To Do   | **Wrap Content in CDATA:** If a result includes file content, use the XML builder's CDATA method to wrap the content (e.g., `builder.create('file').dat(content)`). | `src/formatting/XmlFormatterService.ts`                  |
| **4.7** |  To Do   | **Integrate into `MessageRouter`:** In `src/messageRouter.ts`, after getting the results from `ContextService`, pass them to the `XmlFormatterService` to get the final XML string. | `src/messageRouter.ts`                                   |
| **4.8** |  To Do   | **Update `QueryView.svelte`:** Modify the results display area in the Svelte component to render the returned XML string within a `<pre><code>` block for display. | `webview/src/lib/components/QueryView.svelte`            |
| **4.9** |  To Do   | **Test Special Characters:** Write a unit test that passes code containing `<`, `>`, and `&` to the formatter and asserts that the output XML is valid and preserves the characters. | `src/test/suite/xmlFormatterService.test.ts` (New) |


Of course. Here is the final PRD that covers the remaining architectural and operational improvements for your VS Code extension.

-----

### **New Document: PRD 3: Polish & Robustness - State Management & DevOps**

**1. Title & Overview**

  * **Project:** Code Context Engine - State Management, DevOps, & Polish
  * **Summary:** This final phase focuses on making the extension robust, efficient, and ready for public release. We will implement a central state manager to prevent conflicting operations, add keyboard shortcuts for a better user experience, and establish a CI/CD pipeline in GitHub Actions to automate the build, test, and release process.
  * **Dependencies:** All core features from PRD 1 and PRD 2 must be complete. The SvelteKit UI and the backend services should be fully functional.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Increase user trust and satisfaction by delivering a stable, reliable, and professional-quality tool.
      * Improve development velocity and code quality by automating the testing and release pipeline.
  * **Developer & System Success Metrics:**
      * The extension correctly prevents a new indexing job from starting if one is already in progress.
      * Users can trigger key actions (e.g., open panel, start indexing) using configurable keyboard shortcuts.
      * A GitHub Actions workflow automatically builds and tests the extension on every pull request to the `main` branch.
      * The project has a comprehensive `README.md` and `CONTRIBUTING.md` to support users and future contributors.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin is a power user who expects a polished experience. He wants keyboard shortcuts for his most-used commands and trusts that the extension will handle concurrent operations gracefully without crashing or corrupting his index.
  * **Alisha (Backend Developer):** Alisha wants to ensure the long-term health of the project. A CI/CD pipeline gives her confidence that new changes won't introduce regressions, and a central state manager makes the application's behavior more predictable and easier to debug.

-----

**4. Requirements Breakdown**

| Phase            | Sprint                          | User Story                                                                                                                                              | Acceptance Criteria                                                                                                                                                                                                                                                                  | Duration  |
| :--------------- | :------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------- |
| **Phase 3: Polish** | **Sprint 5: State Management & Hotkeys** | As Alisha, I want to implement a `StateManager` to prevent concurrent operations, so the extension is more robust.                                         | 1. A `StateManager.ts` file is created to hold global state like `isIndexing`.\<br/\>2. The `IndexingService` updates this state when it starts and finishes.\<br/\>3. The `MessageRouter` checks this state and rejects new indexing requests if one is already running. | **2 Weeks** |
|                  |                                 | As Devin, I want to use keyboard shortcuts to open the main panel and start indexing, so I can work more efficiently.                                     | 1. A `keybindings` section is added to `package.json`.\<br/\>2. Default shortcuts are assigned to the `openMainPanel` and `startIndexing` commands.\<br/\>3. The shortcuts are functional and documented in the `README.md`.                                                                   |           |
| **Phase 3: Polish** | **Sprint 6: CI/CD Pipeline & Documentation** | As Alisha, I want a CI/CD pipeline using GitHub Actions to automate builds and testing, so we can ensure code quality and release reliability.          | 1. A `.github/workflows/ci.yml` file is created.\<br/\>2. The workflow runs on pull requests and includes steps for installing dependencies, linting, testing, and building the `.vsix` package.\<br/\>3. The workflow uploads the `.vsix` file as a build artifact. | **2 Weeks** |
|                  |                                 | As Devin, I want clear, comprehensive documentation for the extension, so that I know how to install, configure, and use it effectively.                  | 1. The `README.md` is updated with detailed sections for Features, Installation, and Configuration.\<br/\>2. A `CONTRIBUTING.md` file is created with guidelines for new developers.                                                            |           |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 5:** State Management & Hotkeys (2 Weeks)
  * **Sprint 6:** CI/CD Pipeline & Documentation (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The chosen default keybindings will not have major conflicts with common VS Code shortcuts.
  * **Risk:** The GitHub Actions pipeline may be complex to set up, especially if it involves running services like Docker for integration tests.
      * **Mitigation:** Start with a basic pipeline that only performs linting and unit tests. Add more complex steps like building and integration testing in a separate, follow-up task.
  * **Risk:** The `StateManager` could become a catch-all for unrelated state.
      * **Mitigation:** Enforce a strict policy that the `StateManager` should only contain truly *global* state flags (like `isIndexing`) and not component-level or session-specific data.

-----

### **New Document: tasklist\_sprint\_05.md**

# Task List: Sprint 5 - State Management & Hotkeys

**Goal:** To make the extension more robust by implementing a central state manager and to improve UX by adding keyboard shortcuts.

| Task ID | Status    | Task Description (Sequential & Atomic Steps)                                                                                                                                             | File(s) To Modify                                                         |
| :------ | :-------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------ |
| **5.1** |  To Do   | **Create `StateManager.ts` File:** Create the new file and define the `StateManager` class with a private `_isIndexing` flag and public getter/setter methods. | `src/stateManager.ts` (New)                                               |
| **5.2** |  To Do   | **Instantiate `StateManager` in `ExtensionManager`:** In `src/extensionManager.ts`, create a single instance of `StateManager` and pass it to the services that need it via their constructors. | `src/extensionManager.ts`                                                 |
| **5.3** |  To Do   | **Integrate State into `IndexingService`:** Modify `IndexingService` to accept `StateManager` in its constructor. Call `setIndexing(true)` at the start of `startIndexing` and `false` in a `finally` block. | `src/indexing/indexingService.ts`                                         |
| **5.4** |  To Do   | **Add Guard Clause to `MessageRouter`:** In `src/messageRouter.ts`, for the `startIndexing` command, add a guard clause that checks `stateManager.isIndexing()` and returns an error message to the UI if true. | `src/messageRouter.ts`                                                    |
| **5.5** |  To Do   | **Add `keybindings` to `package.json`:** Add the `contributes.keybindings` section and define keyboard shortcuts for the `openMainPanel` and `startIndexing` commands. | `package.json`                                                            |
| **5.6** |  To Do   | **Test Concurrent Indexing:** Manually trigger an indexing job, and while it's running, try to trigger another one. Verify the second job is blocked and a UI notification is shown. | `(Manual Test)`                                                           |
| **5.7** |  To Do   | **Test Hotkeys:** Reload the extension and verify that the newly defined keyboard shortcuts correctly trigger the "Open Main Panel" and "Start Indexing" commands. | `(Manual Test)`                                                           |

-----

### **New Document: tasklist\_sprint\_06.md**

# Task List: Sprint 6 - CI/CD Pipeline & Documentation

**Goal:** To automate the build and test process with GitHub Actions and create comprehensive user and contributor documentation.

| Task ID | Status    | Task Description (Sequential & Atomic Steps)                                                                                                                                                                   | File(s) To Modify                                  |
| :------ | :-------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------- |
| **6.1** |  To Do   | **Create GitHub Actions Workflow File:** Create a `.github/workflows/ci.yml` file.                                                                                                                            | `.github/workflows/ci.yml` (New)                   |
| **6.2** |  To Do   | **Configure Workflow Triggers:** In `ci.yml`, set the `on` section to trigger the workflow on `push` to `main` and on `pull_request` events.                                        | `.github/workflows/ci.yml`                         |
| **6.3** |  To Do   | **Define Build & Test Job:** Create a job that checks out the code, sets up Node.js, runs `npm install` in both the root and `/webview` directories, and runs linting and unit tests (`npm run lint`, `npm run test`). | `.github/workflows/ci.yml`                         |
| **6.4** |  To Do   | **Add Build Step:** Add a step to the job that runs the `npm run vscode:prepublish` command to build the extension and create the `.vsix` package.                       | `.github/workflows/ci.yml`                         |
| **6.5** |  To Do   | **Upload Artifact:** Add a final step to the job that uses the `actions/upload-artifact` action to save the generated `.vsix` file as a workflow artifact.                                 | `.github/workflows/ci.yml`                         |
| **6.6** |  To Do   | **Update `README.md`:** Thoroughly document the extension's features, installation steps, and all configuration options available in the native VS Code settings.                             | `README.md`                                        |
| **6.7** |  To Do   | **Create Demo GIF:** Record a short, animated GIF showing the primary user workflow (setup, index, query) and add it to the `README.md`.                                           | `README.md`, `assets/demo.gif` (New) |
| **6.8** |  To Do   | **Create `CONTRIBUTING.md`:** Create a new file with clear guidelines for setting up the development environment, running tests, and submitting pull requests.                          | `CONTRIBUTING.md` (New)                            |
| **6.9** |  To Do   | **Test CI Pipeline:** Push a commit or open a pull request to the `main` branch to trigger the CI workflow and verify that all steps execute successfully.                                                         | `(Manual Test on GitHub)`                          |

This completes the full set of PRDs and task lists for the project. You now have a comprehensive plan that addresses the remaining technical debt and adds the final layers of polish and automation needed for a successful public release.</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/missing2/tasklist_sprint_01.md">
# Task List: Sprint 1 - SvelteKit Migration & Componentization

**Goal:** To migrate the existing webview from a plain TypeScript implementation to a modern SvelteKit application and structure the UI into modular components.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Backup Existing Webview:** Open a terminal and run `mv webview webview-backup-$(date +%Y%m%d-%H%M%S)` to create a timestamped backup of the current webview implementation. | `webview/` (directory) |
| **1.2** |  To Do | **Initialize SvelteKit Project:** In the root directory, run `npm create svelte@latest webview`. When prompted, select: **Skeleton project**, **Yes, using TypeScript syntax**, **Add ESLint**, and **Add Prettier**. | `webview/` (new directory) |
| **1.3** |  To Do | **Install Static Adapter:** `cd` into the new `webview` directory and run `npm install -D @sveltejs/adapter-static`. | `webview/package.json` |
| **1.4** |  To Do | **Install Fluent UI Components:** While in the `webview` directory, run `npm install @fluentui/web-components`. | `webview/package.json` |
| **1.5** |  To Do | **Configure Static Build:** Replace the contents of `webview/svelte.config.js` with the provided code to configure the static adapter and set the output directory to `build`. | `webview/svelte.config.js` |
| **1.6** |  To Do | **Create Stores Directory:** Create a new directory at `webview/src/lib/stores`. | `webview/src/lib/stores/` |
| **1.7** |  To Do | **Create View Store:** Create a new file `viewStore.ts` inside the `stores` directory and add the exported `writable` store to manage the active view (`setup`, `indexing`, or `query`). | `webview/src/lib/stores/viewStore.ts` |
| **1.8** |  To Do | **Create App Store:** Create a new file `appStore.ts` inside the `stores` directory for future global app state (e.g., error messages, notifications). Leave it empty for now. | `webview/src/lib/stores/appStore.ts` |
| **1.9** |  To Do | **Create Components Directory:** Create a new directory at `webview/src/lib/components`. | `webview/src/lib/components/` |
| **1.10** |  To Do | **Create `SetupView` Component:** Create `SetupView.svelte` in the `components` directory with a basic `<h1>Setup</h1>` placeholder. | `webview/src/lib/components/SetupView.svelte` |
| **1.11** |  To Do | **Create `IndexingView` Component:** Create `IndexingView.svelte` in the `components` directory with a basic `<h1>Indexing</h1>` placeholder. | `webview/src/lib/components/IndexingView.svelte` |
| **1.12** |  To Do | **Create `QueryView` Component:** Create `QueryView.svelte` in the `components` directory with a basic `<h1>Query</h1>` placeholder. | `webview/src/lib/components/QueryView.svelte` |
| **1.13** |  To Do | **Implement Main Page Layout:** Replace the contents of `webview/src/routes/+page.svelte`. Import the three view components and the `viewStore`, and use an `{#if}` block to conditionally render the correct view based on the store's value. | `webview/src/routes/+page.svelte` |
| **1.14**|  To Do | **Update `WebviewManager` Path Logic:** In `src/webviewManager.ts`, find the `getWebviewContent` method. Modify the `htmlPath` variable to point to `webview/build/index.html`. | `src/webviewManager.ts` |
| **1.15**|  To Do | **Update `WebviewManager` Asset Rewriting:** In the same method, ensure the regex for rewriting asset paths correctly converts paths for the webview using `webview.asWebviewUri`. The existing logic should be close, but verify it works with the new `build` directory structure. | `src/webviewManager.ts` |
| **1.16**|  To Do | **Test Build & Load:** `cd` into `webview/` and run `npm run build`. Then, launch the extension in VS Code (F5) and run the `Open Main Panel` command. Verify the `SetupView` component loads correctly. | `(Manual Test)` |
</file>

<file path="docs/todo/missing2/tasklist_sprint_02.md">
# Task List: Sprint 2 - Intuitive Settings & Diagnostics UI

**Goal:** To build a rich, interactive setup UI that validates the user's system and allows them to test their configuration before committing to an index.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Create Validation Directory:** Create a new directory at `src/validation`. | `src/validation/` |
| **2.2** |  To Do | **Create `SystemValidator.ts`:** Create a new file `SystemValidator.ts` in the `validation` directory. Add the class definition and an async method `checkDocker()` that executes `docker --version` and returns the result. | `src/validation/systemValidator.ts` |
| **2.3** |  To Do | **Integrate `SystemValidator`:** In `src/extensionManager.ts`, import and create an instance of `SystemValidator`. Pass this instance to the `MessageRouter`'s constructor. | `src/extensionManager.ts` |
| **2.4** |  To Do | **Add `validateSystem` Handler:** In `src/messageRouter.ts`, add a new `case 'validateSystem'` to the `handleMessage` method. This handler should call the `systemValidator` and post the results back to the webview. | `src/messageRouter.ts` |
| **2.5** |  To Do | **Create `SystemValidation.svelte` Component:** Create the file `webview/src/lib/components/SystemValidation.svelte`. In the `<script>` section, use `onMount` to call `vscode.postMessage({ command: 'validateSystem' })` and a `window.addEventListener` to listen for the results. | `webview/src/lib/components/SystemValidation.svelte` |
| **2.6** |  To Do | **Implement `SystemValidation.svelte` UI:** In the same file, add HTML to iterate over the validation results and display each check's name, status (success/failure), and message. | `webview/src/lib/components/SystemValidation.svelte` |
| **2.7** |  To Do | **Create `ValidatedInput.svelte` Component:** Create the file `webview/src/lib/components/ValidatedInput.svelte`. Implement a reusable input with props for `label`, `value`, and a `validator` function. It should display an error message if validation fails on blur. | `webview/src/lib/components/ValidatedInput.svelte` |
| **2.8** |  To Do | **Create `ConnectionTester.svelte` Component:** Create `webview/src/lib/components/ConnectionTester.svelte`. Implement a component with a "Test" button that calls a `testFunction` prop and displays the status (e.g., loading, success, error) and result message. | `webview/src/lib/components/ConnectionTester.svelte` |
| **2.9** |  To Do | **Add `testDatabaseConnection` Handler:** In `src/messageRouter.ts`, add a `case 'testDatabaseConnection'`. This handler should attempt to connect to the Qdrant database and return a success or error message to the webview. | `src/messageRouter.ts` |
| **2.10**|  To Do | **Update `SetupView.svelte`:** Import `SystemValidation.svelte` and add it to the top of the view. | `webview/src/lib/components/SetupView.svelte` |
| **2.11**|  To Do | **Add Database Config to `SetupView`:** In `SetupView.svelte`, import and use `ValidatedInput` for the database connection string. Add a `ConnectionTester` component wired to the `testDatabaseConnection` command. | `webview/src/lib/components/SetupView.svelte` |
| **2.12**|  To Do | **Add Provider Config to `SetupView`:** In `SetupView.svelte`, add another `ValidatedInput` for the embedding provider API key (if applicable) and a corresponding `ConnectionTester`. | `webview/src/lib/components/SetupView.svelte` |
| **2.13**|  To Do | **Test System Validation:** Launch the extension and open the main panel. Verify the `SystemValidation` component appears and correctly reports the status of Docker on your machine. | `(Manual Test)` |
| **2.14**|  To Do | **Test Connection Testers:** Enter a valid/invalid database URL and click the "Test" button. Verify that the correct success/error feedback is displayed. | `(Manual Test)` |
</file>

<file path="docs/todo/missing2/tasklist_sprint_03.md">
# Task List: Sprint 3 - Advanced Search UI & Logic

**Goal:** To enhance the search UI with advanced controls and implement the backend logic for deduplicating results.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Add UI Controls to `QueryView`:** In `webview/src/lib/components/QueryView.svelte`, add an `<input type="number">` for "Max Results" and an `<input type="checkbox">` for "Include file content". | `webview/src/lib/components/QueryView.svelte` |
| **3.2** |  To Do | **Bind UI Controls to State:** In the `<script>` section of `QueryView.svelte`, create two state variables, `maxResults` and `includeContent`, and bind them to the new input fields using `bind:value` and `bind:checked`. | `webview/src/lib/components/QueryView.svelte` |
| **3.3** |  To Do | **Update Message Payload:** In the `runQuery` function within `QueryView.svelte`, modify the `vscode.postMessage` call to include `maxResults` and `includeContent` in the `payload` object sent to the backend. | `webview/src/lib/components/QueryView.svelte` |
| **3.4** |  To Do | **Update `ContextService` Method Signature:** In `src/context/contextService.ts`, modify the `queryContext` method signature to accept the new `maxResults: number` and `includeContent: boolean` parameters, providing default values. | `src/context/contextService.ts` |
| **3.5** |  To Do | **Fetch Extra Results:** In `queryContext`, when calling the Qdrant search method, fetch more results than `maxResults` (e.g., `limit: maxResults * 5`) to ensure a sufficient pool for deduplication. | `src/context/contextService.ts` |
| **3.6** |  To Do | **Implement Deduplication `Map`:** In `queryContext`, after getting the raw results, initialize a `new Map<string, QueryResult>()`. Loop through the raw results and populate the map, ensuring only the result with the highest score for each unique `filePath` is kept. | `src/context/contextService.ts` |
| **3.7** |  To Do | **Aggregate and Limit Results:** Convert the map's values to an array using `Array.from(uniqueFiles.values())`. Sort this array by score in descending order. | `src/context/contextService.ts` |
| **3.8** |  To Do | **Slice Final Results:** On the sorted array, use `.slice(0, maxResults)` to truncate the list to the user-specified length. | `src/context/contextService.ts` |
| **3.9** |  To Do | **Conditionally Read Content:** After slicing, add an `if (includeContent)` block. Inside, loop through the final results and use `fs.promises.readFile` to read the file content for each result, assigning it to the `content` property. | `src/context/contextService.ts` |
| **3.10**|  To Do | **Create Test File:** Create a new test file at `src/test/suite/contextService.test.ts`. | `src/test/suite/contextService.test.ts` |
| **3.11**|  To Do | **Write Deduplication Unit Test:** In the new test file, write a test case for `queryContext`. Mock the Qdrant service to return a list of results with duplicate file paths. Assert that the final result is unique and contains only the highest-scoring entry for each file. | `src/test/suite/contextService.test.ts` |
| **3.12**|  To Do | **Test UI Functionality:** Launch the extension. Go to the Query view, set "Max Results" to 5, and run a query. Verify that no more than 5 results are returned. | `(Manual Test)` |
</file>

<file path="docs/todo/missing2/tasklist_sprint_04.md">
# Task List: Sprint 4 - XML Result Formatting

**Goal:** To create a dedicated service for formatting the final, deduplicated search results into a `repomix`-style XML string.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Install XML Builder Library:** Open a terminal in the root directory and run `npm install xmlbuilder2` to add the library to the project. | `package.json` |
| **4.2** |  To Do | **Create Formatting Directory:** Create a new directory at `src/formatting`. | `src/formatting/` |
| **4.3** |  To Do | **Create `XmlFormatterService.ts`:** Create a new file `XmlFormatterService.ts` in the `formatting` directory. Define the `XmlFormatterService` class within it. | `src/formatting/XmlFormatterService.ts` |
| **4.4** |  To Do | **Implement `formatResults` Method:** In `XmlFormatterService`, create a public method `formatResults(results: QueryResult[]): string`. | `src/formatting/XmlFormatterService.ts` |
| **4.5** |  To Do | **Build XML Structure:** Inside `formatResults`, use `xmlbuilder2` to create a root `<files>` element. Loop through the `results` array. For each result, create a `<file>` child element. | `src/formatting/XmlFormatterService.ts` |
| **4.6** |  To Do | **Add `path` Attribute:** When creating each `<file>` element, add a `path` attribute containing the `result.filePath`. | `src/formatting/XmlFormatterService.ts` |
| **4.7** |  To Do | **Wrap Content in CDATA:** Inside the loop, check if `result.content` exists. If it does, use the builder's `.dat()` method to add the content inside a `<![CDATA[...]]>` section within the `<file>` element. | `src/formatting/XmlFormatterService.ts` |
| **4.8** |  To Do | **Return Formatted XML:** At the end of `formatResults`, call `.end({ prettyPrint: true })` on the root element to generate and return the final, formatted XML string. | `src/formatting/XmlFormatterService.ts` |
| **4.9** |  To Do | **Integrate into `ExtensionManager`:** In `src/extensionManager.ts`, import and create an instance of `XmlFormatterService`. Pass this instance to the `MessageRouter`'s constructor. | `src/extensionManager.ts` |
| **4.10**|  To Do | **Integrate into `MessageRouter`:** In `src/messageRouter.ts`, modify the `queryContext` handler. After getting the results from `ContextService`, pass them to `xmlFormatterService.formatResults` to get the XML string. | `src/messageRouter.ts` |
| **4.11**|  To Do | **Update `MessageRouter` Payload:** Change the `postMessage` call in the `queryContext` handler to send the final XML string to the webview, not the raw result object. | `src/messageRouter.ts` |
| **4.12**|  To Do | **Update `QueryView.svelte` Display:** In `webview/src/lib/components/QueryView.svelte`, wrap the `{results}` variable in a `<pre><code>` block to ensure the XML is displayed correctly with proper indentation. | `webview/src/lib/components/QueryView.svelte` |
| **4.13**|  To Do | **Create Formatter Test File:** Create a new test file at `src/test/suite/xmlFormatterService.test.ts`. | `src/test/suite/xmlFormatterService.test.ts` |
| **4.14**|  To Do | **Write CDATA Unit Test:** In the new test file, write a test that passes mock results containing special XML characters (e.g., `<`, `&`) to `formatResults`. Assert that the output contains a valid `CDATA` section and is well-formed. | `src/test/suite/xmlFormatterService.test.ts` |
| **4.15**|  To Do | **Test End-to-End:** Launch the extension. Run a query with "Include file content" checked. Verify the results are displayed as a formatted XML string in the UI. | `(Manual Test)` |
</file>

<file path="docs/todo/missing2/tasklist_sprint_05.md">
# Task List: Sprint 5 - State Management & Hotkeys

**Goal:** To make the extension more robust by implementing a central state manager and to improve UX by adding keyboard shortcuts.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** |  To Do | **Create `StateManager.ts` File:** Create a new file at `src/stateManager.ts`. | `src/stateManager.ts` |
| **5.2** |  To Do | **Implement `StateManager` Class:** In the new file, define the `StateManager` class. Add a private boolean property `_isIndexing` and a public getter `isIndexing`. Add a public method `setIndexing(status: boolean)` to modify the state. | `src/stateManager.ts` |
| **5.3** |  To Do | **Instantiate `StateManager`:** In `src/extensionManager.ts`, import the `StateManager` class. In the constructor, create a single instance: `this.stateManager = new StateManager();`. | `src/extensionManager.ts` |
| **5.4** |  To Do | **Inject `StateManager` into `IndexingService`:** Modify the `IndexingService` constructor to accept a `StateManager` instance. Pass `this.stateManager` when creating the `IndexingService` in `ExtensionManager`. | `src/indexing/indexingService.ts`, `src/extensionManager.ts` |
| **5.5** |  To Do | **Inject `StateManager` into `MessageRouter`:** Modify the `MessageRouter` constructor to accept a `StateManager` instance. Pass `this.stateManager` when creating the `MessageRouter` in `ExtensionManager`. | `src/messageRouter.ts`, `src/extensionManager.ts` |
| **5.6** |  To Do | **Update `IndexingService` State:** In `indexingService.ts`, wrap the logic inside the `startIndexing` method in a `try...finally` block. | `src/indexing/indexingService.ts` |
| **5.7** |  To Do | **Set State Before Indexing:** At the beginning of the `try` block in `startIndexing`, call `this.stateManager.setIndexing(true);`. | `src/indexing/indexingService.ts` |
| **5.8** |  To Do | **Reset State After Indexing:** In the `finally` block, call `this.stateManager.setIndexing(false);` to ensure the state is always reset, even if an error occurs. | `src/indexing/indexingService.ts` |
| **5.9** |  To Do | **Add Guard Clause to `MessageRouter`:** In `messageRouter.ts`, at the beginning of the `case 'startIndexing'` handler, add an `if` statement to check `this.stateManager.isIndexing`. | `src/messageRouter.ts` |
| **5.10**|  To Do | **Block Concurrent Indexing:** If `isIndexing` is true, post an error message back to the webview and `return` immediately to stop further execution. | `src/messageRouter.ts` |
| **5.11**|  To Do | **Verify Keybindings in `package.json`:** Open `package.json` and locate the `contributes.keybindings` section. Verify that shortcuts for `openMainPanel` and `startIndexing` exist and are correct. This task is a verification, not an addition. | `package.json` |
| **5.12**|  To Do | **Document Shortcuts:** Open `README.md` and add a "Keyboard Shortcuts" section, documenting the default hotkeys for users. | `README.md` |
| **5.13**|  To Do | **Test Concurrent Indexing:** Launch the extension. Start an indexing process on a large folder. While it is running, immediately try to trigger the `Start Indexing` command again. | `(Manual Test)` |
| **5.14**|  To Do | **Verify Concurrent Indexing Block:** Confirm that the second indexing process does not start and that an error message (e.g., "An indexing process is already running.") is displayed in the webview. | `(Manual Test)` |
| **5.15**|  To Do | **Test Hotkeys:** With the extension running, press the key combination for `openMainPanel` (e.g., `Cmd+Alt+C`) and verify the panel opens. Press the combination for `startIndexing` and verify the process starts. | `(Manual Test)` |
</file>

<file path="docs/todo/missing2/tasklist_sprint_06.md">
# Task List: Sprint 6 - CI/CD Pipeline & Documentation

**Goal:** To automate the build and test process with GitHub Actions and create comprehensive user and contributor documentation.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** |  To Do | **Create Workflow Directory:** In the root of the project, create the necessary directories for the workflow file by running `mkdir -p .github/workflows`. | `.github/workflows/` |
| **6.2** |  To Do | **Create Workflow File:** Create a new, empty file named `ci.yml` inside the `.github/workflows` directory. | `.github/workflows/ci.yml` |
| **6.3** |  To Do | **Define Workflow Name and Triggers:** In `ci.yml`, add the `name` of the workflow and the `on` section to trigger it on `push` to `main` and on `pull_request` events. | `.github/workflows/ci.yml` |
| **6.4** |  To Do | **Define Build & Test Job:** In `ci.yml`, define a job named `build-and-test` that `runs-on: ubuntu-latest`. | `.github/workflows/ci.yml` |
| **6.5** |  To Do | **Add Checkout Step:** Add the first step to the job using `uses: actions/checkout@v3` to check out the repository code. | `.github/workflows/ci.yml` |
| **6.6** |  To Do | **Add Node.js Setup Step:** Add a step using `uses: actions/setup-node@v3` to install and configure Node.js version 18. | `.github/workflows/ci.yml` |
| **6.7** |  To Do | **Add Root Install Step:** Add a `run` step with the command `npm install` to install the main extension dependencies. | `.github/workflows/ci.yml` |
| **6.8** |  To Do | **Add Webview Install Step:** Add a `run` step with the command `npm install` and set `working-directory: ./webview` to install the webview dependencies. | `.github/workflows/ci.yml` |
| **6.9** |  To Do | **Add Lint Step:** Add a `run` step with the command `npm run lint` to execute the linter. | `.github/workflows/ci.yml` |
| **6.10**|  To Do | **Add Test Step:** Add a `run` step with the command `npm run test` to execute the automated test suite. | `.github/workflows/ci.yml` |
| **6.11**|  To Do | **Add Build Step:** Add a `run` step with the command `npm run vscode:prepublish` to compile the code and build the `.vsix` package. | `.github/workflows/ci.yml` |
| **6.12**|  To Do | **Add Upload Artifact Step:** Add a final step using `uses: actions/upload-artifact@v3`. Configure it to upload the generated `.vsix` file with an appropriate artifact name (e.g., `extension-vsix-package`). | `.github/workflows/ci.yml` |
| **6.13**|  To Do | **Update `README.md`:** Overhaul the `README.md` file. Add detailed sections for Features, Installation from the marketplace, all Configuration options, Commands, and Keyboard Shortcuts. | `README.md` |
| **6.14**|  To Do | **Create Demo GIF:** Use a screen recording tool to record a short GIF of the main user workflow (setup, index, query). Create an `assets` directory and save the file as `assets/demo.gif`. | `assets/demo.gif` |
| **6.15**|  To Do | **Embed Demo GIF:** Add the markdown `![Demo](assets/demo.gif)` to the top of the `README.md` file. | `README.md` |
| **6.16**|  To Do | **Create `CONTRIBUTING.md`:** Create a new `CONTRIBUTING.md` file in the root directory. Add sections for setting up the development environment, running tests, and the pull request process. | `CONTRIBUTING.md` |
| **6.17**|  To Do | **Test CI Pipeline:** Push a commit to a new branch and open a pull request to `main`. Verify that the CI workflow is triggered and all steps execute successfully on GitHub. | `(Manual Test on GitHub)` |
</file>

<file path="src/stateManager.ts">
import * as vscode from 'vscode';

/**
 * StateManager class responsible for managing global application state
 * and preventing conflicting operations.
 * 
 * This class provides centralized state management for the extension,
 * ensuring that operations like indexing don't run concurrently and
 * maintaining consistency across different services.
 */
export class StateManager {
    private _isIndexing: boolean = false;
    private _isInitialized: boolean = false;
    private _lastError: string | null = null;
    private _indexingStartTime: Date | null = null;
    private _indexingProgress: number = 0;
    private _currentOperation: string | null = null;

    // Event emitters for state changes
    private _onStateChanged = new vscode.EventEmitter<StateChangeEvent>();
    public readonly onStateChanged = this._onStateChanged.event;

    /**
     * Creates a new StateManager instance
     */
    constructor() {
        console.log('StateManager: Initialized');
    }

    /**
     * Gets the current state snapshot
     */
    public getState(): ApplicationState {
        return {
            isIndexing: this._isIndexing,
            isInitialized: this._isInitialized,
            lastError: this._lastError,
            indexingStartTime: this._indexingStartTime,
            indexingProgress: this._indexingProgress,
            currentOperation: this._currentOperation
        };
    }

    /**
     * Checks if indexing is currently in progress
     */
    public isIndexing(): boolean {
        return this._isIndexing;
    }

    /**
     * Checks if the extension is initialized
     */
    public isInitialized(): boolean {
        return this._isInitialized;
    }

    /**
     * Gets the last error message
     */
    public getLastError(): string | null {
        return this._lastError;
    }

    /**
     * Gets the current indexing progress (0-100)
     */
    public getIndexingProgress(): number {
        return this._indexingProgress;
    }

    /**
     * Gets the current operation description
     */
    public getCurrentOperation(): string | null {
        return this._currentOperation;
    }

    /**
     * Sets the indexing state
     * @param isIndexing - Whether indexing is in progress
     * @param operation - Optional description of the current operation
     */
    public setIndexing(isIndexing: boolean, operation?: string): void {
        const previousState = this.getState();
        
        this._isIndexing = isIndexing;
        this._currentOperation = operation || null;
        
        if (isIndexing) {
            this._indexingStartTime = new Date();
            this._indexingProgress = 0;
            this._lastError = null; // Clear previous errors when starting
            console.log(`StateManager: Indexing started - ${operation || 'No description'}`);
        } else {
            this._indexingStartTime = null;
            this._currentOperation = null;
            console.log('StateManager: Indexing stopped');
        }

        this._emitStateChange(previousState, this.getState());
    }

    /**
     * Updates the indexing progress
     * @param progress - Progress percentage (0-100)
     * @param operation - Optional description of the current operation
     */
    public updateIndexingProgress(progress: number, operation?: string): void {
        if (!this._isIndexing) {
            console.warn('StateManager: Attempted to update progress while not indexing');
            return;
        }

        const previousState = this.getState();
        
        this._indexingProgress = Math.max(0, Math.min(100, progress));
        if (operation) {
            this._currentOperation = operation;
        }

        this._emitStateChange(previousState, this.getState());
    }

    /**
     * Sets the initialization state
     * @param isInitialized - Whether the extension is initialized
     */
    public setInitialized(isInitialized: boolean): void {
        const previousState = this.getState();
        
        this._isInitialized = isInitialized;
        console.log(`StateManager: Initialization state changed to ${isInitialized}`);

        this._emitStateChange(previousState, this.getState());
    }

    /**
     * Sets an error state
     * @param error - Error message or null to clear
     */
    public setError(error: string | null): void {
        const previousState = this.getState();
        
        this._lastError = error;
        
        if (error) {
            console.error(`StateManager: Error set - ${error}`);
        } else {
            console.log('StateManager: Error cleared');
        }

        this._emitStateChange(previousState, this.getState());
    }

    /**
     * Clears the error state
     */
    public clearError(): void {
        this.setError(null);
    }

    /**
     * Attempts to start an operation, returns false if another operation is in progress
     * @param operationName - Name of the operation to start
     * @returns True if operation can start, false if blocked
     */
    public tryStartOperation(operationName: string): boolean {
        if (this._isIndexing) {
            console.warn(`StateManager: Cannot start '${operationName}' - indexing already in progress`);
            return false;
        }

        console.log(`StateManager: Operation '${operationName}' can proceed`);
        return true;
    }

    /**
     * Gets the duration of the current indexing operation
     * @returns Duration in milliseconds, or null if not indexing
     */
    public getIndexingDuration(): number | null {
        if (!this._isIndexing || !this._indexingStartTime) {
            return null;
        }

        return Date.now() - this._indexingStartTime.getTime();
    }

    /**
     * Resets all state to initial values
     */
    public reset(): void {
        const previousState = this.getState();
        
        this._isIndexing = false;
        this._isInitialized = false;
        this._lastError = null;
        this._indexingStartTime = null;
        this._indexingProgress = 0;
        this._currentOperation = null;

        console.log('StateManager: State reset to initial values');
        this._emitStateChange(previousState, this.getState());
    }

    /**
     * Disposes of the StateManager and cleans up resources
     */
    public dispose(): void {
        this._onStateChanged.dispose();
        console.log('StateManager: Disposed');
    }

    /**
     * Emits a state change event
     */
    private _emitStateChange(previousState: ApplicationState, currentState: ApplicationState): void {
        this._onStateChanged.fire({
            previousState,
            currentState,
            timestamp: new Date()
        });
    }
}

/**
 * Interface representing the application state
 */
export interface ApplicationState {
    isIndexing: boolean;
    isInitialized: boolean;
    lastError: string | null;
    indexingStartTime: Date | null;
    indexingProgress: number;
    currentOperation: string | null;
}

/**
 * Interface for state change events
 */
export interface StateChangeEvent {
    previousState: ApplicationState;
    currentState: ApplicationState;
    timestamp: Date;
}
</file>

<file path="webview/src/lib/components/DiagnosticsView.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import {
        provideFluentDesignSystem,
        fluentButton,
        fluentCard,
        fluentBadge,
        fluentProgressRing
    } from '@fluentui/web-components';
    import { postMessage, onMessage } from '$lib/vscodeApi';
    import { setupState, appActions } from '$lib/stores/appStore';
    import ConnectionTester from './ConnectionTester.svelte';
    
    // Register Fluent UI components
    provideFluentDesignSystem().register(
        fluentButton(),
        fluentCard(),
        fluentBadge(),
        fluentProgressRing()
    );

    // Local state for diagnostics
    let systemStatus = {
        database: 'unknown',
        provider: 'unknown',
        lastIndexed: null as Date | null,
        totalChunks: 0,
        lastError: null as string | null
    };

    let isTestingConnections = false;
    let testResults = {
        database: null as any,
        provider: null as any
    };

    // Message handlers
    let unsubscribeFunctions: (() => void)[] = [];

    onMount(() => {
        // Set up message listeners
        unsubscribeFunctions.push(
            onMessage('systemStatus', (message) => {
                systemStatus = { ...systemStatus, ...message.data };
            }),
            onMessage('connectionTestResult', (message) => {
                if (message.data.type === 'database') {
                    testResults.database = message.data.result;
                } else if (message.data.type === 'provider') {
                    testResults.provider = message.data.result;
                }
                isTestingConnections = false;
            }),
            onMessage('error', (message) => {
                systemStatus.lastError = message.message;
                appActions.setError(message.message);
                isTestingConnections = false;
            })
        );

        // Request initial system status
        postMessage('getSystemStatus');
    });

    onDestroy(() => {
        // Clean up message listeners
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    });

    function openSettings() {
        postMessage('openSettings');
    }

    function testDatabaseConnection() {
        if (isTestingConnections) return;
        
        isTestingConnections = true;
        testResults.database = null;
        
        postMessage('testDatabaseConnection', {
            type: $setupState.selectedDatabase,
            config: {
                // Use current configuration from settings
                host: 'localhost', // This would come from actual settings
                port: $setupState.selectedDatabase === 'qdrant' ? 6333 : 8000
            }
        });
    }

    function testProviderConnection() {
        if (isTestingConnections) return;
        
        isTestingConnections = true;
        testResults.provider = null;
        
        postMessage('testProviderConnection', {
            type: $setupState.selectedProvider,
            config: {
                // Use current configuration from settings
                endpoint: $setupState.selectedProvider === 'ollama' ? 'http://localhost:11434' : undefined
            }
        });
    }

    function refreshStatus() {
        postMessage('getSystemStatus');
    }

    function clearError() {
        systemStatus.lastError = null;
        appActions.clearError();
    }

    // Helper functions
    function getStatusBadgeAppearance(status: string) {
        switch (status) {
            case 'ready':
            case 'connected':
                return 'accent';
            case 'error':
            case 'disconnected':
                return 'important';
            case 'starting':
            case 'connecting':
                return 'neutral';
            default:
                return 'neutral';
        }
    }

    function formatDate(date: Date | null): string {
        if (!date) return 'Never';
        return date.toLocaleString();
    }
</script>

<div class="diagnostics-view">
    <div class="diagnostics-header">
        <h1>Status & Diagnostics</h1>
        <p>Monitor system status, test connections, and access configuration settings.</p>
        
        <div class="header-actions">
            <fluent-button appearance="accent" on:click={openSettings}>
                 Edit Configuration
            </fluent-button>
            <fluent-button on:click={refreshStatus}>
                 Refresh Status
            </fluent-button>
        </div>
    </div>

    <!-- Error Display -->
    {#if systemStatus.lastError}
        <div class="error-banner">
            <div class="error-content">
                <strong> Error:</strong> {systemStatus.lastError}
            </div>
            <fluent-button appearance="stealth" on:click={clearError}></fluent-button>
        </div>
    {/if}

    <!-- Current Configuration Display -->
    <fluent-card class="config-section">
        <h3>Current Configuration</h3>
        <div class="config-grid">
            <div class="config-item">
                <label>Database:</label>
                <div class="config-value">
                    <span>{$setupState.selectedDatabase || 'Not configured'}</span>
                    <fluent-badge appearance={getStatusBadgeAppearance($setupState.databaseStatus)}>
                        {$setupState.databaseStatus}
                    </fluent-badge>
                </div>
            </div>
            
            <div class="config-item">
                <label>Embedding Provider:</label>
                <div class="config-value">
                    <span>{$setupState.selectedProvider || 'Not configured'}</span>
                    <fluent-badge appearance={getStatusBadgeAppearance($setupState.providerStatus)}>
                        {$setupState.providerStatus}
                    </fluent-badge>
                </div>
            </div>
            
            <div class="config-item">
                <label>Last Indexed:</label>
                <div class="config-value">
                    <span>{formatDate(systemStatus.lastIndexed)}</span>
                </div>
            </div>
            
            <div class="config-item">
                <label>Total Chunks:</label>
                <div class="config-value">
                    <span>{systemStatus.totalChunks.toLocaleString()}</span>
                </div>
            </div>
        </div>
    </fluent-card>

    <!-- Connection Testing -->
    <fluent-card class="testing-section">
        <h3>Connection Testing</h3>
        <p>Test your database and embedding provider connections to ensure everything is working correctly.</p>
        
        <div class="test-grid">
            <!-- Database Connection Test -->
            <div class="test-item">
                <h4>Database Connection</h4>
                <div class="test-actions">
                    <fluent-button 
                        appearance="outline" 
                        disabled={isTestingConnections || !$setupState.selectedDatabase}
                        on:click={testDatabaseConnection}
                    >
                        {#if isTestingConnections && testResults.database === null}
                            <fluent-progress-ring></fluent-progress-ring>
                            Testing...
                        {:else}
                             Test Database
                        {/if}
                    </fluent-button>
                </div>
                
                {#if testResults.database}
                    <div class="test-result" class:success={testResults.database.success} class:error={!testResults.database.success}>
                        <strong>{testResults.database.success ? ' Success' : ' Failed'}:</strong>
                        {testResults.database.message}
                        {#if testResults.database.details}
                            <div class="test-details">{testResults.database.details}</div>
                        {/if}
                    </div>
                {/if}
            </div>

            <!-- Provider Connection Test -->
            <div class="test-item">
                <h4>Embedding Provider</h4>
                <div class="test-actions">
                    <fluent-button 
                        appearance="outline" 
                        disabled={isTestingConnections || !$setupState.selectedProvider}
                        on:click={testProviderConnection}
                    >
                        {#if isTestingConnections && testResults.provider === null}
                            <fluent-progress-ring></fluent-progress-ring>
                            Testing...
                        {:else}
                             Test Provider
                        {/if}
                    </fluent-button>
                </div>
                
                {#if testResults.provider}
                    <div class="test-result" class:success={testResults.provider.success} class:error={!testResults.provider.success}>
                        <strong>{testResults.provider.success ? ' Success' : ' Failed'}:</strong>
                        {testResults.provider.message}
                        {#if testResults.provider.details}
                            <div class="test-details">{testResults.provider.details}</div>
                        {/if}
                    </div>
                {/if}
            </div>
        </div>
    </fluent-card>

    <!-- Quick Actions -->
    <fluent-card class="actions-section">
        <h3>Quick Actions</h3>
        <div class="action-buttons">
            <fluent-button appearance="accent" on:click={openSettings}>
                 Open Settings
            </fluent-button>
            <fluent-button on:click={() => postMessage('openMainPanel')}>
                 Main Panel
            </fluent-button>
            <fluent-button on:click={() => postMessage('startIndexing')} disabled={!$setupState.isSetupComplete}>
                 Start Indexing
            </fluent-button>
        </div>
    </fluent-card>
</div>

<style>
    .diagnostics-view {
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        font-family: var(--vscode-font-family);
    }

    .diagnostics-header {
        text-align: center;
        margin-bottom: 30px;
    }

    .diagnostics-header h1 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
        font-size: 28px;
    }

    .diagnostics-header p {
        margin: 0 0 20px 0;
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
    }

    .header-actions {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
    }

    .error-banner {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        margin-bottom: 20px;
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        border-radius: 4px;
        color: var(--vscode-inputValidation-errorForeground);
    }

    .error-content {
        flex: 1;
    }

    .config-section, .testing-section, .actions-section {
        margin-bottom: 20px;
        padding: 20px;
    }

    .config-section h3, .testing-section h3, .actions-section h3 {
        margin: 0 0 15px 0;
        color: var(--vscode-textLink-foreground);
    }

    .config-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
    }

    .config-item {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    .config-item label {
        font-weight: 600;
        color: var(--vscode-foreground);
        font-size: 14px;
    }

    .config-value {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .config-value span {
        color: var(--vscode-descriptionForeground);
    }

    .test-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
    }

    .test-item {
        padding: 15px;
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        background-color: var(--vscode-textCodeBlock-background);
    }

    .test-item h4 {
        margin: 0 0 10px 0;
        color: var(--vscode-foreground);
    }

    .test-actions {
        margin-bottom: 15px;
    }

    .test-result {
        padding: 10px;
        border-radius: 4px;
        font-size: 14px;
    }

    .test-result.success {
        background-color: var(--vscode-charts-green);
        color: white;
    }

    .test-result.error {
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        color: var(--vscode-inputValidation-errorForeground);
    }

    .test-details {
        margin-top: 5px;
        font-size: 12px;
        opacity: 0.9;
    }

    .action-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }

    @media (max-width: 600px) {
        .config-grid {
            grid-template-columns: 1fr;
        }
        
        .test-grid {
            grid-template-columns: 1fr;
        }
        
        .header-actions, .action-buttons {
            flex-direction: column;
            align-items: center;
        }
    }
</style>
</file>

<file path="docs/completed/extension/backlog_sub_sprint_1_dependency_injection_centralized_config.md">
### User Story 1: Refactor Services for Dependency Injection
**As Alisha, I want to** refactor services to receive dependencies via their constructor, **so that** I can unit test them with mocks.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Modify the constructor to accept `qdrantService: QdrantService` and `embeddingProvider: IEmbeddingProvider` as arguments. Remove any `new` keywords for these dependencies.
    -   **Implementation**:
        ```typescript
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';

        export class ContextService {
            constructor(
                private qdrantService: QdrantService,
                private embeddingProvider: IEmbeddingProvider
            ) {
                // ... existing constructor logic ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: `import { QdrantService } from '../db/qdrantService'; import { IEmbeddingProvider } from '../embeddings/embeddingProvider';`
2.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Modify the constructor to accept its dependencies (`fileWalker`, `astParser`, `chunker`, `qdrantService`, `embeddingProvider`, `lspService`) as arguments. Remove any `new` keywords for these dependencies.
    -   **Implementation**:
        ```typescript
        import { FileWalker } from './fileWalker';
        import { AstParser } from '../parsing/astParser';
        import { Chunker } from '../parsing/chunker';
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
        import { LspService } from '../lsp/lspService';

        export class IndexingService {
            constructor(
                private fileWalker: FileWalker,
                private astParser: AstParser,
                private chunker: Chunker,
                private qdrantService: QdrantService,
                private embeddingProvider: IEmbeddingProvider,
                private lspService: LspService
            ) {
                // ... existing constructor logic ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: `import { FileWalker } from './fileWalker'; import { AstParser } from '../parsing/astParser'; import { Chunker } from '../parsing/chunker'; import { QdrantService } from '../db/qdrantService'; import { IEmbeddingProvider } from '../embeddings/embeddingProvider'; import { LspService } from '../lsp/lspService';`
3.  **Filepath**: `src/db/qdrantService.ts`
    -   **Action**: Modify the constructor to accept `connectionString: string`. Remove any `getConfiguration` calls.
    -   **Implementation**:
        ```typescript
        export class QdrantService {
            constructor(private connectionString: string) {
                // ... existing constructor logic, use connectionString ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: None.
4.  **Filepath**: `src/embeddings/ollamaProvider.ts`
    -   **Action**: Modify the constructor to accept `config: OllamaConfig` object. Remove any `getConfiguration` calls.
    -   **Implementation**:
        ```typescript
        interface OllamaConfig {
            apiUrl: string;
            // ... other Ollama specific config ...
        }

        export class OllamaProvider implements IEmbeddingProvider {
            constructor(private config: OllamaConfig) {
                // ... existing constructor logic, use config ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: None.
5.  **Filepath**: `src/embeddings/openaiProvider.ts`
    -   **Action**: Modify the constructor to accept `config: OpenAIConfig` object. Remove any `getConfiguration` calls.
    -   **Implementation**:
        ```typescript
        interface OpenAIConfig {
            apiKey: string;
            // ... other OpenAI specific config ...
        }

        export class OpenAIProvider implements IEmbeddingProvider {
            constructor(private config: OpenAIConfig) {
                // ... existing constructor logic, use config ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: None.
6.  **Filepath**: `src/embeddings/embeddingProvider.ts`
    -   **Action**: Update the `EmbeddingProviderFactory` (or similar factory class/function) to accept the `ConfigService` and pass the correct configuration down to the provider it creates.
    -   **Implementation**: (This will depend on the existing factory structure, but generally involves passing `ConfigService` and using its getters)
        ```typescript
        // Assuming a factory function or class
        import { ConfigService } from '../configService'; // New import
        import { OllamaProvider } from './ollamaProvider';
        import { OpenAIProvider } from './openaiProvider';

        export function createEmbeddingProvider(type: 'ollama' | 'openai', configService: ConfigService): IEmbeddingProvider {
            if (type === 'ollama') {
                return new OllamaProvider(configService.getOllamaConfig());
            } else if (type === 'openai') {
                return new OpenAIProvider(configService.getOpenAIConfig());
            }
            throw new Error('Unknown embedding provider type');
        }
        ```
    -   **Imports**: `import { ConfigService } from '../configService'; import { OllamaProvider } from './ollamaProvider'; import { OpenAIProvider } from './openaiProvider';`

### User Story 2: Centralized Configuration Service
**As Alisha, I want to** create a central configuration service, **so that** settings are managed in one place.

**Actions to Undertake:**
1.  **Filepath**: `src/configService.ts` (New File)
    -   **Action**: Create a new `ConfigService` class that reads all settings from `vscode.workspace.getConfiguration('code-context-engine')` on startup and provides them via getter methods.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';

        interface ExtensionConfig {
            qdrantConnectionString: string;
            ollama: {
                apiUrl: string;
                // ... other ollama specific config ...
            };
            openai: {
                apiKey: string;
                // ... other openai specific config ...
            };
            // ... add other configuration properties as needed ...
        }

        export class ConfigService {
            private config: ExtensionConfig;

            constructor() {
                this.config = vscode.workspace.getConfiguration('code-context-engine') as any; // Cast to any for simplicity, refine with proper type
            }

            public getQdrantConnectionString(): string {
                return this.config.qdrantConnectionString;
            }

            public getOllamaConfig(): { apiUrl: string } {
                return this.config.ollama;
            }

            public getOpenAIConfig(): { apiKey: string } {
                return this.config.openai;
            }

            // Add more getters for other configuration properties
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Update `extension.ts` to instantiate `ConfigService` and pass its instance to other services during their instantiation.
    -   **Implementation**: (Conceptual, exact placement depends on existing `extension.ts` structure)
        ```typescript
        import * as vscode from 'vscode';
        import { ConfigService } from './configService';
        import { QdrantService } from './db/qdrantService';
        import { createEmbeddingProvider } from './embeddings/embeddingProvider';
        import { ContextService } from './context/contextService';
        import { IndexingService } from './indexing/indexingService';
        import { FileWalker } from './indexing/fileWalker';
        import { AstParser } from './parsing/astParser';
        import { Chunker } from './parsing/chunker';
        import { LspService } from './lsp/lspService';

        export function activate(context: vscode.ExtensionContext) {
            const configService = new ConfigService();
            const qdrantService = new QdrantService(configService.getQdrantConnectionString());
            const embeddingProvider = createEmbeddingProvider('ollama', configService); // Example, choose based on config
            const contextService = new ContextService(qdrantService, embeddingProvider);

            const fileWalker = new FileWalker(); // Assuming no dependencies for now
            const astParser = new AstParser(); // Assuming no dependencies for now
            const chunker = new Chunker(); // Assuming no dependencies for now
            const lspService = new LspService(); // Assuming no dependencies for now

            const indexingService = new IndexingService(
                fileWalker,
                astParser,
                chunker,
                qdrantService,
                embeddingProvider,
                lspService
            );

            // ... register commands, etc. ...
        }
        ```
    -   **Imports**: `import { ConfigService } from './configService'; import { QdrantService } './db/qdrantService'; import { createEmbeddingProvider } from './embeddings/embeddingProvider'; import { ContextService } from './context/contextService'; import { IndexingService } from './indexing/indexingService'; import { FileWalker } from './indexing/fileWalker'; import { AstParser } from './parsing/astParser'; import { Chunker } from './parsing/chunker'; import { LspService } from './lsp/lspService';`

### User Story 3: Update Unit Tests for DI
**As Alisha, I want to** update existing unit tests and add new ones, **so that** I can verify service logic with mocked dependencies.

**Actions to Undertake:**
1.  **Filepath**: `src/test/mocks.ts` (New File)
    -   **Action**: Create mock implementations for `QdrantService` and `IEmbeddingProvider` for use in unit tests.
    -   **Implementation**:
        ```typescript
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';

        export class MockQdrantService implements Partial<QdrantService> {
            // Implement mock methods as needed for tests
            // For example:
            // async upsertVectors(vectors: any[]): Promise<void> { /* mock implementation */ }
        }

        export class MockEmbeddingProvider implements Partial<IEmbeddingProvider> {
            // Implement mock methods as needed for tests
            // For example:
            // async embed(text: string): Promise<number[]> { return [0.1, 0.2, 0.3]; }
        }
        ```
    -   **Imports**: `import { QdrantService } from '../db/qdrantService'; import { IEmbeddingProvider } from '../embeddings/embeddingProvider';`
2.  **Filepath**: `src/test/contextService.test.ts`
    -   **Action**: Modify existing tests to pass mocked dependencies to the `ContextService` constructor. Add new tests to cover scenarios with mocked dependencies.
    -   **Implementation**: (Conceptual, depends on testing framework, e.g., Mocha/Chai, Jest)
        ```typescript
        import { expect } from 'chai'; // or 'jest'
        import { ContextService } from '../context/contextService';
        import { MockQdrantService, MockEmbeddingProvider } from './mocks';

        describe('ContextService', () => {
            let mockQdrantService: MockQdrantService;
            let mockEmbeddingProvider: MockEmbeddingProvider;
            let contextService: ContextService;

            beforeEach(() => {
                mockQdrantService = new MockQdrantService();
                mockEmbeddingProvider = new MockEmbeddingProvider();
                contextService = new ContextService(
                    mockQdrantService as any, // Cast to any for partial mock
                    mockEmbeddingProvider as any // Cast to any for partial mock
                );
            });

            it('should do something with mocked dependencies', async () => {
                // Example test:
                // (mockQdrantService as any).someMethod = () => Promise.resolve('mocked result');
                // const result = await contextService.someMethodCallingQdrant();
                // expect(result).to.equal('mocked result');
            });
        });
        ```
    -   **Imports**: `import { expect } from 'chai'; import { ContextService } from '../context/contextService'; import { MockQdrantService, MockEmbeddingProvider } from './mocks';`

**Acceptance Criteria:**
- No service uses the `new` keyword to create its long-lived dependencies.
- No service directly calls `vscode.workspace.getConfiguration()`.
- Unit tests for services can run without needing the VS Code API.

**Testing Plan:**
- **Test Case 1**: Run existing unit tests for `ContextService` and `IndexingService` to ensure they pass with mocked dependencies.
- **Test Case 2**: Add new unit tests for `ConfigService` to verify it correctly reads and provides configuration values.
- **Test Case 3**: Verify that `QdrantService`, `OllamaProvider`, and `OpenAIProvider` constructors correctly receive their configuration/connection strings.
- **Test Case 4**: Ensure that the `EmbeddingProviderFactory` correctly instantiates providers with the configuration from `ConfigService`.
</file>

<file path="docs/completed/extension/backlog_sub_sprint_2_extension_command_managers.md">
### User Story 1: Create ExtensionManager
**As Alisha, I want to** introduce an `ExtensionManager` to handle the extension's lifecycle, **so that** `extension.ts` becomes a simple entry point.

**Actions to Undertake:**
1.  **Filepath**: `src/extensionManager.ts` (New File)
    -   **Action**: Create a new `ExtensionManager` class. Its constructor will instantiate all services (using the DI pattern from Sub-Sprint 1) and managers. It will also have an `initialize` method and a `dispose` method.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { ConfigService } from './configService';
        import { QdrantService } from './db/qdrantService';
        import { createEmbeddingProvider } from './embeddings/embeddingProvider';
        import { ContextService } from './context/contextService';
        import { IndexingService } from './indexing/indexingService';
        import { FileWalker } from './indexing/fileWalker';
        import { AstParser } from './parsing/astParser';
        import { Chunker } from './parsing/chunker';
        import { LspService } from './lsp/lspService';
        import { CommandManager } from './commandManager'; // Will be created in next step

        export class ExtensionManager implements vscode.Disposable {
            private configService: ConfigService;
            private qdrantService: QdrantService;
            private embeddingProvider: IEmbeddingProvider;
            private contextService: ContextService;
            private indexingService: IndexingService;
            private commandManager: CommandManager;

            private disposables: vscode.Disposable[] = [];

            constructor(private context: vscode.ExtensionContext) {
                // Instantiate ConfigService
                this.configService = new ConfigService();

                // Instantiate QdrantService
                this.qdrantService = new QdrantService(this.configService.getQdrantConnectionString());

                // Instantiate EmbeddingProvider
                this.embeddingProvider = createEmbeddingProvider('ollama', this.configService); // Example, choose based on config

                // Instantiate ContextService
                this.contextService = new ContextService(this.qdrantService, this.embeddingProvider);

                // Instantiate other core dependencies
                const fileWalker = new FileWalker();
                const astParser = new AstParser();
                const chunker = new Chunker();
                const lspService = new LspService();

                // Instantiate IndexingService
                this.indexingService = new IndexingService(
                    fileWalker,
                    astParser,
                    chunker,
                    this.qdrantService,
                    this.embeddingProvider,
                    lspService
                );

                // Instantiate CommandManager (pass services it needs)
                this.commandManager = new CommandManager(this.indexingService /*, other services as needed */);
            }

            public initialize(): void {
                // Register commands
                this.disposables.push(...this.commandManager.registerCommands());

                // Add all disposables to the extension context
                this.context.subscriptions.push(...this.disposables);
            }

            public dispose(): void {
                this.disposables.forEach(d => d.dispose());
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { ConfigService } from './configService'; import { QdrantService } from './db/qdrantService'; import { createEmbeddingProvider, IEmbeddingProvider } from './embeddings/embeddingProvider'; import { ContextService } from './context/contextService'; import { IndexingService } from './indexing/indexingService'; import { FileWalker } from './indexing/fileWalker'; import { AstParser } from './parsing/astParser'; import { Chunker } from './parsing/chunker'; import { LspService } from './lsp/lspService'; import { CommandManager } from './commandManager';`

### User Story 2: Create CommandManager
**As Alisha, I want to** create a `CommandManager` to handle all command registrations, **so that** this logic is decoupled from the main activation file.

**Actions to Undertake:**
1.  **Filepath**: `src/commandManager.ts` (New File)
    -   **Action**: Create a new `CommandManager` class. It should have a constructor that accepts the necessary services (e.g., `IndexingService`) and a `registerCommands` method that returns an array of `vscode.Disposable`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { IndexingService } from './indexing/indexingService';

        export class CommandManager {
            constructor(private indexingService: IndexingService) {}

            public registerCommands(): vscode.Disposable[] {
                const disposables: vscode.Disposable[] = [];

                disposables.push(
                    vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                        // This will be handled by WebviewManager in Sub-Sprint 3
                        vscode.window.showInformationMessage('Open Main Panel (placeholder)');
                    }),
                    vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
                        this.indexingService.startIndexing();
                        vscode.window.showInformationMessage('Indexing started!');
                    }),
                    vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                        // This will be handled by WebviewManager in Sub-Sprint 3
                        vscode.window.showInformationMessage('Open Settings (placeholder)');
                    })
                );

                return disposables;
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { IndexingService } from './indexing/indexingService';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Refactor `extension.ts` to simplify `activate` to only create and initialize an `ExtensionManager`. The `deactivate` function should call `extensionManager.dispose()`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { ExtensionManager } from './extensionManager';

        let extensionManager: ExtensionManager;

        export function activate(context: vscode.ExtensionContext) {
            extensionManager = new ExtensionManager(context);
            extensionManager.initialize();
            console.log('Code Context Engine extension activated.');
        }

        export function deactivate() {
            if (extensionManager) {
                extensionManager.dispose();
            }
            console.log('Code Context Engine extension deactivated.');
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { ExtensionManager } from './extensionManager';`

**Acceptance Criteria:**
- The `extension.ts` file is less than 50 lines of code.
- All previously functional commands are still registered and work correctly.
- The extension activates and deactivates cleanly without errors.

**Testing Plan:**
- **Test Case 1**: Install and activate the extension. Verify that the `activate` and `deactivate` console logs appear correctly.
- **Test Case 2**: Execute each of the registered commands (`code-context-engine.openMainPanel`, `code-context-engine.startIndexing`, `code-context-engine.openSettings`) from the VS Code Command Palette. Verify that the corresponding placeholder messages or actions are triggered.
- **Test Case 3**: Reload the VS Code window multiple times to ensure clean activation and deactivation without memory leaks or errors.
- **Test Case 4**: Verify that `extension.ts` contains only the `activate` and `deactivate` functions and the `ExtensionManager` instantiation, and its line count is below 50 lines.
</file>

<file path="docs/completed/extension/backlog_sub_sprint_3_centralized_webview_management.md">
### User Story 1: Create WebviewManager
**As a** developer, **I want to** create a `WebviewManager` to handle the lifecycle of all webview panels, **so that** UI creation logic is centralized and reusable.

**Actions to Undertake:**
1.  **Filepath**: `src/webviewManager.ts` (New File)
    -   **Action**: Create the new file and the `WebviewManager` class structure with a constructor that accepts `vscode.ExtensionContext` and a `dispose` method.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';

        export class WebviewManager implements vscode.Disposable {
            private mainPanel: vscode.WebviewPanel | undefined;
            private settingsPanel: vscode.WebviewPanel | undefined;

            constructor(private context: vscode.ExtensionContext) {}

            private getWebviewContent(webview: vscode.Webview, panelName: string): string {
                const htmlPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');
                let htmlContent = fs.readFileSync(htmlPath, 'utf8');

                // Replace placeholders for webview assets
                const scriptUri = webview.asWebviewUri(vscode.Uri.file(
                    path.join(this.context.extensionPath, 'webview', 'dist', 'index.js')
                ));
                const styleUri = webview.asWebviewUri(vscode.Uri.file(
                    path.join(this.context.extensionPath, 'webview', 'dist', 'styles.css')
                ));

                htmlContent = htmlContent.replace('{{scriptUri}}', scriptUri.toString());
                htmlContent = htmlContent.replace('{{styleUri}}', styleUri.toString());

                // You might want to pass initial data to the webview here
                // For example, a global variable or a message
                htmlContent = htmlContent.replace('{{panelName}}', panelName);

                return htmlContent;
            }

            public showMainPanel(): void {
                if (this.mainPanel) {
                    this.mainPanel.reveal(vscode.ViewColumn.One);
                    return;
                }

                this.mainPanel = vscode.window.createWebviewPanel(
                    'codeContextEngineMain',
                    'Code Context Engine',
                    vscode.ViewColumn.One,
                    {
                        enableScripts: true,
                        localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
                    }
                );

                this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, 'main');

                this.mainPanel.onDidDispose(() => {
                    this.mainPanel = undefined;
                }, null, this.context.subscriptions);
            }

            public showSettingsPanel(): void {
                if (this.settingsPanel) {
                    this.settingsPanel.reveal(vscode.ViewColumn.Two);
                    return;
                }

                this.settingsPanel = vscode.window.createWebviewPanel(
                    'codeContextEngineSettings',
                    'Code Context Settings',
                    vscode.ViewColumn.Two,
                    {
                        enableScripts: true,
                        localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
                    }
                );

                this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, 'settings');

                this.settingsPanel.onDidDispose(() => {
                    this.settingsPanel = undefined;
                }, null, this.context.subscriptions);
            }

            public dispose(): void {
                this.mainPanel?.dispose();
                this.settingsPanel?.dispose();
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import * as path from 'path'; import * as fs from 'fs';`
2.  **Filepath**: `src/extensionManager.ts`
    -   **Action**: Instantiate the `WebviewManager` in the `ExtensionManager`'s constructor and make it accessible.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        // ... other imports ...
        import { WebviewManager } from './webviewManager';

        export class ExtensionManager implements vscode.Disposable {
            // ... existing private members ...
            public webviewManager: WebviewManager;

            constructor(private context: vscode.ExtensionContext) {
                // ... existing instantiations ...

                // Instantiate WebviewManager
                this.webviewManager = new WebviewManager(this.context);

                // Instantiate CommandManager (pass services it needs, including webviewManager)
                this.commandManager = new CommandManager(this.indexingService, this.webviewManager);
            }

            // ... rest of the class ...
        }
        ```
    -   **Imports**: `import { WebviewManager } from './webviewManager';`
3.  **Filepath**: `src/commandManager.ts`
    -   **Action**: Update the `CommandManager` to accept `WebviewManager` and change the `openMainPanel` and `openSettings` command callbacks to call the appropriate methods on the `WebviewManager` instance.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { IndexingService } from './indexing/indexingService';
        import { WebviewManager } from './webviewManager';

        export class CommandManager {
            constructor(private indexingService: IndexingService, private webviewManager: WebviewManager) {}

            public registerCommands(): vscode.Disposable[] {
                const disposables: vscode.Disposable[] = [];

                disposables.push(
                    vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                        this.webviewManager.showMainPanel();
                    }),
                    vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
                        this.indexingService.startIndexing();
                        vscode.window.showInformationMessage('Indexing started!');
                    }),
                    vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                        this.webviewManager.showSettingsPanel();
                    })
                );

                return disposables;
            }
        }
        ```
    -   **Imports**: `import { WebviewManager } from './webviewManager';`

**Acceptance Criteria:**
- All `vscode.window.createWebviewPanel` calls are located exclusively within `WebviewManager.ts`.
- The `openMainPanel` and `openSettings` commands correctly open their respective UIs.
- Attempting to open a panel that is already open simply brings the existing panel into focus.

**Testing Plan:**
- **Test Case 1**: Run the extension. Execute the command `code-context-engine.openMainPanel` from the Command Palette. Verify that the main webview panel opens.
- **Test Case 2**: Execute `code-context-engine.openMainPanel` again. Verify that a new panel is NOT opened, but the existing main panel is brought into focus.
- **Test Case 3**: Run the extension. Execute the command `code-context-engine.openSettings` from the Command Palette. Verify that the settings webview panel opens.
- **Test Case 4**: Execute `code-context-engine.openSettings` again. Verify that a new panel is NOT opened, but the existing settings panel is brought into focus.
- **Test Case 5**: Close both webview panels. Execute the commands again to ensure they can be reopened correctly.
- **Test Case 6**: Verify that the webview content (HTML, JS, CSS) loads correctly within the panels. (This might require inspecting the webview developer tools).
</file>

<file path="docs/completed/extension/backlog_sub_sprint_4_message_routing_state.md">
### User Story 1: Create StateManager
**As Alisha, I want to** introduce a basic `StateManager` to track the global state of the extension, **so that** services don't need to communicate directly with each other for status updates.

**Actions to Undertake:**
1.  **Filepath**: `src/stateManager.ts` (New File)
    -   **Action**: Create a simple `StateManager` class with private properties (e.g., `_isIndexing = false`) and public getter/setter methods.
    -   **Implementation**:
        ```typescript
        export class StateManager {
            private _isIndexing: boolean = false;

            public isIndexing(): boolean {
                return this._isIndexing;
            }

            public setIndexing(state: boolean): void {
                this._isIndexing = state;
            }

            // Add more state properties and their getters/setters as needed
            // private _isProcessingQuery: boolean = false;
            // public isProcessingQuery(): boolean { return this._isProcessingQuery; }
            // public setProcessingQuery(state: boolean): void { this._isProcessingQuery = state; }
        }
        ```
    -   **Imports**: None.

### User Story 2: Create MessageRouter
**As a** developer, **I want to** create a `MessageRouter` to handle all incoming messages from the webview, **so that** communication logic is decoupled and clean.

**Actions to Undertake:**
1.  **Filepath**: `src/messageRouter.ts` (New File)
    -   **Action**: Develop the class with a constructor that accepts the `ExtensionManager` (to access all services and managers) and the `vscode.Webview`. The constructor will set up the `onDidReceiveMessage` listener.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { ExtensionManager } from './extensionManager';

        export class MessageRouter {
            constructor(
                private extensionManager: ExtensionManager,
                private webview: vscode.Webview
            ) {
                this.webview.onDidReceiveMessage(async message => {
                    await this.routeMessage(message);
                }, undefined, this.extensionManager.context.subscriptions);
            }

            private async routeMessage(message: any): Promise<void> {
                const { command, requestId, payload } = message;

                let result: any;
                let error: string | undefined;

                try {
                    switch (command) {
                        case 'startIndexing':
                            if (this.extensionManager.stateManager.isIndexing()) {
                                throw new Error('Indexing is already in progress.');
                            }
                            this.extensionManager.indexingService.startIndexing();
                            result = { success: true };
                            break;
                        // Add more cases for other commands
                        case 'getSettings':
                            result = this.extensionManager.configService.getSettings(); // Assuming ConfigService has a getSettings method
                            break;
                        default:
                            throw new Error(`Unknown command: ${command}`);
                    }
                } catch (e: any) {
                    error = e.message;
                }

                // Send response back to webview
                this.webview.postMessage({
                    command: `${command}Response`,
                    requestId,
                    result,
                    error
                });
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { ExtensionManager } from './extensionManager';`

### User Story 3: Integrate StateManager
**As Alisha, I want to** update services to use the `StateManager`, **so that** the `MessageRouter` can query the state to prevent conflicting actions.

**Actions to Undertake:**
1.  **Filepath**: `src/extensionManager.ts`
    -   **Action**: Instantiate the `StateManager` in `ExtensionManager` and make it accessible to other services.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        // ... other imports ...
        import { StateManager } from './stateManager';

        export class ExtensionManager implements vscode.Disposable {
            // ... existing private members ...
            public stateManager: StateManager;

            constructor(private context: vscode.ExtensionContext) {
                // ... existing instantiations ...

                // Instantiate StateManager
                this.stateManager = new StateManager();

                // Pass StateManager to services that need it
                this.indexingService = new IndexingService(
                    fileWalker,
                    astParser,
                    chunker,
                    this.qdrantService,
                    this.embeddingProvider,
                    lspService,
                    this.stateManager // Pass stateManager here
                );

                // ... other instantiations ...
            }

            // ... rest of the class ...
        }
        ```
    -   **Imports**: `import { StateManager } from './stateManager';`
2.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Inject the `StateManager` instance into the `IndexingService`. Call `this.stateManager.setIndexing(true)` at the beginning of `startIndexing` and `false` in a `finally` block at the end.
    -   **Implementation**:
        ```typescript
        import { StateManager } from '../stateManager';
        // ... other imports ...

        export class IndexingService {
            constructor(
                // ... existing dependencies ...
                private stateManager: StateManager
            ) {}

            public async startIndexing(): Promise<void> {
                this.stateManager.setIndexing(true);
                try {
                    // ... existing indexing logic ...
                    console.log('Indexing started...');
                    // Simulate async work
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    console.log('Indexing complete.');
                } finally {
                    this.stateManager.setIndexing(false);
                }
            }
        }
        ```
    -   **Imports**: `import { StateManager } from '../stateManager';`
3.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: In `WebviewManager`, when a panel is created, remove the old `onDidReceiveMessage` logic and replace it with `new MessageRouter(this.extensionManager, this.mainPanel.webview)`.
    -   **Implementation**:
        ```typescript
        import { MessageRouter } from './messageRouter';
        // ... other imports ...

        export class WebviewManager implements vscode.Disposable {
            // ... existing properties ...

            constructor(private context: vscode.ExtensionContext, private extensionManager: ExtensionManager) {}

            public showMainPanel(): void {
                // ... existing panel creation logic ...

                // Replace old onDidReceiveMessage with MessageRouter
                new MessageRouter(this.extensionManager, this.mainPanel.webview);

                // ... existing onDidDispose ...
            }

            public showSettingsPanel(): void {
                // ... existing panel creation logic ...

                // Replace old onDidReceiveMessage with MessageRouter
                new MessageRouter(this.extensionManager, this.settingsPanel.webview);

                // ... existing onDidDispose ...
            }

            // ... dispose method ...
        }
        ```
    -   **Imports**: `import { MessageRouter } from './messageRouter';`

**Acceptance Criteria:**
- The `onDidReceiveMessage` listener in `WebviewManager` is a single line that instantiates and uses the `MessageRouter`.
- The `MessageRouter` correctly routes commands to the appropriate services.
- Attempting to start a new indexing job while one is already running is gracefully rejected with an error message sent back to the UI.

**Testing Plan:**
- **Test Case 1**: Open the main webview panel. Send a `startIndexing` message from the webview. Verify that indexing starts and the `isIndexing` state is set to `true`.
- **Test Case 2**: While indexing is in progress (from Test Case 1), send another `startIndexing` message. Verify that the `MessageRouter` rejects the command and sends an error message back to the webview.
- **Test Case 3**: After indexing completes, send another `startIndexing` message. Verify that it starts successfully.
- **Test Case 4**: Implement a simple message from the webview (e.g., `getSettings`) and verify that the `MessageRouter` correctly routes it to the `ConfigService` and sends a response back.
- **Test Case 5**: Verify that the `extension.ts` file remains clean and its line count is minimal.
</file>

<file path="docs/completed/extension/implementation_sub_sprint_1_dependency_injection_centralized_config.md">
## Implementation Guidance: Sub-Sprint 1 - Dependency Injection & Centralized Config

This guide provides detailed instructions and code examples for implementing Dependency Injection (DI) and a centralized configuration service within the VS Code extension. The goal is to decouple services, improve testability, and streamline configuration management.

### 1. Centralized Configuration (`ConfigService.ts`)

**Purpose:** To encapsulate all extension settings, providing a single source of truth and preventing direct `vscode.workspace.getConfiguration()` calls throughout the codebase.

**API Information:**
- `vscode.workspace.getConfiguration('section')`: Retrieves a configuration object for a specific section (e.g., 'code-context-engine').

**Code Example (`src/configService.ts` - New File):**
```typescript
import * as vscode from 'vscode';

// Define an interface for your extension's configuration structure
interface ExtensionConfig {
    qdrantConnectionString: string;
    ollama: {
        apiUrl: string;
        // Add other Ollama specific config properties
    };
    openai: {
        apiKey: string;
        // Add other OpenAI specific config properties
    };
    // Add any other top-level configuration properties here
}

export class ConfigService {
    private config: ExtensionConfig;

    constructor() {
        // Load the configuration once during instantiation
        // The 'code-context-engine' string should match your extension's configuration section in package.json
        this.config = vscode.workspace.getConfiguration('code-context-engine') as any; // Cast to any for initial simplicity
    }

    public getQdrantConnectionString(): string {
        return this.config.qdrantConnectionString;
    }

    public getOllamaConfig(): { apiUrl: string } {
        return this.config.ollama;
    }

    public getOpenAIConfig(): { apiKey: string } {
        return this.config.openai;
    }

    // Add more public getter methods for other configuration properties as needed
    // Example:
    // public getSomeOtherSetting(): boolean {
    //     return this.config.someOtherSetting;
    // }
}
```

### 2. Refactoring Services for Dependency Injection

**Purpose:** To modify service constructors to accept their dependencies as arguments, rather than instantiating them internally. This enables easier testing and promotes loose coupling.

**General Approach:**
1.  Identify all `new` keyword usages within a service's constructor or initialization logic that create other long-lived service instances.
2.  Add parameters to the service's constructor for each of these dependencies.
3.  Update the `extension.ts` (or later, `ExtensionManager`) to instantiate these dependencies and pass them to the service constructors.

**Code Examples:**

**a) `src/db/qdrantService.ts`**

Modify the constructor to accept the connection string directly:
```typescript
// src/db/qdrantService.ts

export class QdrantService {
    constructor(private connectionString: string) {
        // Use this.connectionString to initialize Qdrant client
        console.log(`QdrantService initialized with connection: ${this.connectionString}`);
    }

    // ... rest of your QdrantService methods ...
}
```

**b) `src/embeddings/ollamaProvider.ts` and `src/embeddings/openaiProvider.ts`**

Define configuration interfaces and update constructors:

**`src/embeddings/ollamaProvider.ts`**
```typescript
// src/embeddings/ollamaProvider.ts
import { IEmbeddingProvider } from './embeddingProvider';

export interface OllamaConfig {
    apiUrl: string;
    // Add other Ollama specific config properties like model name, etc.
}

export class OllamaProvider implements IEmbeddingProvider {
    constructor(private config: OllamaConfig) {
        console.log(`OllamaProvider initialized with API URL: ${this.config.apiUrl}`);
    }

    async embed(text: string): Promise<number[]> {
        // Implementation using this.config.apiUrl
        return [/* embedding vector */];
    }
}
```

**`src/embeddings/openaiProvider.ts`**
```typescript
// src/embeddings/openaiProvider.ts
import { IEmbeddingProvider } from './embeddingProvider';

export interface OpenAIConfig {
    apiKey: string;
    // Add other OpenAI specific config properties
}

export class OpenAIProvider implements IEmbeddingProvider {
    constructor(private config: OpenAIConfig) {
        console.log(`OpenAIProvider initialized with API Key: ${this.config.apiKey ? '*****' : 'N/A'}`);
    }

    async embed(text: string): Promise<number[]> {
        // Implementation using this.config.apiKey
        return [/* embedding vector */];
    }
}
```

**c) `src/embeddings/embeddingProvider.ts` (Factory Update)**

If you have a factory function or class for creating embedding providers, update it to accept `ConfigService` and pass the relevant config:
```typescript
// src/embeddings/embeddingProvider.ts (assuming this file contains the factory)
import { ConfigService } from '../configService';
import { OllamaProvider, OllamaConfig } from './ollamaProvider';
import { OpenAIProvider, OpenAIConfig } from './openaiProvider';

export interface IEmbeddingProvider {
    embed(text: string): Promise<number[]>;
}

export function createEmbeddingProvider(type: 'ollama' | 'openai', configService: ConfigService): IEmbeddingProvider {
    switch (type) {
        case 'ollama':
            return new OllamaProvider(configService.getOllamaConfig());
        case 'openai':
            return new OpenAIProvider(configService.getOpenAIConfig());
        default:
            throw new Error(`Unsupported embedding provider type: ${type}`);
    }
}
```

**d) `src/context/contextService.ts`**

Update constructor to accept `QdrantService` and `IEmbeddingProvider`:
```typescript
// src/context/contextService.ts
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';

export class ContextService {
    constructor(
        private qdrantService: QdrantService,
        private embeddingProvider: IEmbeddingProvider
    ) {
        // Now you can use this.qdrantService and this.embeddingProvider
    }

    // ... rest of your ContextService methods ...
}
```

**e) `src/indexing/indexingService.ts`**

Update constructor to accept all its dependencies:
```typescript
// src/indexing/indexingService.ts
import { FileWalker } from './fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker } from '../parsing/chunker';
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { LspService } from '../lsp/lspService';

export class IndexingService {
    constructor(
        private fileWalker: FileWalker,
        private astParser: AstParser,
        private chunker: Chunker,
        private qdrantService: QdrantService,
        private embeddingProvider: IEmbeddingProvider,
        private lspService: LspService
    ) {
        // Now you can use these injected dependencies
    }

    // ... rest of your IndexingService methods ...
}
```

### 3. Updating `extension.ts` (Initial Wiring)

**Purpose:** To act as the composition root where all services are instantiated and their dependencies are resolved and passed. This file will become much cleaner in subsequent sprints with the `ExtensionManager`.

**Code Example (`src/extension.ts` - Partial Update):**
```typescript
// src/extension.ts
import * as vscode from 'vscode';
import { ConfigService } from './configService';
import { QdrantService } from './db/qdrantService';
import { createEmbeddingProvider } from './embeddings/embeddingProvider';
import { ContextService } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { FileWalker } from './indexing/fileWalker'; // Assuming no dependencies for now
import { AstParser } from './parsing/astParser';   // Assuming no dependencies for now
import { Chunker } from './parsing/chunker';     // Assuming no dependencies for now
import { LspService } from './lsp/lspService';     // Assuming no dependencies for now

export function activate(context: vscode.ExtensionContext) {
    // 1. Instantiate ConfigService first
    const configService = new ConfigService();

    // 2. Instantiate QdrantService with config
    const qdrantService = new QdrantService(configService.getQdrantConnectionString());

    // 3. Instantiate EmbeddingProvider using the factory and config
    // You might have logic here to determine which provider to use (ollama/openai)
    const embeddingProvider = createEmbeddingProvider('ollama', configService); // Example: using ollama

    // 4. Instantiate ContextService with its dependencies
    const contextService = new ContextService(qdrantService, embeddingProvider);

    // 5. Instantiate other core dependencies (if they don't have their own complex dependencies yet)
    const fileWalker = new FileWalker();
    const astParser = new AstParser();
    const chunker = new Chunker();
    const lspService = new LspService();

    // 6. Instantiate IndexingService with all its dependencies
    const indexingService = new IndexingService(
        fileWalker,
        astParser,
        chunker,
        qdrantService,
        embeddingProvider,
        lspService
    );

    // Register commands, etc., using these instantiated services
    // Example:
    // context.subscriptions.push(
    //     vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
    //         indexingService.startIndexing();
    //     })
    // );

    console.log('Code Context Engine extension activated.');
}

export function deactivate() {
    console.log('Code Context Engine extension deactivated.');
}
```

### 4. Updating Unit Tests

**Purpose:** To ensure that services can be tested in isolation by providing mocked dependencies, verifying their logic without relying on the actual VS Code API or other complex services.

**General Approach:**
1.  Create mock classes or objects that implement the interfaces or mimic the behavior of the real dependencies.
2.  In your test setup (e.g., `beforeEach`), instantiate your service under test, passing in these mock objects.
3.  Use your testing framework's assertion capabilities to verify the service's behavior.

**Code Example (`src/test/mocks.ts` - New File):**
```typescript
// src/test/mocks.ts
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { FileWalker } from '../indexing/fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker } from '../parsing/chunker';
import { LspService } from '../lsp/lspService';

// Partial mocks for services that might have methods called by other services
export class MockQdrantService implements Partial<QdrantService> {
    // Example mock method
    async upsertVectors(vectors: any[]): Promise<void> { /* do nothing or return a mock value */ }
    // Add other methods that ContextService or IndexingService might call
}

export class MockEmbeddingProvider implements Partial<IEmbeddingProvider> {
    async embed(text: string): Promise<number[]> {
        return [0.1, 0.2, 0.3]; // Return a dummy embedding
    }
}

// Full mocks for simple dependencies or those not yet refactored with complex logic
export class MockFileWalker implements Partial<FileWalker> {
    // Implement methods if IndexingService calls them
}

export class MockAstParser implements Partial<AstParser> {
    // Implement methods if IndexingService calls them
}

export class MockChunker implements Partial<Chunker> {
    // Implement methods if IndexingService calls them
}

export class MockLspService implements Partial<LspService> {
    // Implement methods if IndexingService calls them
}
```

**Code Example (`src/test/contextService.test.ts` - Update Existing Test File):**
```typescript
// src/test/contextService.test.ts
import { expect } from 'chai'; // Assuming Chai for assertions, adjust for Jest/other
import { ContextService } from '../context/contextService';
import { MockQdrantService, MockEmbeddingProvider } from './mocks';

describe('ContextService', () => {
    let mockQdrantService: MockQdrantService;
    let mockEmbeddingProvider: MockEmbeddingProvider;
    let contextService: ContextService;

    beforeEach(() => {
        // Instantiate mocks before each test
        mockQdrantService = new MockQdrantService();
        mockEmbeddingProvider = new MockEmbeddingProvider();

        // Instantiate ContextService with the mocks
        contextService = new ContextService(
            mockQdrantService as any, // Cast to any if using Partial<T> for mocks
            mockEmbeddingProvider as any
        );
    });

    it('should call qdrantService when querying context', async () => {
        // Example: Mock a method call and assert it was called
        const queryStub = (mockQdrantService as any).query = sinon.stub().returns(Promise.resolve([])); // Assuming Sinon for stubbing

        await contextService.queryContext('test query');

        expect(queryStub.calledOnce).to.be.true;
    });

    it('should use embeddingProvider to embed query', async () => {
        const embedStub = (mockEmbeddingProvider as any).embed = sinon.stub().returns(Promise.resolve([0.1, 0.2, 0.3]));

        await contextService.queryContext('another query');

        expect(embedStub.calledOnceWith('another query')).to.be.true;
    });

    // Add more tests to cover various scenarios and edge cases
});
```

**Further Guidance:**
*   **Testing Frameworks:** If not already set up, consider using a testing framework like Mocha with Chai (for assertions) and Sinon (for stubs/spies) or Jest (all-in-one).
*   **Type Safety with Mocks:** Using `Partial<T>` is a quick way to create mocks, but for more robust testing, consider dedicated mocking libraries or manually implementing the full interface/class for mocks.
*   **Configuration Schema:** For `ConfigService`, consider defining a JSON schema for your extension's configuration in `package.json` to provide validation and IntelliSense for users.
*   **Error Handling:** Ensure proper error handling is in place for configuration retrieval (e.g., default values if a setting is missing).
</file>

<file path="docs/completed/extension/implementation_sub_sprint_2_extension_command_managers.md">
## Implementation Guidance: Sub-Sprint 2 - Extension & Command Managers

This guide details the creation of `ExtensionManager` and `CommandManager` classes to centralize extension lifecycle management and command registration, significantly simplifying `extension.ts`.

### 1. `ExtensionManager` (`src/extensionManager.ts` - New File)

**Purpose:** To act as the main orchestrator for the extension, responsible for instantiating all services and managers, initializing them, and handling their disposal. It becomes the single entry point for the extension's core logic.

**Key Responsibilities:**
-   **Composition Root:** Instantiates all top-level services and managers (e.g., `ConfigService`, `QdrantService`, `IndexingService`, `CommandManager`).
-   **Initialization:** Calls `initialize` methods on its managed components.
-   **Lifecycle Management:** Manages the `vscode.Disposable` objects for all components, ensuring proper cleanup during deactivation.

**Code Example (`src/extensionManager.ts`):**
```typescript
import * as vscode from 'vscode';
import { ConfigService } from './configService';
import { QdrantService } from './db/qdrantService';
import { createEmbeddingProvider, IEmbeddingProvider } from './embeddings/embeddingProvider';
import { ContextService } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { FileWalker } from './indexing/fileWalker';
import { AstParser } from './parsing/astParser';
import { Chunker } from './parsing/chunker';
import { LspService } from './lsp/lspService';
import { CommandManager } from './commandManager';

export class ExtensionManager implements vscode.Disposable {
    private configService: ConfigService;
    private qdrantService: QdrantService;
    private embeddingProvider: IEmbeddingProvider;
    private contextService: ContextService;
    private indexingService: IndexingService;
    private commandManager: CommandManager;

    private disposables: vscode.Disposable[] = [];

    constructor(private context: vscode.ExtensionContext) {
        // Instantiate ConfigService (from Sub-Sprint 1)
        this.configService = new ConfigService();

        // Instantiate QdrantService (from Sub-Sprint 1)
        this.qdrantService = new QdrantService(this.configService.getQdrantConnectionString());

        // Instantiate EmbeddingProvider (from Sub-Sprint 1)
        // The choice of provider (ollama/openai) can be made based on configService
        this.embeddingProvider = createEmbeddingProvider('ollama', this.configService); 

        // Instantiate ContextService (from Sub-Sprint 1)
        this.contextService = new ContextService(this.qdrantService, this.embeddingProvider);

        // Instantiate other core dependencies that IndexingService needs
        const fileWalker = new FileWalker();
        const astParser = new AstParser();
        const chunker = new Chunker();
        const lspService = new LspService();

        // Instantiate IndexingService (from Sub-Sprint 1)
        this.indexingService = new IndexingService(
            fileWalker,
            astParser,
            chunker,
            this.qdrantService,
            this.embeddingProvider,
            lspService
        );

        // Instantiate CommandManager, passing the services it needs to execute commands
        this.commandManager = new CommandManager(this.indexingService /*, other services as they are created */);
    }

    public initialize(): void {
        // Register all commands and collect their disposables
        this.disposables.push(...this.commandManager.registerCommands());

        // Add all collected disposables to the extension's context subscriptions
        // This ensures they are disposed of when the extension deactivates
        this.context.subscriptions.push(...this.disposables);

        console.log('ExtensionManager initialized.');
    }

    public dispose(): void {
        // Dispose of all managed disposables
        this.disposables.forEach(d => d.dispose());
        console.log('ExtensionManager disposed.');
    }
}
```

### 2. `CommandManager` (`src/commandManager.ts` - New File)

**Purpose:** To centralize the registration of all VS Code commands, decoupling this logic from `extension.ts`. It acts as a dispatcher, delegating command execution to the appropriate service.

**Key Responsibilities:**
-   **Command Registration:** Uses `vscode.commands.registerCommand` to register all commands defined by the extension.
-   **Delegation:** Calls methods on the relevant services (e.g., `IndexingService`) to perform the actual command logic.
-   **Disposable Management:** Returns an array of `vscode.Disposable` objects for the registered commands, which `ExtensionManager` will manage.

**Code Example (`src/commandManager.ts`):**
```typescript
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';

export class CommandManager {
    // The constructor receives instances of services that will handle command logic
    constructor(private indexingService: IndexingService) {}

    public registerCommands(): vscode.Disposable[] {
        const disposables: vscode.Disposable[] = [];

        // Register the 'openMainPanel' command
        disposables.push(
            vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                // In Sub-Sprint 3, this will call a method on WebviewManager
                vscode.window.showInformationMessage('Main Panel command executed (placeholder).');
            })
        );

        // Register the 'startIndexing' command
        disposables.push(
            vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
                this.indexingService.startIndexing();
                vscode.window.showInformationMessage('Indexing started via command!');
            })
        );

        // Register the 'openSettings' command
        disposables.push(
            vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                // In Sub-Sprint 3, this will call a method on WebviewManager
                vscode.window.showInformationMessage('Settings command executed (placeholder).');
            })
        );

        // Add more commands as needed

        return disposables;
    }
}
```

### 3. Refactoring `extension.ts`

**Purpose:** To transform `extension.ts` into a lean entry point that primarily instantiates and initializes the `ExtensionManager`, and handles its disposal. This significantly reduces its complexity and improves maintainability.

**Key Changes:**
-   Remove all direct service instantiations.
-   Remove all direct `vscode.commands.registerCommand` calls.
-   The `activate` function will create an instance of `ExtensionManager` and call its `initialize` method.
-   The `deactivate` function will call the `dispose` method on the `ExtensionManager` instance.

**Code Example (`src/extension.ts`):**
```typescript
import * as vscode from 'vscode';
import { ExtensionManager } from './extensionManager';

// Declare extensionManager outside activate/deactivate to maintain its state
let extensionManager: ExtensionManager;

export function activate(context: vscode.ExtensionContext) {
    // Instantiate the main ExtensionManager
    extensionManager = new ExtensionManager(context);

    // Initialize the ExtensionManager, which in turn sets up all services and commands
    extensionManager.initialize();

    console.log('Code Context Engine extension activated successfully.');
}

export function deactivate() {
    // Dispose of the ExtensionManager and all its managed resources
    if (extensionManager) {
        extensionManager.dispose();
    }
    console.log('Code Context Engine extension deactivated.');
}
```

### Further Guidance:

*   **Error Handling:** Consider adding `try-catch` blocks in `ExtensionManager`'s constructor and `initialize` method to gracefully handle errors during service instantiation or command registration.
*   **Logging:** Implement a consistent logging mechanism (e.g., using `vscode.window.showInformationMessage` for user-facing messages, and `console.log` or a dedicated logger for internal debugging) across your managers and services.
*   **Testability:** With `ExtensionManager` and `CommandManager` in place, you can now write unit tests for `CommandManager` by passing mocked service instances to its constructor, verifying that commands are registered correctly and delegate to the right methods.
*   **Dependency Order:** Pay close attention to the order of instantiation in `ExtensionManager`. Services that are dependencies of others must be instantiated first. The current example follows a logical order based on the previous sub-sprint.
*   **`vscode.Disposable`:** Ensure that any objects that implement `vscode.Disposable` (like `WebviewPanel`s, `EventEmitter`s, `FileSystemWatcher`s, etc.) are properly disposed of by adding them to `context.subscriptions` or managing them within your `ExtensionManager`'s `disposables` array.
</file>

<file path="docs/completed/extension/implementation_sub_sprint_3_centralized_webview_management.md">
## Implementation Guidance: Sub-Sprint 3 - Centralized Webview Management

This guide focuses on creating the `WebviewManager` class to centralize all webview panel creation, display, and lifecycle management. This refactoring will clean up command handlers and `extension.ts` by abstracting webview-related logic.

### 1. `WebviewManager` (`src/webviewManager.ts` - New File)

**Purpose:** To encapsulate all logic related to creating, showing, and disposing of webview panels. It ensures that only one instance of a specific panel type (e.g., main panel, settings panel) exists at a time and handles the loading of webview content.

**Key Responsibilities:**
-   **Panel Creation:** Uses `vscode.window.createWebviewPanel` to create new webview instances.
-   **Panel Management:** Keeps track of active panels and brings them to focus if they already exist.
-   **Content Loading:** Reads the `index.html` file from the `webview/dist` directory and correctly resolves local resource URIs for scripts and stylesheets.
-   **Lifecycle:** Handles panel disposal events to clean up references.

**API Information:**
-   `vscode.window.createWebviewPanel(viewType, title, showOptions, options)`: Creates and shows a new webview panel.
-   `panel.reveal(viewColumn)`: Brings the panel to the foreground.
-   `panel.webview.html = content`: Sets the HTML content of the webview.
-   `panel.webview.asWebviewUri(uri)`: Converts a local file URI into a URI that can be loaded by the webview. Essential for loading local scripts, styles, and images.
-   `panel.onDidDispose(() => { ... })`: Event fired when the webview panel is closed by the user or programmatically.
-   `vscode.Uri.file(path)`: Creates a URI from a file system path.
-   `path.join(...)`: Node.js `path` module for joining path segments.
-   `fs.readFileSync(...)`: Node.js `fs` module for reading file content synchronously.

**Code Example (`src/webviewManager.ts`):**
```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs'; // Node.js file system module

export class WebviewManager implements vscode.Disposable {
    private mainPanel: vscode.WebviewPanel | undefined; // Stores the main webview panel instance
    private settingsPanel: vscode.WebviewPanel | undefined; // Stores the settings webview panel instance

    constructor(private context: vscode.ExtensionContext) {}

    /**
     * Generates the HTML content for the webview, resolving local resource URIs.
     * @param webview The webview instance.
     * @param panelName A name to identify the panel type (e.g., 'main', 'settings').
     * @returns The complete HTML string for the webview.
     */
    private getWebviewContent(webview: vscode.Webview, panelName: string): string {
        // Path to the webview's HTML file in the bundled extension
        const htmlPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');
        let htmlContent = fs.readFileSync(htmlPath, 'utf8');

        // Resolve URIs for local webview resources (JS, CSS)
        const scriptUri = webview.asWebviewUri(vscode.Uri.file(
            path.join(this.context.extensionPath, 'webview', 'dist', 'index.js')
        ));
        const styleUri = webview.asWebviewUri(vscode.Uri.file(
            path.join(this.context.extensionPath, 'webview', 'dist', 'styles.css')
        ));

        // Replace placeholders in the HTML with the actual URIs
        // Ensure your index.html has these placeholders, e.g., <script src="{{scriptUri}}"></script>
        htmlContent = htmlContent.replace('{{scriptUri}}', scriptUri.toString());
        htmlContent = htmlContent.replace('{{styleUri}}', styleUri.toString());

        // You can also pass initial data to the webview here, e.g., a global variable
        htmlContent = htmlContent.replace('{{panelName}}', panelName); // Example: pass panel type

        return htmlContent;
    }

    /**
     * Shows or reveals the main webview panel.
     */
    public showMainPanel(): void {
        if (this.mainPanel) {
            // If panel already exists, just reveal it
            this.mainPanel.reveal(vscode.ViewColumn.One);
            return;
        }

        // Create a new webview panel
        this.mainPanel = vscode.window.createWebviewPanel(
            'codeContextEngineMain', // Unique ID for the panel type
            'Code Context Engine',   // Title displayed to the user
            vscode.ViewColumn.One,   // Column to show the panel in
            {
                enableScripts: true, // Enable JavaScript in the webview
                // Restrict the webview to only load resources from the 'webview/dist' directory
                localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
            }
        );

        // Set the HTML content for the webview
        this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, 'main');

        // Handle panel disposal: clear the reference when the panel is closed
        this.mainPanel.onDidDispose(() => {
            this.mainPanel = undefined;
        }, null, this.context.subscriptions); // Add to context subscriptions for automatic disposal
    }

    /**
     * Shows or reveals the settings webview panel.
     */
    public showSettingsPanel(): void {
        if (this.settingsPanel) {
            this.settingsPanel.reveal(vscode.ViewColumn.Two);
            return;
        }

        this.settingsPanel = vscode.window.createWebviewPanel(
            'codeContextEngineSettings',
            'Code Context Settings',
            vscode.ViewColumn.Two,
            {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
            }
        );

        this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, 'settings');

        this.settingsPanel.onDidDispose(() => {
            this.settingsPanel = undefined;
        }, null, this.context.subscriptions);
    }

    /**
     * Disposes of all active webview panels.
     */
    public dispose(): void {
        this.mainPanel?.dispose();
        this.settingsPanel?.dispose();
    }
}
```

### 2. Update `ExtensionManager` (`src/extensionManager.ts`)

**Purpose:** To instantiate the `WebviewManager` and make it accessible to other parts of the extension, particularly the `CommandManager`.

**Code Example (`src/extensionManager.ts` - Partial Update):**
```typescript
// src/extensionManager.ts
import * as vscode from 'vscode';
// ... other imports ...
import { WebviewManager } from './webviewManager'; // New import

export class ExtensionManager implements vscode.Disposable {
    // ... existing private members for services ...
    public webviewManager: WebviewManager; // Make webviewManager public for access by CommandManager
    private commandManager: CommandManager;

    private disposables: vscode.Disposable[] = [];

    constructor(private context: vscode.ExtensionContext) {
        // ... existing service instantiations ...

        // Instantiate WebviewManager, passing the extension context
        this.webviewManager = new WebviewManager(this.context);

        // Instantiate CommandManager, passing the services it needs, including webviewManager
        this.commandManager = new CommandManager(this.indexingService, this.webviewManager);

        // Add webviewManager to disposables if it needs explicit disposal
        this.disposables.push(this.webviewManager);
    }

    // ... initialize and dispose methods ...
}
```

### 3. Update `CommandManager` (`src/commandManager.ts`)

**Purpose:** To delegate the `openMainPanel` and `openSettings` commands to the newly created `WebviewManager`.

**Code Example (`src/commandManager.ts` - Partial Update):**
```typescript
// src/commandManager.ts
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';
import { WebviewManager } from './webviewManager'; // New import

export class CommandManager {
    constructor(private indexingService: IndexingService, private webviewManager: WebviewManager) {}

    public registerCommands(): vscode.Disposable[] {
        const disposables: vscode.Disposable[] = [];

        disposables.push(
            vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                this.webviewManager.showMainPanel(); // Delegate to WebviewManager
            }),
            vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
                this.indexingService.startIndexing();
                vscode.window.showInformationMessage('Indexing started!');
            }),
            vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                this.webviewManager.showSettingsPanel(); // Delegate to WebviewManager
            })
        );

        return disposables;
    }
}
```

### Further Guidance:

*   **`index.html` Placeholders:** Ensure your `webview/dist/index.html` file has the `{{scriptUri}}` and `{{styleUri}}` placeholders where the JavaScript and CSS files should be linked. For example:
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Code Context Engine</title>
        <link rel="stylesheet" href="{{styleUri}}">
    </head>
    <body>
        <div id="root"></div>
        <script src="{{scriptUri}}"></script>
    </body>
    </html>
    ```
*   **Webview Security:** The `localResourceRoots` option in `createWebviewPanel` is crucial for security. It restricts the webview from loading arbitrary local files. Only allow access to the `webview/dist` directory where your bundled webview assets reside.
*   **Message Passing:** While this sub-sprint focuses on webview management, the next sub-sprint will cover communication between the webview and the extension. Be mindful that `WebviewManager` will eventually need to set up `onDidReceiveMessage` listeners and potentially `postMessage` calls.
*   **Error Handling:** Add error handling for `fs.readFileSync` in `getWebviewContent` to gracefully manage cases where the HTML file might not be found.
</file>

<file path="docs/completed/extension/implementation_sub_sprint_4_message_routing_state.md">
## Implementation Guidance: Sub-Sprint 4 - Message Routing & State

This guide focuses on formalizing the communication layer between the webview and the extension's backend, and centralizing the extension's global state. This involves creating `StateManager` and `MessageRouter` classes.

### 1. `StateManager` (`src/stateManager.ts` - New File)

**Purpose:** To provide a centralized, simple mechanism for tracking the global state of the extension. This prevents services from needing to directly query each other for status updates and allows for consistent state checks (e.g., preventing duplicate operations).

**Key Responsibilities:**
-   **State Storage:** Holds simple boolean flags or other primitive state variables.
-   **State Access:** Provides public getter and setter methods for each state property.

**Code Example (`src/stateManager.ts`):**
```typescript
// src/stateManager.ts

export class StateManager {
    private _isIndexing: boolean = false; // Example state: is an indexing operation currently running?
    private _isProcessingQuery: boolean = false; // Example state: is a query being processed?

    /**
     * Checks if an indexing operation is currently in progress.
     */
    public isIndexing(): boolean {
        return this._isIndexing;
    }

    /**
     * Sets the status of the indexing operation.
     * @param state True if indexing is in progress, false otherwise.
     */
    public setIndexing(state: boolean): void {
        this._isIndexing = state;
    }

    /**
     * Checks if a query is currently being processed.
     */
    public isProcessingQuery(): boolean {
        return this._isProcessingQuery;
    }

    /**
     * Sets the status of the query processing operation.
     * @param state True if a query is being processed, false otherwise.
     */
    public setProcessingQuery(state: boolean): void {
        this._isProcessingQuery = state;
    }

    // Add more state properties and their corresponding getters/setters as your extension grows
}
```

### 2. `MessageRouter` (`src/messageRouter.ts` - New File)

**Purpose:** To centralize the handling of messages received from the webview. It acts as a dispatcher, routing messages to the appropriate backend services and sending responses back to the webview. This replaces large `switch` statements in the webview's `onDidReceiveMessage` listener.

**Key Responsibilities:**
-   **Message Listening:** Sets up the `onDidReceiveMessage` listener for a given webview.
-   **Command Routing:** Parses incoming messages and delegates the execution to the correct service method.
-   **Response Handling:** Sends structured responses (including results or errors) back to the webview.
-   **State Integration:** Uses the `StateManager` to check conditions before executing commands.

**API Information:**
-   `webview.onDidReceiveMessage(callback, thisArgs?, disposables?)`: Event fired when the webview posts a message to the extension.
-   `webview.postMessage(message)`: Sends a message from the extension to the webview.

**Code Example (`src/messageRouter.ts`):**
```typescript
// src/messageRouter.ts
import * as vscode from 'vscode';
import { ExtensionManager } from './extensionManager'; // Import the ExtensionManager

export class MessageRouter {
    constructor(
        private extensionManager: ExtensionManager, // Access to all services and managers
        private webview: vscode.Webview
    ) {
        // Set up the listener for messages from the webview
        this.webview.onDidReceiveMessage(async message => {
            await this.routeMessage(message);
        }, undefined, this.extensionManager.context.subscriptions); // Ensure proper disposal
    }

    /**
     * Routes incoming messages from the webview to the appropriate handler.
     * Messages are expected to have a 'command' and optionally 'requestId' and 'payload'.
     */
    private async routeMessage(message: any): Promise<void> {
        const { command, requestId, payload } = message;

        let result: any; // To store the result of the command execution
        let error: string | undefined; // To store any error messages

        try {
            switch (command) {
                case 'startIndexing':
                    // Check state before starting indexing
                    if (this.extensionManager.stateManager.isIndexing()) {
                        throw new Error('Indexing is already in progress. Please wait.');
                    }
                    // Delegate to IndexingService
                    await this.extensionManager.indexingService.startIndexing();
                    result = { success: true, message: 'Indexing initiated.' };
                    break;

                case 'getSettings':
                    // Example: Assuming ConfigService has a method to return settings
                    result = this.extensionManager.configService.getSettings(); 
                    break;

                // Add more cases for other commands from the webview
                // case 'queryContext':
                //     result = await this.extensionManager.contextService.queryContext(payload.query);
                //     break;

                default:
                    throw new Error(`Unknown command: ${command}`);
            }
        } catch (e: any) {
            // Catch any errors during command execution and store the message
            error = e.message;
        }

        // Send a response back to the webview
        this.webview.postMessage({
            command: `${command}Response`, // Convention: commandName + 'Response'
            requestId, // Include requestId to match responses with requests on the webview side
            result,    // The result of the operation
            error      // Any error message
        });
    }
}
```

### 3. Integrate `StateManager` into `ExtensionManager` and Services

**Purpose:** To make the `StateManager` available throughout the extension and ensure services update the state as their operations begin and end.

**a) Update `ExtensionManager` (`src/extensionManager.ts` - Partial Update):**

Instantiate `StateManager` and pass it to services that need to interact with the global state.
```typescript
// src/extensionManager.ts
import * as vscode from 'vscode';
// ... other imports ...
import { StateManager } from './stateManager'; // New import

export class ExtensionManager implements vscode.Disposable {
    // ... existing private members ...
    public stateManager: StateManager; // Make StateManager public for access by MessageRouter and other services

    constructor(private context: vscode.ExtensionContext) {
        // ... existing instantiations ...

        // Instantiate StateManager
        this.stateManager = new StateManager();

        // Pass StateManager to services that need to update or read global state
        this.indexingService = new IndexingService(
            fileWalker,
            astParser,
            chunker,
            this.qdrantService,
            this.embeddingProvider,
            lspService,
            this.stateManager // Pass stateManager here
        );

        // ... other instantiations ...
    }

    // ... initialize and dispose methods ...
}
```

**b) Update `IndexingService` (`src/indexing/indexingService.ts` - Partial Update):**

Modify `IndexingService` to accept `StateManager` in its constructor and update the `isIndexing` state during its `startIndexing` method.
```typescript
// src/indexing/indexingService.ts
import { StateManager } from '../stateManager'; // New import
// ... other imports ...

export class IndexingService {
    constructor(
        private fileWalker: FileWalker,
        private astParser: AstParser,
        private chunker: Chunker,
        private qdrantService: QdrantService,
        private embeddingProvider: IEmbeddingProvider,
        private lspService: LspService,
        private stateManager: StateManager // New dependency
    ) {
        // ...
    }

    public async startIndexing(): Promise<void> {
        this.stateManager.setIndexing(true); // Set state to true when indexing starts
        try {
            console.log('Indexing started...');
            // Simulate actual indexing work
            await new Promise(resolve => setTimeout(resolve, 3000)); 
            console.log('Indexing complete.');
        } catch (error) {
            console.error('Indexing failed:', error);
            throw error; // Re-throw to propagate the error
        } finally {
            this.stateManager.setIndexing(false); // Always set state to false when indexing finishes (success or failure)
        }
    }

    // ... other methods ...
}
```

### 4. Integrate `MessageRouter` into `WebviewManager`

**Purpose:** To replace the direct `onDidReceiveMessage` listener in `WebviewManager` with an instantiation of `MessageRouter`, making the webview communication cleaner and more modular.

**a) Update `WebviewManager` (`src/webviewManager.ts` - Partial Update):**

Modify the `showMainPanel` and `showSettingsPanel` methods to instantiate `MessageRouter` and pass it the `ExtensionManager` and the webview instance.
```typescript
// src/webviewManager.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { ExtensionManager } from './extensionManager'; // Import ExtensionManager
import { MessageRouter } from './messageRouter'; // New import

export class WebviewManager implements vscode.Disposable {
    // ... existing properties ...

    // WebviewManager now needs ExtensionManager to pass to MessageRouter
    constructor(private context: vscode.ExtensionContext, private extensionManager: ExtensionManager) {}

    // ... getWebviewContent method ...

    public showMainPanel(): void {
        if (this.mainPanel) {
            this.mainPanel.reveal(vscode.ViewColumn.One);
            return;
        }

        this.mainPanel = vscode.window.createWebviewPanel(
            'codeContextEngineMain',
            'Code Context Engine',
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
            }
        );

        this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, 'main');

        // Instantiate MessageRouter for this panel
        new MessageRouter(this.extensionManager, this.mainPanel.webview);

        this.mainPanel.onDidDispose(() => {
            this.mainPanel = undefined;
        }, null, this.context.subscriptions);
    }

    public showSettingsPanel(): void {
        if (this.settingsPanel) {
            this.settingsPanel.reveal(vscode.ViewColumn.Two);
            return;
        }

        this.settingsPanel = vscode.window.createWebviewPanel(
            'codeContextEngineSettings',
            'Code Context Settings',
            vscode.ViewColumn.Two,
            {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
            }
        );

        this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, 'settings');

        // Instantiate MessageRouter for this panel
        new MessageRouter(this.extensionManager, this.settingsPanel.webview);

        this.settingsPanel.onDidDispose(() => {
            this.settingsPanel = undefined;
        }, null, this.context.subscriptions);
    }

    // ... dispose method ...
}
```

**b) Update `ExtensionManager` (`src/extensionManager.ts` - Partial Update):**

Modify `ExtensionManager`'s constructor to pass itself to `WebviewManager`.
```typescript
// src/extensionManager.ts
import * as vscode from 'vscode';
// ... other imports ...
import { WebviewManager } from './webviewManager';

export class ExtensionManager implements vscode.Disposable {
    // ... existing private members ...

    constructor(private context: vscode.ExtensionContext) {
        // ... existing instantiations ...

        // Instantiate WebviewManager, passing the extension context AND itself (this)
        this.webviewManager = new WebviewManager(this.context, this);

        // ... existing commandManager instantiation ...
    }

    // ... initialize and dispose methods ...
}
```

### Further Guidance:

*   **Webview-Side Communication:** On the webview (frontend) side, you'll need to use `vscode.postMessage` to send messages to the extension and listen for responses. A common pattern is to have a utility function that wraps `postMessage` and returns a Promise that resolves when a corresponding response is received (matching `requestId`).
*   **Error Handling:** Implement robust error handling in `MessageRouter` and ensure that errors are clearly communicated back to the webview. Consider different error types (e.g., validation errors, service errors).
*   **Message Structure:** Define a clear message structure for communication between the webview and extension (e.g., `{ command: string, requestId?: string, payload?: any }` for requests and `{ command: string, requestId?: string, result?: any, error?: string }` for responses).
*   **State Granularity:** The `StateManager` is kept simple here. For more complex state management, consider libraries like Redux or MobX, but for most VS Code extensions, a simple custom `StateManager` is sufficient.
*   **Disposables:** Ensure that any `onDidReceiveMessage` listeners are properly disposed of when the webview panel is closed to prevent memory leaks. The `MessageRouter` handles this by adding its listener to `extensionManager.context.subscriptions`.
</file>

<file path="docs/completed/extension/prd.md">
<prd>Of course. Based on the technical debt analysis and the goal of making the extension more robust, I've broken down the refactoring effort into two distinct, sequential phases. The first phase will focus on foundational backend decoupling, and the second will address the webview and communication layers.

Here are the PRDs for this initiative.

-----

### **New Document: PRD 1: Foundational - Backend Decoupling & Refactoring**

**1. Title & Overview**

  * **Project:** Code Context Engine - Backend Refactoring
  * **Summary:** This phase addresses critical technical debt in the extension's backend. We will refactor the core services to use Dependency Injection (DI) for managing dependencies and centralize configuration handling. We will also begin decoupling the monolithic `extension.ts` file by creating dedicated managers for commands and overall extension lifecycle, establishing a more scalable and testable architecture.
  * **Dependencies:** Requires the existing codebase to be stable and all current features to be functional.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Increase development velocity for future features by creating a more maintainable and understandable codebase.
      * Improve the overall stability and reliability of the extension by reducing tight coupling and side effects.
  * **Developer & System Success Metrics:**
      * Core services (`IndexingService`, `ContextService`, etc.) no longer instantiate their own dependencies.
      * Configuration is read from a single, centralized source and passed to services.
      * Unit test coverage for core services increases by at least 50%, as they can now be tested in isolation with mocked dependencies.
      * The `extension.ts` file is significantly smaller, with its primary responsibilities delegated to new manager classes.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha needs to add new features and fix bugs efficiently. A decoupled architecture allows her to work on individual components without understanding the entire system and to write reliable unit tests for her changes.
  * **Devin (Developer - End User):** While this is a backend refactor, Devin will benefit from the increased stability and faster feature development that results from a cleaner codebase.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Refactoring** | **Sprint 1: Dependency & Config Mgmt** | As Alisha, I want to refactor services to receive dependencies via their constructor so I can unit test them with mocks. | 1. `IndexingService` and `ContextService` constructors are updated to accept dependencies like `QdrantService` and `IEmbeddingProvider`.\<br/\>2. The services no longer use the `new` keyword to create their own dependencies.\<br/\>3. Existing unit tests are updated, and new tests are added to verify service logic with mocked dependencies. | **2 Weeks** |
| | | As Alisha, I want to create a central configuration service so that settings are managed in one place. | 1. A new `ConfigService` is created that reads all settings from `vscode.workspace.getConfiguration()` on startup.\<br/\>2. Services that require configuration (e.g., `QdrantService`) receive the necessary values (like a connection string) via their constructor.\<br/\>3. Services no longer call `vscode.workspace.getConfiguration()` directly. | |
| **Phase 1: Refactoring** | **Sprint 2: Lifecycle & Command Mgmt** | As Alisha, I want to introduce an `ExtensionManager` to handle the extension's lifecycle so that `extension.ts` becomes a simple entry point. | 1. A new `ExtensionManager` class is created to manage the initialization and disposal of all services and managers.\<br/\>2. The `activate` function in `extension.ts` is reduced to creating and initializing the `ExtensionManager`.\<br/\>3. The `deactivate` function calls a `dispose` method on the `ExtensionManager`. | **2 Weeks** |
| | | As Alisha, I want to create a `CommandManager` to handle all command registrations so that this logic is decoupled from the main activation file. | 1. A new `CommandManager` class is created.\<br/\>2. All `vscode.commands.registerCommand` calls are moved from `extension.ts` into the `CommandManager`.\<br/\>3. The `CommandManager` delegates the command's execution logic to the appropriate service (e.g., `IndexingService.startIndexing`).\<br/\>4. The `ExtensionManager` is responsible for creating and initializing the `CommandManager`. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** Dependency & Configuration Management (2 Weeks)
  * **Sprint 2:** Lifecycle & Command Management (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The current feature set is well-understood, allowing for a safe refactoring process without introducing regressions.
  * **Risk:** The refactoring effort might take longer than estimated if unforeseen complexities arise in the existing code.
      * **Mitigation:** Prioritize a "lift and shift" approach initially. Move existing logic into new classes without significantly altering the logic itself. Deeper refactoring of the logic can be a separate, future task.
  * **Risk:** Improperly managing the lifecycle of services and disposables in the new manager classes could lead to memory leaks.
      * **Mitigation:** Implement a clear `dispose` pattern in all manager classes and ensure the top-level `ExtensionManager` correctly calls `dispose` on all its managed components.

-----

### **New Document: Sub-Sprint 1: Dependency Injection & Centralized Config**

**Objective:**
To refactor all core services to use constructor-based dependency injection and to receive configuration from a centralized source.

**Parent Sprint:**
PRD 1, Sprint 1: Dependency & Config Mgmt

**Tasks:**

1.  **Create `ConfigService.ts`:** Develop a service that loads all extension settings from `vscode.workspace.getConfiguration()` once and provides them via getter methods.
2.  **Refactor `QdrantService`:** Update its constructor to accept the database connection string directly.
3.  **Refactor `EmbeddingProvider` implementations:** Update their constructors to accept necessary parameters (e.g., API keys, model names).
4.  **Refactor `IndexingService` & `ContextService`:** Update their constructors to accept instances of their dependencies (e.g., `qdrantService`, `embeddingProvider`, `configService`).
5.  **Update Unit Tests:** Modify existing tests to pass mocked dependencies to the service constructors, improving test isolation.

**Acceptance Criteria:**

  * No service uses the `new` keyword to create its long-lived dependencies.
  * No service directly calls `vscode.workspace.getConfiguration()`.
  * Unit tests for services can run without needing the VS Code API.

**Dependencies:**

  * A clear understanding of the existing service dependencies.

**Timeline:**

  * **Start Date:** 2025-08-25
  * **End Date:** 2025-09-05

-----

### **New Document: Sub-Sprint 2: Extension & Command Managers**

**Objective:**
To create the initial `ExtensionManager` and `CommandManager` classes, moving the core lifecycle and command registration logic out of `extension.ts`.

**Parent Sprint:**
PRD 1, Sprint 2: Lifecycle & Command Mgmt

**Tasks:**

1.  **Create `ExtensionManager.ts`:** This class will have an `initialize` method where it instantiates all services (using the DI pattern from Sub-Sprint 1) and managers. It will also have a `dispose` method.
2.  **Create `CommandManager.ts`:** This class will have a constructor that accepts the `ExtensionManager` instance (to access services) and a `registerCommands` method.
3.  **Move Command Logic:** Transfer all `vscode.commands.registerCommand` calls from `extension.ts` to `CommandManager.registerCommands`.
4.  **Refactor `extension.ts`:** Simplify `activate` to only `new ExtensionManager(context).initialize()`. Simplify `deactivate` to call `extensionManager.dispose()`.

**Acceptance Criteria:**

  * The `extension.ts` file is less than 50 lines of code.
  * All previously functional commands are still registered and work correctly.
  * The extension activates and deactivates cleanly without errors.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2025-09-08
  * **End Date:** 2025-09-19

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Dependency & Config Mgmt

**Goal:** To refactor core services to eliminate tight coupling and centralize configuration management, improving testability and maintainability.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Create `ConfigService.ts`:** Create the file and implement a class that reads all settings from `vscode.workspace.getConfiguration('code-context-engine')` in its constructor and stores them in private properties with public getters. | `src/configService.ts` (New) |
| **1.2** |  To Do | **Refactor `QdrantService`:** Modify the constructor to accept `connectionString: string`. Remove the `getConfiguration` call. | `src/db/qdrantService.ts` |
| **1.3** |  To Do | **Refactor `OllamaProvider`:** Modify the constructor to accept `config: OllamaConfig` object. Remove the `getConfiguration` call. | `src/embeddings/ollamaProvider.ts` |
| **1.4** |  To Do | **Refactor `OpenAIProvider`:** Modify the constructor to accept `config: OpenAIConfig` object. Remove the `getConfiguration` call. | `src/embeddings/openaiProvider.ts` |
| **1.5** |  To Do | **Refactor `EmbeddingProviderFactory`:** Update the factory to accept the `ConfigService` and pass the correct configuration down to the provider it creates. | `src/embeddings/embeddingProvider.ts` |
| **1.6** |  To Do | **Refactor `ContextService`:** Modify the constructor to accept `qdrantService: QdrantService` and `embeddingProvider: IEmbeddingProvider` as arguments. Remove the `new` keywords. | `src/context/contextService.ts` |
| **1.7** |  To Do | **Refactor `IndexingService`:** Modify the constructor to accept its dependencies (`fileWalker`, `astParser`, `chunker`, `qdrantService`, `embeddingProvider`, `lspService`) as arguments. Remove the `new` keywords. | `src/indexing/indexingService.ts` |
| **1.8** |  To Do | **Create Test Mocks:** Create mock implementations for `QdrantService` and `IEmbeddingProvider` for use in unit tests. | `src/test/mocks.ts` (New) |
| **1.9** |  To Do | **Update `ContextService` Tests:** Write/update unit tests for `ContextService`, passing in the mocked dependencies to its constructor. | `src/test/contextService.test.ts` |

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Lifecycle & Command Mgmt

**Goal:** To decouple the main `extension.ts` file by creating dedicated managers for the extension's lifecycle and command registration.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Create `CommandManager.ts`:** Create the new file and `CommandManager` class. It should have a constructor that accepts the `ExtensionManager` and a `registerCommands` method. | `src/commandManager.ts` (New) |
| **2.2** |  To Do | **Move `openMainPanel` Command:** Move the `registerCommand` logic for `code-context-engine.openMainPanel` from `extension.ts` to `CommandManager`. The callback will call a method on the `WebviewManager` (to be created in the next PRD). | `src/commandManager.ts`, `src/extension.ts` |
| **2.3** |  To Do | **Move `startIndexing` Command:** Move the `registerCommand` logic for `code-context-engine.startIndexing` to `CommandManager`. The callback will call `indexingService.startIndexing()`. | `src/commandManager.ts`, `src/extension.ts` |
| **2.4** |  To Do | **Move `openSettings` Command:** Move the `registerCommand` logic for `code-context-engine.openSettings` to `CommandManager`. The callback will call a method on the `WebviewManager`. | `src/commandManager.ts`, `src/extension.ts` |
| **2.5** |  To Do | **Create `ExtensionManager.ts`:** Create the new file and `ExtensionManager` class. Its constructor will instantiate all services (using DI) and managers. | `src/extensionManager.ts` (New) |
| **2.6** |  To Do | **Implement `initialize` Method:** In `ExtensionManager`, the `initialize` method will call `commandManager.registerCommands()`. | `src/extensionManager.ts` |
| **2.7** |  To Do | **Implement `dispose` Method:** In `ExtensionManager`, the `dispose` method will call `dispose` on any disposable managers (like `CommandManager`). | `src/extensionManager.ts` |
| **2.8** |  To Do | **Refactor `extension.ts`:** Remove all command registration and service instantiation logic. The `activate` function should now only create and initialize an `ExtensionManager`. | `src/extension.ts` |
| **2.9** |  To Do | **Refactor `deactivate`:** The `deactivate` function in `extension.ts` should now only call `extensionManager.dispose()`. | `src/extension.ts` |
Of course. Here is the final PRD to complete the technical debt and refactoring initiative.

-----

### **New Document: PRD 2: Advanced Refactoring - Webview & Communication**

**1. Title & Overview**

  * **Project:** Code Context Engine - Webview & Communication Refactoring
  * **Summary:** This phase completes the decoupling of `extension.ts` by creating dedicated managers for webview lifecycle and message routing. A `WebviewManager` will centralize the logic for creating, showing, and disposing of all webview panels. A `MessageRouter` will handle all communication between the webview and the extension's backend services, creating a clean and robust communication layer.
  * **Dependencies:** PRD 1 (Backend Decoupling & Refactoring) must be complete. The `ExtensionManager` and `CommandManager` should be in place.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Finalize the architectural refactoring to create a fully modular, scalable, and maintainable codebase.
      * Improve the reliability of the UI and its communication with the backend, leading to a better user experience.
  * **Developer & System Success Metrics:**
      * `extension.ts` is purely an activator and contains no direct webview or message handling logic.
      * All webview panel creation and management logic is consolidated within the `WebviewManager`.
      * The large `switch` statement for message handling is replaced by the `MessageRouter`, which cleanly delegates tasks to the appropriate services.
      * Adding a new webview or a new message command is a simple, low-risk operation that requires changes in only one or two focused files.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha can now add new commands and backend logic without ever needing to touch the UI or communication layers. Her work is isolated to the services she owns.
  * **Frank (Frontend Developer):** Frank works on the SvelteKit UI. He now has a single, predictable `MessageRouter` to interact with. He doesn't need to know which backend service implements a feature; he just sends a command, and the router handles the rest.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Refactoring** | **Sprint 3: Webview Management** | As a developer, I want to create a `WebviewManager` to handle the lifecycle of all webview panels so that UI creation logic is centralized and reusable. | 1. A new `WebviewManager` class is created. \<br/\> 2. All `vscode.window.createWebviewPanel` logic is moved from `extension.ts` (or `CommandManager`) into the `WebviewManager`. \<br/\> 3. The manager handles showing the main panel and the settings panel, ensuring only one of each can exist at a time. \<br/\> 4. The manager is responsible for panel disposal and is properly disposed of by the `ExtensionManager`. | **2 Weeks** |
| | | As Frank, I want the `WebviewManager` to be responsible for providing the correct HTML content so that the webview loading process is standardized. | 1. The logic for reading the `index.html` file from the `webview/dist` directory is moved into a private method in `WebviewManager`. \<br/\> 2. The method correctly replaces asset paths with `webview.asWebviewUri` to ensure CSS and JS files load correctly. \<br/\> 3. The `showMainPanel` and `showSettingsPanel` methods use this helper to set the panel's HTML. | |
| **Phase 2: Refactoring** | **Sprint 4: Communication & State Mgmt** | As a developer, I want to create a `MessageRouter` to handle all incoming messages from the webview so that communication logic is decoupled and clean. | 1. A new `MessageRouter` class is created. \<br/\> 2. The `onDidReceiveMessage` listener for each webview is set up to delegate to an instance of the `MessageRouter`. \<br/\> 3. The `MessageRouter`'s `routeMessage` method contains the `switch` statement that calls the appropriate service based on the message command. \<br/\> 4. The router sends results back to the webview with a consistent response format (e.g., `{ command, requestId, result, error }`). | **2 Weeks** |
| | | As Alisha, I want to introduce a basic `StateManager` to track the global state of the extension so that services don't need to communicate directly with each other for status updates. | 1. A new `StateManager` class is created to hold simple boolean flags (e.g., `isIndexing`, `isBackendHealthy`). \<br/\> 2. Services can update the state via the manager (e.g., `stateManager.setIndexing(true)`). \<br/\> 3. The `MessageRouter` can query the state to prevent conflicting actions (e.g., don't start a new index if `isIndexing` is true). | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 3:** Webview Management (2 Weeks)
  * **Sprint 4:** Communication & State Management (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The message-passing API between the webview and the extension is stable and performant enough for all communication needs.
  * **Risk:** Incorrectly managing panel/webview lifecycles in the `WebviewManager` could lead to memory leaks or "ghost" panels that are not properly disposed of.
      * **Mitigation:** Ensure that the `onDidDispose` event for every created panel is correctly handled and that all disposables are added to the extension's context subscriptions.
  * **Risk:** The `StateManager` could become a complex bottleneck if too much logic is added to it.
      * **Mitigation:** Keep the initial `StateManager` extremely simple, holding only essential, global boolean flags. Avoid putting business logic into the state manager itself; its only job is to store and retrieve state.

-----

### **New Document: Sub-Sprint 3: Centralized Webview Management**

**Objective:**
To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, cleaning up the command handlers and `extension.ts`.

**Parent Sprint:**
PRD 2, Sprint 3: Webview Management

**Tasks:**

1.  **Create `WebviewManager.ts`:** Develop the new class with a constructor that accepts the `vscode.ExtensionContext`.
2.  **Implement `showMainPanel`:** Create a method that contains the logic for creating and showing the main webview panel. It should ensure only one instance of the main panel can exist.
3.  **Implement `showSettingsPanel`:** Create a method that contains the logic for creating and showing the settings webview panel.
4.  **Implement `getWebviewContent`:** Create a private helper method that reads the `index.html`, prepares it with the correct URIs for webview assets, and returns the HTML string.
5.  **Refactor `CommandManager`:** Update the callbacks for the `openMainPanel` and `openSettings` commands to simply call the appropriate methods on the `WebviewManager` instance.

**Acceptance Criteria:**

  * All `vscode.window.createWebviewPanel` calls are located exclusively within `WebviewManager.ts`.
  * The `openMainPanel` and `openSettings` commands correctly open their respective UIs.
  * Attempting to open a panel that is already open simply brings the existing panel into focus.

**Dependencies:**

  * `CommandManager` from PRD 1 must be implemented.

**Timeline:**

  * **Start Date:** 2025-09-22
  * **End Date:** 2025-10-03

-----

### **New Document: Sub-Sprint 4: Message Routing & State**

**Objective:**
To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

**Parent Sprint:**
PRD 2, Sprint 4: Communication & State Mgmt

**Tasks:**

1.  **Create `StateManager.ts`:** Develop a simple class with private properties (e.g., `_isIndexing = false`) and public getter/setter methods.
2.  **Create `MessageRouter.ts`:** Develop the class with a constructor that accepts the `ExtensionManager` (to access all services and managers) and the `vscode.Webview`. The constructor will set up the `onDidReceiveMessage` listener.
3.  **Implement `routeMessage` method:** Move the message-handling `switch` statement from `extension.ts` into this private method within the `MessageRouter`.
4.  **Integrate `StateManager`:** In the `MessageRouter`, check the state before delegating actions. For example: `if (this.stateManager.isIndexing) { /* return error */ }`.
5.  **Update Services:** Modify services like `IndexingService` to update the central state (e.g., `this.stateManager.setIndexing(true)` at the start and `false` at the end).
6.  **Integrate `MessageRouter`:** In `WebviewManager`, when a panel is created, instantiate a `MessageRouter` for it, passing in the necessary dependencies.

**Acceptance Criteria:**

  * The `onDidReceiveMessage` listener in `WebviewManager` is a single line that instantiates and uses the `MessageRouter`.
  * The `MessageRouter` correctly routes commands to the appropriate services.
  * Attempting to start a new indexing job while one is already running is gracefully rejected with an error message sent back to the UI.

**Dependencies:**

  * Sub-Sprint 3 must be complete.

**Timeline:**

  * **Start Date:** 2025-10-06
  * **End Date:** 2025-10-17

-----

### **New Document: tasklist\_sprint\_03.md**

# Task List: Sprint 3 - Webview Management

**Goal:** To centralize all webview creation and lifecycle logic into a dedicated `WebviewManager` class.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Create `WebviewManager.ts`:** Create the new file and the `WebviewManager` class structure with a constructor and a `dispose` method. | `src/webviewManager.ts` (New) |
| **3.2** |  To Do | **Implement `getWebviewContent`:** Create a private helper method that takes a webview instance, reads `webview/dist/index.html`, replaces asset paths using `webview.asWebviewUri`, and returns the final HTML string. | `src/webviewManager.ts` |
| **3.3** |  To Do | **Implement `showMainPanel`:** Create a public method that checks if a main panel instance already exists. If not, it calls `vscode.window.createWebviewPanel`, sets its HTML using the helper, and stores the instance. If it exists, it calls `.reveal()`. | `src/webviewManager.ts` |
| **3.4** |  To Do | **Implement `showSettingsPanel`:** Create a public method with the same logic as `showMainPanel`, but for the settings UI, using a different panel ID and title. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Handle Panel Disposal:** In the `show...` methods, add the `onDidDispose` listener to the created panel to nullify the stored instance variable (e.g., `this.mainPanel = undefined`). | `src/webviewManager.ts` |
| **3.6** |  To Do | **Update `ExtensionManager`:** Instantiate the `WebviewManager` in the `ExtensionManager`'s constructor. | `src/extensionManager.ts` |
| **3.7** |  To Do | **Refactor `CommandManager`:** Change the `openMainPanel` and `openSettings` command callbacks to call `extensionManager.webviewManager.showMainPanel()` and `showSettingsPanel()` respectively. | `src/commandManager.ts` |

-----

### **New Document: tasklist\_sprint\_04.md**

# Task List: Sprint 4 - Communication & State Mgmt

**Goal:** To formalize the webview communication layer with a `MessageRouter` and centralize global state with a `StateManager`.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `StateManager.ts`:** Create the new file and a simple `StateManager` class. Add a private boolean `_isIndexing` and public `isIndexing()` getter and `setIndexing(state: boolean)` setter. | `src/stateManager.ts` (New) |
| **4.2** |  To Do | **Create `MessageRouter.ts`:** Create the new file and the `MessageRouter` class. Its constructor will accept the `ExtensionManager` and `vscode.Webview`. | `src/messageRouter.ts` (New) |
| **4.3** |  To Do | **Implement `routeMessage`:** Move the message handling `switch` statement into a private `async routeMessage` method in `MessageRouter`. | `src/messageRouter.ts` |
| **4.4** |  To Do | **Integrate State Check:** In `routeMessage`, before the `startIndexing` case, add a check: `if (this.extensionManager.stateManager.isIndexing()) { ... post error message ... }`. | `src/messageRouter.ts` |
| **4.5** |  To Do | **Update `IndexingService`:** Inject the `StateManager` instance into the `IndexingService`. Call `this.stateManager.setIndexing(true)` at the beginning of `startIndexing` and `false` in a `finally` block at the end. | `src/indexing/indexingService.ts` |
| **4.6** |  To Do | **Instantiate `MessageRouter`:** In `WebviewManager`, when a panel is created, remove the old `onDidReceiveMessage` logic and replace it with `new MessageRouter(this.extensionManager, this.mainPanel.webview)`. | `src/webviewManager.ts` |
| **4.7** |  To Do | **Instantiate `StateManager`:** In `ExtensionManager`, create a public instance of the `StateManager` so it can be accessed by other services. | `src/extensionManager.ts` |
| **4.8** |  To Do | **Update Service Constructors:** Update the constructors of services (like `IndexingService`) that now need the `StateManager`, and update the instantiation logic in `ExtensionManager`. | `src/extensionManager.ts`, `src/indexing/indexingService.ts` |

This completes the full set of PRDs for the refactoring initiative. You now have a comprehensive plan to transform your extension's architecture into a more robust, maintainable, and scalable system.

</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/completed/extension/tasklist_sprint_01.md">
# Task List: Sub-Sprint 1 - Dependency Injection & Centralized Config

**Goal:** To refactor all core services to use constructor-based dependency injection and to receive configuration from a centralized source, improving testability and maintainability.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Create `ConfigService.ts`:** Create the file `src/configService.ts`. Implement a class that reads all extension settings from `vscode.workspace.getConfiguration('code-context-engine')` in its constructor and stores them in private properties with public getter methods for each configuration item (e.g., `getQdrantConnectionString()`, `getOllamaConfig()`, `getOpenAIConfig()`). | `src/configService.ts` (New) |
| **1.2** |  To Do | **Refactor `QdrantService` Constructor:** Open `src/db/qdrantService.ts`. Modify the constructor to accept `connectionString: string` as a parameter. Remove any direct calls to `vscode.workspace.getConfiguration()` within this service. | `src/db/qdrantService.ts` |
| **1.3** |  To Do | **Refactor `OllamaProvider` Constructor:** Open `src/embeddings/ollamaProvider.ts`. Modify the constructor to accept a `config: OllamaConfig` object as a parameter. Define the `OllamaConfig` interface if it doesn't exist. Remove any direct calls to `vscode.workspace.getConfiguration()` within this service. | `src/embeddings/ollamaProvider.ts` |
| **1.4** |  To Do | **Refactor `OpenAIProvider` Constructor:** Open `src/embeddings/openaiProvider.ts`. Modify the constructor to accept a `config: OpenAIConfig` object as a parameter. Define the `OpenAIConfig` interface if it doesn't exist. Remove any direct calls to `vscode.workspace.getConfiguration()` within this service. | `src/embeddings/openaiProvider.ts` |
| **1.5** |  To Do | **Update `EmbeddingProviderFactory`:** Open `src/embeddings/embeddingProvider.ts` (or wherever your factory is located). Modify the factory function/class to accept an instance of `ConfigService`. Use the `ConfigService` to retrieve the appropriate configuration (e.g., `configService.getOllamaConfig()`) and pass it to the `OllamaProvider` or `OpenAIProvider` constructor when creating an instance. | `src/embeddings/embeddingProvider.ts` |
| **1.6** |  To Do | **Refactor `ContextService` Constructor:** Open `src/context/contextService.ts`. Modify the constructor to accept `qdrantService: QdrantService` and `embeddingProvider: IEmbeddingProvider` as parameters. Remove any `new` keyword usages for these dependencies within the constructor. | `src/context/contextService.ts` |
| **1.7** |  To Do | **Refactor `IndexingService` Constructor:** Open `src/indexing/indexingService.ts`. Modify the constructor to accept all its dependencies (`fileWalker`, `astParser`, `chunker`, `qdrantService`, `embeddingProvider`, `lspService`, and `configService` if needed) as parameters. Remove any `new` keyword usages for these dependencies within the constructor. | `src/indexing/indexingService.ts` |
| **1.8** |  To Do | **Create Test Mocks File:** Create a new file `src/test/mocks.ts`. Implement mock classes or objects for `QdrantService`, `IEmbeddingProvider`, `FileWalker`, `AstParser`, `Chunker`, and `LspService` that can be used in unit tests. These mocks should implement the necessary methods that the services under test will call. | `src/test/mocks.ts` (New) |
| **1.9** |  To Do | **Update `ContextService` Unit Tests:** Open `src/test/contextService.test.ts`. Modify existing unit tests to instantiate `ContextService` with the newly created mock dependencies (e.g., `new ContextService(new MockQdrantService(), new MockEmbeddingProvider())`). Add new tests to verify `ContextService` logic using these mocks, ensuring it does not rely on the actual VS Code API. | `src/test/contextService.test.ts` |
| **1.10** |  To Do | **Update `IndexingService` Unit Tests:** Open `src/test/indexingService.test.ts` (if it exists, otherwise create it). Modify existing unit tests or create new ones to instantiate `IndexingService` with the newly created mock dependencies. Verify `IndexingService` logic using these mocks. | `src/test/indexingService.test.ts` (New/Modify) |
| **1.11** |  To Do | **Update `extension.ts` for Initial Wiring:** Open `src/extension.ts`. In the `activate` function, instantiate `ConfigService`. Then, use the `ConfigService` instance to retrieve configuration values and pass them to the constructors of `QdrantService`, `OllamaProvider`, `OpenAIProvider`, `ContextService`, and `IndexingService` during their instantiation. Ensure all services are correctly wired together. | `src/extension.ts` |
</file>

<file path="docs/completed/extension/tasklist_sprint_02.md">
# Task List: Sub-Sprint 2 - Extension & Command Managers

**Goal:** To create the initial `ExtensionManager` and `CommandManager` classes, moving the core lifecycle and command registration logic out of `extension.ts`.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Create `ExtensionManager.ts` File:** Create the new file `src/extensionManager.ts`. Define the `ExtensionManager` class. Its constructor should accept `vscode.ExtensionContext`. Implement an `initialize()` method where all core services (e.g., `ConfigService`, `QdrantService`, `IndexingService`, `ContextService`) are instantiated using the Dependency Injection pattern established in Sub-Sprint 1. Implement a `dispose()` method to clean up resources. | `src/extensionManager.ts` (New) |
| **2.2** |  To Do | **Create `CommandManager.ts` File:** Create the new file `src/commandManager.ts`. Define the `CommandManager` class. Its constructor should accept instances of services it needs to interact with (e.g., `IndexingService`). Implement a `registerCommands()` method that will contain all `vscode.commands.registerCommand` calls and return an array of `vscode.Disposable` objects. | `src/commandManager.ts` (New) |
| **2.3** |  To Do | **Move `openMainPanel` Command:** Open `src/extension.ts`. Locate the `vscode.commands.registerCommand` call for `code-context-engine.openMainPanel`. Cut this entire registration. Paste it into the `registerCommands()` method of `src/commandManager.ts`. For now, the callback can show a simple `vscode.window.showInformationMessage('Open Main Panel (placeholder)');`. | `src/extension.ts`, `src/commandManager.ts` |
| **2.4** |  To Do | **Move `startIndexing` Command:** Open `src/extension.ts`. Locate the `vscode.commands.registerCommand` call for `code-context-engine.startIndexing`. Cut this entire registration. Paste it into the `registerCommands()` method of `src/commandManager.ts`. The callback should call `this.indexingService.startIndexing()`. | `src/extension.ts`, `src/commandManager.ts` |
| **2.5** |  To Do | **Move `openSettings` Command:** Open `src/extension.ts`. Locate the `vscode.commands.registerCommand` call for `code-context-engine.openSettings`. Cut this entire registration. Paste it into the `registerCommands()` method of `src/commandManager.ts`. For now, the callback can show a simple `vscode.window.showInformationMessage('Open Settings (placeholder)');`. | `src/extension.ts`, `src/commandManager.ts` |
| **2.6** |  To Do | **Instantiate `CommandManager` in `ExtensionManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, instantiate `CommandManager`, passing it the necessary service instances (e.g., `this.indexingService`). In the `initialize()` method, call `this.commandManager.registerCommands()` and add the returned disposables to `this.disposables` array. | `src/extensionManager.ts` |
| **2.7** |  To Do | **Refactor `extension.ts` - `activate` Function:** Open `src/extension.ts`. Simplify the `activate` function. It should now only instantiate `ExtensionManager` (passing `context`) and then call its `initialize()` method. Remove all direct service instantiations and command registrations from `activate`. | `src/extension.ts` |
| **2.8** |  To Do | **Refactor `extension.ts` - `deactivate` Function:** Open `src/extension.ts`. Simplify the `deactivate` function. It should now only call `extensionManager.dispose()` (assuming `extensionManager` is a module-scoped variable). | `src/extension.ts` |
| **2.9** |  To Do | **Verify `extension.ts` Line Count:** Ensure that after refactoring, the `src/extension.ts` file contains less than 50 lines of code. | `src/extension.ts` |
</file>

<file path="docs/completed/extension/tasklist_sprint_03.md">
# Task List: Sub-Sprint 3 - Centralized Webview Management

**Goal:** To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, cleaning up the command handlers and `extension.ts`.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Create `WebviewManager.ts` File:** Create the new file `src/webviewManager.ts`. Define the `WebviewManager` class. Its constructor should accept `vscode.ExtensionContext`. Include private properties to hold references to `mainPanel` and `settingsPanel` (both `vscode.WebviewPanel | undefined`). Implement a `dispose()` method to clean up these panels. | `src/webviewManager.ts` (New) |
| **3.2** |  To Do | **Implement `getWebviewContent` Helper:** In `src/webviewManager.ts`, create a private helper method `getWebviewContent(webview: vscode.Webview, panelName: string): string`. This method should read `webview/dist/index.html` using `fs.readFileSync()`. It must then replace placeholders (e.g., `{{scriptUri}}`, `{{styleUri}}`) with URIs generated by `webview.asWebviewUri()` for `webview/dist/index.js` and `webview/dist/styles.css`. | `src/webviewManager.ts` |
| **3.3** |  To Do | **Implement `showMainPanel` Method:** In `src/webviewManager.ts`, create a public method `showMainPanel(): void`. This method should check if `this.mainPanel` already exists. If it does, call `this.mainPanel.reveal(vscode.ViewColumn.One)` and return. If not, create a new `vscode.WebviewPanel` using `vscode.window.createWebviewPanel()`, set its `webview.html` using `getWebviewContent()`, and store the panel in `this.mainPanel`. Add an `onDidDispose` listener to the panel to set `this.mainPanel` back to `undefined` when the panel is closed. | `src/webviewManager.ts` |
| **3.4** |  To Do | **Implement `showSettingsPanel` Method:** In `src/webviewManager.ts`, create a public method `showSettingsPanel(): void`. This method should follow the same logic as `showMainPanel`, but for the settings UI, using a different panel ID and title, and potentially a different `vscode.ViewColumn` (e.g., `vscode.ViewColumn.Two`). Store the panel in `this.settingsPanel`. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Update `ExtensionManager` for `WebviewManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, instantiate `WebviewManager`, passing it the `vscode.ExtensionContext` (e.g., `this.webviewManager = new WebviewManager(this.context);`). Make `webviewManager` a public property so it can be accessed by `CommandManager`. Add `this.webviewManager` to the `disposables` array. | `src/extensionManager.ts` |
| **3.6** |  To Do | **Refactor `CommandManager` for Webview Commands:** Open `src/commandManager.ts`. Modify the constructor to accept `WebviewManager` as a dependency. Update the callbacks for `code-context-engine.openMainPanel` and `code-context-engine.openSettings` commands to call `this.webviewManager.showMainPanel()` and `this.webviewManager.showSettingsPanel()` respectively, replacing the placeholder messages. | `src/commandManager.ts` |
| **3.7** |  To Do | **Verify Webview HTML Placeholders:** Open `webview/dist/index.html`. Ensure it contains `{{scriptUri}}` and `{{styleUri}}` placeholders in the appropriate `<script>` and `<link>` tags for the `getWebviewContent` method to replace. | `webview/dist/index.html` |
</file>

<file path="docs/completed/extension/tasklist_sprint_04.md">
# Task List: Sub-Sprint 4 - Message Routing & State

**Goal:** To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `StateManager.ts` File:** Create the new file `src/stateManager.ts`. Define a simple `StateManager` class. Add a private boolean property `_isIndexing` initialized to `false`. Implement a public getter `isIndexing(): boolean` and a public setter `setIndexing(state: boolean): void` for this property. | `src/stateManager.ts` (New) |
| **4.2** |  To Do | **Create `MessageRouter.ts` File:** Create the new file `src/messageRouter.ts`. Define the `MessageRouter` class. Its constructor should accept `extensionManager: ExtensionManager` and `webview: vscode.Webview`. In the constructor, set up the `webview.onDidReceiveMessage` listener, delegating to a private `routeMessage` method. | `src/messageRouter.ts` (New) |
| **4.3** |  To Do | **Implement `routeMessage` Method:** In `src/messageRouter.ts`, implement the private `async routeMessage(message: any): Promise<void>` method. This method should contain a `switch` statement to handle different `message.command` values (e.g., `'startIndexing'`). It should call the appropriate service method via `this.extensionManager` and send a response back to the webview using `this.webview.postMessage()`, including `requestId`, `result`, and `error` fields. | `src/messageRouter.ts` |
| **4.4** |  To Do | **Integrate State Check in `MessageRouter`:** In `src/messageRouter.ts`, within the `routeMessage` method, for the `'startIndexing'` case, add a check: `if (this.extensionManager.stateManager.isIndexing()) { throw new Error('Indexing is already in progress.'); }` before calling `startIndexing()`. | `src/messageRouter.ts` |
| **4.5** |  To Do | **Update `ExtensionManager` for `StateManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, instantiate `StateManager` (e.g., `this.stateManager = new StateManager();`). Make `stateManager` a public property. Pass the `stateManager` instance as a dependency to `IndexingService` during its instantiation. | `src/extensionManager.ts` |
| **4.6** |  To Do | **Update `IndexingService` to Use `StateManager`:** Open `src/indexing/indexingService.ts`. Modify the constructor to accept `stateManager: StateManager` as a dependency. In the `startIndexing()` method, call `this.stateManager.setIndexing(true)` at the beginning and `this.stateManager.setIndexing(false)` in a `finally` block to ensure the state is reset after the operation completes (whether successful or not). | `src/indexing/indexingService.ts` |
| **4.7** |  To Do | **Integrate `MessageRouter` in `WebviewManager`:** Open `src/webviewManager.ts`. Modify the `showMainPanel()` and `showSettingsPanel()` methods. Remove any existing `webview.onDidReceiveMessage` listener. Instead, instantiate `MessageRouter` (e.g., `new MessageRouter(this.extensionManager, this.mainPanel.webview);`) for each panel. Ensure `WebviewManager`'s constructor now accepts `extensionManager: ExtensionManager` as a dependency. | `src/webviewManager.ts` |
| **4.8** |  To Do | **Update `ExtensionManager` to Pass Itself to `WebviewManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, when instantiating `WebviewManager`, pass `this` (the `ExtensionManager` instance itself) as the second argument (e.g., `this.webviewManager = new WebviewManager(this.context, this);`). | `src/extensionManager.ts` |
</file>

<file path="docs/completed/extension2/backlog_sprint_1_webview_panel_lifecycle.md">
### User Story 1: Centralized Webview Panel Management
**As Alisha, I want a** `WebviewManager` class to handle the creation and disposal of webview panels, **so that** UI logic is centralized and decoupled from `extension.ts`.

**Actions to Undertake:**
1.  **Filepath**: `src/webviewManager.ts` (New File)
    -   **Action**: Create a new file `webviewManager.ts` and define the `WebviewManager` class.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';

        export class WebviewManager {
            private static instance: WebviewManager;
            private panel: vscode.WebviewPanel | undefined;
            private readonly context: vscode.ExtensionContext;

            private constructor(context: vscode.ExtensionContext) {
                this.context = context;
            }

            public static getInstance(context: vscode.ExtensionContext): WebviewManager {
                if (!WebviewManager.instance) {
                    WebviewManager.instance = new WebviewManager(context);
                }
                return WebviewManager.instance;
            }

            public showMainPanel() {
                if (this.panel) {
                    this.panel.reveal(vscode.ViewColumn.One);
                    return;
                }

                this.panel = vscode.window.createWebviewPanel(
                    'codeContextEngine',
                    'Code Context Engine',
                    vscode.ViewColumn.One,
                    {
                        enableScripts: true,
                        localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
                    }
                );

                this.panel.webview.html = this.getWebviewContent();

                this.panel.onDidDispose(() => {
                    this.panel = undefined;
                }, null, this.context.subscriptions);
            }

            private getWebviewContent(): string {
                // This will be implemented in the next user story
                return `<!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Code Context Engine</title>
                </head>
                <body>
                    <h1>Loading Webview...</h1>
                </body>
                </html>`;
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import * as path from 'path';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Instantiate `WebviewManager` and call `showMainPanel` from a command.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { WebviewManager } from './webviewManager'; // Add this import

        export function activate(context: vscode.ExtensionContext) {
            console.log('Congratulations, your extension "code-context-engine" is now active!');

            // Instantiate WebviewManager
            const webviewManager = WebviewManager.getInstance(context);

            let disposable = vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                webviewManager.showMainPanel(); // Delegate to WebviewManager
            });

            context.subscriptions.push(disposable);
        }

        export function deactivate() {}
        ```
    -   **Imports**: `import { WebviewManager } from './webviewManager';`

**Acceptance Criteria:**
-   A new file `src/webviewManager.ts` exists containing the `WebviewManager` class.
-   The `WebviewManager` class has a `showMainPanel()` method.
-   Executing the `code-context-engine.openMainPanel` command opens a new VS Code webview panel.
-   If the panel is already open, executing the command reveals the existing panel instead of creating a new one.
-   Closing the webview panel correctly disposes of its instance within the `WebviewManager`.

**Testing Plan:**
-   **Test Case 1**: Run the extension, execute the "Code Context Engine: Open Main Panel" command. Verify a new webview panel appears.
-   **Test Case 2**: Execute the command again. Verify the existing panel is revealed and no new panel is created.
-   **Test Case 3**: Close the webview panel. Execute the command again. Verify a new panel is created.

### User Story 2: Load SvelteKit Build Output
**As Frank, I want the** `WebviewManager` to correctly load the SvelteKit build output, **so my** application renders properly inside VS Code.

**Actions to Undertake:**
1.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: Implement `getWebviewContent` to read `index.html` and replace asset paths.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs'; // Add this import

        export class WebviewManager {
            // ... existing code ...

            private getWebviewContent(): string {
                const webviewPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');
                let htmlContent = fs.readFileSync(webviewPath, 'utf8');

                // Replace relative paths with webview-specific URIs
                htmlContent = htmlContent.replace(
                    /(<script src="|\ssrc="|<link href=")(?!https?:\/\/)([^"]*)"/g,
                    (match, p1, p2) => {
                        const resourcePath = path.join(this.context.extensionPath, 'webview', 'dist', p2);
                        const uri = this.panel!.webview.asWebviewUri(vscode.Uri.file(resourcePath));
                        return `${p1}${uri}"`;
                    }
                );

                return htmlContent;
            }
        }
        ```
    -   **Imports**: `import * as fs from 'fs';`

**Acceptance Criteria:**
-   The SvelteKit application's `index.html` is read and loaded into the webview.
-   All relative asset paths (e.g., `/_app/assets/`) within the `index.html` are correctly converted to `webview.asWebviewUri` format.
-   The SvelteKit application renders correctly within the VS Code webview panel, including its CSS and JavaScript.

**Testing Plan:**
-   **Test Case 1**: Run the extension and open the main panel. Verify the SvelteKit application loads and displays its UI elements (e.g., text, buttons, styling).
-   **Test Case 2**: Open the webview's developer tools (right-click on the webview and select "Inspect Element"). Verify that all loaded resources (JS, CSS) have `vscode-resource:` URIs.
-   **Test Case 3**: Check the console for any errors related to failed resource loading.

### User Story 3: Command Delegation to CommandManager
**As a** developer, **I want the** main panel command to be handled by the `CommandManager`, which delegates to the `WebviewManager`.

**Actions to Undertake:**
1.  **Filepath**: `src/commandManager.ts` (New File)
    -   **Action**: Create a new file `commandManager.ts` and define the `CommandManager` class.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { WebviewManager } from './webviewManager';

        export class CommandManager {
            private readonly context: vscode.ExtensionContext;
            private readonly webviewManager: WebviewManager;

            constructor(context: vscode.ExtensionContext, webviewManager: WebviewManager) {
                this.context = context;
                this.webviewManager = webviewManager;
            }

            public registerCommands() {
                this.context.subscriptions.push(
                    vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                        this.webviewManager.showMainPanel();
                    })
                );
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { WebviewManager } from './webviewManager';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Instantiate `CommandManager` and register commands. Remove direct command registration.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { WebviewManager } from './webviewManager';
        import { CommandManager } from './commandManager'; // Add this import

        export function activate(context: vscode.ExtensionContext) {
            console.log('Congratulations, your extension "code-context-engine" is now active!');

            const webviewManager = WebviewManager.getInstance(context);
            const commandManager = new CommandManager(context, webviewManager); // Instantiate CommandManager
            commandManager.registerCommands(); // Register commands

            // Remove the old disposable for 'code-context-engine.openMainPanel'
            // let disposable = vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
            //     webviewManager.showMainPanel();
            // });
            // context.subscriptions.push(disposable);
        }

        export function deactivate() {}
        ```
    -   **Imports**: `import { CommandManager } from './commandManager';`

**Acceptance Criteria:**
-   A new file `src/commandManager.ts` exists containing the `CommandManager` class.
-   The `CommandManager` registers the `code-context-engine.openMainPanel` command.
-   The `extension.ts` file no longer directly registers the `openMainPanel` command but delegates to `CommandManager`.
-   Executing the `code-context-engine.openMainPanel` command still successfully opens/reveals the webview panel.

**Testing Plan:**
-   **Test Case 1**: Run the extension, execute the "Code Context Engine: Open Main Panel" command. Verify the webview panel opens.
-   **Test Case 2**: Inspect `extension.ts` to confirm that the direct `vscode.commands.registerCommand` for `openMainPanel` has been removed.
-   **Test Case 3**: Verify that the `CommandManager` is instantiated and its `registerCommands` method is called in `extension.ts`.
</file>

<file path="docs/completed/extension2/backlog_sprint_2_message_routing_api.md">
### User Story 1: Backend MessageRouter
**As a** developer, **I want a** `MessageRouter` class in the backend to handle all incoming webview messages, **so that** communication logic is centralized and testable.

**Actions to Undertake:**
1.  **Filepath**: `src/messageRouter.ts` (New File)
    -   **Action**: Create a new file `messageRouter.ts` and define the `MessageRouter` class.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';

        export class MessageRouter {
            private webview: vscode.Webview;

            constructor(webview: vscode.Webview) {
                this.webview = webview;
                this.webview.onDidReceiveMessage(message => this.handleMessage(message));
            }

            private async handleMessage(message: any) {
                switch (message.command) {
                    // This will be implemented in the next user story
                    case 'ping':
                        console.log('Received ping from webview');
                        this.webview.postMessage({ command: 'pong', requestId: message.requestId });
                        break;
                    default:
                        console.warn('Unknown command received:', message.command);
                        break;
                }
            }

            public postMessage(message: any) {
                this.webview.postMessage(message);
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: Instantiate `MessageRouter` and pass the webview instance to it. Delegate `onDidReceiveMessage` to `MessageRouter`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';
        import { MessageRouter } from './messageRouter'; // Add this import

        export class WebviewManager {
            private static instance: WebviewManager;
            private panel: vscode.WebviewPanel | undefined;
            private readonly context: vscode.ExtensionContext;
            private messageRouter: MessageRouter | undefined; // Add this line

            private constructor(context: vscode.ExtensionContext) {
                this.context = context;
            }

            public static getInstance(context: vscode.ExtensionContext): WebviewManager {
                if (!WebviewManager.instance) {
                    WebviewManager.instance = new WebviewManager(context);
                }
                return WebviewManager.instance;
            }

            public showMainPanel() {
                if (this.panel) {
                    this.panel.reveal(vscode.ViewColumn.One);
                    return;
                }

                this.panel = vscode.window.createWebviewPanel(
                    'codeContextEngine',
                    'Code Context Engine',
                    vscode.ViewColumn.One,
                    {
                        enableScripts: true,
                        localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
                    }
                );

                this.messageRouter = new MessageRouter(this.panel.webview); // Instantiate MessageRouter

                this.panel.webview.html = this.getWebviewContent();

                this.panel.onDidDispose(() => {
                    this.panel = undefined;
                    this.messageRouter = undefined; // Clear message router on dispose
                }, null, this.context.subscriptions);
            }

            private getWebviewContent(): string {
                const webviewPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');
                let htmlContent = fs.readFileSync(webviewPath, 'utf8');

                htmlContent = htmlContent.replace(
                    /(<script src="|\ssrc="|<link href=")(?!https?:\/\/)([^"]*)"/g,
                    (match, p1, p2) => {
                        const resourcePath = path.join(this.context.extensionPath, 'webview', 'dist', p2);
                        const uri = this.panel!.webview.asWebviewUri(vscode.Uri.file(resourcePath));
                        return `${p1}${uri}"`;
                    }
                );

                return htmlContent;
            }
        }
        ```
    -   **Imports**: `import { MessageRouter } from './messageRouter';`

**Acceptance Criteria:**
-   A new file `src/messageRouter.ts` exists containing the `MessageRouter` class.
-   The `WebviewManager` instantiates `MessageRouter` when a new webview panel is created.
-   The `MessageRouter` receives messages from the webview via `onDidReceiveMessage`.
-   The `MessageRouter` can send messages back to the webview via `postMessage`.

**Testing Plan:**
-   **Test Case 1**: Set a breakpoint in `MessageRouter.handleMessage`. Send a message from the webview (e.g., via browser console `vscode.postMessage({ command: 'test' })`). Verify the breakpoint is hit.
-   **Test Case 2**: Set a breakpoint in `WebviewManager.showMainPanel` after `messageRouter` is instantiated. Verify `messageRouter` is an instance of `MessageRouter`.

### User Story 2: Frontend vscodeApi Client
**As Frank, I want a** `vscodeApi` client in my SvelteKit app to abstract away the `postMessage` API, **so I can** easily communicate with the extension.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/vscodeApi.ts`
    -   **Action**: Implement the `vscodeApi` client to wrap `acquireVsCodeApi()` and handle message passing.
    -   **Implementation**:
        ```typescript
        // webview/src/lib/vscodeApi.ts

        interface VsCodeApi {
            postMessage(message: any): void;
            setState(newState: any): void;
            getState(): any;
        }

        declare const acquireVsCodeApi: () => VsCodeApi;

        const vscode = acquireVsCodeApi();

        type MessageCallback = (message: any) => void;

        const callbacks = new Map<string, MessageCallback>();
        let requestIdCounter = 0;

        window.addEventListener('message', event => {
            const message = event.data;
            if (message.requestId && callbacks.has(message.requestId)) {
                callbacks.get(message.requestId)?.(message);
                callbacks.delete(message.requestId);
            } else {
                // Handle unsolicited messages or general events
                console.log('Received unsolicited message:', message);
            }
        });

        export const vscodeApi = {
            postMessage: (command: string, payload?: any): Promise<any> => {
                const requestId = `req-${requestIdCounter++}`;
                const message = { command, requestId, payload };
                vscode.postMessage(message);

                return new Promise(resolve => {
                    callbacks.set(requestId, resolve);
                });
            },
            onMessage: (callback: MessageCallback) => {
                // This is a simplified approach for general messages. For specific command responses,
                // the postMessage promise-based approach is preferred.
                window.addEventListener('message', event => {
                    const message = event.data;
                    // Only call callback for messages not handled by requestId
                    if (!message.requestId) {
                        callback(message);
                    }
                });
            },
            getState: () => vscode.getState(),
            setState: (newState: any) => vscode.setState(newState),
        };
        ```
    -   **Imports**: None (uses global `acquireVsCodeApi` and `window`)

**Acceptance Criteria:**
-   A `webview/src/lib/vscodeApi.ts` file exists.
-   It exports a `vscodeApi` object with `postMessage` and `onMessage` methods.
-   The `postMessage` method sends messages to the extension and returns a Promise that resolves with the response.
-   The client correctly handles `requestId` for request-response pairing.
-   Svelte components can import and use `vscodeApi` for communication.

**Testing Plan:**
-   **Test Case 1**: In a Svelte component, import `vscodeApi` and call `vscodeApi.postMessage('test', { data: 'hello' })`. Verify the message is received by the extension (using a breakpoint in `MessageRouter`).
-   **Test Case 2**: From the extension, send a message back to the webview using `webview.postMessage`. Verify the `window.addEventListener('message')` in `vscodeApi.ts` receives it.

### User Story 3: End-to-End Ping Command
**As a** developer, **I want to** implement a "ping" command to verify the communication bridge, **so we can** confirm the connection is working end-to-end.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/index.ts` (or a new Svelte component)
    -   **Action**: Add a button to the Svelte UI that sends a 'ping' command.
    -   **Implementation**:
        ```html
        <!-- Example in a Svelte component (e.g., App.svelte or a new PingTest.svelte) -->
        <script lang="ts">
            import { vscodeApi } from './lib/vscodeApi';
            let responseMessage: string = '';

            async function sendPing() {
                try {
                    responseMessage = 'Sending ping...';
                    const response = await vscodeApi.postMessage('ping');
                    responseMessage = `Received: ${response.command} (requestId: ${response.requestId})`;
                } catch (error) {
                    responseMessage = `Error: ${error.message}`;
                }
            }
        </script>

        <main>
            <h1>Webview Communication Test</h1>
            <button on:click={sendPing}>Send Ping to Extension</button>
            {#if responseMessage}
                <p>{responseMessage}</p>
            {/if}
        </main>

        <style>
            /* Add some basic styling */
            main {
                font-family: sans-serif;
                padding: 20px;
            }
            button {
                padding: 10px 20px;
                font-size: 16px;
                cursor: pointer;
            }
            p {
                margin-top: 15px;
                color: green;
            }
        </style>
        ```
    -   **Imports**: `import { vscodeApi } from './lib/vscodeApi';`
2.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: Ensure the 'ping' command is handled and a 'pong' response is sent.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';

        export class MessageRouter {
            private webview: vscode.Webview;

            constructor(webview: vscode.Webview) {
                this.webview = webview;
                this.webview.onDidReceiveMessage(message => this.handleMessage(message));
            }

            private async handleMessage(message: any) {
                switch (message.command) {
                    case 'ping':
                        console.log('Received ping from webview', message.requestId);
                        // Send pong back with the same requestId
                        this.webview.postMessage({ command: 'pong', requestId: message.requestId });
                        break;
                    default:
                        console.warn('Unknown command received:', message.command);
                        break;
                }
            }

            public postMessage(message: any) {
                this.webview.postMessage(message);
            }
        }
        ```
    -   **Imports**: None (already imported)

**Acceptance Criteria:**
-   A button exists in the Svelte webview UI to send a 'ping' message.
-   Clicking the button sends a message with `command: 'ping'` and a `requestId` to the extension.
-   The extension's `MessageRouter` receives the 'ping' message and sends back a 'pong' message with the same `requestId`.
-   The Svelte UI receives the 'pong' response and displays a success message to the user.

**Testing Plan:**
-   **Test Case 1**: Run the extension, open the webview. Click the "Send Ping to Extension" button. Verify that "Received: pong" is displayed in the webview.
-   **Test Case 2**: Check the VS Code extension output channel and the webview's developer console for any errors or unexpected messages.
</file>

<file path="docs/completed/extension2/implementation_sprint_1_webview_panel_lifecycle.md">
## Implementation Guidance: Sprint 1 - Webview Panel Lifecycle

This guide provides detailed instructions and API information for implementing the Webview Panel Lifecycle sprint, focusing on creating a robust and decoupled webview management system within a VS Code extension.

### 1. Centralized Webview Panel Management (`WebviewManager`)

**Objective:** Create a `WebviewManager` class to encapsulate all logic related to the creation, display, and disposal of VS Code webview panels, thereby decoupling UI management from the main `extension.ts` file.

**Key VS Code APIs & Concepts:**

*   **`vscode.WebviewPanel`**: The core class representing a webview panel. It allows you to display HTML content within VS Code.
    *   **`vscode.window.createWebviewPanel(viewType, title, showOptions, options)`**: This static method is used to create a new webview panel.
        *   `viewType` (string): An identifier for the type of webview. Used internally by VS Code.
        *   `title` (string): The title displayed in the webview's tab.
        *   `showOptions` (`vscode.ViewColumn` or `{ viewColumn: vscode.ViewColumn, preserveFocus?: boolean }`): Specifies where the panel should be shown (e.g., `vscode.ViewColumn.One` for the first editor column).
        *   `options` (`vscode.WebviewOptions`): Configuration for the webview, including `enableScripts` (crucial for SvelteKit apps) and `localResourceRoots` (to allow loading local files).
*   **`panel.reveal(viewColumn?: vscode.ViewColumn, preserveFocus?: boolean)`**: If a panel already exists, this method brings it to the foreground.
*   **`panel.onDidDispose`**: An event that fires when the webview panel is disposed (e.g., when the user closes it). This is critical for cleaning up resources and setting the internal panel reference to `undefined` to prevent memory leaks and ensure correct behavior when the panel is reopened.
*   **`vscode.ExtensionContext`**: Provides access to the extension's environment, including `extensionPath` (the absolute path to your extension's root directory) and `subscriptions` (an array to which disposables are added for automatic cleanup on extension deactivation).

**Implementation Details:**

1.  **Singleton Pattern for `WebviewManager`**: Implement `WebviewManager` as a singleton to ensure only one instance manages the main webview panel. This is achieved by a private constructor and a static `getInstance` method.
2.  **Panel Instance Management**: The `WebviewManager` should hold a private reference to the `vscode.WebviewPanel` instance. Before creating a new panel, check if this reference exists. If it does, call `panel.reveal()` instead of creating a new one.
3.  **Disposal Handling**: Attach an `onDidDispose` listener to the created panel. Inside this listener, set the internal panel reference to `undefined`.
4.  **`localResourceRoots`**: When creating the webview panel, set `localResourceRoots` in the `WebviewOptions` to include the `webview/dist` directory. This is essential for the webview to be able to load local assets (JS, CSS, images) from your SvelteKit build output.
    *   Example: `localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]`

**File Reference:**
*   `src/webviewManager.ts` (New File)
*   `src/extension.ts` (Modification)

### 2. Load SvelteKit Build Output

**Objective:** Ensure the `WebviewManager` correctly reads the SvelteKit `index.html` and transforms its relative asset paths into VS Code webview-compatible URIs.

**Key VS Code APIs & Concepts:**

*   **`panel.webview.html`**: This property of `vscode.WebviewPanel` is where you set the HTML content to be displayed in the webview. It expects a string containing the full HTML document.
*   **`panel.webview.asWebviewUri(localResource)`**: This is a crucial method for security and functionality. It takes a `vscode.Uri` pointing to a local file (e.g., a JavaScript file, CSS file, image) and returns a special `vscode-resource:` URI that the webview can safely load. Without this, the webview cannot access local files due to security restrictions.
*   **`path` module (Node.js built-in)**: Useful for constructing file paths in a platform-independent way (e.g., `path.join`).
*   **`fs` module (Node.js built-in)**: Used for reading file content (e.g., `fs.readFileSync`).

**Implementation Details:**

1.  **Read `index.html`**: Use `fs.readFileSync` to read the content of `webview/dist/index.html`.
2.  **Path Transformation**: The SvelteKit build process typically generates `index.html` with relative paths for its assets (e.g., `<script src="/_app/immutable/start-XXXX.js">`). These paths need to be converted.
    *   Use a regular expression to find all `src` and `href` attributes that point to relative paths within your `webview/dist` directory.
    *   For each matched relative path, construct an absolute file URI using `vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist', relativePath))`.
    *   Then, convert this absolute URI to a webview-compatible URI using `this.panel.webview.asWebviewUri(absoluteUri)`.
    *   Replace the original relative path in the HTML string with the new `vscode-resource:` URI.

**Example Regex for Path Replacement:**
```javascript
htmlContent = htmlContent.replace(
    /(<script src="|\ssrc="|<link href=")(?!https?:\/\/)([^"]*)"/g,
    (match, p1, p2) => {
        const resourcePath = path.join(this.context.extensionPath, 'webview', 'dist', p2);
        const uri = this.panel!.webview.asWebviewUri(vscode.Uri.file(resourcePath));
        return `${p1}${uri}"`;
    }
);
```

**File Reference:**
*   `src/webviewManager.ts` (Modification)

### 3. Command Delegation to `CommandManager`

**Objective:** Refactor the command registration logic from `extension.ts` into a dedicated `CommandManager` class, promoting a cleaner and more modular architecture.

**Key VS Code APIs & Concepts:**

*   **`vscode.commands.registerCommand(command, callback)`**: Registers a command that can be invoked by users (e.g., via the Command Palette) or programmatically.
*   **`context.subscriptions.push(disposable)`**: All disposables (like the return value of `registerCommand`) should be added to the `context.subscriptions` array. This ensures they are automatically cleaned up when the extension is deactivated.

**Implementation Details:**

1.  **`CommandManager` Class**: Create a new class `CommandManager` that takes `vscode.ExtensionContext` and an instance of `WebviewManager` in its constructor.
2.  **`registerCommands` Method**: This method will contain all the `vscode.commands.registerCommand` calls. Instead of directly calling `webviewManager.showMainPanel()`, it will call `this.webviewManager.showMainPanel()`.
3.  **`extension.ts` Refactor**: In `activate`, instantiate `WebviewManager` first, then pass its instance to the `CommandManager` constructor. Call `commandManager.registerCommands()`.
4.  **Remove Direct Registration**: Ensure that the direct `vscode.commands.registerCommand` call for `code-context-engine.openMainPanel` is removed from `extension.ts`.

**File Reference:**
*   `src/commandManager.ts` (New File)
*   `src/extension.ts` (Modification)
</file>

<file path="docs/completed/extension2/prd.md">
<prd>Of course. Connecting the webview frontend to the main extension is a critical step. Based on your request and the existing codebase, I've created a series of PRDs to establish this communication layer robustly.

This plan focuses on creating a clean, decoupled architecture where `extension.ts` acts as an orchestrator, delegating specific responsibilities like webview management and message handling to dedicated classes.

-----

### **New Document: PRD 1: Foundational - Webview Panel Management**

**1. Title & Overview**

  * **Project:** Code Context Engine - Webview Management
  * **Summary:** This phase focuses on creating a centralized and reusable system for managing the lifecycle of the extension's webview panels. We will create a `WebviewManager` class responsible for creating, showing, and disposing of the main panel and any future panels (like settings). This will decouple all UI panel logic from the main `extension.ts` file.
  * **Dependencies:** The SvelteKit project must have a build process that outputs to the `webview/dist` directory.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Establish a stable and reliable foundation for the extension's user interface.
      * Improve developer efficiency by making the process of adding or managing UI panels predictable and straightforward.
  * **Developer & System Success Metrics:**
      * The `WebviewManager` successfully creates and displays the SvelteKit application within a VS Code panel.
      * All logic for reading `index.html` and rewriting asset paths with `asWebviewUri` is contained within the `WebviewManager`.
      * The extension can open the main panel via a command, and attempting to open it again simply reveals the existing panel.
      * The panel and its resources are properly disposed of when closed by the user or when the extension is deactivated.

-----

**3. User Personas**

  * **Frank (Frontend Developer):** Frank needs a consistent way for the extension to load his SvelteKit application. He shouldn't have to worry about the complexities of the VS Code API; he just needs his built application to be displayed correctly.
  * **Alisha (Backend Developer):** Alisha needs to trigger UI panels from commands. She wants a simple API call (e.g., `webviewManager.showMainPanel()`) to show the UI without needing to manage the panel's state or creation logic herself.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Webview** | **Sprint 1: Webview Panel Lifecycle** | As Alisha, I want a `WebviewManager` class to handle the creation and disposal of webview panels, so that UI logic is centralized and decoupled from `extension.ts`. | 1. A new `WebviewManager.ts` file and class are created.\<br/\>2. The class has a method `showMainPanel()` that creates a `vscode.WebviewPanel`.\<br/\>3. The manager ensures only one instance of the main panel can exist at a time.\<br/\>4. The manager correctly handles the `onDidDispose` event to clean up its reference to the panel. | **2 Weeks** |
| | | As Frank, I want the `WebviewManager` to correctly load the SvelteKit build output, so my application renders properly inside VS Code. | 1. The `WebviewManager` contains a private method to read the `index.html` from `webview/dist`.\<br/\>2. This method correctly replaces relative asset paths (e.g., `/_app/`) with the special `webview.asWebviewUri` format.\<br/\>3. The `showMainPanel()` method uses this helper to set the panel's HTML content. | |
| | | As a developer, I want the main panel command to be handled by the `CommandManager`, which delegates to the `WebviewManager`. | 1. The `CommandManager` has a command for `code-context-engine.openMainPanel`.\<br/\>2. The command's callback invokes `extensionManager.webviewManager.showMainPanel()`.\<br/\>3. The `extension.ts` file no longer contains any direct panel creation logic. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 1:** Webview Panel Lifecycle & Content Loading (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The SvelteKit build output path (`webview/dist`) is stable and predictable.
  * **Risk:** Incorrectly rewriting the asset paths in `index.html` will cause the SvelteKit app to fail to load its CSS or JavaScript, resulting in a blank panel.
      * **Mitigation:** Create a robust regular expression to handle the path replacement and thoroughly test that all assets load correctly in the webview's developer tools.
  * **Risk:** Forgetting to handle the `onDidDispose` event will lead to memory leaks and buggy behavior where the extension thinks a panel is open when it isn't.
      * **Mitigation:** Ensure that the panel reference within the `WebviewManager` is set to `undefined` within the `onDidDispose` callback.

-----

### **New Document: PRD 2: Core - Bidirectional Message Passing**

**1. Title & Overview**

  * **Project:** Code Context Engine - Webview Communication Bridge
  * **Summary:** This phase focuses on establishing a robust, type-safe, and decoupled communication channel between the SvelteKit webview (frontend) and the extension host (backend). We will create a `MessageRouter` class on the backend and a `vscodeApi` client on the frontend to standardize how messages are sent and received.
  * **Dependencies:** PRD 1 must be complete. The `WebviewManager` must be able to successfully display the SvelteKit application.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Enable core application functionality by creating a reliable data channel between the UI and the backend logic.
      * Improve developer experience by providing a simple and predictable API for frontend-backend communication.
  * **Developer & System Success Metrics:**
      * A `MessageRouter` class successfully replaces the `switch` statement for message handling.
      * The frontend `vscodeApi` client can successfully send a message to the extension and receive a response.
      * A defined message structure (e.g., with `command`, `requestId`, `payload`) is used for all communication.
      * An end-to-end "ping-pong" test (UI sends "ping", backend responds with "pong") works correctly, validating the entire communication pipeline.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Comms** | **Sprint 2: Message Routing & API** | As a developer, I want a `MessageRouter` class in the backend to handle all incoming webview messages, so that communication logic is centralized and testable. | 1. A new `MessageRouter.ts` file and class are created.\<br/\>2. The `WebviewManager` instantiates the `MessageRouter` for each panel it creates, passing it the webview instance.\<br/\>3. The `onDidReceiveMessage` listener in `WebviewManager` delegates directly to the `MessageRouter`.\<br/\>4. The `MessageRouter` contains the `switch` logic to route commands to the appropriate services. | **2 Weeks** |
| | | As Frank, I want a `vscodeApi` client in my SvelteKit app to abstract away the `postMessage` API, so I can easily communicate with the extension. | 1. A `vscodeApi.ts` file is created in the `webview` project.\<br/\>2. It exports functions like `postMessage` and `onMessage` that wrap the native `acquireVsCodeApi()` methods.\<br/\>3. The client includes logic to handle request-response pairs using a `requestId`.\<br/\>4. Svelte components import and use this client instead of the global `vscode` API directly. | |
| | | As a developer, I want to implement a "ping" command to verify the communication bridge, so we can confirm the connection is working end-to-end. | 1. The Svelte UI has a test button that, when clicked, sends a `{ command: 'ping' }` message via the `vscodeApi` client.\<br/\>2. The `MessageRouter` has a `case` for "ping" that immediately sends back a `{ command: 'pong' }` message.\<br/\>3. The Svelte UI listens for the "pong" message and displays a success notification to the user. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 2:** Message Routing & API Implementation (2 Weeks)

This completes the PRDs for establishing the connection between the webview and `extension.ts`. You now have a clear plan to build a robust and maintainable foundation for all UI-to-backend communication.</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/completed/fe/backlog_sprint_1_setup_view_implementation.md">
# Backlog: Sprint 1 - Setup View Implementation

**Objective:** To build the complete user onboarding and setup UI within the VS Code extension's webview. This view is the user's first interaction and must clearly guide them through configuring the necessary database and embedding providers for a new, un-indexed repository.

---

### User Story 1: Display Initial Setup Screen

**As a** new user (Devin), **I want to** see a clear setup screen when I open an un-indexed project, **so that** I know what I need to do to get started.

**Workflow:**
1.  The extension's activation logic checks if a `code-context.json` file exists in the root of the opened workspace.
2.  If the file does not exist, the extension opens a new Webview panel displaying the `SetupView`.
3.  The `SetupView` component renders the primary UI structure.

**Codebase Review:**
*   `src/extension.ts`: Will need modification to add the file check and the command to launch the webview.
*   `webview/`: This directory is currently empty. The entire SvelteKit application will be created here.

**File Changes:**
*   `src/extension.ts`: Modify `activate` function.
*   `webview/src/+page.svelte` (New File): To be created as the main `SetupView` component.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    *   **Action**: On activation, check for the existence of `code-context.json` in the workspace root.
    *   **Implementation**: Use `vscode.workspace.findFiles('code-context.json')` to check for the file. If the result is empty, set a context key like `code-context.isConfigured: false`.
    *   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `package.json`
    *   **Action**: Add a `when` clause to the `viewsWelcome` contribution point to show a welcome view with a "Setup Project" button only when `!code-context.isConfigured`.
    *   **Implementation**:
        ```json
        "contributes": {
          "viewsWelcome": [
            {
              "view": "explorer",
              "contents": "Welcome to Code Context! [Setup Project](command:code-context.setup)\n",
              "when": "!code-context.isConfigured"
            }
          ]
        }
        ```
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Register a command `code-context.setup` that creates and shows a new webview panel.
    *   **Implementation**: Use `vscode.window.createWebviewPanel` to create the panel. The panel should load the SvelteKit build output.
    *   **Imports**: `import * as path from 'path';`, `import * as fs from 'fs';`
4.  **Filepath**: `webview/src/+page.svelte` (New File)
    *   **Action**: Create the main Svelte component for the setup view.
    *   **Implementation**:
        ```html
        <script>
          import DatabaseSetup from '$lib/components/DatabaseSetup.svelte';
          import EmbeddingSetup from '$lib/components/EmbeddingSetup.svelte';
        </script>
        <h1>Code Context Setup</h1>
        <DatabaseSetup />
        <EmbeddingSetup />
        ```
    *   **Imports**: None.

**Acceptance Criteria:**
-   When a project without `code-context.json` is opened, a welcome view in the explorer prompts the user to set up the project.
-   Running the setup command opens a webview titled "Code Context Setup".
-   The view contains distinct sections for "Database Configuration" and "Embedding Provider".
-   The primary call-to-action button ("Index Now") is initially disabled.

---

### User Story 2: Configure Vector Database

**As a** new user (Devin), **I want to** select my desired vector database and get help starting it if it's not running, **so that** my code can be indexed.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte` (New File)
    *   **Action**: Create a Svelte component for database configuration.
    *   **Implementation**: Include a Fluent UI `<Select>` for "Qdrant" and a `<Button>` labeled "Start Local Qdrant".
    *   **Imports**: `import { Select, Button } from '@svelte-fui/core';`
2.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Implement the button's `on:click` handler to send a message to the VS Code extension host.
    *   **Implementation**: `vscode.postMessage({ command: 'startDatabase' });`
    *   **Imports**: None.
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Add a message listener to the webview panel to handle the `startDatabase` command.
    *   **Implementation**: The listener will execute `docker-compose up` in a new VS Code terminal.
    *   **Implementation**: `const terminal = vscode.window.createTerminal('Qdrant'); terminal.sendText('docker-compose up'); terminal.show();`
    *   **Imports**: `import * as vscode from 'vscode';`
4.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Display a status icon that changes from "Not Running" to "Running" based on a message from the backend.
    *   **Implementation**: The extension backend will perform a health check and `postMessage` to the webview with the status.
    *   **Imports**: None.

**Acceptance Criteria:**
-   A dropdown allows selecting "Qdrant".
-   Clicking "Start Local Qdrant" opens a new terminal and runs `docker-compose up`.
-   A status indicator correctly reflects the database's running status after a health check from the backend.

---

### User Story 3: Configure Embedding Provider

**As a** new user (Devin), **I want to** choose which embedding model to use for indexing my code, **so that** the context is generated accurately.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/EmbeddingSetup.svelte` (New File)
    *   **Action**: Create a Svelte component for embedding provider selection.
    *   **Implementation**: Use a Fluent UI `<Select>` with options "Ollama" and "OpenAI".
    *   **Imports**: `import { Select } from '@svelte-fui/core';`
2.  **Filepath**: `webview/src/lib/stores/setupStore.ts` (New File)
    *   **Action**: Create a Svelte writable store to manage the setup state.
    *   **Implementation**: `export const setupState = writable({ databaseReady: false, providerSelected: null });`
    *   **Imports**: `import { writable } from 'svelte/store';`
3.  **Filepath**: `webview/src/+page.svelte`
    *   **Action**: Create the main "Index Now" button. Its `disabled` attribute should be reactively bound to the store's state.
    *   **Implementation**: `<Button disabled={!$setupState.databaseReady || !$setupState.providerSelected}>Index Now</Button>`
    *   **Imports**: `import { Button } from '@svelte-fui/core';`, `import { setupState } from '$lib/stores/setupStore';`
4.  **Filepath**: `webview/src/+page.svelte`
    *   **Action**: When clicked, the "Index Now" button sends the selected configuration to the extension backend.
    *   **Implementation**: `vscode.postMessage({ command: 'startIndexing', config: $setupState });`
    *   **Imports**: None.

**Acceptance Criteria:**
-   A dropdown allows selecting "Ollama" or "OpenAI".
-   The "Index Now" button is enabled only after the database is running and an embedding provider is selected.
-   Clicking the button sends the chosen configuration to the extension backend.

**Testing Plan:**
-   **Manual Test Case 1**: Open a project without `code-context.json`. Verify the welcome view appears.
-   **Manual Test Case 2**: Click the setup button. Verify the webview opens.
-   **Manual Test Case 3**: Click "Start Local Qdrant". Verify a terminal opens and runs the command.
-   **Manual Test Case 4**: Select an embedding provider. Verify the "Index Now" button becomes enabled once the DB is "running".
-   **Manual Test Case 5**: Click "Index Now" and verify the configuration is sent to the extension (check debugger).
</file>

<file path="docs/completed/fe/backlog_sprint_1_web_api_boilerplate.md">
### User Story 1: Create C# Web API Foundation
**As Alisha, I want to** create a new ASP.NET Core Web API project, **so that** we have the foundational service for our backend logic.

**Actions to Undertake:**
1.  **Filepath**: `(Project Root)`
    -   **Action**: Create a new .NET solution and three projects: `CodeContext.Api` (webapi), `CodeContext.Core` (classlib), and `CodeContext.Infrastructure` (classlib).
    -   **Implementation**:
        ```bash
        dotnet new sln -n CodeContext
        dotnet new webapi -n CodeContext.Api -o CodeContext.Api
        dotnet new classlib -n CodeContext.Core -o CodeContext.Core
        dotnet new classlib -n CodeContext.Infrastructure -o CodeContext.Infrastructure
        dotnet sln CodeContext.sln add CodeContext.Api/CodeContext.Api.csproj
        dotnet sln CodeContext.sln add CodeContext.Core/CodeContext.Core.csproj
        dotnet sln CodeContext.sln add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Api/CodeContext.Api.csproj`
    -   **Action**: Add project references from `CodeContext.Api` to `CodeContext.Core` and `CodeContext.Infrastructure`.
    -   **Implementation**:
        ```xml
        <ItemGroup>
            <ProjectReference Include="..\CodeContext.Core\CodeContext.Core.csproj" />
            <ProjectReference Include="..\CodeContext.Infrastructure\CodeContext.Infrastructure.csproj" />
        </ItemGroup>
        ```
    -   **Imports**: None.
3.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Implement a basic `/health` endpoint using minimal API syntax.
    -   **Implementation**:
        ```csharp
        app.MapGet("/health", () => Results.Ok());
        ```
    -   **Imports**: `using Microsoft.AspNetCore.Builder;` (already there)
4.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Add Swagger/OpenAPI support.
    -   **Implementation**:
        ```csharp
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();
        // ...
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }
        ```
    -   **Imports**: `using Microsoft.OpenApi.Models;` (not directly in Program.cs, but implicitly used by AddSwaggerGen)
5.  **Filepath**: `CodeContext.Core/`
    -   **Action**: Create placeholder interfaces `IEmbeddingProvider.cs` and `IVectorDatabaseClient.cs` in the `CodeContext.Core` project.
    -   **Implementation**:
        ```csharp
        // CodeContext.Core/IEmbeddingProvider.cs
        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                // Placeholder for future methods
            }
        }

        // CodeContext.Core/IVectorDatabaseClient.cs
        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                // Placeholder for future methods
            }
        }
        ```
    -   **Imports**: None.
6.  **Filepath**: `CodeContext.Infrastructure/`
    -   **Action**: Create placeholder folders `DatabaseClients` and `EmbeddingProviders` in the `CodeContext.Infrastructure` project.
    -   **Implementation**: (This is a folder creation, not code. I'll describe it.)
        ```
        (Create directory CodeContext.Infrastructure/DatabaseClients)
        (Create directory CodeContext.Infrastructure/EmbeddingProviders)
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   A new .NET solution is created containing `CodeContext.Api`, `CodeContext.Core`, and `CodeContext.Infrastructure` projects.
-   The `CodeContext.Api` project correctly references `CodeContext.Core` and `CodeContext.Infrastructure`.
-   A basic `/health` endpoint is accessible and returns a `200 OK` status.
-   Swagger/OpenAPI documentation is available and functional.
-   Placeholder interfaces `IEmbeddingProvider` and `IVectorDatabaseClient` exist in `CodeContext.Core`.
-   Placeholder folders `DatabaseClients` and `EmbeddingProviders` exist in `CodeContext.Infrastructure`.

**Testing Plan:**
-   **Test Case 1**: Run `dotnet build CodeContext.sln` to ensure all projects build successfully.
-   **Test Case 2**: Navigate to the `CodeContext.Api` directory and run `dotnet run`. Verify the API starts without errors.
-   **Test Case 3**: Access `http://localhost:<port>/health` in a browser or via `curl` and confirm a `200 OK` response.
-   **Test Case 4**: Access `http://localhost:<port>/swagger` in a browser and confirm the Swagger UI loads correctly.
</file>

<file path="docs/completed/fe/backlog_sprint_2_extensible_client_framework.md">
### User Story 1: Define Abstract Interfaces for Clients
**As Alisha, I want to** define abstract interfaces for database clients and embedding providers, **so that** we can easily add new implementations in the future.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/IEmbeddingProvider.cs`
    -   **Action**: Add `GenerateEmbeddingsAsync` method to `IEmbeddingProvider` interface.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts);
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`
2.  **Filepath**: `CodeContext.Core/IVectorDatabaseClient.cs`
    -   **Action**: Add `UpsertAsync` and `QueryAsync` methods to `IVectorDatabaseClient` interface.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                Task UpsertAsync(string collectionName, List<VectorData> vectors);
                Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK);
            }

            public class VectorData
            {
                public string Id { get; set; }
                public float[] Vector { get; set; }
                public Dictionary<string, object> Payload { get; set; }
            }

            public class QueryResult
            {
                public string Id { get; set; }
                public double Score { get; set; }
                public Dictionary<string, object> Payload { get; set; }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`

### User Story 2: Implement Dependency Injection for Clients
**As Alisha, I want to** use dependency injection to register and resolve these clients, **so that** the application is loosely coupled and testable.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Configure .NET's built-in dependency injection container.
    -   **Implementation**: (This is more about how to use DI, not a specific code snippet to add, but rather how to register services. I'll provide a conceptual example.)
        ```csharp
        // Example: Registering a concrete implementation (will be done in later sprints)
        // builder.Services.AddSingleton<IEmbeddingProvider, OllamaProvider>();
        // builder.Services.AddSingleton<IVectorDatabaseClient, QdrantClient>();
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Core/ClientFactory.cs` (New File)
    -   **Action**: Create a `ClientFactory` or `ClientStrategy` service that can resolve the correct client implementation based on a configuration string.
    -   **Implementation**:
        ```csharp
        using System;
        using Microsoft.Extensions.DependencyInjection;

        namespace CodeContext.Core
        {
            public class ClientFactory
            {
                private readonly IServiceProvider _serviceProvider;

                public ClientFactory(IServiceProvider serviceProvider)
                {
                    _serviceProvider = serviceProvider;
                }

                public IEmbeddingProvider GetEmbeddingProvider(string providerType)
                {
                    return providerType.ToLowerInvariant() switch
                    {
                        "ollama" => _serviceProvider.GetRequiredService<OllamaProvider>(), // Concrete type will be registered
                        _ => throw new ArgumentException($"Unknown embedding provider type: {providerType}")
                    };
                }

                public IVectorDatabaseClient GetVectorDatabaseClient(string clientType)
                {
                    return clientType.ToLowerInvariant() switch
                    {
                        "qdrant" => _serviceProvider.GetRequiredService<QdrantClient>(), // Concrete type will be registered
                        _ => throw new ArgumentException($"Unknown vector database client type: {clientType}")
                    };
                }
            }
        }
        ```
    -   **Imports**: `using System;`, `using Microsoft.Extensions.DependencyInjection;`
3.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Register the `ClientFactory` with the DI container.
    -   **Implementation**:
        ```csharp
        builder.Services.AddSingleton<ClientFactory>();
        ```
    -   **Imports**: `using CodeContext.Core;`

**Acceptance Criteria:**
-   `IEmbeddingProvider` interface in `CodeContext.Core` includes `GenerateEmbeddingsAsync(List<string> texts)` method.
-   `IVectorDatabaseClient` interface in `CodeContext.Core` includes `UpsertAsync(string collectionName, List<VectorData> vectors)` and `QueryAsync(string collectionName, float[] vector, int topK)` methods, along with `VectorData` and `QueryResult` classes.
-   .NET's built-in dependency injection container is configured to allow registration and resolution of these interfaces.
-   A `ClientFactory` class exists in `CodeContext.Core` that can resolve client implementations based on a string.
-   The `ClientFactory` is registered with the DI container.
-   Unit tests (to be written in a separate test project) verify that the correct client is returned for a given configuration.

**Testing Plan:**
-   **Test Case 1**: (Conceptual, as concrete implementations are not yet present) Verify that the `IEmbeddingProvider` and `IVectorDatabaseClient` interfaces compile without errors.
-   **Test Case 2**: (Conceptual) Write a simple console application or a unit test project that attempts to resolve `ClientFactory` from the DI container and then calls its `GetEmbeddingProvider` and `GetVectorDatabaseClient` methods with dummy strings (e.g., "ollama", "qdrant") to ensure it compiles and the factory logic is sound (it will throw exceptions until concrete types are registered).
-   **Test Case 3**: (Conceptual) Ensure the `VectorData` and `QueryResult` classes are correctly defined and accessible.
</file>

<file path="docs/completed/fe/backlog_sprint_3_backend_process_management.md">
### User Story 1: Auto-Start C# Backend Service
**As a** developer, **I want the** VS Code extension to automatically start the C# backend service when the extension is activated, **so that** I don't have to run it manually.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts` (Assuming this is the main extension file)
    -   **Action**: Implement logic to spawn the C# backend executable using `child_process.spawn`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
        import * as path from 'path';

        let backendProcess: ChildProcessWithoutNullStreams | null = null;

        export function activate(context: vscode.ExtensionContext) {
            console.log('Code Context extension is now active!');

            // Determine the path to the C# backend executable
            // This path will depend on your build process and where the executable is placed.
            // Example: Assuming it's in a 'bin' folder relative to the extension root
            const backendExecutablePath = path.join(context.extensionPath, 'bin', 'CodeContext.Api'); // Adjust as needed

            backendProcess = spawn(backendExecutablePath, [], {
                cwd: path.dirname(backendExecutablePath), // Run from the executable's directory
                stdio: ['ignore', 'pipe', 'pipe'] // Ignore stdin, pipe stdout/stderr
            });

            backendProcess.stdout.on('data', (data) => {
                console.log(`Backend stdout: ${data}`);
                // You might want to log this to an output channel in VS Code
            });

            backendProcess.stderr.on('data', (data) => {
                console.error(`Backend stderr: ${data}`);
                // Log errors to an output channel
            });

            backendProcess.on('close', (code) => {
                console.log(`Backend process exited with code ${code}`);
                backendProcess = null;
                // Handle process exit, e.g., attempt restart or notify user
            });

            backendProcess.on('error', (err) => {
                console.error('Failed to start backend process:', err);
                vscode.window.showErrorMessage(`Failed to start Code Context backend: ${err.message}`);
                backendProcess = null;
            });

            // Add a disposable to ensure process is killed on deactivate
            context.subscriptions.push({
                dispose: () => {
                    if (backendProcess) {
                        console.log('Terminating backend process...');
                        backendProcess.kill(); // Send SIGTERM
                        backendProcess = null;
                    }
                }
            });
        }

        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill();
                backendProcess = null;
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { spawn, ChildProcessWithoutNullStreams } from 'child_process';`, `import * as path from 'path';`
2.  **Filepath**: `extension.ts`
    -   **Action**: Ensure the child process is terminated when the extension is deactivated.
    -   **Implementation**: (Included in the `activate` and `deactivate` functions above)
        ```typescript
        // In activate:
        context.subscriptions.push({
            dispose: () => {
                if (backendProcess) {
                    console.log('Terminating backend process...');
                    backendProcess.kill();
                    backendProcess = null;
                }
            }
        });

        // In deactivate:
        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill();
                backendProcess = null;
            }
        }
        ```
    -   **Imports**: None.

### User Story 2: Monitor Backend Service Health
**As a** developer, **I want the** extension to monitor the health of the C# backend service, **so that** it can reliably send API requests.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts`
    -   **Action**: Periodically send HTTP GET requests to the backend's `/health` endpoint.
    -   **Implementation**:
        ```typescript
        // Inside activate function, after spawning backendProcess
        const backendPort = 5000; // Or read from configuration
        const healthCheckInterval = 5000; // 5 seconds
        let healthCheckAttempts = 0;
        const maxHealthCheckAttempts = 10;
        let healthCheckTimer: NodeJS.Timeout | null = null;

        function startHealthCheck() {
            if (healthCheckTimer) {
                clearInterval(healthCheckTimer);
            }
            healthCheckTimer = setInterval(async () => {
                if (!backendProcess) {
                    console.log('Backend process not running, stopping health check.');
                    clearInterval(healthCheckTimer!);
                    return;
                }

                try {
                    const response = await fetch(`http://localhost:${backendPort}/health`);
                    if (response.ok) {
                        console.log('Backend is healthy.');
                        healthCheckAttempts = 0;
                        // Update UI state to "Running"
                        // vscode.window.showInformationMessage('Code Context Backend is Running!');
                        // If you have a webview, send a message to it
                        // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'running' });
                    } else {
                        console.warn(`Backend health check failed: ${response.status}`);
                        healthCheckAttempts++;
                        // Update UI state to "Starting" or "Error"
                        // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'starting' });
                        if (healthCheckAttempts >= maxHealthCheckAttempts) {
                            console.error('Max health check attempts reached. Attempting to restart backend.');
                            clearInterval(healthCheckTimer!);
                            restartBackend(); // Implement this function
                        }
                    }
                } catch (error) {
                    console.error('Error during backend health check:', error);
                    healthCheckAttempts++;
                    // Update UI state to "Error"
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'error' });
                    if (healthCheckAttempts >= maxHealthCheckAttempts) {
                        console.error('Max health check attempts reached. Attempting to restart backend.');
                        clearInterval(healthCheckTimer!);
                        restartBackend(); // Implement this function
                    }
                }
            }, healthCheckInterval);
        }

        function restartBackend() {
            if (backendProcess) {
                backendProcess.kill();
                backendProcess = null;
            }
            console.log('Restarting backend process...');
            // Re-call the spawn logic from activate, or a dedicated function
            // For simplicity, let's assume activate handles it, or create a startBackend function
            // startBackend(); // Call a function that encapsulates the spawning logic
            // For now, just log and let the user know
            vscode.window.showWarningMessage('Code Context Backend is restarting due to health check failures.');
            // In a real scenario, you'd re-run the spawn logic here.
            // For this backlog, we'll assume a simple restart mechanism.
            activate(context); // This is a simplified restart, might need more robust logic
        }

        // Call this after backendProcess is successfully spawned
        startHealthCheck();
        ```
    -   **Imports**: `import fetch from 'node-fetch';` (or `import { fetch } from 'undici';` for Node.js 18+)
2.  **Filepath**: `extension.ts`
    -   **Action**: Implement logic to restart the backend if health checks consistently fail.
    -   **Implementation**: (Included in the `startHealthCheck` and `restartBackend` functions above)
    -   **Imports**: None.

**Acceptance Criteria:**
-   The VS Code extension successfully launches the C# backend executable upon activation.
-   `stdout` and `stderr` from the backend process are captured and logged (e.g., to VS Code's output channel).
-   The backend process is reliably terminated when the extension is deactivated or VS Code is closed.
-   The extension periodically pings the backend's `/health` endpoint.
-   The extension can detect when the backend is unhealthy and attempts to restart it after a configurable number of failures.
-   (Implicit) The UI (webview) can receive status updates about the backend's health (e.g., "Starting", "Running", "Error").

**Testing Plan:**
-   **Test Case 1**: Activate the extension and verify that the C# backend process starts (check task manager/process list).
-   **Test Case 2**: Deactivate the extension and verify that the C# backend process is terminated.
-   **Test Case 3**: Introduce a deliberate error in the C# backend's `/health` endpoint (e.g., make it return 500) and observe if the extension attempts to restart the backend after multiple failures.
-   **Test Case 4**: Verify that backend `stdout` and `stderr` messages appear in the VS Code output channel (if implemented).
-   **Test Case 5**: (Manual) Observe the UI state changes (if a basic UI is already present) reflecting the backend's status.
</file>

<file path="docs/completed/fe/backlog_sprint_4_onboarding_setup_ui.md">
### User Story 1: Display Setup/Query UI Based on Index Status
**As Devin, when I open a new project, I want the** extension to check if it's been indexed and show me a setup screen if it hasn't.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts`
    -   **Action**: Check for the existence of `.vscode/code-context.json` on extension activation.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';

        // ... (existing imports and backend process management logic) ...

        export function activate(context: vscode.ExtensionContext) {
            // ... (existing backend process spawning and health check setup) ...

            // Create and show the webview panel
            const panel = vscode.window.createWebviewPanel(
                'codeContext', // Identifies the type of the webview
                'Code Context', // Title of the panel displayed to the user
                vscode.ViewColumn.One, // Editor column to show the new webview panel in
                {
                    enableScripts: true, // Enable JavaScript in the webview
                    localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                }
            );

            // Get path to SvelteKit build output
            const svelteAppPath = path.join(context.extensionPath, 'webview', 'dist', 'index.html');
            panel.webview.html = fs.readFileSync(svelteAppPath, 'utf8');

            // Check for code-context.json
            const workspaceFolders = vscode.workspace.workspaceFolders;
            let configFilePath: string | undefined;
            if (workspaceFolders && workspaceFolders.length > 0) {
                configFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'code-context.json');
            }

            let initialView: 'setup' | 'query' = 'setup';
            if (configFilePath && fs.existsSync(configFilePath)) {
                initialView = 'query';
            }

            // Send initial view state to webview
            panel.webview.postMessage({ type: 'initialView', view: initialView });

            // Handle messages from the webview
            panel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showInformationMessage(message.text);
                            return;
                        case 'startDocker':
                            // Handle Docker command execution
                            handleStartDockerCommand(message.service, context);
                            return;
                        // ... other commands
                    }
                },
                undefined,
                context.subscriptions
            );

            // Add panel to disposables
            context.subscriptions.push(panel);
        }

        // ... (deactivate function) ...
        ```
    -   **Imports**: `import * as fs from 'fs';`
2.  **Filepath**: `webview/src/lib/stores/viewStore.ts` (New File)
    -   **Action**: Create a Svelte store to manage the current view state (`'setup'` or `'query'`).
    -   **Implementation**:
        ```typescript
        import { writable } from 'svelte/store';

        export const currentView = writable<'setup' | 'query'>('setup'); // Default to setup
        ```
    -   **Imports**: `import { writable } from 'svelte/store';`
3.  **Filepath**: `webview/src/App.svelte` (Main Svelte component)
    -   **Action**: Render `SetupView.svelte` or `QueryView.svelte` based on the `currentView` store.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';

            onMount(() => {
                // Listen for messages from the VS Code extension
                window.addEventListener('message', event => {
                    const message = event.data; // The JSON data that the extension sent
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        // ... handle other messages like backend status
                    }
                });
            });
        </script>

        {#if $currentView === 'setup'}
            <SetupView />
        {:else if $currentView === 'query'}
            <QueryView />
        {/if}
        ```
    -   **Imports**: `import { onMount } from 'svelte';`, `import { currentView } from './lib/stores/viewStore';`, `import SetupView from './lib/components/SetupView.svelte';`, `import QueryView from './lib/components/QueryView.svelte';`

### User Story 2: Implement Setup UI with Docker Helper
**As Devin, I want the** setup screen to let me choose my database and embedding provider, with helper buttons to start any required local services.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/SetupView.svelte` (New File)
    -   **Action**: Create the Svelte component for the setup view with dropdowns for database/embedding provider and a "Start Local" button.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { createEventDispatcher } from 'svelte';
            import { postMessageToVsCode } from '../utils/vscode'; // Helper to send messages to extension

            const dispatch = createEventDispatcher();

            let selectedDatabase: string = 'qdrant'; // Default
            let selectedEmbeddingProvider: string = 'ollama'; // Default

            function handleStartLocalService(service: string) {
                postMessageToVsCode('startDocker', { service });
            }

            function handleSaveAndIndex() {
                // Send configuration to extension to save and trigger indexing
                postMessageToVsCode('saveConfigAndIndex', {
                    database: selectedDatabase,
                    embeddingProvider: selectedEmbeddingProvider
                });
            }
        </script>

        <div class="setup-container">
            <h1>Setup Code Context</h1>

            <section>
                <h2>Database Configuration</h2>
                <label for="database-select">Select Database:</label>
                <select id="database-select" bind:value={selectedDatabase}>
                    <option value="qdrant">Qdrant (Local)</option>
                    <!-- Add other options later -->
                </select>
                <button on:click={() => handleStartLocalService('qdrant')}>Start Local Qdrant</button>
                <!-- Add status indicator here -->
            </section>

            <section>
                <h2>Embedding Provider Configuration</h2>
                <label for="embedding-select">Select Embedding Provider:</label>
                <select id="embedding-select" bind:value={selectedEmbeddingProvider}>
                    <option value="ollama">Ollama (Local)</option>
                    <!-- Add other options later -->
                </select>
                <button on:click={() => handleStartLocalService('ollama')}>Start Local Ollama</button>
                <!-- Add status indicator here -->
            </section>

            <button on:click={handleSaveAndIndex}>Save & Index</button>
        </div>

        <style>
            /* Basic styling for layout */
            .setup-container {
                padding: 20px;
                font-family: sans-serif;
            }
            section {
                margin-bottom: 20px;
                border: 1px solid #ccc;
                padding: 15px;
                border-radius: 5px;
            }
            label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            select, button {
                margin-right: 10px;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid #ddd;
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                cursor: pointer;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
        </style>
        ```
    -   **Imports**: `import { createEventDispatcher } from 'svelte';`, `import { postMessageToVsCode } from '../utils/vscode';`
2.  **Filepath**: `webview/src/lib/utils/vscode.ts` (New File)
    -   **Action**: Create a utility function to send messages from the Svelte webview to the VS Code extension.
    -   **Implementation**:
        ```typescript
        // This is how you send messages from the webview to the extension
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        export function postMessageToVsCode(command: string, data: any) {
            vscode.postMessage({ command, ...data });
        }
        ```
    -   **Imports**: None (uses `declare const acquireVsCodeApi: any;` for VS Code API)
3.  **Filepath**: `extension.ts`
    -   **Action**: Implement `handleStartDockerCommand` to open a new VS Code terminal and run `docker-compose` commands.
    -   **Implementation**:
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        function handleStartDockerCommand(service: string, context: vscode.ExtensionContext) {
            let command: string;
            let terminalName: string;

            switch (service) {
                case 'qdrant':
                    command = 'docker-compose -f docker-compose.qdrant.yml up -d'; // Assuming a docker-compose file
                    terminalName = 'Qdrant Docker';
                    break;
                case 'ollama':
                    command = 'docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama'; // Example Ollama command
                    terminalName = 'Ollama Docker';
                    break;
                default:
                    vscode.window.showErrorMessage(`Unknown service to start: ${service}`);
                    return;
            }

            const terminal = vscode.window.createTerminal(terminalName);
            terminal.show();
            terminal.sendText(command);

            // Optional: You might want to poll for service health after starting Docker
            // and send a message back to the webview to update status.
            // For this backlog, we'll assume the command execution is sufficient.
        }
        ```
    -   **Imports**: None.
4.  **Filepath**: `webview/src/lib/components/QueryView.svelte` (New File)
    -   **Action**: Create a placeholder Svelte component for the query view.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            // Placeholder for future query functionality
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <p>Your code is indexed. Query functionality will be available here soon!</p>
            <!-- Future: input box, results display -->
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: sans-serif;
            }
        </style>
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   On extension activation, the webview panel is displayed.
-   If `.vscode/code-context.json` does not exist in the workspace root, the `SetupView` component is rendered.
-   If `.vscode/code-context.json` exists, the `QueryView` component is rendered.
-   The `SetupView` contains dropdowns for selecting database and embedding provider.
-   "Start Local" buttons are present next to the selections.
-   Clicking a "Start Local" button opens a new VS Code terminal and executes the corresponding Docker command.
-   (Implicit) The UI can receive and display status updates (e.g., "Running") for the Docker services.

**Testing Plan:**
-   **Test Case 1**: Start VS Code with an empty workspace (no `.vscode/code-context.json`). Verify the `SetupView` is displayed.
-   **Test Case 2**: Create an empty `.vscode/code-context.json` file in the workspace root. Restart VS Code. Verify the `QueryView` is displayed.
-   **Test Case 3**: In `SetupView`, click the "Start Local Qdrant" button. Verify a new terminal opens and the `docker-compose` command is executed.
-   **Test Case 4**: In `SetupView`, click the "Start Local Ollama" button. Verify a new terminal opens and the `docker run` command is executed.
-   **Test Case 5**: (Manual) Verify that the dropdowns in `SetupView` are functional.
</file>

<file path="docs/completed/fe/backlog_sprint_5_concrete_client_implementation.md">
### User Story 1: Implement Qdrant Client
**As Alisha, I want to** implement the concrete client for Qdrant, **so that** the backend can communicate with the vector database.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Infrastructure/CodeContext.Infrastructure.csproj`
    -   **Action**: Add the `Qdrant.Client` NuGet package.
    -   **Implementation**:
        ```xml
        <ItemGroup>
            <PackageReference Include="Qdrant.Client" Version="1.x.x" /> <!-- Use the latest stable version -->
        </ItemGroup>
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs` (New File)
    -   **Action**: Create `QdrantClient` class implementing `IVectorDatabaseClient` and its `UpsertAsync` method.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IVectorDatabaseClient, VectorData, QueryResult
        using Qdrant.Client;
        using Qdrant.Client.Grpc;

        namespace CodeContext.Infrastructure.DatabaseClients
        {
            public class QdrantClient : IVectorDatabaseClient
            {
                private readonly QdrantGrpcClient _client;
                private readonly string _host;
                private readonly int _port;

                public QdrantClient(string host, int port)
                {
                    _host = host;
                    _port = port;
                    _client = new QdrantGrpcClient(host, port);
                }

                public async Task UpsertAsync(string collectionName, List<VectorData> vectors)
                {
                    // Ensure collection exists (or create it)
                    var collections = await _client.Collections.ListAsync();
                    if (!collections.Any(c => c.Name == collectionName))
                    {
                        await _client.Collections.CreateAsync(
                            collectionName,
                            new VectorParams { Size = vectors.First().Vector.Length, Distance = Distance.Cosine } // Assuming all vectors have same size
                        );
                    }

                    var points = vectors.Select(v => new PointStruct
                    {
                        Id = v.Id,
                        Vectors = v.Vector.ToList(),
                        Payload = v.Payload.ToDictionary(p => p.Key, p => Value.From(p.Value)) // Convert payload to Qdrant's Value
                    }).ToList();

                    await _client.Points.UpsertAsync(collectionName, points);
                }

                public async Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK)
                {
                    var searchResult = await _client.Points.SearchAsync(
                        collectionName,
                        vector.ToList(),
                        limit: (ulong)topK
                    );

                    return searchResult.Select(s => new QueryResult
                    {
                        Id = s.Id,
                        Score = s.Score,
                        Payload = s.Payload.ToDictionary(p => p.Key, p => p.Value.ToValue()) // Convert Qdrant's Value back to object
                    }).ToList();
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Linq;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`, `using Qdrant.Client;`, `using Qdrant.Client.Grpc;`

### User Story 2: Implement Ollama Provider
**As Alisha, I want to** implement the concrete client for Ollama, **so that** the backend can generate embeddings.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs` (New File)
    -   **Action**: Create `OllamaProvider` class implementing `IEmbeddingProvider` and its `GenerateEmbeddingsAsync` method.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Net.Http;
        using System.Text;
        using System.Text.Json;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider

        namespace CodeContext.Infrastructure.EmbeddingProviders
        {
            public class OllamaProvider : IEmbeddingProvider
            {
                private readonly HttpClient _httpClient;
                private readonly string _ollamaApiUrl;
                private readonly string _modelName;

                public OllamaProvider(HttpClient httpClient, string ollamaApiUrl, string modelName)
                {
                    _httpClient = httpClient;
                    _ollamaApiUrl = ollamaApiUrl;
                    _modelName = modelName;
                }

                public async Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts)
                {
                    var embeddings = new List<float[]>();
                    foreach (var text in texts)
                    {
                        var requestBody = new
                        {
                            model = _modelName,
                            prompt = text
                        };

                        var json = JsonSerializer.Serialize(requestBody);
                        var content = new StringContent(json, Encoding.UTF8, "application/json");

                        var response = await _httpClient.PostAsync($"{_ollamaApiUrl}/api/embeddings", content);
                        response.EnsureSuccessStatusCode(); // Throws an exception if not 2xx

                        var responseBody = await response.Content.ReadAsStringAsync();
                        var jsonDoc = JsonDocument.Parse(responseBody);
                        var embeddingArray = jsonDoc.RootElement.GetProperty("embedding").EnumerateArray().Select(e => (float)e.GetDouble()).ToArray();
                        embeddings.Add(embeddingArray);
                    }
                    return embeddings;
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Linq;`, `using System.Net.Http;`, `using System.Text;`, `using System.Text.Json;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`

### User Story 3: Implement AST Parsing and Indexing Service
**As Alisha, I want to** integrate AST parsing and create an indexing service, **so that** the backend can process code and store embeddings.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/Services/ParsingService.cs` (New File)
    -   **Action**: Create `ParsingService` to handle Abstract Syntax Tree (AST) parsing of code files. (Conceptual, as specific AST library is not chosen yet).
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core.Services
        {
            public class ParsingService
            {
                public Task<List<string>> ParseCodeFileAsync(string filePath)
                {
                    // This is a placeholder. Actual implementation would use a library
                    // like Microsoft.CodeAnalysis (Roslyn) for C#, or similar for other languages.
                    // It would extract meaningful code snippets, function definitions, etc.
                    return Task.FromResult(new List<string> { $"Content of {filePath} for embedding." });
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`
2.  **Filepath**: `CodeContext.Core/Services/IndexingService.cs` (New File)
    -   **Action**: Create `IndexingService` to orchestrate the indexing workflow (parsing, embedding, upserting).
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider, IVectorDatabaseClient, VectorData

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                private readonly ParsingService _parsingService;
                private readonly IEmbeddingProvider _embeddingProvider;
                private readonly IVectorDatabaseClient _vectorDatabaseClient;

                public IndexingService(
                    ParsingService parsingService,
                    IEmbeddingProvider embeddingProvider,
                    IVectorDatabaseClient vectorDatabaseClient)
                {
                    _parsingService = parsingService;
                    _embeddingProvider = embeddingProvider;
                    _vectorDatabaseClient = vectorDatabaseClient;
                }

                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName)
                {
                    // Placeholder: In a real scenario, you'd enumerate files in repositoryPath
                    // and process them.
                    var filePaths = new List<string> {
                        "path/to/file1.cs",
                        "path/to/file2.ts"
                    };

                    foreach (var filePath in filePaths)
                    {
                        var codeSnippets = await _parsingService.ParseCodeFileAsync(filePath);
                        if (codeSnippets.Any())
                        {
                            var embeddings = await _embeddingProvider.GenerateEmbeddingsAsync(codeSnippets);

                            var vectorsToUpsert = new List<VectorData>();
                            for (int i = 0; i < embeddings.Count; i++)
                            {
                                vectorsToUpsert.Add(new VectorData
                                {
                                    Id = $"{filePath}_{i}", // Unique ID for each snippet
                                    Vector = embeddings[i],
                                    Payload = new Dictionary<string, object> { { "filePath", filePath }, { "snippet", codeSnippets[i] } }
                                });
                            }
                            await _vectorDatabaseClient.UpsertAsync(collectionName, vectorsToUpsert);
                        }
                    }
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`

### User Story 4: Register Services and Create Index Endpoint
**As Alisha, I want to** register all new services with the DI container and create an `/index` endpoint, **so that** the API can trigger the indexing process.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Register `QdrantClient`, `OllamaProvider`, `ParsingService`, and `IndexingService` with the DI container.
    -   **Implementation**:
        ```csharp
        using CodeContext.Core;
        using CodeContext.Core.Services;
        using CodeContext.Infrastructure.DatabaseClients;
        using CodeContext.Infrastructure.EmbeddingProviders;
        using System.Net.Http; // For HttpClient

        // ... existing builder.Services ...

        // Register HttpClient for OllamaProvider
        builder.Services.AddHttpClient<OllamaProvider>(); // Registers HttpClient and OllamaProvider

        // Register concrete client implementations
        // For QdrantClient, you might need configuration for host/port
        builder.Services.AddSingleton<IVectorDatabaseClient>(sp =>
        {
            // Read configuration for Qdrant host/port
            var configuration = sp.GetRequiredService<IConfiguration>();
            var qdrantHost = configuration["Qdrant:Host"] ?? "localhost";
            var qdrantPort = int.Parse(configuration["Qdrant:Port"] ?? "6334");
            return new QdrantClient(qdrantHost, qdrantPort);
        });

        builder.Services.AddSingleton<IEmbeddingProvider>(sp =>
        {
            // Read configuration for Ollama API URL and model name
            var configuration = sp.GetRequiredService<IConfiguration>();
            var ollamaApiUrl = configuration["Ollama:ApiUrl"] ?? "http://localhost:11434";
            var ollamaModel = configuration["Ollama:Model"] ?? "llama2"; // Default model
            var httpClient = sp.GetRequiredService<HttpClient>(); // Get HttpClient from DI
            return new OllamaProvider(httpClient, ollamaApiUrl, ollamaModel);
        });

        // Register services
        builder.Services.AddSingleton<ParsingService>();
        builder.Services.AddSingleton<IndexingService>();

        // ... existing app.MapGet("/health") ...
        ```
    -   **Imports**: `using CodeContext.Core;`, `using CodeContext.Core.Services;`, `using CodeContext.Infrastructure.DatabaseClients;`, `using CodeContext.Infrastructure.EmbeddingProviders;`, `using System.Net.Http;`, `using Microsoft.Extensions.Configuration;`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Create a `POST /index` endpoint that triggers the `IndexingService`.
    -   **Implementation**:
        ```csharp
        // ... existing app.MapGet("/health") ...

        app.MapPost("/index", async (IndexingService indexingService) =>
        {
            // In a real scenario, you'd get the repository path from the request or configuration
            // For now, use a placeholder or read from appsettings.json
            var repositoryPath = "/path/to/your/code/repository"; // Placeholder
            var collectionName = "code_context_collection"; // Placeholder

            await indexingService.IndexRepositoryAsync(repositoryPath, collectionName);
            return Results.Ok("Indexing started.");
        });

        app.Run();
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   `Qdrant.Client` NuGet package is added to `CodeContext.Infrastructure`.
-   `QdrantClient` class implements `IVectorDatabaseClient` and correctly handles `UpsertAsync` and `QueryAsync` (though `QueryAsync` is not explicitly tested in this sprint's AC).
-   `OllamaProvider` class implements `IEmbeddingProvider` and correctly makes HTTP requests to Ollama and parses responses.
-   `ParsingService` and `IndexingService` classes are created in `CodeContext.Core/Services`.
-   All new services (`QdrantClient`, `OllamaProvider`, `ParsingService`, `IndexingService`) are registered with the DI container in `Program.cs`.
-   A `POST /index` endpoint exists in the API that triggers the `IndexingService`.

**Testing Plan:**
-   **Test Case 1**: Build the C# solution (`dotnet build CodeContext.sln`). Ensure no compilation errors.
-   **Test Case 2**: Run the API project (`dotnet run --project CodeContext.Api`).
-   **Test Case 3**: Use a tool like Postman or `curl` to send a `POST` request to `http://localhost:<port>/index`. Verify a `200 OK` response and that the indexing process (even if placeholder) is initiated.
-   **Test Case 4**: (Requires local Qdrant and Ollama instances) Start local Qdrant and Ollama containers. Run the API and trigger the `/index` endpoint. Observe logs for successful communication with Qdrant and Ollama. Verify data is inserted into Qdrant (e.g., using Qdrant's API or UI).
-   **Test Case 5**: (Unit Tests) Write unit tests for `QdrantClient` and `OllamaProvider` using mocking frameworks (e.g., Moq) to ensure their methods behave as expected without requiring actual external services.
</file>

<file path="docs/completed/fe/backlog_sprint_6_end_to_end_indexing_query_ui.md">
### User Story 1: Real-time Indexing Progress Feedback
**As Devin, I want to** click the "Index Now" button and see a progress bar while my code is being indexed, **so that** I have clear feedback on the process.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/Services/IndexingService.cs`
    -   **Action**: Implement a mechanism (e.g., `IProgress<T>`) to report progress updates during indexing.
    -   **Implementation**:
        ```csharp
        using System; // For Action
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core;

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                // ... (constructor and existing fields) ...

                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName, IProgress<int>? progress = null)
                {
                    // Simulate file discovery
                    var allFiles = new List<string> {
                        Path.Combine(repositoryPath, "src", "Program.cs"),
                        Path.Combine(repositoryPath, "src", "Utils.ts"),
                        Path.Combine(repositoryPath, "src", "AnotherFile.cs")
                    };
                    int totalFiles = allFiles.Count;
                    int processedFiles = 0;

                    foreach (var filePath in allFiles)
                    {
                        // ... (existing parsing, embedding, upserting logic) ...
                        processedFiles++;
                        int percentage = (int)((double)processedFiles / totalFiles * 100);
                        progress?.Report(percentage); // Report progress
                        await Task.Delay(100); // Simulate work
                    }
                }
            }
        }
        ```
    -   **Imports**: `using System;`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Create a Server-Sent Events (SSE) endpoint to stream progress updates from the backend to the UI.
    -   **Implementation**:
        ```csharp
        // ... existing imports ...
        using Microsoft.AspNetCore.Http; // For HttpContext
        using System.Threading.Channels; // For Channel

        // ... existing app.MapPost("/index") ...

        // Define a channel for broadcasting progress updates
        var progressChannel = Channel.CreateUnbounded<int>();

        app.MapPost("/index", async (IndexingService indexingService, HttpContext httpContext) =>
        {
            var repositoryPath = "/Users/bramburn/dev/bigcontext";
            var collectionName = "code_context_collection";

            // Create a progress reporter that pushes to the channel
            var progressReporter = new Progress<int>(percentage =>
            {
                progressChannel.Writer.TryWrite(percentage);
            });

            // Run indexing in a background task so the HTTP request can return quickly
            _ = Task.Run(async () =>
            {
                try
                {
                    await indexingService.IndexRepositoryAsync(repositoryPath, collectionName, progressReporter);
                    progressChannel.Writer.TryWrite(100); // Indicate completion
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Indexing error: {ex.Message}");
                    // Optionally send an error message through the channel or a separate mechanism
                }
            });

            return Results.Accepted(); // Return 202 Accepted
        });

        app.MapGet("/index-progress", async (HttpContext httpContext) =>
        {
            httpContext.Response.Headers.Add("Content-Type", "text/event-stream");
            httpContext.Response.Headers.Add("Cache-Control", "no-cache");
            httpContext.Response.Headers.Add("Connection", "keep-alive");

            await foreach (var percentage in progressChannel.Reader.ReadAllAsync(httpContext.RequestAborted))
            {
                await httpContext.Response.WriteAsync($"data: {percentage}\n\n");
                await httpContext.Response.Body.FlushAsync();
            }
        });

        app.Run();
        ```
    -   **Imports**: `using Microsoft.AspNetCore.Http;`, `using System.Threading.Channels;`
3.  **Filepath**: `webview/src/lib/components/IndexingView.svelte` (New File)
    -   **Action**: Create `IndexingView.svelte` with a progress bar and connect it to the SSE endpoint.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount, onDestroy } from 'svelte';
            import { postMessageToVsCode } from '../utils/vscode';
            import { currentView } from '../stores/viewStore';

            let progressPercentage: number = 0;
            let indexingStatus: string = 'Starting indexing...';
            let eventSource: EventSource | null = null;

            onMount(() => {
                // Start indexing process on mount (or when triggered by a button click)
                // For now, we'll assume it's triggered by the extension after config save.
                // In a real scenario, the "Save & Index" button in SetupView would trigger this.
                // postMessageToVsCode('startIndexing'); // Send message to extension to start backend indexing

                // Connect to SSE endpoint for progress updates
                eventSource = new EventSource('http://localhost:5000/index-progress'); // Adjust port if needed

                eventSource.onmessage = (event) => {
                    const percentage = parseInt(event.data, 10);
                    if (!isNaN(percentage)) {
                        progressPercentage = percentage;
                        indexingStatus = `Indexing progress: ${percentage}%`;
                        if (percentage >= 100) {
                            indexingStatus = 'Indexing complete!';
                            setTimeout(() => {
                                currentView.set('query'); // Transition to query view
                            }, 1000); // Give a moment for user to see 100%
                        }
                    }
                };

                eventSource.onerror = (error) => {
                    console.error('EventSource failed:', error);
                    indexingStatus = 'Indexing failed or disconnected.';
                    eventSource?.close();
                };
            });

            onDestroy(() => {
                eventSource?.close(); // Close the connection when component is destroyed
            });
        </script>

        <div class="indexing-container">
            <h1>Indexing Your Codebase</h1>
            <p>{indexingStatus}</p>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: {progressPercentage}%;"></div>
            </div>
            <p>{progressPercentage}%</p>
        </div>

        <style>
            .indexing-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            .progress-bar-container {
                width: 100%;
                background-color: var(--vscode-editorGroup-background);
                border: 1px solid var(--vscode-panel-border);
                border-radius: 5px;
                height: 20px;
                overflow: hidden;
            }
            .progress-bar {
                height: 100%;
                background-color: var(--vscode-progressBar-background);
                width: 0%;
                transition: width 0.3s ease-in-out;
            }
        </style>
        ```
    -   **Imports**: `import { onMount, onDestroy } from 'svelte';`, `import { postMessageToVsCode } from '../utils/vscode';`, `import { currentView } from '../stores/viewStore';`
4.  **Filepath**: `webview/src/App.svelte`
    -   **Action**: Update `App.svelte` to render `IndexingView` when indexing is in progress.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';
            import IndexingView from './lib/components/IndexingView.svelte'; // New import

            onMount(() => {
                window.addEventListener('message', event => {
                    const message = event.data;
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        case 'startIndexingUI': // Message from extension to show indexing view
                            currentView.set('indexing');
                            break;
                        // ... handle other messages
                    }
                });
            });
        </script>

        <main>
            {#if $currentView === 'setup'}
                <SetupView />
            {:else if $currentView === 'indexing'}
                <IndexingView />
            {:else if $currentView === 'query'}
                <QueryView />
            {/if}
        </main>
        ```
    -   **Imports**: `import IndexingView from './lib/components/IndexingView.svelte';`
5.  **Filepath**: `webview/src/lib/stores/viewStore.ts`
    -   **Action**: Update `currentView` store to include `'indexing'` state.
    -   **Implementation**:
        ```typescript
        import { writable } from 'svelte/store';

        export const currentView = writable<'setup' | 'indexing' | 'query'>('setup');
        ```
    -   **Imports**: None.

### User Story 2: Implement Core Query View
**As Devin, after indexing is complete, I want to** see a chat input box where I can type a question to find relevant code.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/QueryView.svelte`
    -   **Action**: Implement the `QueryView.svelte` component with a text input and a submit button, and a display area for results.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { postMessageToVsCode } from '../utils/vscode';

            let query: string = '';
            let searchResults: { filePath: string; snippet: string }[] = [];
            let isLoading: boolean = false;

            async function handleQuerySubmit() {
                if (!query.trim()) return;

                isLoading = true;
                searchResults = []; // Clear previous results

                // Send query to VS Code extension, which will forward to backend
                const response = await postMessageToVsCode('submitQuery', { query });

                // Assuming the extension sends back the results via a message
                // For now, we'll simulate or expect a direct return if possible (less ideal for async)
                // In a real scenario, the extension would send a message back to the webview
                // with the results, and this component would listen for it.
                // For this backlog, let's assume postMessageToVsCode can return a promise with results.
                // (This is a simplification for the backlog, actual implementation needs a message listener)
                if (response && response.type === 'queryResults') {
                    searchResults = response.results;
                } else {
                    // Simulate results for backlog purposes
                    searchResults = [
                        { filePath: "/path/to/file1.cs", snippet: "public class MyClass { /* ... */ }" },
                        { filePath: "/path/to/file2.ts", snippet: "function calculateSum(a: number, b: number) { /* ... */ }" }
                    ];
                }

                isLoading = false;
            }
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <div class="query-input-area">
                <input
                    type="text"
                    placeholder="Ask a question about your codebase..."
                    bind:value={query}
                    on:keydown={(e) => { if (e.key === 'Enter') handleQuerySubmit(); }}
                />
                <button on:click={handleQuerySubmit} disabled={isLoading}>
                    {#if isLoading}Searching...{:else}Search{/if}
                </button>
            </div>

            {#if searchResults.length > 0}
                <div class="search-results">
                    <h2>Results:</h2>
                    {#each searchResults as result}
                        <div class="result-item">
                            <h3>{result.filePath}</h3>
                            <pre><code>{result.snippet}</code></pre>
                        </div>
                    {/each}
                </div>
            {:else if !isLoading}
                <p>No results yet. Type a query above.</p>
            {/if}
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            .query-input-area {
                display: flex;
                margin-bottom: 20px;
            }
            .query-input-area input {
                flex-grow: 1;
                padding: 10px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border-radius: 4px;
                margin-right: 10px;
            }
            .query-input-area button {
                padding: 10px 15px;
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }
            button:hover:not(:disabled) {
                background-color: var(--vscode-button-hoverBackground);
            }
            button:disabled {
                opacity: 0.6;
                cursor: not-allowed;
            }
            .search-results {
                margin-top: 20px;
            }
            .result-item {
                background-color: var(--vscode-editorGroup-background);
                border: 1px solid var(--vscode-panel-border);
                padding: 15px;
                margin-bottom: 10px;
                border-radius: 5px;
            }
            .result-item h3 {
                margin-top: 0;
                color: var(--vscode-textLink-foreground);
            }
            .result-item pre {
                background-color: var(--vscode-editor-background);
                padding: 10px;
                border-radius: 3px;
                overflow-x: auto;
            }
        </style>
        ```
    -   **Imports**: `import { postMessageToVsCode } from '../utils/vscode';`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Implement a `POST /query` endpoint that takes a query string, generates an embedding, performs a vector search, and returns relevant file paths.
    -   **Implementation**:
        ```csharp
        // ... existing imports ...
        using CodeContext.Core.Services; // For IndexingService (and now QueryService)

        // ... existing endpoints ...

        app.MapPost("/query", async (QueryRequest request, IndexingService indexingService, IEmbeddingProvider embeddingProvider, IVectorDatabaseClient vectorDatabaseClient) =>
        {
            if (string.IsNullOrWhiteSpace(request.QueryText))
            {
                return Results.BadRequest("Query text cannot be empty.");
            }

            var collectionName = "code_context_collection"; // Must match indexing collection

            try
            {
                // 1. Generate embedding for the query text
                var queryEmbedding = (await embeddingProvider.GenerateEmbeddingsAsync(new List<string> { request.QueryText })).FirstOrDefault();
                if (queryEmbedding == null)
                {
                    return Results.Problem("Failed to generate embedding for query.", statusCode: 500);
                }

                // 2. Perform vector search
                var searchResults = await vectorDatabaseClient.QueryAsync(collectionName, queryEmbedding, topK: 5); // Get top 5 results

                // 3. Format results for UI
                var formattedResults = searchResults.Select(r => new QueryResponseItem
                {
                    FilePath = r.Payload.ContainsKey("filePath") ? r.Payload["filePath"].ToString() : "Unknown Path",
                    Snippet = r.Payload.ContainsKey("snippet") ? r.Payload["snippet"].ToString() : "No snippet available"
                }).ToList();

                return Results.Ok(formattedResults);
            }
            catch (Exception ex)
            {
                return Results.Problem($"Query failed: {ex.Message}", statusCode: 500);
            }
        });

        app.Run();

        // Define request and response models for the query endpoint
        public record QueryRequest(string QueryText);
        public record QueryResponseItem(string FilePath, string Snippet);
        ```
    -   **Imports**: `using CodeContext.Core.Services;`
3.  **Filepath**: `extension.ts`
    -   **Action**: Handle `submitQuery` message from webview, forward to backend, and send results back to webview.
    -   **Implementation**:
        ```typescript
        // ... (inside activate function, in panel.webview.onDidReceiveMessage) ...
        case 'submitQuery':
            try {
                const queryText = message.query;
                const backendUrl = `http://localhost:${backendPort}/query`;
                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ queryText })
                });

                if (response.ok) {
                    const results = await response.json();
                    panel.webview.postMessage({ type: 'queryResults', results });
                } else {
                    const errorText = await response.text();
                    vscode.window.showErrorMessage(`Backend query failed: ${response.status} - ${errorText}`);
                    panel.webview.postMessage({ type: 'queryResults', results: [] }); // Send empty results on error
                }
            } catch (error: any) {
                vscode.window.showErrorMessage(`Error sending query to backend: ${error.message}`);
                panel.webview.postMessage({ type: 'queryResults', results: [] });
            }
            return;
        // ...
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   Clicking "Save & Index" (from SetupView) or a dedicated "Index Now" button (if added) triggers the indexing process in the backend.
-   The Svelte UI displays a progress bar that updates in real-time based on progress events streamed from the backend.
-   Upon successful completion of indexing (100% progress), the UI automatically transitions from `IndexingView` to `QueryView`.
-   The `QueryView` component features a text input field and a submit button.
-   Typing a query and submitting it sends a `POST` request to the C# backend's `/query` endpoint.
-   The backend successfully generates an embedding for the query, performs a vector search, and returns a list of relevant file paths and snippets.
-   The `QueryView` displays the returned search results in a clear, readable format.

**Testing Plan:**
-   **Test Case 1**: Start the extension with no `code-context.json`. Go through the setup, click "Save & Index". Verify `IndexingView` appears and the progress bar updates.
-   **Test Case 2**: Observe the console logs of the C# backend to confirm indexing progress is being reported.
-   **Test Case 3**: After indexing completes, verify the UI automatically transitions to `QueryView`.
-   **Test Case 4**: In `QueryView`, type a simple query (e.g., "how to calculate sum") and click "Search".
-   **Test Case 5**: Observe the C# backend logs to confirm the query was received, embedding generated, and search performed.
-   **Test Case 6**: Verify that the `QueryView` displays the returned file paths and snippets.
-   **Test Case 7**: (Edge Case) Test with an empty query or a query that yields no results.
</file>

<file path="docs/completed/fe/backlog_sub_sprint_1_database_configuration_component.md">
# Backlog: Sub-Sprint 1 - Database Configuration Component

**Objective:** To build the Svelte component for the database selection and management part of the setup view.

**Parent Sprint:** Sprint 1: Setup View Implementation

---

### User Story: Manage Database Configuration

**As a** new user (Devin), **I want to** select my vector database, start it if needed, and see its status, **so that** I can prepare my project for indexing.

**Workflow:**
1.  The `DatabaseSetup.svelte` component renders a dropdown for database selection and a button to start the local service.
2.  A status indicator shows the current state of the database (e.g., "Not Running", "Running").
3.  Clicking the "Start" button sends a message to the extension backend.
4.  The backend runs the necessary command and sends a status update back to the webview.

**File Changes:**
*   `webview/src/lib/components/DatabaseSetup.svelte` (New File)
*   `src/extension.ts` (Modification)
*   `webview/src/lib/stores/setupStore.ts` (Modification)

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte` (New File)
    *   **Action**: Build the UI with a Fluent UI `<Select>` component for database choice (initially just "Qdrant") and a `<Button>` to start the service.
    *   **Implementation**:
        ```html
        <script lang="ts">
          import { Button, Select } from '@svelte-fui/core';
          import { setupState } from '$lib/stores/setupStore';
          // ... message handling logic ...
        </script>
        <h2>Database Configuration</h2>
        <Select items={['Qdrant']} placeholder="Select a database" />
        <Button on:click={startDatabase}>Start Local Qdrant</Button>
        <span>Status: {$setupState.databaseReady ? 'Running' : 'Not Running'}</span>
        ```
    *   **Imports**: `@svelte-fui/core`, `../stores/setupStore`
2.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Implement the `startDatabase` function to send a `startDatabase` message via `postMessage`.
    *   **Implementation**: `const vscode = acquireVsCodeApi(); function startDatabase() { vscode.postMessage({ command: 'startDatabase' }); }`
    *   **Imports**: None.
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Add a case for `startDatabase` in the `onDidReceiveMessage` listener. This should execute the `docker-compose up` command in a new terminal.
    *   **Implementation**: `case 'startDatabase': const terminal = vscode.window.createTerminal('Qdrant'); terminal.sendText('docker-compose up'); terminal.show(); break;`
    *   **Imports**: `vscode`
4.  **Filepath**: `src/extension.ts`
    *   **Action**: Implement a basic health check loop after starting the database. On success, `postMessage` to the webview with the updated status.
    *   **Implementation**: Use `setTimeout` and a fetch-like request to the Qdrant health endpoint. `panel.webview.postMessage({ command: 'databaseStatus', status: 'running' });`
    *   **Imports**: None.
5.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Add a listener for messages from the extension to update the `setupState` store.
    *   **Implementation**: `window.addEventListener('message', event => { const message = event.data; if (message.command === 'databaseStatus' && message.status === 'running') { setupState.update(s => ({ ...s, databaseReady: true })); } });`
    *   **Imports**: `setupState` from store.

**Acceptance Criteria:**
-   The dropdown displays "Qdrant" as an option.
-   Clicking the button successfully opens a terminal and runs `docker-compose up`.
-   The UI status correctly reflects the health status received from the backend, changing from "Not Running" to "Running".
-   The `databaseReady` state in the Svelte store is updated correctly.

**Dependencies:**
-   VS Code extension boilerplate must be complete.
-   A `docker-compose.yml` file must exist in the project root.
</file>

<file path="docs/completed/fe/backlog_sub_sprint_2_embedding_provider_workflow_logic.md">
# Backlog: Sub-Sprint 2 - Embedding Provider & Workflow Logic

**Objective:** To build the embedding provider selection component and the final workflow logic to enable indexing.

**Parent Sprint:** Sprint 1: Setup View Implementation

---

### User Story: Select Embedding Provider and Start Indexing

**As a** new user (Devin), **I want to** choose my embedding provider and trigger the indexing process, **so that** my code context can be generated.

**Workflow:**
1.  The `EmbeddingSetup.svelte` component renders a dropdown for selecting an embedding provider.
2.  The main `SetupView` component contains the "Index Now" button, which is disabled by default.
3.  The button's state is reactively bound to the `setupState` store. It becomes enabled only when the database is ready AND an embedding provider has been selected.
4.  Clicking the button sends the complete configuration to the extension backend to begin the indexing process.

**File Changes:**
*   `webview/src/lib/components/EmbeddingSetup.svelte` (New File)
*   `webview/src/lib/stores/setupStore.ts` (Modification)
*   `webview/src/routes/+page.svelte` (Modification)
*   `src/extension.ts` (Modification)

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/EmbeddingSetup.svelte` (New File)
    *   **Action**: Build the UI with a Fluent UI `<Select>` component to choose between "Ollama" and "OpenAI".
    *   **Implementation**:
        ```html
        <script lang="ts">
          import { Select } from '@svelte-fui/core';
          import { setupState } from '$lib/stores/setupStore';
          const providers = ['Ollama', 'OpenAI'];
          function handleSelect(event) {
            setupState.update(s => ({ ...s, providerSelected: event.detail.value }));
          }
        </script>
        <h2>Embedding Provider</h2>
        <Select items={providers} placeholder="Select a provider" on:change={handleSelect} />
        ```
    *   **Imports**: `@svelte-fui/core`, `../stores/setupStore`
2.  **Filepath**: `webview/src/lib/stores/setupStore.ts`
    *   **Action**: Ensure the store can hold the selected provider's name.
    *   **Implementation**: The existing `providerSelected: string | null;` in the `SetupState` interface is sufficient.
    *   **Imports**: None.
3.  **Filepath**: `webview/src/routes/+page.svelte`
    *   **Action**: Add the "Index Now" button and bind its `disabled` property to a derived state from the store.
    *   **Implementation**:
        ```html
        <script lang="ts">
          import { setupState } from '$lib/stores/setupStore';
          import { Button } from '@svelte-fui/core';
          $: canStartIndex = $setupState.databaseReady && $setupState.providerSelected;
          function startIndexing() {
            vscode.postMessage({ command: 'startIndexing', config: $setupState });
          }
        </script>
        <Button variant="accent" disabled={!canStartIndex} on:click={startIndexing}>Index Now</Button>
        ```
    *   **Imports**: `setupState`, `Button`
4.  **Filepath**: `src/extension.ts`
    *   **Action**: Add a case for `startIndexing` in the `onDidReceiveMessage` listener.
    *   **Implementation**: `case 'startIndexing': const config = message.config; vscode.window.showInformationMessage(`Starting indexing with provider: ${config.providerSelected}`); // Future logic to save config and start backend process goes here. break;`
    *   **Imports**: `vscode`

**Acceptance Criteria:**
-   The dropdown displays "Ollama" and "OpenAI" as options.
-   Selecting a provider updates the `providerSelected` field in the Svelte store.
-   The "Index Now" button is disabled by default.
-   The button becomes enabled only after the database is running AND a provider is selected.
-   Clicking the button successfully sends the full configuration details to the extension backend.

**Dependencies:**
-   Sub-Sprint 1 must be complete.
</file>

<file path="docs/completed/fe/implementation_sprint_1_setup_view_implementation.md">
# Implementation Guidance: Sprint 1 - Setup View Implementation

**Objective:** To provide the technical guidance, code examples, and API information needed to build the onboarding and setup UI using SvelteKit, Fluent UI, and the VS Code Webview API.

---

### 1. Scaffolding the SvelteKit Project in `webview/`

Since the `webview` directory is empty, you will need to create a new SvelteKit project there. This will serve as the foundation for the entire UI.

**Command:**
```bash
# Navigate to the project root
cd /Users/bramburn/dev/bigcontext

# Create a new SvelteKit project inside the webview directory
npm create svelte@latest webview

# Follow the prompts:
# ? Which Svelte app template?  SvelteKit demo app
# ? Add type checking with TypeScript?  Yes, using TypeScript syntax
# ? Select additional options  ESLint, Prettier
```

After creation, `cd webview` and run `npm install`.

### 2. Configuring SvelteKit for VS Code Webviews

For a webview, the SvelteKit app must be exported as a static, single-page application (SPA).

**1. Install Static Adapter:**
```bash
cd /Users/bramburn/dev/bigcontext/webview
npm install -D @sveltejs/adapter-static@next
```

**2. Configure `svelte.config.js`:**
Modify `webview/svelte.config.js` to use the static adapter. This ensures all UI assets are bundled into a `build` directory with predictable paths.

```javascript
// webview/svelte.config.js
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/kit/vite';

/** @type {import('@sveltejs/kit').Config} */
const config = {
    preprocess: vitePreprocess(),
    kit: {
        adapter: adapter({
            pages: 'build',
            assets: 'build',
            fallback: 'index.html', // Important for SPA behavior
            precompress: false
        }),
        // This is crucial for resolving asset paths correctly inside the webview
        paths: {
            base: '{{vscode-resource-base}}' // A placeholder we will replace
        },
        appDir: 'app'
    }
};

export default config;
```

### 3. Integrating Fluent UI

We will use `svelte-fui`, a community-maintained library for Fluent UI components in Svelte.

**1. Install Dependencies:**
```bash
cd /Users/bramburn/dev/bigcontext/webview
npm install @svelte-fui/core @svelte-fui/tailwindcss
```

**2. Configure TailwindCSS:**
Create `webview/tailwind.config.js` and add the `svelte-fui` preset.
```javascript
// webview/tailwind.config.js
/** @type {import('tailwindcss').Config}*/
const config = {
  content: ['./src/**/*.{html,js,svelte,ts}'],
  presets: [require('@svelte-fui/tailwindcss').preset()],
  theme: {
    extend: {}
  },
  plugins: []
};

module.exports = config;
```
You will also need to set up Tailwind by creating `postcss.config.js` and `src/app.css` as per the SvelteKit Tailwind integration docs.

### 4. Webview Panel Creation and Communication (`src/extension.ts`)

This is the core logic for loading and interacting with the Svelte UI from the extension host.

**1. Loading the UI:**
The `createWebviewPanel` function loads the `index.html` from the SvelteKit `build` directory. We must replace the asset paths with special `vscode-resource` URIs.

```typescript
// src/extension.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

function createWebviewPanel(context: vscode.ExtensionContext) {
    const panel = vscode.window.createWebviewPanel(
        'setupView',
        'Code Context Setup',
        vscode.ViewColumn.One,
        {
            enableScripts: true,
            localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'webview', 'build')]
        }
    );

    const buildPath = vscode.Uri.joinPath(context.extensionUri, 'webview', 'build').fsPath;
    let html = fs.readFileSync(path.join(buildPath, 'index.html'), 'utf8');

    // Create the base URI for webview resources
    const baseUri = panel.webview.asWebviewUri(vscode.Uri.file(buildPath)).toString();
    // Replace our placeholder with the correct base URI
    html = html.replace('{{vscode-resource-base}}', baseUri);

    panel.webview.html = html;
    return panel;
}
```

**2. Bidirectional Messaging:**
Communication relies on `panel.webview.postMessage` and `panel.webview.onDidReceiveMessage`.

*   **From Extension to Webview:**
    ```typescript
    // src/extension.ts
    // Example: Sending database status to the UI
    panel.webview.postMessage({ command: 'databaseStatus', status: 'Running' });
    ```

*   **From Webview to Extension:**
    First, get the VS Code API instance in your Svelte component.
    ```html
    <!-- webview/src/lib/components/DatabaseSetup.svelte -->
    <script lang="ts">
        const vscode = acquireVsCodeApi();

        function startDatabase() {
            vscode.postMessage({
                command: 'startDatabase',
                payload: { type: 'qdrant' }
            });
        }
    </script>
    <Button on:click={startDatabase}>Start Local Qdrant</Button>
    ```
    Then, handle the message in `extension.ts`.
    ```typescript
    // src/extension.ts
    panel.webview.onDidReceiveMessage(message => {
        switch (message.command) {
            case 'startDatabase':
                const terminal = vscode.window.createTerminal(`Qdrant DB`);
                terminal.sendText('docker-compose up');
                terminal.show();
                // Here you would add logic to health-check the DB
                // and post a message back to the webview on success.
                return;
        }
    });
    ```

### 5. Running Commands in a Terminal

The `vscode.window.createTerminal` API is used to create and manage terminal instances from the extension.

**API Reference:** `vscode.window.createTerminal`
*   **`name`**: A string that is shown in the terminal's dropdown.
*   **`shellPath`**: (Optional) Path to a custom shell executable.
*   **`shellArgs`**: (Optional) Arguments for the shell.

**Example:**
```typescript
// src/extension.ts
// This creates a new terminal named "My Command" and runs "echo Hello"
const terminal = vscode.window.createTerminal("My Command");
terminal.sendText("echo Hello");
terminal.show(); // Makes the terminal visible to the user
```
For the PRD requirement, you will use `terminal.sendText('docker-compose up');`. You should also advise the user that this requires `docker-compose.yml` to be present in the workspace root and Docker to be running.
</file>

<file path="docs/completed/fe/implementation_sprint_1_web_api_boilerplate.md">
### How to Implement Sprint 1: C# Web API Boilerplate

This sprint focuses on setting up the foundational C# ASP.NET Core Web API project with a clean architecture.

**Key Technologies and Concepts:**

*   **ASP.NET Core Minimal APIs:** A simplified approach to building HTTP APIs in .NET 6 and later, reducing boilerplate code.
*   **.NET CLI:** Command-line interface for developing .NET applications.
*   **Dependency Injection (DI):** Built-in feature in ASP.NET Core for managing object dependencies, promoting loose coupling.
*   **Swagger/OpenAPI:** Tools for documenting and testing RESTful APIs.
*   **Clean Architecture:** Organizing code into layers (e.g., Core, Infrastructure, API) to separate concerns and improve maintainability.

**Detailed Implementation Steps and Code Examples:**

1.  **Create .NET Solution and Projects:**
    Use the `dotnet new` command to scaffold the solution and projects.
    *   **Command:**
        ```bash
        dotnet new sln -n CodeContext
        dotnet new webapi -n CodeContext.Api -o CodeContext.Api
        dotnet new classlib -n CodeContext.Core -o CodeContext.Core
        dotnet new classlib -n CodeContext.Infrastructure -o CodeContext.Infrastructure
        dotnet sln CodeContext.sln add CodeContext.Api/CodeContext.Api.csproj
        dotnet sln CodeContext.sln add CodeContext.Core/CodeContext.Core.csproj
        dotnet sln CodeContext.sln add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj
        ```
    *   **Guidance:** The `-o` flag creates the project in a new directory. `dotnet sln add` links the projects to the solution file.

2.  **Set Project References:**
    Edit the `CodeContext.Api.csproj` file to add references to the Core and Infrastructure projects. This allows the API layer to access types defined in the other layers.
    *   **File:** `CodeContext.Api/CodeContext.Api.csproj`
    *   **Code Example (add inside `<Project>` tag):**
        ```xml
        <ItemGroup>
            <ProjectReference Include="..\CodeContext.Core\CodeContext.Core.csproj" />
            <ProjectReference Include="..\CodeContext.Infrastructure\CodeContext.Infrastructure.csproj" />
        </ItemGroup>
        ```
    *   **Guidance:** Ensure the `Include` paths correctly point to the `.csproj` files of the Core and Infrastructure projects relative to the API project.

3.  **Implement Health Check Endpoint:**
    Modify `Program.cs` in the API project to add a simple `/health` endpoint. This is crucial for monitoring the API's availability.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add before `app.Run();`):**
        ```csharp
        // ... existing code ...

        app.MapGet("/health", () => Results.Ok());

        app.Run();
        ```
    *   **Guidance:** `Results.Ok()` is part of the `Microsoft.AspNetCore.Http.Results` class, which is implicitly available in minimal API contexts. This endpoint will return an HTTP 200 OK status.

4.  **Add Swagger/OpenAPI:**
    Integrate Swashbuckle to generate OpenAPI specifications and provide a Swagger UI for API documentation and testing.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add in `builder.Services` section):**
        ```csharp
        // ... existing code ...
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();

        var app = builder.Build();

        // Configure the HTTP request pipeline.
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }
        // ... existing code ...
        ```
    *   **Guidance:** `AddEndpointsApiExplorer()` is needed for minimal APIs to be discovered by Swagger. `AddSwaggerGen()` registers the Swagger generator. `UseSwagger()` and `UseSwaggerUI()` enable the middleware for serving the generated specification and the UI, respectively. These are typically enabled only in development environments.

5.  **Define Core Interfaces:**
    Create placeholder interfaces in the `CodeContext.Core` project. These interfaces will define the contracts for embedding providers and vector database clients, promoting a clean separation of concerns and extensibility.
    *   **File:** `CodeContext.Core/IEmbeddingProvider.cs`
    *   **Code Example:**
        ```csharp
        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                // Future methods for generating embeddings will go here, e.g.:
                // Task<float[]> GenerateEmbeddingAsync(string text);
            }
        }
        ```
    *   **File:** `CodeContext.Core/IVectorDatabaseClient.cs`
    *   **Code Example:**
        ```csharp
        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                // Future methods for interacting with vector databases will go here, e.g.:
                // Task UpsertAsync(string id, float[] vector, Dictionary<string, object> payload);
                // Task<List<QueryResult>> QueryAsync(float[] vector, int topK);
            }
        }
        ```
    *   **Guidance:** These interfaces are currently empty but establish the architectural placeholders.

6.  **Define Infrastructure Placeholders:**
    Create directories within the `CodeContext.Infrastructure` project to logically separate concrete implementations of database clients and embedding providers.
    *   **Action:** Manually create the following directories:
        *   `CodeContext.Infrastructure/DatabaseClients`
        *   `CodeContext.Infrastructure/EmbeddingProviders`
    *   **Guidance:** These folders will house the actual implementations (e.g., `QdrantClient.cs`, `OllamaProvider.cs`) in later sprints.

**Verification:**

After implementing these steps, build the solution (`dotnet build CodeContext.sln`) and run the API project (`dotnet run --project CodeContext.Api`). Verify that:
*   The API starts successfully.
*   You can access `http://localhost:<port>/health` and get a 200 OK response.
*   You can access `http://localhost:<port>/swagger` and see the Swagger UI.
</file>

<file path="docs/completed/fe/implementation_sprint_2_extensible_client_framework.md">
### How to Implement Sprint 2: Extensible Client Framework

This sprint focuses on designing the core interfaces for our external dependencies (embedding providers and vector databases) and setting up the dependency injection (DI) mechanism to manage their concrete implementations. This is crucial for building a flexible and testable architecture.

**Key Technologies and Concepts:**

*   **Interfaces (C#):** Define contracts for classes, enabling polymorphism and loose coupling.
*   **Dependency Injection (DI):** A software design pattern that allows for the inversion of control, where dependencies are provided to a class rather than the class creating them. ASP.NET Core has a built-in DI container.
*   **Strategy Pattern / Factory Pattern:** Design patterns that can be used to select and provide the correct implementation of an interface at runtime based on configuration or other criteria.
*   **`IServiceProvider` and `GetRequiredService<T>()`:** Core components of the .NET DI system for resolving registered services.

**Detailed Implementation Steps and Code Examples:**

1.  **Enhance `IEmbeddingProvider` Interface:**
    Define the `GenerateEmbeddingsAsync` method, which will be responsible for converting text into numerical vector representations.
    *   **File:** `CodeContext.Core/IEmbeddingProvider.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                /// <summary>
                /// Generates embeddings for a list of text inputs.
                /// </summary>
                /// <param name="texts">A list of strings to generate embeddings for.</param>
                /// <returns>A list of float arrays, where each array is an embedding for the corresponding text.</returns>
                Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts);
            }
        }
        ```
    *   **Guidance:** The `List<float[]>` return type is a common representation for embeddings. `Task` indicates an asynchronous operation, which is standard for I/O-bound tasks like API calls.

2.  **Enhance `IVectorDatabaseClient` Interface:**
    Define methods for `UpsertAsync` (inserting/updating vectors) and `QueryAsync` (searching for similar vectors). Also, define helper classes `VectorData` and `QueryResult` for structured data transfer.
    *   **File:** `CodeContext.Core/IVectorDatabaseClient.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                /// <summary>
                /// Inserts or updates vectors in the specified collection.
                /// </summary>
                /// <param name="collectionName">The name of the vector collection.</param>
                /// <param name="vectors">A list of VectorData objects to upsert.</param>
                Task UpsertAsync(string collectionName, List<VectorData> vectors);

                /// <summary>
                /// Queries the vector database for similar vectors.
                /// </summary>
                /// <param name="collectionName">The name of the vector collection to query.</param>
                /// <param name="vector">The query vector.</param>
                /// <param name="topK">The number of top similar results to return.</param>
                /// <returns>A list of QueryResult objects.</returns>
                Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK);
            }

            /// <summary>
            /// Represents a single vector data point to be stored in the database.
            /// </summary>
            public class VectorData
            {
                public string Id { get; set; } // Unique identifier for the vector
                public float[] Vector { get; set; } // The embedding vector itself
                public Dictionary<string, object> Payload { get; set; } // Additional metadata
            }

            /// <summary>
            /// Represents a single query result from the vector database.
            /// </summary>
            public class QueryResult
            {
                public string Id { get; set; } // Identifier of the matched vector
                public double Score { get; set; } // Similarity score
                public Dictionary<string, object> Payload { get; set; } // Associated metadata
            }
        }
        ```
    *   **Guidance:** `Payload` is a `Dictionary<string, object>` to allow flexible metadata storage alongside vectors.

3.  **Create `ClientFactory` for Dynamic Resolution:**
    This factory will be responsible for providing the correct concrete implementation of `IEmbeddingProvider` or `IVectorDatabaseClient` based on a configuration string. This uses the Strategy/Factory pattern.
    *   **File:** `CodeContext.Core/ClientFactory.cs` (New File)
    *   **Code Example:**
        ```csharp
        using System;
        using Microsoft.Extensions.DependencyInjection; // Required for GetRequiredService

        namespace CodeContext.Core
        {
            public class ClientFactory
            {
                private readonly IServiceProvider _serviceProvider;

                public ClientFactory(IServiceProvider serviceProvider)
                {
                    _serviceProvider = serviceProvider;
                }

                public IEmbeddingProvider GetEmbeddingProvider(string providerType)
                {
                    // In a real application, you might use a more sophisticated lookup
                    // or configuration-driven approach. For now, a switch is sufficient.
                    return providerType.ToLowerInvariant() switch
                    {
                        "ollama" => _serviceProvider.GetRequiredService<OllamaProvider>(), // OllamaProvider will be registered in Program.cs
                        _ => throw new ArgumentException($"Unknown embedding provider type: {providerType}")
                    };
                }

                public IVectorDatabaseClient GetVectorDatabaseClient(string clientType)
                {
                    return clientType.ToLowerInvariant() switch
                    {
                        "qdrant" => _serviceProvider.GetRequiredService<QdrantClient>(), // QdrantClient will be registered in Program.cs
                        _ => throw new ArgumentException($"Unknown vector database client type: {clientType}")
                    };
                }
            }
        }
        ```
    *   **Guidance:** The `ClientFactory` takes `IServiceProvider` in its constructor, allowing it to resolve other services (our concrete client implementations) at runtime. Note that `OllamaProvider` and `QdrantClient` are concrete types that will be implemented and registered in later sprints.

4.  **Register `ClientFactory` with DI Container:**
    Add the `ClientFactory` as a singleton service in `Program.cs` so it can be injected wherever needed.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add in `builder.Services` section):**
        ```csharp
        using CodeContext.Core; // Add this import at the top

        // ... existing code ...
        builder.Services.AddSingleton<ClientFactory>();

        // In later sprints, you will register concrete implementations like this:
        // builder.Services.AddSingleton<OllamaProvider>();
        // builder.Services.AddSingleton<QdrantClient>();
        // builder.Services.AddSingleton<IEmbeddingProvider, OllamaProvider>(); // If you want to directly inject the interface
        // builder.Services.AddSingleton<IVectorDatabaseClient, QdrantClient>(); // If you want to directly inject the interface
        ```
    *   **Guidance:** `AddSingleton` ensures only one instance of `ClientFactory` is created and reused throughout the application's lifetime.

**Verification:**

*   Ensure the solution builds successfully after these changes.
*   While direct runtime testing of the factory's resolution capabilities is limited without concrete implementations, you can write unit tests in a separate test project (e.g., `CodeContext.Tests`) to verify the factory's logic.
    *   **Example Unit Test (Conceptual):**
        ```csharp
        // In CodeContext.Tests/ClientFactoryTests.cs
        using Xunit;
        using Microsoft.Extensions.DependencyInjection;
        using CodeContext.Core;
        using Moq; // For mocking interfaces

        public class ClientFactoryTests
        {
            [Fact]
            public void GetEmbeddingProvider_ReturnsOllamaProvider_WhenOllamaTypeIsRequested()
            {
                // Arrange
                var services = new ServiceCollection();
                var mockOllamaProvider = new Mock<IEmbeddingProvider>(); // Mock the concrete provider
                services.AddSingleton(mockOllamaProvider.Object); // Register the mock as the concrete type
                services.AddSingleton<ClientFactory>();
                var serviceProvider = services.BuildServiceProvider();
                var factory = serviceProvider.GetRequiredService<ClientFactory>();

                // Act
                var provider = factory.GetEmbeddingProvider("ollama");

                // Assert
                Assert.NotNull(provider);
                // You might assert the type if OllamaProvider was a concrete class,
                // but here we are just checking if a service was returned.
            }

            // Add similar tests for IVectorDatabaseClient
        }
        ```
    *   **Guidance:** This conceptual test demonstrates how you would set up a test environment using `ServiceCollection` and `Moq` (a mocking library) to verify the factory's behavior.
</file>

<file path="docs/completed/fe/implementation_sprint_3_backend_process_management.md">
### How to Implement Sprint 3: Backend Process Management

This sprint focuses on the critical integration between the VS Code extension (TypeScript) and the C# backend. The goal is to automate the lifecycle management of the backend process, ensuring it starts automatically, is monitored for health, and is properly terminated.

**Key Technologies and Concepts:**

*   **Node.js `child_process` module:** Provides the ability to spawn child processes, execute shell commands, and interact with their I/O streams. Specifically, `spawn` is preferred for long-running processes.
*   **VS Code Extension API:** `vscode.ExtensionContext` for managing disposables, `vscode.window.showInformationMessage` for user notifications.
*   **HTTP `fetch` API:** For making HTTP requests to the backend's health endpoint. In Node.js, you might need a polyfill like `node-fetch` or use `undici` for Node.js 18+.
*   **Process Management:** Handling `stdout`, `stderr`, `close`, and `error` events of the child process. Ensuring proper termination (`kill()`).

**Detailed Implementation Steps and Code Examples:**

1.  **Spawn C# Backend Executable:**
    In your extension's `activate` function, use `child_process.spawn` to launch the compiled C# executable. You'll need to determine the correct path to your executable after the C# project is built.
    *   **File:** `extension.ts` (main extension file)
    *   **Code Example:**
        ```typescript
        import * as vscode from 'vscode';
        import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
        import * as path from 'path';
        import fetch from 'node-fetch'; // Or 'undici' for Node.js 18+

        let backendProcess: ChildProcessWithoutNullStreams | null = null;
        const backendPort = 5000; // Define your backend's port

        export function activate(context: vscode.ExtensionContext) {
            console.log('Code Context extension is now active!');

            // IMPORTANT: Adjust this path based on your C# build output location.
            // This assumes the C# project builds to a 'bin' folder within the extension's root.
            const backendExecutablePath = path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api'); // Example for Windows/Linux
            // For macOS, it might be: path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api')
            // Or if it's a self-contained deployment: path.join(context.extensionPath, 'publish', 'CodeContext.Api')

            // Ensure the executable exists before trying to spawn
            if (!require('fs').existsSync(backendExecutablePath)) {
                vscode.window.showErrorMessage(`Code Context backend executable not found at: ${backendExecutablePath}`);
                return;
            }

            backendProcess = spawn(backendExecutablePath, [], {
                cwd: path.dirname(backendExecutablePath), // Run from the executable's directory
                stdio: ['ignore', 'pipe', 'pipe'] // Ignore stdin, pipe stdout/stderr
            });

            // Capture stdout for logging
            backendProcess.stdout.on('data', (data) => {
                console.log(`[Backend stdout]: ${data.toString()}`);
                // Consider using a dedicated VS Code OutputChannel for better logging
                // const outputChannel = vscode.window.createOutputChannel("Code Context Backend");
                // outputChannel.appendLine(`[Backend stdout]: ${data.toString()}`);
            });

            // Capture stderr for error logging
            backendProcess.stderr.on('data', (data) => {
                console.error(`[Backend stderr]: ${data.toString()}`);
                // outputChannel.appendLine(`[Backend stderr]: ${data.toString()}`);
            });

            // Handle process exit
            backendProcess.on('close', (code) => {
                console.log(`Backend process exited with code ${code}`);
                backendProcess = null;
                // Potentially notify user or attempt restart if unexpected exit
            });

            // Handle errors during spawning (e.g., executable not found, permissions)
            backendProcess.on('error', (err) => {
                console.error('Failed to start backend process:', err);
                vscode.window.showErrorMessage(`Failed to start Code Context backend: ${err.message}`);
                backendProcess = null;
            });

            // Ensure the process is killed when the extension deactivates
            context.subscriptions.push({
                dispose: () => {
                    if (backendProcess) {
                        console.log('Terminating backend process on extension deactivation...');
                        backendProcess.kill(); // Sends SIGTERM
                        backendProcess = null;
                    }
                }
            });

            // Start health check after a short delay to allow backend to start listening
            setTimeout(() => startHealthCheck(context), 2000);
        }

        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill(); // Ensure process is killed
                backendProcess = null;
            }
        }
        ```
    *   **Guidance:**
        *   `cwd`: Set the current working directory for the spawned process to the directory containing the executable.
        *   `stdio`: `['ignore', 'pipe', 'pipe']` means stdin is ignored, stdout and stderr are piped to the parent process (your extension), allowing you to capture their output.
        *   **Executable Path:** The path `path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api')` is a common pattern for .NET Core executables. For cross-platform compatibility, you might need to check `process.platform` or use a self-contained deployment.
        *   **Error Handling:** Implement robust error handling for `spawn` and `on('error')` events.

2.  **Implement Backend Health Monitoring:**
    Create a function to periodically check the backend's `/health` endpoint. If it fails repeatedly, attempt to restart the backend.
    *   **File:** `extension.ts`
    *   **Code Example (add as a new function):**
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        let healthCheckTimer: NodeJS.Timeout | null = null;
        let healthCheckAttempts = 0;
        const maxHealthCheckAttempts = 5; // Number of failed attempts before restart
        const healthCheckInterval = 5000; // Check every 5 seconds

        async function checkBackendHealth(context: vscode.ExtensionContext): Promise<boolean> {
            if (!backendProcess) {
                console.log('Backend process not running, health check skipped.');
                return false;
            }
            try {
                const response = await fetch(`http://localhost:${backendPort}/health`);
                if (response.ok) {
                    console.log('Backend is healthy.');
                    healthCheckAttempts = 0;
                    // You can send a message to your webview here to update UI status
                    // vscode.window.activeTextEditor?.document.uri.scheme === 'vscode-webview' &&
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'running' });
                    return true;
                } else {
                    console.warn(`Backend health check failed: HTTP ${response.status}`);
                    return false;
                }
            } catch (error) {
                console.error('Error during backend health check:', error);
                return false;
            }
        }

        function startHealthCheck(context: vscode.ExtensionContext) {
            if (healthCheckTimer) {
                clearInterval(healthCheckTimer);
            }
            healthCheckTimer = setInterval(async () => {
                const isHealthy = await checkBackendHealth(context);
                if (!isHealthy) {
                    healthCheckAttempts++;
                    // Update UI state to "Starting" or "Error"
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'starting' });

                    if (healthCheckAttempts >= maxHealthCheckAttempts) {
                        console.error('Max health check attempts reached. Attempting to restart backend.');
                        clearInterval(healthCheckTimer!);
                        restartBackend(context);
                    }
                }
            }, healthCheckInterval);
        }

        function restartBackend(context: vscode.ExtensionContext) {
            if (backendProcess) {
                console.log('Killing existing backend process for restart...');
                backendProcess.kill(); // Send SIGTERM
                backendProcess = null;
            }
            healthCheckAttempts = 0; // Reset attempts for new process
            console.log('Attempting to restart backend process...');
            // Re-call activate to re-spawn and re-initialize everything
            // In a more complex app, you might have a dedicated `startBackend` function
            deactivate(); // Clean up existing disposables
            activate(context); // Re-activate the extension, which will spawn a new process
            vscode.window.showWarningMessage('Code Context Backend is restarting due to health check failures.');
        }
        ```
    *   **Guidance:**
        *   `setInterval`: Used for periodic checks.
        *   `fetch`: Make HTTP requests. Remember to install `node-fetch` (`npm install node-fetch`) or use Node.js's built-in `fetch` if on Node.js 18+.
        *   **Restart Logic:** The `restartBackend` function kills the current process and then re-calls `activate(context)`. This is a simple way to re-initialize the extension and spawn a new backend. For more fine-grained control, you might extract the spawning logic into a separate `startBackend` function.
        *   **UI Integration:** The comments show where you would send messages to a VS Code Webview to update the UI status.

**Verification:**

*   **Manual Testing:**
    1.  Open VS Code and activate the extension. Check your system's process list (Task Manager on Windows, Activity Monitor on macOS, `ps aux | grep CodeContext.Api` on Linux) to confirm the C# backend process is running.
    2.  Deactivate the extension (e.g., by closing the VS Code window or disabling the extension). Verify the C# backend process is no longer running.
    3.  While the extension is active, manually kill the C# backend process (e.g., using Task Manager). Observe if the extension detects the unhealthiness and attempts to restart the backend after a few intervals.
*   **Logging:** Monitor the VS Code Debug Console (for `console.log` messages) or a dedicated Output Channel (if implemented) for messages indicating process start/stop, health checks, and errors.
</file>

<file path="docs/completed/fe/implementation_sprint_4_onboarding_setup_ui.md">
### How to Implement Sprint 4: Onboarding & Setup UI

This sprint focuses on building the initial user interface within the VS Code extension, specifically for onboarding new users and allowing them to configure their database and embedding provider. This involves creating a VS Code Webview and integrating a Svelte frontend.

**Key Technologies and Concepts:**

*   **VS Code Webviews:** Allow you to create custom UI within VS Code using HTML, CSS, and JavaScript (or frameworks like Svelte, React, Vue).
*   **Svelte:** A reactive JavaScript framework for building user interfaces.
*   **`vscode.workspace.workspaceFolders`:** API to get information about open workspace folders.
*   **`fs` module (Node.js):** For file system operations like checking file existence.
*   **`vscode.window.createTerminal()`:** API to create and interact with VS Code integrated terminals.
*   **Message Passing (Extension <-> Webview):** Communication between the VS Code extension (Node.js/TypeScript) and the webview (Svelte/JavaScript) is done via `postMessage` and `onDidReceiveMessage`.

**Detailed Implementation Steps and Code Examples:**

1.  **Create and Manage VS Code Webview:**
    The `extension.ts` file will be responsible for creating the webview panel and loading your Svelte application into it. It will also handle communication between the extension and the webview.
    *   **File:** `extension.ts`
    *   **Code Example (within `activate` function):**
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';
        // ... (other imports like child_process, fetch) ...

        export function activate(context: vscode.ExtensionContext) {
            // ... (backend process management setup) ...

            // Create and show the webview panel
            const panel = vscode.window.createWebviewPanel(
                'codeContext', // Unique ID for the webview
                'Code Context', // Title shown in VS Code tab
                vscode.ViewColumn.One, // Where to open the panel (e.g., in the first editor column)
                {
                    enableScripts: true, // VERY IMPORTANT: Allows JavaScript to run in the webview
                    // Restrict the webview to only load resources from our extension's 'webview/dist' directory
                    localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                }
            );

            // Get the path to the SvelteKit build output (index.html)
            const svelteAppPath = path.join(context.extensionPath, 'webview', 'dist', 'index.html');
            if (!fs.existsSync(svelteAppPath)) {
                vscode.window.showErrorMessage('Svelte webview build not found. Please run `npm run build` in the webview directory.');
                return;
            }
            panel.webview.html = fs.readFileSync(svelteAppPath, 'utf8');

            // Check for existing configuration file
            const workspaceFolders = vscode.workspace.workspaceFolders;
            let configFilePath: string | undefined;
            if (workspaceFolders && workspaceFolders.length > 0) {
                // Assuming config file is in .vscode/code-context.json relative to workspace root
                configFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'code-context.json');
            }

            let initialView: 'setup' | 'query' = 'setup';
            if (configFilePath && fs.existsSync(configFilePath)) {
                initialView = 'query'; // If config exists, show query view
            }

            // Send initial view state to the Svelte webview
            panel.webview.postMessage({ type: 'initialView', view: initialView });

            // Handle messages received from the webview (e.g., user clicks a button)
            panel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showInformationMessage(message.text);
                            return;
                        case 'startDocker':
                            handleStartDockerCommand(message.service, context);
                            return;
                        case 'saveConfigAndIndex':
                            // Implement saving config and triggering indexing in a later sprint
                            vscode.window.showInformationMessage('Configuration saved (not yet implemented) and indexing will start!');
                            return;
                    }
                },
                undefined,
                context.subscriptions // Ensure the message listener is disposed
            );

            // Add the panel to the extension's disposables so it's cleaned up when the extension deactivates
            context.subscriptions.push(panel);
        }
        ```
    *   **Guidance:**
        *   `enableScripts: true` is crucial for your Svelte app to run.
        *   `localResourceRoots` is a security measure to prevent the webview from loading arbitrary content.
        *   `panel.webview.html = fs.readFileSync(...)` loads your Svelte app's `index.html`.
        *   `panel.webview.postMessage` sends data to the webview.
        *   `panel.webview.onDidReceiveMessage` listens for data from the webview.

2.  **Svelte App Structure and View Management:**
    Your Svelte application will have a main `App.svelte` component that conditionally renders `SetupView.svelte` or `QueryView.svelte` based on a Svelte store.
    *   **File:** `webview/src/lib/stores/viewStore.ts` (New File)
    *   **Code Example:**
        ```typescript
        import { writable } from 'svelte/store';

        // Defines the current view of the webview: 'setup' or 'query'
        export const currentView = writable<'setup' | 'query'>('setup');
        ```
    *   **File:** `webview/src/App.svelte` (Main Svelte component)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';

            onMount(() => {
                // Listen for messages from the VS Code extension
                window.addEventListener('message', event => {
                    const message = event.data; // The JSON data that the extension sent
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        // Add cases for other messages from extension (e.g., backend status updates)
                    }
                });
            });
        </script>

        <main>
            {#if $currentView === 'setup'}
                <SetupView />
            {:else if $currentView === 'query'}
                <QueryView />
            {/if}
        </main>

        <style>
            /* Global styles for your Svelte app */
            body {
                margin: 0;
                padding: 0;
                background-color: var(--vscode-editor-background);
                color: var(--vscode-editor-foreground);
            }
            /* You can use VS Code CSS variables for theming */
        </style>
        ```
    *   **Guidance:** The `onMount` lifecycle hook is used to set up the message listener. The `{#if}` block conditionally renders components.

3.  **Implement `SetupView.svelte`:**
    This component will contain the UI elements for selecting database/embedding providers and the "Start Local" buttons.
    *   **File:** `webview/src/lib/components/SetupView.svelte` (New File)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            import { postMessageToVsCode } from '../utils/vscode'; // Utility to send messages to extension

            let selectedDatabase: string = 'qdrant'; // Default selection
            let selectedEmbeddingProvider: string = 'ollama'; // Default selection

            function handleStartLocalService(service: string) {
                // Send a message to the VS Code extension to execute the Docker command
                postMessageToVsCode('startDocker', { service });
            }

            function handleSaveAndIndex() {
                // Send configuration to extension to save and trigger indexing
                postMessageToVsCode('saveConfigAndIndex', {
                    database: selectedDatabase,
                    embeddingProvider: selectedEmbeddingProvider
                });
            }
        </script>

        <div class="setup-container">
            <h1>Code Context Setup</h1>

            <section>
                <h2>Database Configuration</h2>
                <label for="database-select">Select Database:</label>
                <select id="database-select" bind:value={selectedDatabase}>
                    <option value="qdrant">Qdrant (Local)</option>
                    <!-- Add more database options here as they are supported -->
                </select>
                <button on:click={() => handleStartLocalService('qdrant')}>Start Local Qdrant</button>
                <!-- Future: Add status indicator (e.g., "Running", "Stopped") -->
            </section>

            <section>
                <h2>Embedding Provider Configuration</h2>
                <label for="embedding-select">Select Embedding Provider:</label>
                <select id="embedding-select" bind:value={selectedEmbeddingProvider}>
                    <option value="ollama">Ollama (Local)</option>
                    <!-- Add more embedding provider options here -->
                </select>
                <button on:click={() => handleStartLocalService('ollama')}>Start Local Ollama</button>
                <!-- Future: Add status indicator -->
            </section>

            <button on:click={handleSaveAndIndex}>Save & Index</button>
        </div>

        <style>
            /* Basic styling for the setup view */
            .setup-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            section {
                margin-bottom: 20px;
                border: 1px solid var(--vscode-panel-border);
                padding: 15px;
                border-radius: 5px;
                background-color: var(--vscode-editorGroup-background);
            }
            label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            select, button {
                margin-right: 10px;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                cursor: pointer;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
        </style>
        ```
    *   **Guidance:** `bind:value` creates two-way data binding for select elements. `postMessageToVsCode` is a custom utility.

4.  **Create `postMessageToVsCode` Utility:**
    This simple utility abstracts the `acquireVsCodeApi()` call, making it easier to send messages from Svelte to the extension.
    *   **File:** `webview/src/lib/utils/vscode.ts` (New File)
    *   **Code Example:**
        ```typescript
        // This function is provided by VS Code to webviews to communicate back to the extension.
        // It must be called exactly once per webview panel.
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        /**
         * Sends a message from the Svelte webview to the VS Code extension.
         * @param command The command string (e.g., 'startDocker', 'saveConfig').
         * @param data Any additional data to send with the command.
         */
        export function postMessageToVsCode(command: string, data: any) {
            vscode.postMessage({ command, ...data });
        }
        ```
    *   **Guidance:** `acquireVsCodeApi()` is a global function available in webview contexts.

5.  **Implement `handleStartDockerCommand` in Extension:**
    This function in `extension.ts` will receive messages from the webview and execute the appropriate Docker commands in a new VS Code terminal.
    *   **File:** `extension.ts`
    *   **Code Example (add as a new function):**
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        function handleStartDockerCommand(service: string, context: vscode.ExtensionContext) {
            let command: string;
            let terminalName: string;
            let cwd: string | undefined; // Current working directory for the terminal

            // Assuming docker-compose files are in a 'docker' sub-directory of the extension
            const dockerComposeDir = path.join(context.extensionPath, 'docker');

            switch (service) {
                case 'qdrant':
                    command = 'docker-compose -f docker-compose.qdrant.yml up -d';
                    terminalName = 'Code Context: Qdrant';
                    cwd = dockerComposeDir; // Run docker-compose from its directory
                    break;
                case 'ollama':
                    // Example Ollama command to run it as a detached container
                    command = 'docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama';
                    terminalName = 'Code Context: Ollama';
                    // Ollama command can be run from any directory, no specific cwd needed
                    break;
                default:
                    vscode.window.showErrorMessage(`Unknown service to start: ${service}`);
                    return;
            }

            const terminal = vscode.window.createTerminal({
                name: terminalName,
                cwd: cwd // Set the working directory for the terminal
            });
            terminal.show(); // Show the terminal panel
            terminal.sendText(command); // Send the command to the terminal

            vscode.window.showInformationMessage(`Attempting to start ${service} via Docker. Check '${terminalName}' terminal for status.`);
            // In a real scenario, you'd also want to poll the health of these services
            // and update the UI status in SetupView.svelte.
        }
        ```
    *   **Guidance:**
        *   `vscode.window.createTerminal()` creates a new integrated terminal.
        *   `terminal.show()` brings the terminal into focus.
        *   `terminal.sendText()` sends the command to be executed in the terminal.
        *   Consider adding a `docker-compose.qdrant.yml` file in a `docker` directory within your extension for Qdrant.

6.  **Create Placeholder `QueryView.svelte`:**
    This component will be displayed when a `code-context.json` file is found, indicating the project is already set up.
    *   **File:** `webview/src/lib/components/QueryView.svelte` (New File)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            // This component will be developed in a later sprint for querying functionality.
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <p>Your project is configured. Query functionality will be available here soon!</p>
            <!-- Future: Input box for queries, display area for results -->
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
        </style>
        ```
    *   **Guidance:** This is a minimal placeholder for now.

**Verification:**

*   **Build Svelte App:** Before testing, navigate to your `webview` directory and run `npm install` and then `npm run build` to compile your Svelte app into the `dist` folder.
*   **VS Code Testing:**
    1.  Open VS Code with an empty folder (no `.vscode/code-context.json`). Activate your extension. Verify that the "Code Context" webview panel appears and displays the `SetupView` with dropdowns and buttons.
    2.  Create an empty file at `.vscode/code-context.json` in your workspace root. Reload the VS Code window (Ctrl+R or Cmd+R). Verify that the webview now displays the `QueryView` placeholder.
    3.  Go back to the `SetupView` (by deleting `.vscode/code-context.json` and reloading). Click the "Start Local Qdrant" button. Verify a new VS Code terminal opens and the `docker-compose` command is executed. Repeat for "Start Local Ollama".
</file>

<file path="docs/completed/fe/implementation_sprint_5_concrete_client_implementation.md">
### How to Implement Sprint 5: Concrete Client Implementation (C#)

This sprint is about bringing our abstract interfaces to life by implementing concrete clients for Qdrant (vector database) and Ollama (embedding provider). We will also introduce the core indexing logic that orchestrates the parsing, embedding, and storage of code context.

**Key Technologies and Concepts:**

*   **Qdrant.Client NuGet Package:** The official .NET client library for interacting with Qdrant.
*   **`HttpClient` (C#):** For making HTTP requests to the Ollama API.
*   **`System.Text.Json`:** For JSON serialization and deserialization when communicating with Ollama.
*   **Abstract Syntax Tree (AST) Parsing:** The process of analyzing source code to build a tree-like representation of its structure. For C#, `Microsoft.CodeAnalysis` (Roslyn) is the standard. For other languages, you'd use appropriate libraries.
*   **Dependency Injection (DI):** Continues to be crucial for injecting our new concrete clients and services.
*   **`IConfiguration`:** For reading settings like API URLs and model names from `appsettings.json`.

**Detailed Implementation Steps and Code Examples:**

1.  **Add Qdrant.Client NuGet Package:**
    Install the official Qdrant .NET client library into your `CodeContext.Infrastructure` project.
    *   **Command:**
        ```bash
        dotnet add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj package Qdrant.Client
        ```
    *   **Guidance:** Always check NuGet.org for the latest stable version.

2.  **Implement `QdrantClient` Class:**
    Create a class that implements `IVectorDatabaseClient` and uses the `Qdrant.Client` library to perform upsert and query operations.
    *   **File:** `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IVectorDatabaseClient, VectorData, QueryResult
        using Qdrant.Client;
        using Qdrant.Client.Grpc; // For PointStruct, VectorParams, Distance, etc.

        namespace CodeContext.Infrastructure.DatabaseClients
        {
            public class QdrantClient : IVectorDatabaseClient
            {
                private readonly QdrantGrpcClient _client;
                private readonly string _collectionName; // Default collection name

                public QdrantClient(string host, int port, string collectionName = "code_context_collection")
                {
                    _client = new QdrantGrpcClient(host, port);
                    _collectionName = collectionName;
                }

                public async Task UpsertAsync(string collectionName, List<VectorData> vectors)
                {
                    if (!vectors.Any()) return;

                    // Ensure collection exists or create it.
                    // In a production app, you might check this once on startup or have a dedicated migration.
                    var collections = await _client.Collections.ListAsync();
                    if (!collections.Any(c => c.Name == collectionName))
                    {
                        // Assuming all vectors have the same dimension (size) and cosine distance
                        await _client.Collections.CreateAsync(
                            collectionName,
                            new VectorParams { Size = (ulong)vectors.First().Vector.Length, Distance = Distance.Cosine }
                        );
                    }

                    // Convert our generic VectorData to Qdrant's PointStruct
                    var points = vectors.Select(v => new PointStruct
                    {
                        Id = v.Id, // Qdrant uses string IDs
                        Vectors = v.Vector.ToList(), // Convert float[] to List<float>
                        Payload = v.Payload.ToDictionary(
                            p => p.Key,
                            p => Value.From(p.Value) // Convert generic object to Qdrant's Value type
                        )
                    }).ToList();

                    // Perform the upsert operation
                    await _client.Points.UpsertAsync(collectionName, points);
                }

                public async Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK)
                {
                    var searchResult = await _client.Points.SearchAsync(
                        collectionName,
                        vector.ToList(), // Convert float[] to List<float>
                        limit: (ulong)topK
                    );

                    // Convert Qdrant's SearchPoint to our generic QueryResult
                    return searchResult.Select(s => new QueryResult
                    {
                        Id = s.Id,
                        Score = s.Score,
                        Payload = s.Payload.ToDictionary(
                            p => p.Key,
                            p => p.Value.ToValue() // Convert Qdrant's Value back to generic object
                        )
                    }).ToList();
                }
            }
        }
        ```
    *   **Guidance:**
        *   `QdrantGrpcClient`: The main client for gRPC communication with Qdrant.
        *   `Value.From(object)` and `Value.ToValue()`: Helper methods for converting between C# objects and Qdrant's internal `Value` type for payload data.
        *   Collection creation: The example includes logic to create the collection if it doesn't exist. In a real application, this might be handled during setup or migration.

3.  **Implement `OllamaProvider` Class:**
    Create a class that implements `IEmbeddingProvider` and makes HTTP POST requests to a local Ollama instance to generate embeddings.
    *   **File:** `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Net.Http;
        using System.Text;
        using System.Text.Json;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider

        namespace CodeContext.Infrastructure.EmbeddingProviders
        {
            public class OllamaProvider : IEmbeddingProvider
            {
                private readonly HttpClient _httpClient;
                private readonly string _ollamaApiUrl;
                private readonly string _modelName;

                public OllamaProvider(HttpClient httpClient, string ollamaApiUrl, string modelName)
                {
                    _httpClient = httpClient;
                    _ollamaApiUrl = ollamaApiUrl;
                    _modelName = modelName;
                }

                public async Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts)
                {
                    var embeddings = new List<float[]>();
                    foreach (var text in texts)
                    {
                        var requestBody = new
                        {
                            model = _modelName,
                            prompt = text,
                            // You might add options like "keep_alive" for performance
                            // options = new { temperature = 0.0 }
                        };

                        var json = JsonSerializer.Serialize(requestBody);
                        var content = new StringContent(json, Encoding.UTF8, "application/json");

                        var response = await _httpClient.PostAsync($"{_ollamaApiUrl}/api/embeddings", content);
                        response.EnsureSuccessStatusCode(); // Throws an exception for non-2xx status codes

                        var responseBody = await response.Content.ReadAsStringAsync();
                        using (JsonDocument jsonDoc = JsonDocument.Parse(responseBody))
                        {
                            var embeddingArray = jsonDoc.RootElement.GetProperty("embedding").EnumerateArray()
                                .Select(e => (float)e.GetDouble())
                                .ToArray();
                            embeddings.Add(embeddingArray);
                        }
                    }
                    return embeddings;
                }
            }
        }
        ```
    *   **Guidance:**
        *   `HttpClient`: Best practice is to use `IHttpClientFactory` for managing `HttpClient` instances in ASP.NET Core. This is handled by `builder.Services.AddHttpClient<OllamaProvider>();` in `Program.cs`.
        *   Ollama API: The `/api/embeddings` endpoint expects a JSON payload with `model` and `prompt`.
        *   `JsonSerializer`: Used for serializing C# objects to JSON and deserializing JSON responses.

4.  **Add AST Parsing Logic (Placeholder):**
    Create a `ParsingService` that will eventually use an AST library to extract meaningful code snippets. For C#, `Microsoft.CodeAnalysis` (Roslyn) is the go-to.
    *   **File:** `CodeContext.Core/Services/ParsingService.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.IO;
        using System.Threading.Tasks;

        namespace CodeContext.Core.Services
        {
            public class ParsingService
            {
                /// <summary>
                /// Parses a code file and extracts relevant text snippets for embedding.
                /// This is a placeholder; actual implementation would use an AST library.
                /// </summary>
                /// <param name="filePath">The path to the code file.</param>
                /// <returns>A list of text snippets extracted from the file.</returns>
                public async Task<List<string>> ParseCodeFileAsync(string filePath)
                {
                    if (!File.Exists(filePath))
                    {
                        return new List<string>();
                    }

                    // For now, just return the entire file content as a single snippet.
                    // In a real implementation:
                    // - Use Roslyn for C# files (Microsoft.CodeAnalysis.CSharp)
                    // - Use other parsers for TypeScript, Python, etc.
                    // - Break down code into functions, classes, comments, etc.
                    var content = await File.ReadAllTextAsync(filePath);
                    return new List<string> { content };
                }
            }
        }
        ```
    *   **Guidance:** For C# parsing, you would add `Microsoft.CodeAnalysis.CSharp` NuGet package and use its APIs to traverse the syntax tree.

5.  **Create `IndexingService`:**
    This service orchestrates the entire indexing workflow: reading files, parsing them, generating embeddings, and upserting to the vector database.
    *   **File:** `CodeContext.Core/Services/IndexingService.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider, IVectorDatabaseClient, VectorData

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                private readonly ParsingService _parsingService;
                private readonly IEmbeddingProvider _embeddingProvider;
                private readonly IVectorDatabaseClient _vectorDatabaseClient;

                public IndexingService(
                    ParsingService parsingService,
                    IEmbeddingProvider embeddingProvider,
                    IVectorDatabaseClient vectorDatabaseClient)
                {
                    _parsingService = parsingService;
                    _embeddingProvider = embeddingProvider;
                    _vectorDatabaseClient = vectorDatabaseClient;
                }

                /// <summary>
                /// Indexes a given code repository by parsing files, generating embeddings,
                /// and storing them in the vector database.
                /// </summary>
                /// <param name="repositoryPath">The root path of the code repository.</param>
                /// <param name="collectionName">The name of the Qdrant collection to use.</param>
                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName)
                {
                    // TODO: Implement actual file enumeration (e.g., using Directory.EnumerateFiles)
                    // and filtering (e.g., .gitignore, file extensions).
                    var dummyFilePaths = new List<string> { 
                        Path.Combine(repositoryPath, "src", "Program.cs"), 
                        Path.Combine(repositoryPath, "src", "Utils.ts") 
                    };

                    foreach (var filePath in dummyFilePaths)
                    {
                        Console.WriteLine($"Indexing file: {filePath}"); // For logging progress
                        var codeSnippets = await _parsingService.ParseCodeFileAsync(filePath);

                        if (codeSnippets.Any())
                        {
                            var embeddings = await _embeddingProvider.GenerateEmbeddingsAsync(codeSnippets);

                            var vectorsToUpsert = new List<VectorData>();
                            for (int i = 0; i < embeddings.Count; i++)
                            {
                                vectorsToUpsert.Add(new VectorData
                                {
                                    Id = $"{filePath.Replace("\", "/")}_{i}", // Create a unique ID, normalize path
                                    Vector = embeddings[i],
                                    Payload = new Dictionary<string, object>
                                    {
                                        { "filePath", filePath },
                                        { "snippet", codeSnippets[i] }
                                    }
                                });
                            }
                            await _vectorDatabaseClient.UpsertAsync(collectionName, vectorsToUpsert);
                            Console.WriteLine($"Indexed {embeddings.Count} snippets from {filePath}");
                        }
                    }
                    Console.WriteLine("Indexing complete.");
                }
            }
        }
        ```
    *   **Guidance:** This service takes dependencies on `ParsingService`, `IEmbeddingProvider`, and `IVectorDatabaseClient`, which will be injected by DI.

6.  **Register Services with DI Container:**
    Update `Program.cs` in the API project to register all the new concrete implementations and services.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (within `builder.Services` section):**
        ```csharp
        using CodeContext.Core;
        using CodeContext.Core.Services;
        using CodeContext.Infrastructure.DatabaseClients;
        using CodeContext.Infrastructure.EmbeddingProviders;
        using Microsoft.Extensions.Configuration; // For IConfiguration
        using System.Net.Http; // For HttpClient

        // ... existing services ...

        // Register HttpClient for OllamaProvider (best practice for HttpClient management)
        builder.Services.AddHttpClient(); // Registers a default HttpClient

        // Register concrete client implementations as singletons
        builder.Services.AddSingleton<IVectorDatabaseClient>(sp =>
        {
            var configuration = sp.GetRequiredService<IConfiguration>();
            var qdrantHost = configuration["Qdrant:Host"] ?? "localhost";
            var qdrantPort = int.Parse(configuration["Qdrant:Port"] ?? "6334");
            var collectionName = configuration["Qdrant:CollectionName"] ?? "code_context_collection";
            return new QdrantClient(qdrantHost, qdrantPort, collectionName);
        });

        builder.Services.AddSingleton<IEmbeddingProvider>(sp =>
        {
            var configuration = sp.GetRequiredService<IConfiguration>();
            var ollamaApiUrl = configuration["Ollama:ApiUrl"] ?? "http://localhost:11434";
            var ollamaModel = configuration["Ollama:Model"] ?? "llama2"; // Default model
            var httpClientFactory = sp.GetRequiredService<IHttpClientFactory>();
            var httpClient = httpClientFactory.CreateClient(); // Get a named client if needed, or default
            return new OllamaProvider(httpClient, ollamaApiUrl, ollamaModel);
        });

        // Register core services
        builder.Services.AddSingleton<ParsingService>();
        builder.Services.AddSingleton<IndexingService>();

        // ... existing app.MapGet("/health") ...
        ```
    *   **Guidance:**
        *   `AddHttpClient()`: Registers `IHttpClientFactory`, which is used to create `HttpClient` instances.
        *   `IConfiguration`: You'll need to add `appsettings.json` to your `CodeContext.Api` project to configure Qdrant and Ollama settings.
            ```json
            // appsettings.json
            {
              "Logging": {
                "LogLevel": {
                  "Default": "Information",
                  "Microsoft.AspNetCore": "Warning"
                }
              },
              "AllowedHosts": "*",
              "Qdrant": {
                "Host": "localhost",
                "Port": 6334,
                "CollectionName": "code_context_collection"
              },
              "Ollama": {
                "ApiUrl": "http://localhost:11434",
                "Model": "llama2"
              }
            }
            ```

7.  **Create `/index` Endpoint:**
    Add a new minimal API endpoint that triggers the `IndexingService`.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add before `app.Run();`):**
        ```csharp
        // ... existing endpoints ...

        app.MapPost("/index", async (IndexingService indexingService) =>
        {
            // In a real application, the repository path would come from the request
            // or be managed by the extension. For now, use a hardcoded path or read from config.
            var repositoryPath = "/Users/bramburn/dev/bigcontext"; // Example: Use the current project root
            var collectionName = "code_context_collection"; // Should match Qdrant config

            try
            {
                await indexingService.IndexRepositoryAsync(repositoryPath, collectionName);
                return Results.Ok("Indexing process completed successfully.");
            }
            catch (Exception ex)
            {
                return Results.Problem($"Indexing failed: {ex.Message}", statusCode: 500);
            }
        });

        app.Run();
        ```
    *   **Guidance:** The `IndexingService` is automatically injected into the endpoint handler. Add error handling for robustness.

**Verification:**

*   **Prerequisites:** Ensure you have a local Qdrant instance running (e.g., via Docker) and Ollama installed with a model downloaded (e.g., `ollama run llama2`).
*   **Build and Run:** Build your C# solution (`dotnet build`) and run the API project (`dotnet run --project CodeContext.Api`).
*   **Test `/health`:** Confirm `http://localhost:<port>/health` returns 200 OK.
*   **Test `/index`:** Use a tool like Postman, Insomnia, or `curl` to send a `POST` request to `http://localhost:<port>/index`.
    *   `curl -X POST http://localhost:<port>/index`
*   **Observe Logs:** Check the console output of your running C# API for messages from `IndexingService` and any errors from Qdrant or Ollama communication.
*   **Verify Qdrant Data:** If successful, you should see new points (vectors) added to your Qdrant collection. You can use Qdrant's API or UI to verify this.
</file>

<file path="docs/completed/fe/implementation_sub_sprint_1_database_configuration_component.md">
# Implementation Guidance: Sub-Sprint 1 - Database Configuration Component

**Objective:** To provide detailed instructions for creating the `DatabaseSetup.svelte` component, handling user interaction, and communicating with the extension backend to manage the database service.

---

### 1. Component Structure (`DatabaseSetup.svelte`)

This component is responsible for the database section of the UI. It will contain a selector, a button, and a status indicator.

**File:** `webview/src/lib/components/DatabaseSetup.svelte`

```html
<script lang="ts">
  import { Button, Select } from '@svelte-fui/core';
  import { setupState } from '$lib/stores/setupStore';
  import { onMount } from 'svelte';

  // Acquire the vscode API only once
  const vscode = acquireVsCodeApi();

  function startDatabase() {
    // Disable button to prevent multiple clicks
    // You can add a 'loading' state here
    vscode.postMessage({ command: 'startDatabase' });
  }

  onMount(() => {
    const handleMessage = (event: MessageEvent) => {
      const message = event.data; // The JSON data from the extension
      if (message.command === 'databaseStatus') {
        console.log(`Received status: ${message.status}`);
        setupState.update(s => ({ ...s, databaseReady: message.status === 'running' }));
      }
    };

    window.addEventListener('message', handleMessage);

    // Cleanup listener when component is destroyed
    return () => {
      window.removeEventListener('message', handleMessage);
    };
  });
</script>

<div class="space-y-4 p-4 border rounded-md">
  <h3 class="text-lg font-semibold">Database Configuration</h3>
  <div class="flex items-center space-x-4">
    <Select items={['Qdrant']} placeholder="Select Database" class="flex-grow" />
    <Button variant="primary" on:click={startDatabase}>Start Local Qdrant</Button>
  </div>
  <div>
    <span>Status:</span>
    {#if $setupState.databaseReady}
      <span class="text-green-500"> Running</span>
    {:else}
      <span class="text-gray-500"> Not Running</span>
    {/if}
  </div>
</div>
```

### 2. Backend Logic (`src/extension.ts`)

The extension needs to listen for the `startDatabase` message and then perform two key actions:
1.  Run the Docker command.
2.  Poll a health check endpoint to verify the service is running.

```typescript
// src/extension.ts inside the onDidReceiveMessage handler

case 'startDatabase': {
    const terminal = vscode.window.createTerminal('Qdrant');
    // Assumes docker-compose.yml is in the root of the workspace
    terminal.sendText('docker-compose up');
    terminal.show();

    // Start polling for Qdrant health
    pollQdrantHealth(panel);
    return;
}

// ...

function pollQdrantHealth(panel: vscode.WebviewPanel) {
    let attempts = 0;
    const maxAttempts = 30; // Poll for 30 seconds (30 * 1000ms)
    const interval = 1000; // 1 second

    const intervalId = setInterval(async () => {
        if (attempts >= maxAttempts) {
            clearInterval(intervalId);
            vscode.window.showErrorMessage('Qdrant health check timed out.');
            // Optionally send a 'failed' status to the webview
            panel.webview.postMessage({ command: 'databaseStatus', status: 'failed' });
            return;
        }

        try {
            // Qdrant's default health check endpoint
            const response = await fetch('http://localhost:6333/healthz');
            if (response.ok) {
                clearInterval(intervalId);
                vscode.window.showInformationMessage('Qdrant is running!');
                panel.webview.postMessage({ command: 'databaseStatus', status: 'running' });
            }
        } catch (error) {
            // Ignore errors until timeout
            attempts++;
        }
    }, interval);
}
```

**Important Considerations:**
*   **Error Handling:** The `pollQdrantHealth` function should handle timeouts and fetch errors gracefully. It's crucial to inform the user if the database fails to start, perhaps with an error notification in VS Code.
*   **Hardcoded URL:** The URL `http://localhost:6333` is the default for Qdrant. For a more robust solution, this should be configurable.
*   **User Experience:** Provide feedback to the user that a health check is in progress (e.g., a "Checking..." status in the UI).

### 3. State Management (`setupStore.ts`)

The Svelte store remains simple for this sub-sprint. The `databaseReady` flag is the key piece of state managed here, which will be updated based on messages from the extension backend.

**File:** `webview/src/lib/stores/setupStore.ts`
```typescript
import { writable } from 'svelte/store';

export interface SetupState {
  databaseReady: boolean;
  providerSelected: string | null;
}

export const setupState = writable<SetupState>({
  databaseReady: false,
  providerSelected: null,
});
```
This typed store will help prevent errors and improve autocompletion in the Svelte components.
</file>

<file path="docs/completed/fe/implementation_sub_sprint_2_embedding_provider_workflow_logic.md">
# Implementation Guidance: Sub-Sprint 2 - Embedding Provider & Workflow Logic

**Objective:** To provide instructions for creating the `EmbeddingSetup.svelte` component and managing the application state to control the main indexing workflow.

---

### 1. Component Structure (`EmbeddingSetup.svelte`)

This component allows the user to select their preferred embedding provider. The selection will be stored in our central Svelte store.

**File:** `webview/src/lib/components/EmbeddingSetup.svelte`

```html
<script lang="ts">
  import { Select } from '@svelte-fui/core';
  import { setupState } from '$lib/stores/setupStore';

  const embeddingProviders = [
    { label: 'Ollama (Local)', value: 'ollama' },
    { label: 'OpenAI', value: 'openai' }
  ];

  // This function updates the central store when a selection is made.
  function handleProviderSelect(event: CustomEvent<{ value: string; label: string }>) {
    if (event.detail.value) {
      setupState.update(s => ({ ...s, providerSelected: event.detail.value }));
    }
  }
</script>

<div class="space-y-4 p-4 border rounded-md">
  <h3 class="text-lg font-semibold">Embedding Provider</h3>
  <Select
    items={embeddingProviders}
    placeholder="Select a provider"
    on:change={handleProviderSelect}
    class="w-full"
  />
  {#if $setupState.providerSelected}
    <p class="text-sm text-gray-600">You have selected: {$setupState.providerSelected}</p>
  {/if}
</div>
```

### 2. Finalizing the Workflow (`SetupView.svelte` / `+page.svelte`)

The main view component will now bring everything together. It will use a Svelte "derived store" (`$:` syntax) to automatically compute whether the "Index Now" button should be enabled.

**File:** `webview/src/routes/+page.svelte`

```html
<script lang="ts">
  import { Button } from '@svelte-fui/core';
  import { setupState } from '$lib/stores/setupStore';
  import DatabaseSetup from '$lib/components/DatabaseSetup.svelte';
  import EmbeddingSetup from '$lib/components/EmbeddingSetup.svelte';

  // Acquire the vscode API once at the top level
  const vscode = acquireVsCodeApi();

  // This is a "derived" variable. It will automatically update
  // whenever the values inside $setupState change.
  $: canStartIndex = $setupState.databaseReady && $setupState.providerSelected;

  function startIndexing() {
    if (!canStartIndex) return; // Safety check

    // Send the entire configuration state to the backend
    vscode.postMessage({
      command: 'startIndexing',
      config: $setupState
    });
  }
</script>

<div class="p-8 space-y-6">
  <h1 class="text-2xl font-bold">Code Context Setup</h1>

  <DatabaseSetup />
  <EmbeddingSetup />

  <div class="pt-6 text-center">
    <Button
      variant="accent"
      class="w-full max-w-xs"
      disabled={!canStartIndex}
      on:click={startIndexing}
    >
      Index Now
    </Button>
    {#if !canStartIndex}
      <p class="text-sm text-gray-500 mt-2">
        Please start the database and select an embedding provider to continue.
      </p>
    {/if}
  </div>
</div>
```

### 3. Backend Logic (`src/extension.ts`)

The final step is to handle the `startIndexing` message in the extension. For this sub-sprint, we will simply acknowledge the message and log the configuration. In a future sprint, this is where the logic to write the `code-context.json` file and trigger the backend indexing process would go.

```typescript
// src/extension.ts inside the onDidReceiveMessage handler

case 'startIndexing': {
    const config = message.config; // config is the SetupState object
    console.log('Received configuration:', config);

    // 1. Save the configuration to code-context.json
    // const workspaceFolders = vscode.workspace.workspaceFolders;
    // if (workspaceFolders) {
    //   const configPath = vscode.Uri.joinPath(workspaceFolders[0].uri, 'code-context.json');
    //   const configData = Buffer.from(JSON.stringify(config, null, 2));
    //   await vscode.workspace.fs.writeFile(configPath, configData);
    // }

    // 2. Show a confirmation to the user
    vscode.window.showInformationMessage(
        `Configuration saved! Starting indexing with ${config.providerSelected}.`
    );

    // 3. Close the webview panel
    panel.dispose();

    // 4. (Future) Trigger the actual indexing process in the C# backend.
    return;
}
```

This completes the frontend workflow for the setup view. The UI now captures all necessary user input and sends it to the extension backend when the user is ready to proceed.
</file>

<file path="docs/completed/fe/prd.md">
<prd>Here is the software engineering roadmap based on your detailed project description.

| # | Theme | Milestone & Description | Timeframe | Assigned Team | Status |
| :- | :--- | :--- | :--- | :--- | :--- |
| 1 | **Backend Architecture** | **Develop C# Web API Foundation:** Build the initial ASP.NET Core Web API project, establishing the core service for the extension to communicate with. | Q1 2026 | Backend (C#) | Planned |
| 2 | **Backend Architecture** | **Implement Extensible Client Framework:** Use dependency injection and strategy patterns in C# to create abstract interfaces for various database clients and embedding providers. | Q1 2026 | Backend (C#) | Planned |
| 3 | **Extension Integration** | **Establish Extension-to-Backend Communication:** Implement logic in the TypeScript extension to manage (start/monitor) the C# backend process and communicate via local HTTP requests. | Q2 2026 | Frontend (TS/Svelte) | Not Started |
| 4 | **Onboarding & UI** | **Build Initial Setup & Indexing UI:** Create the Svelte UI that detects an un-indexed repository and presents the setup screen for database and embedding provider selection. | Q2 2026 | Frontend (TS/Svelte) | Not Started |
| 5 | **Core Functionality** | **Implement Qdrant & Ollama Clients:** Build the first concrete client implementations for the database (Qdrant) and embedding provider (Ollama) within the C# backend. | Q3 2026 | Backend (C#) | Not Started |
| 6 | **Onboarding & UI** | **Integrate Docker Helper Commands:** Connect the UI buttons to open a VS Code terminal and execute the required Docker commands for spinning up local databases. | Q3 2026 | Frontend (TS/Svelte) | Not Started |
| 7 | **Core Functionality** | **Develop End-to-End Indexing Workflow:** Connect the UI "Index" button to the C# API to trigger the full AST parsing, embedding, and vector storage process, showing progress in the UI. | Q4 2026 | Full Team | Not Started |
| 8 | **Core Functionality** | **Implement Core Query View:** Create the post-indexing UI with a simple input box for users to submit natural language queries to the C# backend for a response. | Q4 2026 | Full Team | Not Started |
| 9 | **Feature Enhancement** | **Build Settings Management & Re-Indexing:** Implement the settings (cog) icon functionality and the logic to trigger a full re-index when a user saves configuration changes. | Q1 2027 | Full Team | Not Started |

Of course. Let's continue with the detailed PRDs for the C\# backend and the UI onboarding, following the established roadmap.

-----

### **New Document: PRD 2: Backend Foundation - C\# Web API & Extensible Clients**

**1. Title & Overview**

  * **Project:** Code Context Engine - C\# Backend Foundation
  * **Summary:** This phase covers the creation of a robust, standalone C\# ASP.NET Core Web API. This backend service will handle all heavy lifting, including code parsing, vectorization, and database communication. The architecture will be designed for extensibility from day one, using dependency injection and abstract client interfaces to easily support various databases and embedding providers in the future.
  * **Dependencies:** Requires the .NET SDK and a C\# development environment (like VS Code with the C\# Dev Kit or Visual Studio).

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Decouple the core processing logic from the VS Code extension frontend, allowing for more robust and scalable development.
      * Create a flexible architecture that can adapt to new technologies (databases, embedding models) without significant refactoring.
  * **Developer & System Success Metrics:**
      * The C\# Web API project is successfully created and can be run locally.
      * A basic `/health` endpoint returns a `200 OK` status.
      * The service architecture correctly implements the strategy or factory pattern for database and embedding clients.
      * The solution includes separate class library projects for core logic, infrastructure, and the API, promoting clean architecture.
      * Unit tests are in place for the client abstraction layer.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha is responsible for building and maintaining the core indexing engine. She needs a well-structured, testable, and maintainable codebase that follows best practices for C\# development, such as dependency injection and clear separation of concerns.
  * **Devin (Developer - End User):** While Devin doesn't interact with this backend directly, he will benefit from its stability and performance. A well-architected backend ensures the indexing process is fast, reliable, and less prone to crashing.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Backend** | **Sprint 1: C\# Web API Boilerplate** | As Alisha, I want to create a new ASP.NET Core Web API project so we have the foundational service for our backend logic. | 1. A new .NET solution is created containing a Web API project.\<br/\>2. The API is configured to use minimal API syntax for endpoints.\<br/\>3. A basic `/health` endpoint is implemented that returns a success status.\<br/\>4. The project includes Swagger/OpenAPI support for API documentation and testing. | **2 Weeks** |
| | | As Alisha, I want to establish a clean architecture with separate projects for Core, Infrastructure, and API so that our codebase is organized and maintainable. | 1. The solution is organized into `CodeContext.Api`, `CodeContext.Core` (for domain logic/interfaces), and `CodeContext.Infrastructure` (for external clients).\<br/\>2. Project references are set up correctly (e.g., API depends on Core and Infrastructure).\<br/\>3. Basic folders and classes are created in each project to establish the structure. | |
| **Phase 2: Backend** | **Sprint 2: Extensible Client Framework** | As Alisha, I want to define abstract interfaces for database clients and embedding providers so we can easily add new implementations in the future. | 1. An `IEmbeddingProvider` interface with a `GenerateEmbeddingsAsync` method is created in `CodeContext.Core`.\<br/\>2. An `IVectorDatabaseClient` interface with `UpsertAsync` and `QueryAsync` methods is created in `CodeContext.Core`.\<br/\>3. These interfaces are agnostic of any specific technology (e.g., they use generic data types). | **2 Weeks** |
| | | As Alisha, I want to use dependency injection to register and resolve these clients so that the application is loosely coupled and testable. | 1. .NET's built-in dependency injection container is configured in `Program.cs`.\<br/\>2. A "factory" or "strategy" service is created that can resolve the correct client implementation based on a configuration string (e.g., "qdrant", "ollama").\<br/\>3. Unit tests are written to verify that the correct client is returned for a given configuration. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** C\# Web API Boilerplate (2 Weeks)
  * **Sprint 2:** Extensible Client Framework (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The development team is proficient in C\# and the .NET ecosystem.
  * **Risk:** Over-engineering the client framework. The initial design for the abstractions might be too complex for the immediate need.
      * **Mitigation:** Start with a simple interface and concrete implementation first (e.g., for Qdrant). Refactor to a more abstract factory pattern only when adding the second client (e.g., ChromaDB), following the rule of three.
  * **Risk:** Communication between the TypeScript extension and a C\# process can be complex to manage (e.g., starting, stopping, and handling errors).
      * **Mitigation:** This risk is primarily addressed in PRD 3, but in this phase, ensure the C\# API is simple and stateless (standard HTTP requests) to minimize integration complexity.

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - C\# Web API Boilerplate

**Goal:** To establish the foundational C\# ASP.NET Core Web API project with a clean architecture.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Create .NET Solution & Projects:** Use the `dotnet new` CLI to create a solution file (`CodeContext.sln`) and three projects: `webapi`, `classlib` (for Core), and `classlib` (for Infrastructure). | `(Project Root)` |
| **1.2** |  To Do | **Set Project References:** Configure the `.csproj` files so that the API project references the Core and Infrastructure projects. | `CodeContext.Api/CodeContext.Api.csproj` |
| **1.3** |  To Do | **Implement Health Check Endpoint:** In the `Program.cs` of the API project, add a minimal API endpoint for `/health` that returns `Results.Ok()`. | `CodeContext.Api/Program.cs` |
| **1.4** |  To Do | **Add Swagger/OpenAPI:** Configure the API to use Swashbuckle for generating an OpenAPI specification and a Swagger UI. | `CodeContext.Api/Program.cs` |
| **1.5** |  To Do | **Define Core Interfaces:** In the Core project, create initial placeholder interfaces (`IEmbeddingProvider.cs`, `IVectorDatabaseClient.cs`). | `CodeContext.Core/` |
| **1.6** |  To Do | **Define Infrastructure Placeholders:** In the Infrastructure project, create initial placeholder folders for `DatabaseClients` and `EmbeddingProviders`. | `CodeContext.Infrastructure/` |
| **1.7** |  To Do | **Test API Launch:** Run the API project and ensure it starts correctly, and that you can access the `/health` endpoint and the `/swagger` UI in a browser. | `(Local Environment)` |

-----

### **New Document: PRD 3: VS Code Integration & UI Onboarding**

**1. Title & Overview**

  * **Project:** Code Context Engine - VS Code Integration & Onboarding
  * **Summary:** This phase focuses on the user's first experience. It involves building the Svelte UI for the initial setup and creating the TypeScript logic within the VS Code extension to manage the C\# backend process. This includes detecting when a repository hasn't been indexed, guiding the user through database and embedding model selection, and providing helper buttons to run Docker commands.
  * **Dependencies:** PRD 1 and PRD 2 must be complete. The C\# backend must be buildable and runnable from the command line.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Create a smooth and intuitive onboarding experience to maximize user activation.
      * Abstract away technical complexity (like running Docker) to make the tool accessible to a wider range of developers.
  * **Developer & System Success Metrics:**
      * The TypeScript extension can successfully spawn the C\# backend as a child process.
      * The extension can reliably check the health of the C\# backend by polling the `/health` endpoint.
      * The Svelte UI correctly displays the setup screen when no index configuration is found.
      * Clicking the "Start Database" button in the UI successfully opens a new VS Code terminal and runs the `docker-compose up` command.
      * The UI state updates correctly to show that the database is "running" after a successful health check.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: Integration & UI** | **Sprint 3: Backend Process Management** | As a developer, I want the VS Code extension to automatically start the C\# backend service when the extension is activated, so I don't have to run it manually. | 1. The extension uses Node.js's `child_process.spawn` to launch the compiled C\# executable.\<br/\>2. The extension correctly captures `stdout` and `stderr` from the C\# process for logging.\<br/\>3. The child process is automatically terminated when the extension is deactivated or VS Code is closed. | **2 Weeks** |
| | | As a developer, I want the extension to monitor the health of the C\# backend service so it can reliably send API requests. | 1. The extension periodically sends an HTTP GET request to the backend's `/health` endpoint.\<br/\>2. The UI state reflects whether the backend is "Starting", "Running", or "Error".\<br/\>3. If the health check fails multiple times, the process is restarted. | |
| **Phase 3: Integration & UI** | **Sprint 4: Onboarding & Setup UI** | As Devin, when I open a new project, I want the extension to check if it's been indexed and show me a setup screen if it hasn't. | 1. On activation, the extension looks for the `code-context.json` file in the `.vscode` directory.\<br/\>2. If the file is not found, the main webview panel displays the "Setup" component.\<br/\>3. If the file is found, the main webview panel displays the "Query" component (to be built later). | **2 Weeks** |
| | | As Devin, I want the setup screen to let me choose my database and embedding provider, with helper buttons to start any required local services. | 1. The UI presents dropdowns for selecting a database (Qdrant, etc.) and embedding provider (Ollama, etc.).\<br/\>2. A button next to the database selection ("Start Local Qdrant") is present.\<br/\>3. Clicking the button creates a new VS Code terminal and runs the appropriate `docker-compose` command.\<br/\>4. The UI shows a success indicator once the service is confirmed to be running via a health check. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 3:** Backend Process Management (2 Weeks)
  * **Sprint 4:** Onboarding & Setup UI (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The C\# backend executable can be reliably located and run from the TypeScript extension across different operating systems (Windows, macOS, Linux).
  * **Risk:** Managing the lifecycle of the child C\# process could be buggy, leading to orphaned processes that consume system resources.
      * **Mitigation:** Implement robust error handling and ensure the process is always killed in the `deactivate` function of the extension. Use libraries like `tree-kill` if necessary to ensure the entire process tree is terminated.
  * **Risk:** The user may not have Docker installed or running, causing the helper commands to fail.
      * **Mitigation:** Provide clear error messages in the UI and terminal. The UI should check for the `docker` command on the system's PATH and disable the button with a helpful tooltip if it's not found.

Of course. Here are the final PRDs and their associated task lists, completing the project roadmap.

-----

### **New Document: PRD 4: Core Functionality - End-to-End Indexing & Querying**

**1. Title & Overview**

  * **Project:** Code Context Engine - Core Functionality Implementation
  * **Summary:** This phase is about bringing the core user journey to life. It involves implementing the first concrete clients for Qdrant and Ollama within the C\# backend. We will then connect the UI to the backend to create a seamless, end-to-end indexing workflow. Finally, we will build the initial chat/query interface, allowing users to ask their first questions and receive contextually relevant answers from their indexed codebase.
  * **Dependencies:** PRD 3 must be complete. The extension must be able to manage the C\# backend process and display the initial setup UI.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Deliver the "Aha\!" moment for the user by providing the first tangible results from their indexed code.
      * Validate the end-to-end architecture, from UI interaction to backend processing and back.
  * **Developer & System Success Metrics:**
      * The C\# backend can successfully generate embeddings using a local Ollama instance and store them in a local Qdrant database.
      * The `IndexingService` in the C\# backend correctly orchestrates the full pipeline: AST parsing, embedding, and database upserting.
      * The UI's "Index Now" button successfully triggers the indexing process via an API call to the C\# backend.
      * The UI displays a real-time progress bar that accurately reflects the status sent from the backend.
      * A user can type a query into the main chat box, and the extension will return a list of relevant file paths based on a vector search.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin has just completed the initial setup. He now wants to see the extension in action. He needs a simple interface to start the indexing, see that it's working, and then ask a basic question to see if the tool can find relevant code for him.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 4: Core Functionality** | **Sprint 5: Concrete Client Implementation (C\#)** | As Alisha, I want to implement the concrete client for Qdrant so that the backend can communicate with the vector database. | 1. A `QdrantClient` class is created in the Infrastructure project that implements `IVectorDatabaseClient`.\<br/\>2. The client correctly connects to the Qdrant instance specified in the configuration.\<br/\>3. The `UpsertAsync` method successfully saves vectors and their payloads to the database. | **2 Weeks** |
| | | As Alisha, I want to implement the concrete client for Ollama so that the backend can generate embeddings. | 1. An `OllamaProvider` class is created that implements `IEmbeddingProvider`.\<br/\>2. The provider makes successful HTTP POST requests to a local Ollama `/api/embeddings` endpoint.\<br/\>3. The class correctly parses the response to extract the embedding vectors.\<br/\>4. The implementation is registered with the dependency injection container. | |
| **Phase 4: Core Functionality** | **Sprint 6: End-to-End Indexing & Query UI** | As Devin, I want to click the "Index Now" button and see a progress bar while my code is being indexed so I have clear feedback on the process. | 1. Clicking the "Index Now" button in the Svelte UI sends a `POST /index` request to the C\# backend.\<br/\>2. The backend streams progress updates (e.g., via Server-Sent Events or WebSockets) back to the UI.\<br/\>3. The Fluent UI progress bar in the Svelte component updates based on the events received from the backend.\<br/\>4. The UI transitions to the "Query" view upon receiving a "completed" event. | **2 Weeks** |
| | | As Devin, after indexing is complete, I want to see a chat input box where I can type a question to find relevant code. | 1. A new "Query" Svelte component is created, featuring a text input and a submit button.\<br/\>2. Typing a query and hitting Enter sends a `POST /query` request to the C\# backend with the query text.\<br/\>3. The backend performs a vector search using the query and returns a list of file paths.\<br/\>4. The UI displays the returned file paths as a simple list. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 5:** Concrete Client Implementation (C\#) (2 Weeks)
  * **Sprint 6:** End-to-End Indexing & Query UI (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The selected Ollama embedding model provides sufficiently accurate embeddings for code to yield relevant search results.
  * **Risk:** The real-time progress update mechanism (e.g., SSE or WebSockets) could be complex to implement between the C\# backend and the VS Code webview.
      * **Mitigation:** Start with a simpler polling mechanism if a streaming approach proves too difficult. The frontend can poll a `/index/status` endpoint on the backend every few seconds to get the progress.
  * **Risk:** The performance of the end-to-end indexing on a large repository might be slow, leading to a poor user experience.
      * **Mitigation:** Focus on optimizing the "hot path" in the C\# backendspecifically, batching requests to the embedding provider and the database client to improve throughput.

-----

### **New Document: tasklist\_sprint\_05.md**

# Task List: Sprint 5 - Concrete Client Implementation (C\#)

**Goal:** To build the first concrete implementations for the database and embedding provider clients in the C\# backend.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** |  To Do | **Add Qdrant.Client NuGet Package:** Install the official Qdrant .NET client library into the `CodeContext.Infrastructure` project. | `CodeContext.Infrastructure/CodeContext.Infrastructure.csproj` |
| **5.2** |  To Do | **Implement `QdrantClient` Class:** Create the class that implements `IVectorDatabaseClient`. Implement the `UpsertAsync` method using the NuGet package's API. | `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs` |
| **5.3** |  To Do | **Implement `OllamaProvider` Class:** Create the class that implements `IEmbeddingProvider`. Use `HttpClient` to send requests to the Ollama API. | `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs` |
| **5.4** |  To Do | **Add AST Parsing Logic:** Integrate a C\# AST parsing library (e.g., Roslyn for C\#, a community library for others) into a new `ParsingService`. | `CodeContext.Core/Services/ParsingService.cs` |
| **5.5** |  To Do | **Create `IndexingService`:** Build the main service in `CodeContext.Core` that orchestrates the workflow: takes file paths, calls the `ParsingService`, the `IEmbeddingProvider`, and the `IVectorDatabaseClient`. | `CodeContext.Core/Services/IndexingService.cs` |
| **5.6** |  To Do | **Register Services with DI:** In the API project's `Program.cs`, register all new services and clients with the dependency injection container. | `CodeContext.Api/Program.cs` |
| **5.7** |  To Do | **Create `/index` Endpoint:** Create the initial API endpoint that will trigger the `IndexingService`. | `CodeContext.Api/Program.cs` |

-----

### **New Document: PRD 5: Feature Enhancement & Polish**

**1. Title & Overview**

  * **Project:** Code Context Engine - Settings & Release Readiness
  * **Summary:** This final phase focuses on polishing the user experience and preparing the extension for its first public release. It involves building the settings management UI, enabling users to change their configuration and trigger a re-index. It also includes creating essential user and contributor documentation and establishing a CI/CD pipeline to automate builds and deployments to the marketplace.
  * **Dependencies:** PRD 4 must be complete. The core indexing and querying loop must be functional.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Increase user trust and adoption through a professional and polished user experience.
      * Ensure the long-term maintainability and scalability of the project by automating the release process.
  * **Developer & System Success Metrics:**
      * The settings UI correctly reads from and writes to the extension's configuration.
      * Saving a new configuration (e.g., changing the embedding model) successfully triggers the re-indexing workflow.
      * A GitHub Actions workflow is in place that automatically builds and tests the extension on every pull request.
      * The extension is successfully published to the VS Code Marketplace via an automated pipeline.
      * The project's `README.md` provides clear instructions for installation and use.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 5: Polish** | **Sprint 7: Settings Management & Re-Indexing** | As Devin, I want a settings icon in the UI so I can go back and change my database or embedding provider at any time. | 1. A "cog" icon is added to the main UI panel.\<br/\>2. Clicking the icon navigates the webview to the "Setup" component, pre-filled with the current configuration.\<br/\>3. The current configuration is read from the `code-context.json` file. | **2 Weeks** |
| | | As Devin, when I save a change in the settings, I want the extension to automatically re-index my project so that my changes take effect. | 1. The "Save" button in the settings UI is relabeled "Save & Re-Index".\<br/\>2. Clicking the button first saves the new configuration to `code-context.json`.\<br/\>3. After saving, the extension automatically triggers the end-to-end indexing process.\<br/\>4. The UI displays the progress bar, and transitions back to the query view on completion. | |
| **Phase 5: Polish** | **Sprint 8: Documentation & Publishing** | As a project owner, I want a CI/CD pipeline to automate builds and testing so we can ensure code quality and release reliability. | 1. A GitHub Actions workflow is created to run on every pull request.\<br/\>2. The workflow includes steps to build the C\# backend and the SvelteKit frontend.\<br/\>3. The workflow runs all unit tests for both the backend and frontend.\<br/\>4. A separate, manually triggered "release" workflow is created to publish the extension. | **2 Weeks** |
| | | As Devin, I want clear documentation in the `README.md` file so I can easily understand how to install and use the extension. | 1. The `README.md` is updated with sections for "Features", "Installation", "Configuration", and a "Quick Start" guide.\<br/\>2. A short animated GIF is created to demonstrate the primary user workflow.\<br/\>3. A `CONTRIBUTING.md` file is added to guide potential contributors. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 7:** Settings Management & Re-Indexing (2 Weeks)
  * **Sprint 8:** Documentation & Publishing (2 Weeks)

-----

### **New Document: tasklist\_sprint\_06.md**

# Task List: Sprint 6 - End-to-End Indexing & Query UI

**Goal:** To connect the frontend and backend to create the core indexing and querying user workflows.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** |  To Do | **Implement Progress Reporting:** In the C\# `IndexingService`, implement a mechanism (e.g., a callback or event bus) to report progress updates. | `CodeContext.Core/Services/IndexingService.cs` |
| **6.2** |  To Do | **Create Progress Endpoint:** Expose progress updates via a WebSocket or Server-Sent Events (SSE) endpoint in the C\# API. | `CodeContext.Api/Program.cs` |
| **6.3** |  To Do | **Connect UI to Progress Endpoint:** In the SvelteKit UI, connect to the progress endpoint after triggering an index and update the progress bar component. | `webview/src/lib/components/IndexingView.svelte` |
| **6.4** |  To Do | **Create Query View Component:** Build the `QueryView.svelte` component with a text input for questions and an area to display results. | `webview/src/lib/components/QueryView.svelte` |
| **6.5** |  To Do | **Implement `/query` Endpoint in C\#:** Create the API endpoint that takes a query string, generates an embedding for it, and uses the `IVectorDatabaseClient` to perform a similarity search. | `CodeContext.Api/Program.cs` |
| **6.6** |  To Do | **Connect UI to `/query` Endpoint:** When the user submits a query in the UI, make a `POST` request to the `/query` endpoint and display the returned file paths. | `webview/src/lib/components/QueryView.svelte` |
| **6.7** |  To Do | **Implement UI State Transition:** Manage the application's state to correctly switch from the `IndexingView` to the `QueryView` upon successful completion. | `webview/src/lib/stores/viewStore.ts` |

This completes the full set of Product Requirements Documents and their associated task lists for your project. You now have a comprehensive, strategic plan that takes you from the initial architectural decisions all the way to a polished, publishable VS Code extension.

Of course. Let's continue with the remaining PRDs and task lists to complete the UI/UX development plan for your extension.

-----

### **New Document: PRD 2: UI/UX - Indexing Progress View**

**1. Title & Overview**

  * **Project:** Code Context Engine - Indexing Progress UI
  * **Summary:** This phase is dedicated to building the UI that provides users with clear, real-time feedback while their repository is being indexed. A well-executed progress view is crucial for user trust, as it communicates that the extension is working and prevents the perception of it being frozen or broken during a potentially long-running task.
  * **Dependencies:** PRD 1 (Onboarding & Setup UI) must be complete. The C\# backend must provide an endpoint (either WebSocket or SSE) that streams progress updates.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Improve user retention during the initial, critical indexing phase by providing a transparent and informative experience.
      * Reduce user friction and prevent premature cancellation of the indexing process.
  * **User Success Metrics:**
      * The progress bar accurately reflects the real-world progress of the indexing job with less than a 5% margin of error.
      * The status text updates clearly, informing the user of the current stage (e.g., "Parsing files", "Generating embeddings").
      * User-initiated cancellations of the indexing process are below 10%.

-----

**3. User Personas**

  * **Devin (Developer - End User):** After clicking "Index Now," Devin expects immediate feedback. He wants to see that the process has started and get a reasonable estimate of how long it might take. Clear progress indicators give him the confidence to let the extension run while he works on other things.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Progress UI** | **Sprint 2: Progress View Implementation** | As Devin, after starting the indexing, I want to see a dedicated view with a progress bar so I know that the process is running. | 1. After the "startIndexing" message is sent, the webview immediately transitions to the `IndexingProgressView` component.\<br/\>2. A Fluent UI `<ProgressBar>` is prominently displayed.\<br/\>3. A text label below the bar shows the current percentage and a status message (e.g., "0% - Initializing..."). | **2 Weeks** |
| | | As Devin, I want the progress bar and status text to update in real-time as the indexing proceeds through different stages. | 1. The SvelteKit frontend successfully establishes a connection to the backend's progress streaming endpoint.\<br/\>2. The progress bar's value is reactively bound to the percentage received from the backend.\<br/\>3. The status text updates to reflect the messages sent from the backend (e.g., file names, current stage).\<br/\>4. The UI gracefully handles a dropped connection and attempts to reconnect. | |
| | | As Devin, I want the view to automatically switch to the main query interface once the indexing is complete. | 1. Upon receiving a "completed" event from the backend, the progress bar fills to 100%.\<br/\>2. A "Complete" message is briefly displayed.\<br/\>3. After a short delay (e.g., 1-2 seconds), the application state changes, and the `QueryView` component is rendered. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 2:** Progress View Implementation (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The backend can provide reasonably accurate progress percentages. If the backend can only provide status messages, the progress bar might need to be an indeterminate one.
  * **Risk:** A WebSocket or SSE connection between the VS Code webview and a local C\# process might be blocked by local firewall or security software.
      * **Mitigation:** Provide a fallback mechanism where the UI polls a standard HTTP endpoint (`GET /index/status`) every few seconds. This is less efficient but more reliable.
  * **Risk:** The UI might become unresponsive if it receives a very high frequency of progress updates from the backend.
      * **Mitigation:** Implement throttling or debouncing on the frontend to ensure the UI only re-renders at a reasonable interval (e.g., every 100-200ms).

-----

### **New Document: Sub-Sprint 3: Backend Connection for Progress Updates**

**Objective:**
To establish the communication channel from the SvelteKit frontend to the C\# backend to receive real-time progress events.

**Parent Sprint:**
PRD 2, Sprint 2: Progress View Implementation

**Tasks:**

1.  **Choose Streaming Technology:** Decide on the technology for real-time updates (WebSockets are a good choice for this).
2.  **Implement WebSocket Client:** In the SvelteKit app, create a service that connects to the C\# backend's WebSocket endpoint when the indexing view is loaded.
3.  **Create Progress Store:** Implement a new Svelte store (`progressStore.ts`) to hold the current percentage and status message.
4.  **Update Store on Message:** The WebSocket client, upon receiving a message from the backend, will parse the data and update the `progressStore`.

**Acceptance Criteria:**

  * The frontend successfully connects to the backend's WebSocket server.
  * Messages sent from the backend are correctly received and logged in the frontend's developer console.
  * The `progressStore` is accurately updated with the received data.

**Dependencies:**

  * The C\# backend must have a WebSocket or SSE endpoint that broadcasts progress.

**Timeline:**

  * **Start Date:** 2026-01-19
  * **End Date:** 2026-01-23

-----

### **New Document: Sub-Sprint 4: Svelte Progress UI Component**

**Objective:**
To build the user-facing Svelte component that displays the indexing progress.

**Parent Sprint:**
PRD 2, Sprint 2: Progress View Implementation

**Tasks:**

1.  **Create `IndexingProgressView.svelte`:** Build the main component for this view.
2.  **Add Fluent UI ProgressBar:** Integrate and style the `<ProgressBar>` component.
3.  **Subscribe to Progress Store:** In the component's script, subscribe to the `progressStore` to get live updates.
4.  **Bind UI to Store:** Reactively bind the `value` of the progress bar and the content of the status text label to the data from the store.
5.  **Implement Completion Logic:** Use a reactive statement (`$:`) to watch for when the progress percentage reaches 100, then trigger a state change to navigate to the query view.

**Acceptance Criteria:**

  * The progress bar visually updates as the value in the store changes.
  * The status text correctly displays the message from the store.
  * When progress hits 100, the UI automatically transitions to the next view.

**Dependencies:**

  * Sub-Sprint 3 must be complete.

**Timeline:**

  * **Start Date:** 2026-01-26
  * **End Date:** 2026-01-30

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Progress View Implementation

**Goal:** To build the UI for displaying real-time indexing progress to the user.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Install WebSocket client library:** Add a library like `socket.io-client` or use the native browser `WebSocket` API. | `webview/package.json` |
| **2.2** |  To Do | **Create `progressStore.ts`:** Define a new Svelte store with `percentage` and `message` properties. | `webview/src/lib/stores/progressStore.ts` |
| **2.3** |  To Do | **Create `ProgressService.ts`:** Implement the client-side logic to connect to the backend WebSocket and update the `progressStore`. | `webview/src/lib/services/ProgressService.ts` |
| **2.4** |  To Do | **Build `IndexingProgressView.svelte` component:** Add the Fluent UI progress bar and text labels. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.5** |  To Do | **Connect Component to Store:** In the Svelte component, import and subscribe to the `progressStore`. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.6** |  To Do | **Implement UI Bindings:** Bind the `value` of the progress bar and the text content of the label to the store's reactive variables. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.7** |  To Do | **Implement View Transition Logic:** In the main view manager, listen for the "completion" state and switch the visible component to the `QueryView`. | `webview/src/lib/ViewManager.svelte` |
| **2.8** |  To Do | **Test with Mock Backend:** Create a mock backend service that sends simulated progress updates to test the UI in isolation. | `webview/src/lib/mocks/mockProgressService.ts` |

-----

### **New Document: PRD 3: UI/UX - Main Query & Results View**

**1. Title & Overview**

  * **Project:** Code Context Engine - Main Query Interface
  * **Summary:** This phase covers the development of the primary user interface where developers will interact with the indexed codebase. The design will focus on simplicity and efficiency, providing a clean, chat-like experience for asking questions and receiving results. This view is the core of the product's day-to-day value.
  * **Dependencies:** The indexing process must be complete, and the C\# backend must expose a `/query` endpoint.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Drive daily active usage by providing a powerful and easy-to-use interface for code discovery.
      * Clearly demonstrate the value of the indexing process by providing fast, relevant search results.
  * **User Success Metrics:**
      * The time from submitting a query to seeing the first result is less than 2 seconds.
      * The UI for displaying results is clear and allows users to easily identify and navigate to the relevant files.
      * The settings icon is easily discoverable, allowing users to return to the configuration view when needed.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: Query UI** | **Sprint 3: Query & Results Implementation** | As Devin, after my project is indexed, I want to see a simple text box where I can type my question, so I can start searching immediately. | 1. The `QueryView` component is displayed after indexing is complete.\<br/\>2. A Fluent UI `<TextField>` is shown at the bottom of the view, styled like a chat input.\<br/\>3. A "Submit" button or icon is present, and pressing "Enter" also triggers a submission. | **2 Weeks** |
| | | As Devin, when I submit a query, I want to see the list of relevant files returned by the engine, so I can find the code I'm looking for. | 1. Submitting a query sends a `POST` request to the C\# backend's `/query` endpoint.\<br/\>2. While waiting for a response, a loading indicator is displayed.\<br/\>3. The returned list of file paths is displayed in a clean, scrollable list in the main view area.\<br/\>4. Each file path is a clickable link that opens the corresponding file in a new VS Code editor tab. | |
| | | As Devin, I want to be able to easily access the settings to re-configure my project, so I can change the embedding model or database later. | 1. A "cog" icon is displayed in the top-right corner of the view.\<br/\>2. Clicking the icon navigates the user back to the `SetupView` component.\<br/\>3. The `SetupView` is pre-populated with the project's current, saved configuration. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 3:** Query & Results Implementation (2 Weeks)

This completes the full set of Product Requirements Documents and associated task lists for the UI/UX of your extension. You now have a comprehensive plan covering the entire frontend user journey, from initial setup to actively querying the codebase.
</prd>
[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/completed/setup/backlog_sprint_6_lsp_integration_devops.md">
### User Story 1: LSP Data Integration into Index

**As a** developer, **I want to** capture data from the Language Server Protocol (LSP) during indexing, **so that** the code context index includes rich relationship information (e.g., definitions, references).

**Actions to Undertake:**
1.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Modify the `IndexingService` to interact with the active LSP for supported languages.
    -   **Implementation**: (Add logic to query LSP for definitions and references for each code chunk)
        ```typescript
        // Inside IndexingService.startIndexing loop, after chunking:
        // For each chunk, query LSP for definitions/references
        const definitions = await vscode.commands.executeCommand(
            'vscode.executeDefinitionProvider',
            vscode.Uri.file(file),
            new vscode.Position(chunk.startLine, 0) // Adjust position as needed
        );
        // Process definitions and add to chunk metadata

        const references = await vscode.commands.executeCommand(
            'vscode.executeReferenceProvider',
            vscode.Uri.file(file),
            new vscode.Position(chunk.startLine, 0) // Adjust position as needed
        );
        // Process references and add to chunk metadata
        ```
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/db/qdrantService.ts`
    -   **Action**: Update the `QdrantService` to store the new LSP-derived relationship metadata alongside the vectors.
    -   **Implementation**: (Modify `upsertChunks` to accept and store additional payload fields for LSP data)
        ```typescript
        // In QdrantService.upsertChunks, modify payload:
        payload: {
            filePath: chunk.filePath,
            content: chunk.content,
            startLine: chunk.startLine,
            endLine: chunk.endLine,
            type: chunk.type,
            // New LSP metadata fields
            definitions: chunk.definitions, // Example
            references: chunk.references,   // Example
        },
        ```
    -   **Imports**: None.

### User Story 2: CI/CD Pipeline with GitHub Actions

**As a** developer, **I want to** set up a CI/CD pipeline using GitHub Actions, **so that** the build, test, and packaging process for the extension is automated.

**Actions to Undertake:**
1.  **Filepath**: `.github/workflows/ci.yml` (New File)
    -   **Action**: Create a new GitHub Actions workflow file.
    -   **Implementation**: (Initial workflow structure)
        ```yaml
        name: CI/CD

        on: [push, pull_request]

        jobs:
          build:
            runs-on: ubuntu-latest
            steps:
              - uses: actions/checkout@v3
              - name: Use Node.js
                uses: actions/setup-node@v3
                with:
                  node-version: '18'
              - name: Install dependencies
                run: npm install
              - name: Run lint
                run: npm run lint
              - name: Run tests
                run: npm test
              - name: Build VS Code Extension
                run: npm run vscode:prepublish
              - name: Upload artifact
                uses: actions/upload-artifact@v3
                with:
                  name: vsix-package
                  path: ./*.vsix
        ```
    -   **Imports**: None.
2.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Configure the workflow to be triggered on `push` and `pull_request` events.
    -   **Implementation**: (See `on` section in the YAML above)
    -   **Imports**: None.
3.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Add steps for installing dependencies, running linting, executing unit tests, and building the `.vsix` package.
    -   **Implementation**: (See `steps` section in the YAML above)
    -   **Imports**: None.

**Acceptance Criteria:**
-   The `IndexingService` successfully queries the LSP for definition and reference information for code chunks.
-   The `QdrantService` stores the LSP-derived metadata in Qdrant alongside the code chunk vectors.
-   A GitHub Actions workflow file (`.github/workflows/ci.yml`) is created and correctly configured.
-   Every push and pull request to the repository triggers the CI/CD workflow.
-   The workflow successfully installs dependencies, runs linting checks, executes unit tests, and builds the `.vsix` extension package.
-   The `.vsix` package is uploaded as a build artifact.

**Testing Plan:**
-   **Test Case 1**: Make a small code change that triggers the LSP (e.g., add a new function). Run the indexing process. Verify that the LSP data (definitions, references) is captured and stored in Qdrant (requires inspecting Qdrant data).
-   **Test Case 2**: Push a commit to a branch. Verify that a GitHub Actions workflow run is triggered.
-   **Test Case 3**: Create a pull request. Verify that a GitHub Actions workflow run is triggered for the pull request.
-   **Test Case 4**: Review the GitHub Actions workflow run logs to ensure all steps (install, lint, test, build) pass successfully.
-   **Test Case 5**: Verify that the `.vsix` package is available as a build artifact in the GitHub Actions run summary.
</file>

<file path="docs/completed/setup/backlog_sprint_7_documentation_publishing.md">
### User Story 1: Comprehensive User Documentation

**As a** user, **I want to** have clear and comprehensive documentation for the extension, **so that** I can easily install, configure, and use it.

**Actions to Undertake:**
1.  **Filepath**: `README.md`
    -   **Action**: Update the `README.md` file with a feature list, installation instructions, and a guide on configuring the settings.
    -   **Implementation**: (Write content for `README.md`)
        ```markdown
        # Code Context Engine VS Code Extension

        ## Features
        - Code indexing and semantic search
        - LSP integration for rich context
        - Customizable settings for embedding providers and database

        ## Installation
        1. Install from VS Code Marketplace (link to be added).
        2. Alternatively, clone this repository and run `vsce package` then `code --install-extension your-extension.vsix`.

        ## Configuration
        Access settings via `Ctrl+Shift+P` (Cmd+Shift+P) and search for "Code Context Engine: Open Settings".
        - **Embedding Provider**: Choose between Ollama, OpenAI, etc.
        - **Database Connection String**: Specify your Qdrant instance.

        ## Usage
        (Detailed steps on how to use the extension, e.g., how to trigger indexing, how to perform queries)
        ```
    -   **Imports**: None.
2.  **Filepath**: `assets/demo.gif` (New File)
    -   **Action**: Create an animated GIF demonstrating the core workflow of the extension.
    -   **Implementation**: (Use screen recording software to capture workflow and convert to optimized GIF)
        ```
        <!-- In README.md -->
        ![Demo GIF](assets/demo.gif)
        ```
    -   **Imports**: None.
3.  **Filepath**: `CONTRIBUTING.md` (New File)
    -   **Action**: Create a `CONTRIBUTING.md` file with guidelines for new developers.
    -   **Implementation**: (Write content for `CONTRIBUTING.md`)
        ```markdown
        # Contributing to Code Context Engine

        We welcome contributions! Here's how to get started:

        ## Setup
        1. Clone the repository.
        2. Run `npm install`.
        3. Open in VS Code.

        ## Running Tests
        `npm test`

        ## Submitting Changes
        - Fork the repository.
        - Create a new branch for your feature or bug fix.
        - Ensure your code adheres to our linting rules (`npm run lint`).
        - Write clear commit messages.
        - Open a pull request.
        ```
    -   **Imports**: None.

### User Story 2: Publish to VS Code Marketplace

**As a** project owner, **I want to** publish the extension to the VS Code Marketplace, **so that** it is easily discoverable and accessible to all users.

**Actions to Undertake:**
1.  **Filepath**: `(External)`
    -   **Action**: Create a publisher identity on the VS Code Marketplace.
    -   **Implementation**: (Follow instructions on VS Code Marketplace publisher creation)
    -   **Imports**: None.
2.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Update the GitHub Actions pipeline with a manual "release" trigger.
    -   **Implementation**: (Add `workflow_dispatch` to `on` section)
        ```yaml
        on:
          push:
            branches:
              - main
          pull_request:
            branches:
              - main
          workflow_dispatch: # Manual trigger
        ```
    -   **Imports**: None.
3.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Implement a job in the CI/CD pipeline that automatically packages and publishes the extension to the marketplace when triggered.
    -   **Implementation**: (Add a new job, potentially with `vsce publish` and secrets)
        ```yaml
        # ... existing build job ...

        release:
          needs: build # Ensure build job completes successfully first
          runs-on: ubuntu-latest
          if: github.event_name == 'workflow_dispatch' # Only run on manual trigger

          steps:
            - uses: actions/checkout@v3
            - name: Use Node.js
              uses: actions/setup-node@v3
              with:
                node-version: '18'
            - name: Install dependencies
              run: npm install
            - name: Download VSIX artifact
              uses: actions/download-artifact@v3
              with:
                name: vsix-package
            - name: Publish to VS Code Marketplace
              run: npx vsce publish -p ${{ secrets.VSCE_TOKEN }}
              env:
                VSCE_TOKEN: ${{ secrets.VSCE_TOKEN }}
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   The `README.md` file is updated with all required sections (features, installation, configuration, usage).
-   An animated GIF demonstrating the core workflow is present in the `assets` directory and linked in `README.md`.
-   A `CONTRIBUTING.md` file is created with clear guidelines for contributors.
-   A publisher identity is successfully created on the VS Code Marketplace.
-   The GitHub Actions workflow includes a manual trigger for publishing.
-   Triggering the release workflow successfully publishes the extension to the VS Code Marketplace.

**Testing Plan:**
-   **Test Case 1**: Review `README.md` and `CONTRIBUTING.md` for completeness, clarity, and accuracy.
-   **Test Case 2**: Verify the animated GIF plays correctly and effectively demonstrates the extension's functionality.
-   **Test Case 3**: Manually trigger the GitHub Actions release workflow. Monitor the workflow run for successful completion.
-   **Test Case 4**: After successful release, search for the extension on the VS Code Marketplace to confirm its presence and correct listing.
-   **Test Case 5**: Install the published extension in a fresh VS Code instance and verify its basic functionality.
</file>

<file path="docs/completed/setup/backlog_sub_sprint_1_vs_code_extension_boilerplate_setup.md">
### User Story 1: VS Code Extension Project Setup

**As a** developer, **I want to** set up a new VS Code extension project with a fundamental file structure and configuration, **so that** I have a clean and organized starting point for development.

**Actions to Undertake:**
1.  **Filepath**: `(Project Root)`
    -   **Action**: Generate a new TypeScript-based VS Code extension using `yo code`.
    -   **Implementation**: `npx yo code` (select "New Extension (TypeScript)")
    -   **Imports**: None.
2.  **Filepath**: `package.json`
    -   **Action**: Configure the extension's name, publisher, and activation events in `package.json`.
    -   **Implementation**: (Modify `name`, `publisher`, and `activationEvents` fields as per project requirements)
    -   **Imports**: None.
3.  **Filepath**: `(Project Root)`
    -   **Action**: Create separate directories for the `extension` (backend) and `webview` (frontend) source code.
    -   **Implementation**: `mkdir src/extension` and `mkdir src/webview` (or similar structure if `yo code` provides a different default)
    -   **Imports**: None.
4.  **Filepath**: `src/extension.ts`
    -   **Action**: Write the initial `extension.ts` file, including the `activate` and `deactivate` functions.
    -   **Implementation**: (Basic `activate` and `deactivate` functions with a sample command)
        ```typescript
        import * as vscode from 'vscode';

        export function activate(context: vscode.ExtensionContext) {
            console.log('Congratulations, your extension "your-extension-name" is now active!');

            let disposable = vscode.commands.registerCommand('your-extension-name.helloWorld', () => {
                vscode.window.showInformationMessage('Hello World from your-extension-name!');
            });

            context.subscriptions.push(disposable);
        }

        export function deactivate() {}
        ```
    -   **Imports**: `import * as vscode from 'vscode';`

**Acceptance Criteria:**
-   The extension can be launched in a VS Code development host.
-   A "Hello World" command from the extension can be successfully executed from the command palette.
-   The project structure is clean and logically separated, with distinct directories for backend and frontend concerns.

**Testing Plan:**
-   **Test Case 1**: Run the extension in a VS Code development host (`F5` in VS Code). Verify no errors occur on activation.
-   **Test Case 2**: Open the command palette (`Ctrl+Shift+P` or `Cmd+Shift+P`), search for "Hello World", and execute the command. Verify the "Hello World from your-extension-name!" information message appears.
-   **Test Case 3**: Inspect the project directory to confirm the presence of `src/extension` and `src/webview` (or equivalent) directories.
</file>

<file path="docs/completed/setup/backlog_sub_sprint_2_sveltekit_fluent_ui_integration.md">
### User Story 1: SvelteKit Webview Integration

**As a** developer, **I want to** integrate a SvelteKit application into a VS Code webview, **so that** I can build a rich and interactive user interface for the extension.

**Actions to Undertake:**
1.  **Filepath**: `webview/`
    -   **Action**: Initialize a new SvelteKit project within the `webview` directory.
    -   **Implementation**: `cd webview && npm create svelte@latest .` (select "Skeleton project", "TypeScript", "ESLint", "Prettier", "Vitest")
    -   **Imports**: None.
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Create the logic in `extension.ts` to render the SvelteKit app inside a VS Code webview panel.
    -   **Implementation**: (Add `createWebviewPanel` and `resolveWebviewView` logic, loading `index.html` from SvelteKit's build output)
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';

        export function activate(context: vscode.ExtensionContext) {
            // ... existing code ...

            let panel: vscode.WebviewPanel | undefined = undefined;

            context.subscriptions.push(
                vscode.commands.registerCommand('code-context-engine.openPanel', () => {
                    if (panel) {
                        panel.reveal(vscode.ViewColumn.One);
                    } else {
                        panel = vscode.window.createWebviewPanel(
                            'codeContextEngine',
                            'Code Context Engine',
                            vscode.ViewColumn.One,
                            {
                                enableScripts: true,
                                localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                            }
                        );

                        const svelteAppPath = vscode.Uri.file(
                            path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                        );
                        panel.webview.html = fs.readFileSync(svelteAppPath.fsPath, 'utf8');

                        panel.onDidDispose(
                            () => {
                                panel = undefined;
                            },
                            null,
                            context.subscriptions
                        );
                    }
                })
            );
        }

        // ... deactivate function ...
        ```
    -   **Imports**: `import * as path from 'path';`, `import * as fs from 'fs';` (need to import `fs` for `readFileSync`)

### User Story 2: Fluent UI Integration

**As a** developer, **I want to** integrate Microsoft's Fluent UI library into the SvelteKit project, **so that** I can build a consistent and professional-looking UI quickly.

**Actions to Undertake:**
1.  **Filepath**: `webview/package.json`
    -   **Action**: Add the Fluent UI Svelte library as a dependency to the SvelteKit project.
    -   **Implementation**: `cd webview && npm install @fluentui/web-components @fluentui/web-components-react @fluentui/react-components` (Note: The PRD mentions `svelte-fluent-ui`, but the official Fluent UI for web components is `@fluentui/web-components`. I will use the official one. If `svelte-fluent-ui` is a specific Svelte wrapper, it should be installed instead. I will assume the user meant the official Fluent UI components.)
    -   **Imports**: None.
2.  **Filepath**: `webview/src/routes/index.svelte` (or a new component like `MainPanel.svelte`)
    -   **Action**: Create a Svelte component for the main panel that includes an "Index Now" button and a placeholder for a progress bar from the Fluent UI library.
    -   **Implementation**: (Example using Fluent UI Web Components)
        ```html
        <script lang="ts">
          import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";

          provideFluentDesignSystem().register(
            fluentButton(),
            fluentProgressRing()
          );

          function handleIndexNow() {
            console.log("Index Now clicked!");
            // Logic to trigger indexing
          }
        </script>

        <main>
          <h1>Code Context Engine</h1>
          <fluent-button appearance="accent" @click="{handleIndexNow}">Index Now</fluent-button>
          <fluent-progress-ring style="margin-top: 20px;"></fluent-progress-ring>
        </main>

        <style>
          /* Basic styling */
          main {
            padding: 20px;
            font-family: sans-serif;
          }
        </style>
        ```
    -   **Imports**: `import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";`
3.  **Filepath**: `webview/src/app.html` (or global CSS)
    -   **Action**: Ensure the UI components automatically adapt to VS Code's light and dark themes.
    -   **Implementation**: (Utilize VS Code CSS variables for theming)
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <link rel="icon" href="/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            %sveltekit.head%
            <style>
              /* Apply VS Code theme colors */
              body {
                background-color: var(--vscode-editor-background);
                color: var(--vscode-editor-foreground);
              }
              /* Example for Fluent UI components */
              fluent-button {
                --accent-fill-rest: var(--vscode-button-background);
                --accent-fill-hover: var(--vscode-button-hoverBackground);
                --accent-fill-active: var(--vscode-button-background);
                --accent-foreground-rest: var(--vscode-button-foreground);
              }
              fluent-progress-ring {
                --accent-fill-rest: var(--vscode-progressBar-background);
              }
            </style>
          </head>
          <body data-sveltekit-preload-data="hover">
            <div style="display: contents">%sveltekit.body%</div>
          </body>
        </html>
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   The SvelteKit application renders correctly inside the VS Code extension panel when the command to open it is executed.
-   The "Index Now" button is visible and interactive (e.g., logs a message to the console when clicked).
-   UI components (button, progress bar) correctly reflect the active VS Code theme (light/dark) without manual intervention.

**Testing Plan:**
-   **Test Case 1**: Run the extension in a development host. Execute the command to open the webview panel. Verify the SvelteKit app loads and displays the "Index Now" button and progress bar.
-   **Test Case 2**: Click the "Index Now" button and check the VS Code developer console for the logged message.
-   **Test Case 3**: Change the VS Code theme (e.g., from Light to Dark) and observe if the Fluent UI components' styling (background, text color) adapts accordingly.
</file>

<file path="docs/completed/setup/backlog_sub_sprint_5_implement_context_query_api.md">
### User Story 1: Retrieve File Content via API

**As a** developer, **I want to** query the extension's backend to retrieve the content of a specific file, **so that** the frontend can display it to the user.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts` (New File)
    -   **Action**: Create a new `ContextService` class to encapsulate context retrieval logic.
    -   **Implementation**: 
        ```typescript
        import * as vscode from 'vscode';
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
        import { OllamaProvider } from '../embeddings/ollamaProvider'; // Example provider

        export class ContextService {
            private qdrantService: QdrantService;
            private embeddingProvider: IEmbeddingProvider;

            constructor() {
                this.qdrantService = new QdrantService();
                this.embeddingProvider = new OllamaProvider(); // This will be configurable later
            }

            public async getFileContent(filePathQuery: string): Promise<string | null> {
                // Placeholder: In a real scenario, you'd use embedding and Qdrant search
                // to find the most relevant file path based on the query.
                // For now, assume filePathQuery is an exact path for demonstration.
                try {
                    const uri = vscode.Uri.file(filePathQuery);
                    const contentBuffer = await vscode.workspace.fs.readFile(uri);
                    return contentBuffer.toString();
                } catch (error) {
                    console.error(`Error reading file ${filePathQuery}:`, error);
                    return null;
                }
            }

            public async findRelatedFiles(conceptOrFilePath: string, limit: number = 5): Promise<string[]> {
                // Placeholder: Implement actual vector search using embeddingProvider and QdrantService
                console.log(`Finding related files for: ${conceptOrFilePath}`);
                // Example: return dummy data
                return ["/path/to/related/file1.ts", "/path/to/related/file2.ts"];
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { QdrantService } from '../db/qdrantService';`, `import { IEmbeddingProvider } from '../embeddings/embeddingProvider';`, `import { OllamaProvider } from '../embeddings/ollamaProvider';`
2.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Implement the `getFileContent` method to read the content of a specified file from disk.
    -   **Implementation**: (See `getFileContent` in the `ContextService` implementation above)
    -   **Imports**: None.

### User Story 2: Find Related Files via API

**As a** developer, **I want to** query the extension's backend to find files related to a given concept or file path, **so that** the frontend can display relevant code context to the user.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Implement the `findRelatedFiles` method to perform a vector similarity search in Qdrant and return a list of relevant file paths.
    -   **Implementation**: (See `findRelatedFiles` in the `ContextService` implementation above. This will require actual integration with `embeddingProvider` and `qdrantService`.)
    -   **Imports**: None.

### User Story 3: Expose Backend API via Webview Message Passing

**As a** developer, **I want to** expose the `ContextService` methods to the SvelteKit frontend using VS Code's webview message passing, **so that** the frontend can interact with the backend API.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    -   **Action**: Set up a message listener on the webview panel to handle incoming requests from the frontend.
    -   **Implementation**: (Add `panel.webview.onDidReceiveMessage` handler)
        ```typescript
        // Inside activate function, after panel creation:
        panel.webview.onDidReceiveMessage(
            async message => {
                const contextService = new ContextService(); // Or pass an instance if already created
                switch (message.command) {
                    case 'getFileContent':
                        const fileContent = await contextService.getFileContent(message.filePath);
                        panel.webview.postMessage({ command: 'fileContentResult', content: fileContent });
                        return;
                    case 'findRelatedFiles':
                        const relatedFiles = await contextService.findRelatedFiles(message.query);
                        panel.webview.postMessage({ command: 'relatedFilesResult', files: relatedFiles });
                        return;
                }
            },
            undefined,
            context.subscriptions
        );
        ```
    -   **Imports**: `import { ContextService } from './context/contextService';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Route incoming messages to the appropriate `ContextService` method and send results back to the frontend.
    -   **Implementation**: (See `switch` statement and `panel.webview.postMessage` in the `onDidReceiveMessage` handler above)
    -   **Imports**: None.
3.  **Filepath**: `webview/src/lib/vscodeApi.ts` (New File)
    -   **Action**: Create a wrapper service in the SvelteKit app to simplify posting and listening for messages from the extension backend.
    -   **Implementation**: 
        ```typescript
        // webview/src/lib/vscodeApi.ts
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        export function postMessage(message: any) {
            vscode.postMessage(message);
        }

        export function onMessage(callback: (message: any) => void) {
            window.addEventListener('message', event => {
                callback(event.data);
            });
        }
        ```
    -   **Imports**: None.
4.  **Filepath**: `webview/src/routes/+page.svelte` (or relevant Svelte component)
    -   **Action**: Modify the frontend to send messages to the backend and handle responses.
    -   **Implementation**: 
        ```html
        <script lang="ts">
          import { postMessage, onMessage } from '../lib/vscodeApi';
          import { onMount } from 'svelte';

          let fileContent: string | null = null;
          let relatedFiles: string[] = [];

          onMount(() => {
            onMessage(message => {
              switch (message.command) {
                case 'fileContentResult':
                  fileContent = message.content;
                  break;
                case 'relatedFilesResult':
                  relatedFiles = message.files;
                  break;
              }
            });
          });

          function requestFileContent(filePath: string) {
            postMessage({ command: 'getFileContent', filePath });
          }

          function requestRelatedFiles(query: string) {
            postMessage({ command: 'findRelatedFiles', query });
          }
        </script>

        <button on:click={() => requestFileContent('/path/to/your/file.ts')}>Get File Content</button>
        {#if fileContent}
          <pre>{fileContent}</pre>
        {/if}

        <button on:click={() => requestRelatedFiles('authentication logic')}>Find Related Files</button>
        {#if relatedFiles.length > 0}
          <ul>
            {#each relatedFiles as file}
              <li>{file}</li>
            {/each}
          </ul>
        {/if}
        ```
    -   **Imports**: `import { postMessage, onMessage } from '../lib/vscodeApi';`, `import { onMount } from 'svelte';`

**Acceptance Criteria:**
-   When the frontend sends a `getFileContent` message with a valid file path, the backend responds with the correct file content.
-   When the frontend sends a `findRelatedFiles` message with a query, the backend responds with an array of relevant file paths.
-   The backend API gracefully handles cases where files are not found or no related files are identified, returning `null` or an empty array respectively.

**Testing Plan:**
-   **Test Case 1**: Manually trigger a `getFileContent` request from the frontend (e.g., via a button click). Verify that the correct file content is displayed in the webview.
-   **Test Case 2**: Manually trigger a `findRelatedFiles` request from the frontend. Verify that a list of related files is displayed.
-   **Test Case 3**: Test with a non-existent file path for `getFileContent` and verify the frontend handles the `null` response gracefully (e.g., displays an error message).
-   **Test Case 4**: Test with a query that yields no related files for `findRelatedFiles` and verify the frontend handles the empty array gracefully.
</file>

<file path="docs/completed/setup/backlog_sub_sprint_6_develop_settings_ui.md">
### User Story 1: Open Settings UI from Command Palette

**As a** user, **I want to** open the extension's settings UI from the VS Code Command Palette, **so that** I can easily access and configure the extension.

**Actions to Undertake:**
1.  **Filepath**: `package.json`
    -   **Action**: Define a new command in `package.json` to open the settings webview.
    -   **Implementation**: (Add to `contributes.commands` section)
        ```json
        {
            "command": "code-context-engine.openSettings",
            "title": "Code Context Engine: Open Settings"
        }
        ```
    -   **Imports**: None.
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Register the new command in `extension.ts` to create and show the settings webview panel.
    -   **Implementation**: (Add to `activate` function)
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';

        // ... existing activate function content ...

        let settingsPanel: vscode.WebviewPanel | undefined = undefined;

        context.subscriptions.push(
            vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                const columnToShowIn = vscode.window.activeTextEditor
                    ? vscode.window.activeTextEditor.viewColumn
                    : undefined;

                if (settingsPanel) {
                    settingsPanel.reveal(columnToShowIn);
                } else {
                    settingsPanel = vscode.window.createWebviewPanel(
                        'codeContextEngineSettings',
                        'Code Context Engine Settings',
                        columnToShowIn || vscode.ViewColumn.One,
                        {
                            enableScripts: true,
                            localResourceRoots: [
                                vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                            ]
                        }
                    );

                    const svelteAppPath = vscode.Uri.file(
                        path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                    );

                    let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');
                    htmlContent = htmlContent.replace(/\/\_app\//g, settingsPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                    settingsPanel.webview.html = htmlContent;

                    settingsPanel.onDidDispose(
                        () => {
                            settingsPanel = undefined;
                        },
                        null,
                        context.subscriptions
                    );
                }
            })
        );
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import * as path from 'path';`, `import * as fs from 'fs';`

### User Story 2: Display and Edit Settings in UI

**As a** user, **I want to** see and edit the extension's configuration settings (e.g., embedding provider, database connection string) in a dedicated UI, **so that** I can customize its behavior.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/routes/settings.svelte` (New File)
    -   **Action**: Create a new Svelte component for the settings UI, using Fluent UI components for input fields (e.g., `<fluent-select>`, `<fluent-text-field>`).
    -   **Implementation**: 
        ```html
        <script lang="ts">
          import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";
          import { onMount } from 'svelte';
          import { postMessage, onMessage } from '../lib/vscodeApi';

          provideFluentDesignSystem().register(
            fluentSelect(),
            fluentOption(),
            fluentTextField(),
            fluentButton()
          );

          let embeddingProvider: string = 'Ollama'; // Default value
          let databaseConnectionString: string = '';

          onMount(() => {
            // Request current settings from extension backend on component mount
            postMessage({ command: 'getSettings' });

            onMessage(message => {
              if (message.command === 'settingsResult') {
                embeddingProvider = message.settings.embeddingProvider || 'Ollama';
                databaseConnectionString = message.settings.databaseConnectionString || '';
              }
            });
          });

          function saveSettings() {
            const settings = {
              embeddingProvider,
              databaseConnectionString,
            };
            postMessage({ command: 'saveSettings', settings });
          }
        </script>

        <main>
          <h1>Extension Settings</h1>

          <fluent-text-field
            appearance="outline"
            placeholder="Database Connection String"
            bind:value={databaseConnectionString}
            style="width: 100%; margin-bottom: 15px;"
          >
            Database Connection String
          </fluent-text-field>

          <fluent-select
            appearance="outline"
            bind:value={embeddingProvider}
            style="width: 100%; margin-bottom: 20px;"
          >
            <fluent-option value="Ollama">Ollama</fluent-option>
            <fluent-option value="OpenAI">OpenAI</fluent-option>
            <!-- Add more options as needed -->
          </fluent-select>

          <fluent-button appearance="accent" @click={saveSettings}>Save Settings</fluent-button>
        </main>

        <style>
          main {
            padding: 20px;
            font-family: var(--vscode-font-family);
            color: var(--vscode-editor-foreground);
          }
          /* Basic styling for Fluent UI components to match VS Code theme */
          fluent-text-field,
          fluent-select {
            --neutral-fill-rest: var(--vscode-input-background);
            --neutral-foreground-rest: var(--vscode-input-foreground);
            --neutral-stroke-rest: var(--vscode-input-border);
            --neutral-fill-stealth-rest: var(--vscode-input-background);
            --neutral-fill-stealth-hover: var(--vscode-input-background);
            --neutral-fill-stealth-active: var(--vscode-input-background);
            --neutral-foreground-hover: var(--vscode-input-foreground);
            --neutral-foreground-active: var(--vscode-input-foreground);
            --neutral-stroke-hover: var(--vscode-input-border);
            --neutral-stroke-active: var(--vscode-input-border);
          }
          fluent-button {
            --accent-fill-rest: var(--vscode-button-background);
            --accent-foreground-rest: var(--vscode-button-foreground);
            --accent-fill-hover: var(--vscode-button-hoverBackground);
          }
        </style>
        ```
    -   **Imports**: `import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";`, `import { onMount } from 'svelte';`, `import { postMessage, onMessage } from '../lib/vscodeApi';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Implement a message handler in `extension.ts` to retrieve current settings from VS Code configuration and send them to the webview.
    -   **Implementation**: (Inside `onDidReceiveMessage` handler)
        ```typescript
        // ... existing message handling ...

        case 'getSettings':
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const currentSettings = {
                embeddingProvider: config.get('embeddingProvider'),
                databaseConnectionString: config.get('databaseConnectionString'),
            };
            settingsPanel?.webview.postMessage({ command: 'settingsResult', settings: currentSettings });
            return;
        ```
    -   **Imports**: None.

### User Story 3: Save Settings to VS Code Configuration

**As a** user, **I want to** save my changes to the extension's settings, **so that** my preferences are persisted across VS Code sessions.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    -   **Action**: Implement a message handler in `extension.ts` to receive updated settings from the webview and save them to VS Code workspace configuration.
    -   **Implementation**: (Inside `onDidReceiveMessage` handler)
        ```typescript
        // ... existing message handling ...

        case 'saveSettings':
            const newSettings = message.settings;
            const configToUpdate = vscode.workspace.getConfiguration('code-context-engine');
            await configToUpdate.update('embeddingProvider', newSettings.embeddingProvider, vscode.ConfigurationTarget.Global);
            await configToUpdate.update('databaseConnectionString', newSettings.databaseConnectionString, vscode.ConfigurationTarget.Global);
            vscode.window.showInformationMessage('Settings saved!');
            return;
        ```
    -   **Imports**: None.
2.  **Filepath**: `package.json`
    -   **Action**: Define the configuration schema in `package.json` under `contributes.configuration`.
    -   **Implementation**: (Add to `contributes` section)
        ```json
        "configuration": {
            "title": "Code Context Engine Configuration",
            "properties": {
                "code-context-engine.embeddingProvider": {
                    "type": "string",
                    "default": "Ollama",
                    "description": "Select the embedding provider to use (e.g., Ollama, OpenAI)."
                },
                "code-context-engine.databaseConnectionString": {
                    "type": "string",
                    "default": "http://localhost:6333",
                    "description": "Connection string for the Qdrant database."
                }
            }
        }
        ```
    -   **Imports**: None.

### User Story 4: Services Read from Configuration

**As a** developer, **I want to** ensure the extension's backend services (e.g., `IndexingService`, `QdrantService`) read their configuration from the VS Code workspace settings, **so that** user changes are applied correctly.

**Actions to Undertake:**
1.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Update `IndexingService` to read the selected embedding provider from the VS Code configuration.
    -   **Implementation**: (Modify constructor or relevant method)
        ```typescript
        // In IndexingService constructor or a setup method
        const config = vscode.workspace.getConfiguration('code-context-engine');
        const providerName = config.get<string>('embeddingProvider', 'Ollama');
        if (providerName === 'OpenAI') {
            this.embeddingProvider = new OpenAIProvider();
        } else {
            this.embeddingProvider = new OllamaProvider();
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { OpenAIProvider } from '../embeddings/openaiProvider';`, `import { OllamaProvider } from '../embeddings/ollamaProvider';`
2.  **Filepath**: `src/db/qdrantService.ts`
    -   **Action**: Update `QdrantService` to read the database connection string from the VS Code configuration.
    -   **Implementation**: (Modify constructor or client initialization)
        ```typescript
        // In QdrantService constructor
        const config = vscode.workspace.getConfiguration('code-context-engine');
        const connectionString = config.get<string>('databaseConnectionString', 'http://localhost:6333');
        this.client = new QdrantClient({ url: connectionString });
        ```
    -   **Imports**: `import * as vscode from 'vscode';`

**Acceptance Criteria:**
-   A new command "Code Context Engine: Open Settings" appears in the Command Palette.
-   Executing the command opens a new webview panel titled "Code Context Engine Settings".
-   The settings UI displays the default values for embedding provider and database connection string.
-   Changing values in the settings UI and clicking "Save Settings" updates the `settings.json` file (either user or workspace settings).
-   After saving, if the extension is reloaded or the relevant services are re-initialized, they pick up the new configuration values.

**Testing Plan:**
-   **Test Case 1**: Open the Command Palette, search for and execute "Code Context Engine: Open Settings". Verify the panel opens.
-   **Test Case 2**: Change the "Embedding Provider" to "OpenAI" and the "Database Connection String" to a custom value. Click "Save Settings". Close and reopen VS Code. Verify the settings persist.
-   **Test Case 3**: Verify that `IndexingService` and `QdrantService` instances (after re-initialization or extension reload) use the newly saved configuration values.
-   **Test Case 4**: Test with invalid connection strings or provider names to ensure graceful fallback to defaults or error handling.
</file>

<file path="docs/completed/setup/implementation_sprint_6_lsp_integration_devops.md">
### Implementation Guide: Sprint 6 - LSP Integration & DevOps

**Objective:** To enrich the index with LSP data and automate the build and test process.

#### **Analysis**

This sprint introduces two significant enhancements: integrating Language Server Protocol (LSP) data into the code context index and establishing a robust CI/CD pipeline using GitHub Actions. LSP integration will make the code context engine more intelligent by understanding semantic relationships within the code, going beyond mere syntactic parsing. The CI/CD pipeline will automate the build, test, and packaging process, ensuring code quality and a streamlined release workflow.

#### **Prerequisites and Setup**

1.  **Completed Indexing Pipeline:** Ensure the indexing, chunking, vectorization, and Qdrant storage (from Sprints 2 and 3) are fully functional.
2.  **GitHub Repository:** Your project must be hosted on GitHub to utilize GitHub Actions.

#### **Implementation Guide**

Here's a step-by-step guide to implementing LSP Integration and DevOps:

**1. LSP Data Integration into `IndexingService`**

To capture LSP data, you'll modify your `IndexingService` to programmatically query the active language server for information like definitions and references for each code chunk.

  *   **File:** `src/indexing/indexingService.ts`
  *   **API Information:**
      *   `vscode.commands.executeCommand()`: This is the key API to interact with VS Code's built-in commands, including those exposed by language servers.
      *   `vscode.executeDefinitionProvider`: Command to get definitions.
      *   `vscode.executeReferenceProvider`: Command to get references.
      *   `vscode.Position`: Represents a position in a text document.
      *   `vscode.Location`, `vscode.DefinitionLink`, `vscode.Reference`: Data structures returned by LSP commands.

  *   **Implementation Example (within `startIndexing` loop, after chunking):**
    ```typescript
    import * as vscode from 'vscode';
    // ... other imports

    export class IndexingService {
        // ... existing code ...

        private async processChunkWithLSP(fileUri: vscode.Uri, chunk: CodeChunk): Promise<void> {
            const position = new vscode.Position(chunk.startLine, 0); // Start of the chunk

            // Get Definitions
            try {
                const definitions = await vscode.commands.executeCommand<
                    vscode.Definition | vscode.DefinitionLink[]
                >('vscode.executeDefinitionProvider', fileUri, position);

                if (definitions) {
                    // Process definitions (e.g., extract URIs, ranges, etc.)
                    // Store relevant info in chunk.payload or a new property
                    // Example: chunk.lspDefinitions = definitions.map(d => ({ uri: d.uri.toString(), range: d.range }));
                }
            } catch (error) {
                console.warn(`LSP Definition Provider failed for ${fileUri.fsPath}:${chunk.startLine}:`, error);
            }

            // Get References
            try {
                const references = await vscode.commands.executeCommand<vscode.Reference[]>( 'vscode.executeReferenceProvider', fileUri, position);

                if (references) {
                    // Process references
                    // Example: chunk.lspReferences = references.map(r => ({ uri: r.uri.toString(), range: r.range }));
                }
            } catch (error) {
                console.warn(`LSP Reference Provider failed for ${fileUri.fsPath}:${chunk.startLine}:`, error);
            }
        }

        public async startIndexing(): Promise<void> {
            // ... existing file walking, parsing, chunking logic ...

            for (const file of files) {
                // ... existing parsing and chunking ...
                const fileUri = vscode.Uri.file(file);
                if (language) {
                    const tree = this.astParser.parse(language, content);
                    const chunks = this.chunker.chunk(file, tree, content);

                    for (const chunk of chunks) {
                        await this.processChunkWithLSP(fileUri, chunk); // Call LSP processing for each chunk
                        allChunks.push(chunk);
                    }
                }
            }
            // ... rest of indexing (embedding, Qdrant upsert) ...
        }
    }
    ```

**2. Extend Qdrant Metadata in `QdrantService`**

Modify your `QdrantService` to accept and store the new LSP-derived metadata as part of the payload when upserting chunks into Qdrant.

  *   **File:** `src/db/qdrantService.ts`
  *   **Key Concept:** Qdrant allows arbitrary JSON payloads to be stored alongside vectors. This is where you'll put your LSP data.

  *   **Implementation Example (modify `upsertChunks` method):**
    ```typescript
    import { QdrantClient } from '@qdrant/js-client-rest';
    import type { CodeChunk } from '../parsing/chunker';

    // Extend CodeChunk interface if not already done to include LSP data
    // declare module '../parsing/chunker' {
    //     interface CodeChunk {
    //         lspDefinitions?: { uri: string; range: any; }[];
    //         lspReferences?: { uri: string; range: any; }[];
    //     }
    // }

    export class QdrantService {
        // ... existing code ...

        public async upsertChunks(collectionName: string, chunks: CodeChunk[], vectors: number[][]): Promise<void> {
            const points = chunks.map((chunk, i) => ({
                id: `${chunk.filePath}:${chunk.startLine}-${chunk.endLine}`,
                vector: vectors[i],
                payload: {
                    filePath: chunk.filePath,
                    content: chunk.content,
                    startLine: chunk.startLine,
                    endLine: chunk.endLine,
                    type: chunk.type,
                    // Add LSP metadata to payload
                    lspDefinitions: chunk.lspDefinitions || [],
                    lspReferences: chunk.lspReferences || [],
                },
            }));

            await this.client.upsert(collectionName, {
                wait: true,
                points,
            });
        }
    }
    ```

**3. Create GitHub Actions Workflow**

Set up a new workflow file in your `.github/workflows/` directory. This file defines the automated steps for your CI/CD pipeline.

  *   **File:** `.github/workflows/ci.yml` (New File)
  *   **Key Concepts:**
      *   `on`: Defines when the workflow runs (e.g., `push`, `pull_request`).
      *   `jobs`: A workflow run is made up of one or more jobs.
      *   `runs-on`: The type of machine to run the job on.
      *   `steps`: A sequence of tasks to be executed.
      *   `actions/checkout`: Action to check out your repository.
      *   `actions/setup-node`: Action to set up Node.js environment.
      *   `npm install`, `npm run lint`, `npm test`, `npm run vscode:prepublish`: Standard commands for VS Code extension development.
      *   `actions/upload-artifact`: To save build artifacts.

  *   **Implementation Example:**
    ```yaml
    name: CI/CD

    on:
      push:
        branches:
          - main
      pull_request:
        branches:
          - main

    jobs:
      build:
        runs-on: ubuntu-latest

        steps:
          - name: Checkout repository
            uses: actions/checkout@v3

          - name: Set up Node.js
            uses: actions/setup-node@v3
            with:
              node-version: '18' # Or your project's Node.js version

          - name: Install dependencies
            run: npm install

          - name: Run lint
            run: npm run lint

          - name: Run tests
            run: npm test

          - name: Build VS Code Extension
            run: npm run vscode:prepublish # This command typically builds the .vsix

          - name: Upload VSIX artifact
            uses: actions/upload-artifact@v3
            with:
              name: vsix-package
              path: '*.vsix' # Adjust if your .vsix is in a different location
    ```

**4. Configure Linting, Testing, and Build Steps**

Ensure your `package.json` has the necessary scripts for linting, testing, and building, which the GitHub Actions workflow will then call.

  *   **File:** `package.json`
  *   **Key Concepts:**
      *   `"lint"`: Script for running your linter (e.g., ESLint).
      *   `"test"`: Script for running your unit tests (e.g., Vitest, Mocha).
      *   `"vscode:prepublish"`: Standard script for preparing your extension for publishing, which typically includes compiling TypeScript and packaging.

  *   **Example `scripts` section in `package.json`:**
    ```json
    "scripts": {
        "vscode:prepublish": "npm run compile",
        "compile": "tsc -p ./",
        "watch": "tsc -watch -p ./",
        "pretest": "npm run compile",
        "test": "node ./out/test/runTest.js",
        "lint": "eslint src --ext ts"
    },
    ```
    *Note: Adjust these scripts based on your actual project setup (e.g., if you use `vitest` directly, your `test` script would be `vitest`).*

This completes the implementation guide for Sprint 6. You now have a more intelligent indexing process leveraging LSP data and an automated CI/CD pipeline to ensure continuous quality and efficient development.
</file>

<file path="docs/completed/setup/implementation_sprint_7_documentation_publishing.md">
### Implementation Guide: Sprint 7 - Documentation & Publishing

**Objective:** To create high-quality documentation and publish the extension to the marketplace.

#### **Analysis**

This final sprint focuses on the crucial aspects of product delivery: comprehensive documentation and marketplace publishing. Effective documentation (README, contributing guide) is vital for user adoption and community engagement. Publishing to the VS Code Marketplace makes the extension discoverable and easily installable. Automating the publishing process via GitHub Actions ensures consistency and reduces manual errors.

#### **Prerequisites and Setup**

1.  **Completed Extension:** The extension should be fully functional and tested from previous sprints.
2.  **GitHub Repository:** Your project must be hosted on GitHub.
3.  **VS Code Extension Publisher Account:** You will need to create one on the Azure DevOps organization for VS Code publishers.
4.  **`vsce` (Visual Studio Code Extension Manager):** This tool is used for packaging and publishing VS Code extensions.
    ```bash
    npm install -g vsce
    ```

#### **Implementation Guide**

Here's a step-by-step guide to creating documentation and publishing your extension:

**1. Write `README.md` Content**

The `README.md` is the first thing users see. It should clearly explain what your extension does, how to install it, configure it, and use it.

  *   **File:** `README.md`
  *   **Key Sections to Include:**
      *   **Title and Overview:** A clear, concise description of the extension.
      *   **Features:** A bulleted list of key functionalities.
      *   **Installation:** Step-by-step instructions for installing from the Marketplace or manually.
      *   **Configuration:** How to access and change settings, with examples.
      *   **Usage:** A guide on how to use the extension's core features.
      *   **Screenshots/GIFs:** Visual aids are highly recommended.
      *   **Contributing (Optional):** Link to `CONTRIBUTING.md`.
      *   **License:** Information about the extension's license.

  *   **Example Structure:**
    ```markdown
    # Code Context Engine VS Code Extension

    ![Demo GIF](assets/demo.gif) <!-- Link to your demo GIF -->

    A powerful VS Code extension that helps developers understand their codebase by providing contextual information through semantic search and LSP integration.

    ## Features
    - Intelligent code indexing using AST parsing and LSP data.
    - Semantic search for related files and code snippets.
    - Customizable embedding providers (Ollama, OpenAI).
    - Local Qdrant vector database integration.
    - Intuitive settings UI for easy configuration.

    ## Installation
    1.  **From VS Code Marketplace:** Search for "Code Context Engine" in the Extensions view (`Ctrl+Shift+X` or `Cmd+Shift+X`) and click "Install".
    2.  **Manual Installation:**
        a.  Clone this repository: `git clone https://github.com/your-username/code-context-engine.git`
        b.  Navigate to the project root: `cd code-context-engine`
        c.  Package the extension: `vsce package`
        d.  Install the `.vsix` file: Open VS Code, go to Extensions view, click `...` (More Actions) -> `Install from VSIX...` and select the generated `.vsix` file.

    ## Configuration
    To configure the extension, open the Command Palette (`Ctrl+Shift+P` or `Cmd+Shift+P`) and search for "Code Context Engine: Open Settings".

    -   **Embedding Provider:** Select your preferred embedding model (e.g., Ollama for local models, OpenAI for cloud-based).
    -   **Database Connection String:** Specify the URL for your Qdrant instance (e.g., `http://localhost:6333`).

    ## Usage
    1.  **Index Your Repository:** Open the Code Context Engine panel (View -> Open View -> Code Context Engine) and click "Index Now".
    2.  **Query Context:** Use the search bar in the panel to ask questions about your codebase (e.g., "Show me authentication logic", "Find files related to user profiles").

    ## Contributing
    We welcome contributions! Please see our [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

    ## License
    [Your License Here]
    ```

**2. Create Demo GIF**

A short, animated GIF demonstrating the core functionality of your extension can significantly improve user understanding and engagement.

  *   **Tool:** Use screen recording software (e.g., OBS Studio, ShareX, macOS built-in recorder) to capture your workflow. Then, use a GIF converter (e.g., online tools, FFmpeg) to create an optimized GIF.
  *   **File:** `assets/demo.gif` (or similar path, referenced in `README.md`)
  *   **Tips:**
      *   Keep it short and focused (10-30 seconds).
      *   Highlight the most impactful features.
      *   Ensure good resolution and clear text.
      *   Optimize file size for faster loading.

**3. Write `CONTRIBUTING.md`**

This file provides guidelines for potential contributors, making it easier for others to get involved with your project.

  *   **File:** `CONTRIBUTING.md`
  *   **Key Sections to Include:**
      *   **How to Contribute:** General overview.
      *   **Local Development Setup:** Instructions for cloning, installing dependencies, and running the project locally.
      *   **Running Tests:** How to execute unit and integration tests.
      *   **Code Style and Linting:** Any specific coding conventions or tools.
      *   **Submitting Changes:** Guidelines for pull requests (e.g., branch naming, commit message format).
      *   **Reporting Bugs/Suggesting Features:** How to open issues.

  *   **Example Structure:**
    ```markdown
    # Contributing to Code Context Engine

    We welcome and appreciate contributions to the Code Context Engine VS Code extension! By contributing, you help us make this tool better for everyone.

    ## How to Get Started

    1.  **Fork the Repository:** Start by forking the `code-context-engine` repository on GitHub.
    2.  **Clone Your Fork:** `git clone https://github.com/your-username/code-context-engine.git`
    3.  **Install Dependencies:** Navigate to the project root and install all necessary dependencies:
        ```bash
        npm install
        ```
    4.  **Open in VS Code:** Open the cloned project in Visual Studio Code.

    ## Local Development

    -   **Run Extension:** Press `F5` in VS Code to launch a new Extension Development Host window with your extension loaded.
    -   **Build Webview:** If you make changes to the SvelteKit webview, navigate to the `webview` directory and run `npm run build` to compile the changes.

    ## Running Tests

    To run the project's tests:

    ```bash
    npm test
    ```

    ## Code Style and Linting

    We use ESLint and Prettier to maintain code quality and consistency. Please ensure your code passes linting checks before submitting a pull request:

    ```bash
    npm run lint
    ```

    ## Submitting Changes (Pull Requests)

    1.  **Create a Branch:** Create a new branch for your feature or bug fix:
        `git checkout -b feature/your-feature-name` or `git checkout -b bugfix/issue-number`
    2.  **Make Your Changes:** Implement your feature or fix the bug.
    3.  **Write Tests:** Ensure your changes are covered by appropriate unit or integration tests.
    4.  **Commit Your Changes:** Write clear, concise commit messages that explain *what* and *why*.
    5.  **Push to Your Fork:** `git push origin your-branch-name`
    6.  **Open a Pull Request:** Go to the original `code-context-engine` repository on GitHub and open a new pull request from your branch.

    ## Reporting Issues / Suggesting Features

    If you find a bug or have a feature request, please open an issue on our [GitHub Issues page](https://github.com/your-username/code-context-engine/issues).
    ```

**4. Create Marketplace Publisher Identity**

To publish your extension, you need a publisher ID. This is done through Azure DevOps.

  *   **Action:** Follow the official VS Code documentation to create a publisher. This typically involves:
      1.  Going to the Azure DevOps organization for VS Code publishers.
      2.  Creating a new organization if you don't have one.
      3.  Creating a Personal Access Token (PAT) with `Marketplace (Publish)` scope.
  *   **Reference:** [Publishing Extensions - Visual Studio Code](https://code.visualstudio.com/api/references/publishing-extensions)

**5. Update GitHub Actions for Manual Release Trigger**

Modify your `ci.yml` workflow to include a `workflow_dispatch` event, allowing you to manually trigger the release job from the GitHub Actions UI.

  *   **File:** `.github/workflows/ci.yml`
  *   **Key Concept:** `workflow_dispatch` enables manual triggering of workflows.

  *   **Implementation Example (add to `on` section):**
    ```yaml
    on:
      push:
        branches:
          - main
      pull_request:
        branches:
          - main
      workflow_dispatch: # This enables manual triggering
    ```

**6. Implement Publishing Step in CI/CD Pipeline**

Add a new job to your `ci.yml` that will execute the `vsce publish` command. This job should depend on the `build` job and use a GitHub Secret to store your `vsce` Personal Access Token (PAT).

  *   **File:** `.github/workflows/ci.yml`
  *   **Key Concepts:**
      *   `needs`: Specifies that a job depends on the successful completion of another job.
      *   `if`: Conditional execution of a job.
      *   `secrets`: Securely store sensitive information like API keys.
      *   `vsce publish -p <token>`: Command to publish the extension.

  *   **Implementation Example (add a new job after `build` job):**
    ```yaml
    # ... (existing build job)

    release:
      needs: build # This job depends on the 'build' job completing successfully
      runs-on: ubuntu-latest
      if: github.event_name == 'workflow_dispatch' # Only run this job when manually triggered

      steps:
        - name: Checkout repository
          uses: actions/checkout@v3

        - name: Set up Node.js
          uses: actions/setup-node@v3
          with:
            node-version: '18' # Or your project's Node.js version

        - name: Install vsce
          run: npm install -g vsce

        - name: Download VSIX artifact
          uses: actions/download-artifact@v3
          with:
            name: vsix-package
            path: .

        - name: Publish to VS Code Marketplace
          run: vsce publish -p ${{ secrets.VSCE_TOKEN }}
          env:
            VSCE_TOKEN: ${{ secrets.VSCE_TOKEN }} # Pass the token as an environment variable
    ```
    *   **Important:** You must add `VSCE_TOKEN` as a repository secret in your GitHub repository settings (Settings -> Secrets and variables -> Actions -> New repository secret).

**7. Test the Release Process**

After setting up the workflow, perform a test release to ensure everything works as expected.

  *   **Action:**
      1.  Go to your GitHub repository -> Actions tab.
      2.  Select your `CI/CD` workflow.
      3.  Click `Run workflow` button (usually on the right side).
      4.  Select the `main` branch and click `Run workflow`.
      5.  Monitor the workflow run for success.
      6.  Check the VS Code Marketplace for your published extension.

This completes the implementation guide for Sprint 7. You now have a well-documented extension and an automated process for publishing it to the VS Code Marketplace, making it accessible to a wider audience.
</file>

<file path="docs/completed/setup/implementation_sub_sprint_1_vs_code_extension_boilerplate_setup.md">
### Implementation Guide: Sub-Sprint 1 - VS Code Extension Boilerplate Setup

**Objective:** To create the fundamental file structure and configuration for a new VS Code extension using TypeScript.

#### **Analysis**

Since a `repomix-roocode.xml` or similar comprehensive code structure file was not provided for this specific sub-sprint, the analysis is based on the general requirements for a VS Code extension and best practices for project setup. The goal is to establish a clean, maintainable, and standard TypeScript-based extension project.

#### **Prerequisites and Setup**

Before starting, ensure you have the following installed:

1.  **Node.js and npm/yarn:** Essential for JavaScript/TypeScript development.
2.  **VS Code Extension Generator (`yo code`):** This Yeoman generator scaffolds new VS Code extension projects.
    ```bash
    npm install -g yo generator-code
    ```

#### **Implementation Guide**

Here's a step-by-step guide to setting up the VS Code extension boilerplate:

**1. Generate the VS Code Extension Project**

Use the `yo code` generator to create the initial project structure. This command will prompt you with several questions to configure your extension.

  *   **Command:**
    ```bash
    npx yo code
    ```
  *   **Prompts to select:**
      *   `? What type of extension do you want to create?` -> `New Extension (TypeScript)`
      *   `? What is the name of your extension?` -> `CodeContextEngine` (or a suitable name)
      *   `? What is the identifier of your extension?` -> `code-context-engine`
      *   `? What is the description of your extension?` -> (Provide a brief description)
      *   `? Enable TypeScript checking and linting?` -> `Yes`
      *   `? Initialize a git repository?` -> `Yes` (Recommended)
      *   `? Do you want to open the new folder with VS Code?` -> `Yes`

  *   **API Information:** The `yo code` generator uses the VS Code Extension API internally to set up the `package.json`, `src/extension.ts`, and other configuration files.

**2. Configure `package.json`**

The `package.json` file is crucial for defining your extension's metadata, commands, and activation events. Review and adjust the generated file.

  *   **File:** `package.json`
  *   **Key fields to review/modify:**
      *   `name`: The unique identifier for your extension.
      *   `displayName`: The name displayed in the VS Code Marketplace.
      *   `description`: A brief summary of your extension.
      *   `publisher`: Your VS Code Marketplace publisher ID.
      *   `activationEvents`: Defines when your extension is activated (e.g., `onCommand:your-extension.helloWorld`).
      *   `main`: The entry point of your extension (usually `out/extension.js`).
      *   `contributes`: This section is where you declare commands, views, keybindings, etc.

  *   **Example `activationEvents` (if not already present):**
    ```json
    "activationEvents": [
        "onCommand:code-context-engine.helloWorld"
    ],
    ```

**3. Establish Project Structure**

The `yo code` generator provides a basic structure. For a SvelteKit frontend, it's good practice to separate the backend (extension) and frontend (webview) code. You'll typically have a `src` directory for your main extension code and a separate directory for your SvelteKit project.

  *   **Action:** Create a `webview` directory at the root level (or within `src` if preferred) to house your SvelteKit application.
  *   **Command:**
    ```bash
    mkdir webview
    ```
  *   **Resulting structure (example):**
    ```
    your-extension-name/
     .vscode/
     src/
        extension.ts
     webview/  <-- New directory for SvelteKit
     package.json
     tsconfig.json
     .gitignore
     ...
    ```

**4. Initial Backend Logic (`extension.ts`)**

The `extension.ts` file is the main entry point for your VS Code extension. It contains the `activate` function, which is called when your extension is activated, and the `deactivate` function, called when your extension is deactivated.

  *   **File:** `src/extension.ts`
  *   **Key concepts:**
      *   `activate(context: vscode.ExtensionContext)`: This is where you register commands, create webviews, and set up event listeners.
      *   `deactivate()`: Used for cleanup, like disposing of resources.
      *   `vscode.commands.registerCommand()`: Registers a command that can be invoked by the user (e.g., from the Command Palette).
      *   `vscode.window.showInformationMessage()`: Displays a message to the user.
      *   `context.subscriptions.push()`: Adds disposables (objects with a `dispose` method) to the extension's context, ensuring they are cleaned up when the extension is deactivated.

  *   **Example `src/extension.ts` (as generated by `yo code` and slightly modified for clarity):**
    ```typescript
    import * as vscode from 'vscode';

    /**
     * This method is called when your extension is activated.
     * The extension is activated the very first time the command is executed.
     */
    export function activate(context: vscode.ExtensionContext) {

        // Use the console to output diagnostic information (console.log) and errors (console.error)
        // This line of code will only be executed once when your extension is activated
        console.log('Congratulations, your extension "code-context-engine" is now active!');

        // The command has been defined in the package.json file
        // Now provide the implementation of the command with registerCommand
        // The commandId parameter must match the command field in package.json
        let disposable = vscode.commands.registerCommand('code-context-engine.helloWorld', () => {
            // The code you place here will be executed every time your command is executed
            // Display a message box to the user
            vscode.window.showInformationMessage('Hello World from Code Context Engine!');
        });

        context.subscriptions.push(disposable);
    }

    /**
     * This method is called when your extension is deactivated
     */
    export function deactivate() {}
    ```

This completes the foundational setup for your VS Code extension. You now have a runnable project with a basic command, ready for further development in subsequent sprints.
</file>

<file path="docs/completed/setup/implementation_sub_sprint_2_sveltekit_fluent_ui_integration.md">
### Implementation Guide: Sub-Sprint 2 - SvelteKit and Fluent UI Integration

**Objective:** To set up the SvelteKit frontend and integrate the Fluent UI component library, creating the initial user interface.

#### **Analysis**

This sub-sprint focuses on the frontend development of the VS Code extension. The core idea is to leverage SvelteKit for building a modern, reactive UI within a VS Code webview. Fluent UI is chosen for its consistency with Microsoft's design language, ensuring a native feel within VS Code. The integration requires careful handling of webview communication and theme adaptation.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 1 Completion:** Ensure the basic VS Code extension boilerplate is set up as per Sub-Sprint 1's guide.
2.  **Node.js and npm/yarn:** Already installed from previous steps.

#### **Implementation Guide**

Here's a step-by-step guide to integrating SvelteKit and Fluent UI:

**1. Initialize SvelteKit Project within `webview` Directory**

Navigate into the `webview` directory you created in Sub-Sprint 1 and initialize a new SvelteKit project. Choose the "Skeleton project" and enable TypeScript, ESLint, Prettier, and Vitest for a robust development environment.

  *   **Command:**
    ```bash
    cd webview
    npm create svelte@latest .
    ```
  *   **Prompts to select:**
      *   `? Which Svelte project template?` -> `Skeleton project`
      *   `? Add TypeScript?` -> `Yes, using TypeScript syntax`
      *   `? Add ESLint for code linting?` -> `Yes`
      *   `? Add Prettier for code formatting?` -> `Yes`
      *   `? Add Playwright for browser testing?` -> `No` (or Yes, if desired for e2e)
      *   `? Add Vitest for unit testing?` -> `Yes`

  *   **Install dependencies:**
    ```bash
    npm install
    ```

**2. Configure Webview in `extension.ts` to Load SvelteKit App**

Your `extension.ts` needs to create a `WebviewPanel` and load the compiled SvelteKit application's `index.html` into it. SvelteKit builds to a `dist` folder by default.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.window.createWebviewPanel()`: Creates and shows a new webview panel.
      *   `panel.webview.html`: Sets the HTML content of the webview.
      *   `panel.webview.options.localResourceRoots`: Allows the webview to load local resources (like CSS/JS from your SvelteKit build).
      *   `vscode.Uri.file()` and `path.join()`: Used to construct absolute paths to your SvelteKit build assets.
      *   `fs.readFileSync()`: Node.js file system module to read the `index.html` file. You might need to add `import * as fs from 'fs';` at the top of `extension.ts`.

  *   **Implementation Example:**
    ```typescript
    import * as vscode from 'vscode';
    import * as path from 'path';
    import * as fs from 'fs'; // Add this import

    export function activate(context: vscode.ExtensionContext) {
        console.log('Congratulations, your extension "code-context-engine" is now active!');

        let currentPanel: vscode.WebviewPanel | undefined = undefined;

        context.subscriptions.push(
            vscode.commands.registerCommand('code-context-engine.openSveltePanel', () => {
                const columnToShowIn = vscode.window.activeTextEditor
                    ? vscode.window.activeTextEditor.viewColumn
                    : undefined;

                if (currentPanel) {
                    currentPanel.reveal(columnToShowIn);
                } else {
                    currentPanel = vscode.window.createWebviewPanel(
                        'codeContextEngine',
                        'Code Context Engine',
                        columnToShowIn || vscode.ViewColumn.One,
                        {
                            enableScripts: true,
                            localResourceRoots: [
                                vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                            ]
                        }
                    );

                    const svelteAppPath = vscode.Uri.file(
                        path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                    );

                    // Read the SvelteKit index.html and set it as the webview content
                    let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');

                    // Important: Replace relative paths with webview-specific URIs
                    // This ensures that SvelteKit's JS/CSS assets are loaded correctly
                    htmlContent = htmlContent.replace(/\/\_app\//g, currentPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                    currentPanel.webview.html = htmlContent;

                    currentPanel.onDidDispose(
                        () => {
                            currentPanel = undefined;
                        },
                        null,
                        context.subscriptions
                    );
                }
            })
        );
    }

    export function deactivate() {}
    ```
    *   **Note on `htmlContent.replace`**: SvelteKit generates paths like `/_app/`. You need to convert these to `webview-uri`s so the webview can load them. The regex ` /\/_app\//g` targets these paths.

**3. Install Fluent UI Svelte Library**

While the PRD mentioned `svelte-fluent-ui`, the official Fluent UI components are often used as web components or React components. For Svelte, you can use the `@fluentui/web-components` directly or a community-maintained Svelte wrapper if available and preferred. For this guide, I will use the official web components as they are framework-agnostic.

  *   **Command (from `webview` directory):**
    ```bash
    cd webview
    npm install @fluentui/web-components
    ```

**4. Implement UI with Fluent UI Components**

Create your main Svelte component (e.g., `src/routes/+page.svelte` or a new component like `src/lib/MainPanel.svelte`) and use Fluent UI components.

  *   **File:** `webview/src/routes/+page.svelte` (or `webview/src/lib/MainPanel.svelte`)
  *   **API Information:**
      *   `provideFluentDesignSystem().register(...)`: Registers the Fluent UI web components for use.
      *   `<fluent-button>`: Fluent UI button component.
      *   `<fluent-progress-ring>`: Fluent UI progress indicator.

  *   **Implementation Example (`webview/src/routes/+page.svelte`):**
    ```html
    <script lang="ts">
      import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";

      // Register Fluent UI components
      provideFluentDesignSystem().register(
        fluentButton(),
        fluentProgressRing()
      );

      function handleIndexNow() {
        console.log("Index Now button clicked!");
        // In a real scenario, this would trigger the backend indexing process
      }
    </script>

    <main>
      <h1>Code Context Engine</h1>
      <p>Click the button to start indexing your repository.</p>
      <fluent-button appearance="accent" @click="{handleIndexNow}">Index Now</fluent-button>
      <div style="margin-top: 20px;">
        <p>Indexing Progress:</p>
        <fluent-progress-ring></fluent-progress-ring>
      </div>
    </main>

    <style>
      /* Basic styling for the page */
      main {
        padding: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        line-height: 1.5;
      }

      h1 {
        color: var(--vscode-editor-foreground);
      }

      p {
        color: var(--vscode-editor-foreground);
      }

      /* Ensure Fluent UI components inherit VS Code theme colors */
      fluent-button {
        --accent-fill-rest: var(--vscode-button-background);
        --accent-fill-hover: var(--vscode-button-hoverBackground);
        --accent-fill-active: var(--vscode-button-background);
        --accent-foreground-rest: var(--vscode-button-foreground);
        --neutral-fill-rest: var(--vscode-button-background);
        --neutral-fill-hover: var(--vscode-button-hoverBackground);
        --neutral-fill-active: var(--vscode-button-background);
        --neutral-foreground-rest: var(--vscode-button-foreground);
      }

      fluent-progress-ring {
        --accent-fill-rest: var(--vscode-progressBar-background);
      }
    </style>
    ```

**5. Theme Integration**

VS Code exposes its theme colors as CSS variables. You can use these variables in your SvelteKit application's global CSS or directly within components to ensure your UI adapts to the user's chosen theme.

  *   **File:** `webview/src/app.css` (or directly in your Svelte components' `<style>` tags)
  *   **API Information:** VS Code CSS Variables (e.g., `--vscode-editor-background`, `--vscode-editor-foreground`, `--vscode-button-background`).

  *   **Implementation Example (`webview/src/app.css`):**
    ```css
    /* Global styles for the webview */
    body {
      background-color: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
    }

    /* Example of applying VS Code theme colors to Fluent UI components */
    fluent-button {
      --accent-fill-rest: var(--vscode-button-background);
      --accent-fill-hover: var(--vscode-button-hoverBackground);
      --accent-fill-active: var(--vscode-button-background);
      --accent-foreground-rest: var(--vscode-button-foreground);
    }

    fluent-progress-ring {
      --accent-fill-rest: var(--vscode-progressBar-background);
    }
    ```

**Build the SvelteKit App:**

Before running the extension, you need to build your SvelteKit application so that `extension.ts` can load the `index.html` and other assets from the `dist` folder.

  *   **Command (from `webview` directory):**
    ```bash
    cd webview
    npm run build
    ```

This completes the integration of SvelteKit and Fluent UI into your VS Code extension. You now have a visually consistent and interactive frontend ready to communicate with your extension's backend.
</file>

<file path="docs/completed/setup/implementation_sub_sprint_5_implement_context_query_api.md">
### Implementation Guide: Sub-Sprint 5 - Implement Context Query API

**Objective:** To build the internal backend API that will allow the frontend to query the indexed codebase.

#### **Analysis**

This sub-sprint is critical for enabling the core functionality of the extension: allowing users to query their codebase for contextual information. It involves creating a backend service (`ContextService`) that orchestrates interactions with the Qdrant vector database and an embedding provider. Communication between the SvelteKit frontend and this backend service will occur via VS Code's webview message passing API. The design emphasizes modularity, with clear separation of concerns between file system operations, embedding generation, and vector database interactions.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 3 Completion:** Ensure that the Qdrant service and embedding providers (Ollama/OpenAI) are set up and functional, as this sprint relies heavily on them.
2.  **VS Code Extension Project:** A working VS Code extension project with a SvelteKit webview integrated (from previous sprints).

#### **Implementation Guide**

Here's a step-by-step guide to implementing the Context Query API:

**1. Create `ContextService`**

This service will act as the orchestrator for all context-related queries. It will depend on the `QdrantService` (for database interactions) and an `IEmbeddingProvider` (for generating embeddings).

  *   **File:** `src/context/contextService.ts` (New File)
  *   **Key Concepts:**
      *   **Dependency Injection (Basic):** The `ContextService` will instantiate `QdrantService` and an `IEmbeddingProvider`. In a more complex application, these might be passed in via a dependency injection framework.
      *   **Orchestration:** This service will coordinate calls to the embedding provider and Qdrant to fulfill queries.

  *   **Implementation Example:**
    ```typescript
    import * as vscode from 'vscode';
    import { QdrantService } from '../db/qdrantService';
    import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
    import { OllamaProvider } from '../embeddings/ollamaProvider'; // Default or configurable provider
    import { CodeChunk } from '../parsing/chunker'; // Assuming CodeChunk interface is available

    export class ContextService {
        private qdrantService: QdrantService;
        private embeddingProvider: IEmbeddingProvider;
        private collectionName: string; // Qdrant collection name, typically workspace-specific

        constructor(workspaceRoot: string) {
            this.qdrantService = new QdrantService();
            this.embeddingProvider = new OllamaProvider(); // TODO: Make this configurable via settings
            this.collectionName = vscode.workspace.name || 'default_collection'; // Use workspace name as collection
        }

        /**
         * Retrieves the content of a specific file based on a query.
         * In a real scenario, this would involve vector search to find the most relevant file.
         * For now, it directly reads the file if the path is exact.
         */
        public async getFileContent(filePath: string): Promise<string | null> {
            try {
                const uri = vscode.Uri.file(filePath);
                const contentBuffer = await vscode.workspace.fs.readFile(uri);
                return contentBuffer.toString();
            } catch (error) {
                vscode.window.showErrorMessage(`Error reading file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
                console.error(`Error reading file ${filePath}:`, error);
                return null;
            }
        }

        /**
         * Finds files related to a given concept or file path using vector similarity search.
         */
        public async findRelatedFiles(query: string, limit: number = 5): Promise<string[]> {
            try {
                // 1. Generate embedding for the query
                const queryEmbedding = (await this.embeddingProvider.generateEmbeddings([query]))[0];
                if (!queryEmbedding) {
                    vscode.window.showWarningMessage("Could not generate embedding for the query.");
                    return [];
                }

                // 2. Perform similarity search in Qdrant
                const searchResult = await this.qdrantService.search(this.collectionName, queryEmbedding, limit);

                // 3. Extract unique file paths from the search results
                const relatedFilePaths = new Set<string>();
                for (const hit of searchResult) {
                    if (hit.payload && hit.payload.filePath) {
                        relatedFilePaths.add(hit.payload.filePath as string);
                    }
                }
                return Array.from(relatedFilePaths);

            } catch (error) {
                vscode.window.showErrorMessage(`Error finding related files: ${error instanceof Error ? error.message : String(error)}`);
                console.error("Error in findRelatedFiles:", error);
                return [];
            }
        }
    }
    ```

**2. Implement `getFileContent` and `findRelatedFiles`**

These methods are the core of your context API. `getFileContent` will directly read from the file system (or eventually use vector search to resolve a path), while `findRelatedFiles` will leverage your embedding provider and Qdrant.

  *   **File:** `src/context/contextService.ts`
  *   **API Information:**
      *   `vscode.workspace.fs.readFile()`: VS Code API for reading file content.
      *   `this.embeddingProvider.generateEmbeddings()`: Your custom method from Sub-Sprint 3 to get vector representations of text.
      *   `this.qdrantService.search()`: Your custom method from Sub-Sprint 3 to query the Qdrant database.

  *   **Implementation:** (See `ContextService` example above. Ensure `QdrantService` has a `search` method and `IEmbeddingProvider` has `generateEmbeddings`.)

**3. Expose via Message Passing in `extension.ts`**

Your `extension.ts` will act as the bridge between the webview (frontend) and your backend `ContextService`. It will listen for messages from the webview, call the appropriate `ContextService` method, and send the results back.

  *   **File:** `src/extension.ts`
  *   **Key Concepts:**
      *   `panel.webview.onDidReceiveMessage()`: Event listener for messages from the webview.
      *   `panel.webview.postMessage()`: Sends messages back to the webview.
      *   **Message Structure:** Define a clear message structure (e.g., `{ command: string, payload: any }`) for both incoming and outgoing messages.

  *   **Implementation Example (within `activate` function, after `panel` creation):**
    ```typescript
    // Assuming `currentPanel` is your WebviewPanel instance
    const contextService = new ContextService(vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '');

    currentPanel.webview.onDidReceiveMessage(
        async message => {
            switch (message.command) {
                case 'getFileContent':
                    const fileContent = await contextService.getFileContent(message.filePath);
                    currentPanel?.webview.postMessage({ command: 'fileContentResult', content: fileContent });
                    return;
                case 'findRelatedFiles':
                    const relatedFiles = await contextService.findRelatedFiles(message.query);
                    currentPanel?.webview.postMessage({ command: 'relatedFilesResult', files: relatedFiles });
                    return;
                // Add other commands as needed
            }
        },
        undefined,
        context.subscriptions
    );
    ```

**4. Create Frontend API Client (`webview/src/lib/vscodeApi.ts`)**

To simplify communication from the SvelteKit frontend, create a small wrapper that abstracts the `acquireVsCodeApi()` and message posting/listening.

  *   **File:** `webview/src/lib/vscodeApi.ts` (New File)
  *   **Key Concepts:**
      *   `acquireVsCodeApi()`: Global function provided by VS Code to webviews to get a reference to the VS Code API.
      *   `vscode.postMessage()`: Sends a message from the webview to the extension.
      *   `window.addEventListener('message', ...)`: Listens for messages sent from the extension to the webview.

  *   **Implementation Example:**
    ```typescript
    // webview/src/lib/vscodeApi.ts
    declare const acquireVsCodeApi: any; // Declare to avoid TypeScript errors
    const vscode = acquireVsCodeApi();

    /**
     * Sends a message from the webview to the VS Code extension backend.
     * @param message The message payload.
     */
    export function postMessage(message: any) {
        vscode.postMessage(message);
    }

    /**
     * Registers a callback to listen for messages from the VS Code extension backend.
     * @param callback The function to call when a message is received.
     */
    export function onMessage(callback: (message: any) => void) {
        window.addEventListener('message', event => {
            callback(event.data);
        });
    }
    ```

**5. Integrate Frontend with API Client**

Modify your Svelte components to use the `vscodeApi.ts` client to send requests and handle responses.

  *   **File:** `webview/src/routes/+page.svelte` (or other relevant Svelte components)
  *   **Key Concepts:**
      *   `onMount`: Svelte lifecycle hook to run code when the component is first mounted.
      *   Reactive variables: Svelte's way of updating the UI when data changes.

  *   **Implementation Example (simplified):**
    ```html
    <script lang="ts">
      import { onMount } from 'svelte';
      import { postMessage, onMessage } from '../lib/vscodeApi';

      let fileContent: string | null = null;
      let relatedFiles: string[] = [];
      let queryInput: string = '';
      let filePathInput: string = '';

      onMount(() => {
        onMessage(message => {
          switch (message.command) {
            case 'fileContentResult':
              fileContent = message.content;
              if (fileContent === null) {
                alert("File not found or could not be read.");
              }
              break;
            case 'relatedFilesResult':
              relatedFiles = message.files;
              if (relatedFiles.length === 0) {
                alert("No related files found.");
              }
              break;
            // Handle other message types
          }
        });
      });

      function handleGetFileContent() {
        if (filePathInput) {
          postMessage({ command: 'getFileContent', filePath: filePathInput });
        }
      }

      function handleFindRelatedFiles() {
        if (queryInput) {
          postMessage({ command: 'findRelatedFiles', query: queryInput });
        }
      }
    </script>

    <main>
      <h1>Context Query API Demo</h1>

      <h2>Get File Content</h2>
      <input type="text" bind:value={filePathInput} placeholder="Enter file path (e.g., /src/extension.ts)" style="width: 300px;" />
      <button on:click={handleGetFileContent}>Get Content</button>
      {#if fileContent !== null}
        <h3>File Content:</h3>
        <pre style="white-space: pre-wrap; word-break: break-all; max-height: 300px; overflow-y: auto; background-color: var(--vscode-editor-background); color: var(--vscode-editor-foreground); padding: 10px; border: 1px solid var(--vscode-editorWidget-border);">{fileContent}</pre>
      {/if}

      <h2>Find Related Files</h2>
      <input type="text" bind:value={queryInput} placeholder="Enter concept or file path (e.g., authentication logic)" style="width: 300px;" />
      <button on:click={handleFindRelatedFiles}>Find Related</button>
      {#if relatedFiles.length > 0}
        <h3>Related Files:</h3>
        <ul>
          {#each relatedFiles as file}
            <li>{file}</li>
          {/each}
        </ul>
      {/if}
    </main>

    <style>
      /* Add basic styling for inputs and buttons to match VS Code theme */
      input[type="text"] {
        background-color: var(--vscode-input-background);
        color: var(--vscode-input-foreground);
        border: 1px solid var(--vscode-input-border);
        padding: 5px;
        margin-right: 10px;
      }
      button {
        background-color: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
        border: none;
        padding: 8px 12px;
        cursor: pointer;
      }
      button:hover {
        background-color: var(--vscode-button-hoverBackground);
      }
    </style>
    ```

This completes the implementation guide for Sub-Sprint 5. You now have a functional backend API for querying code context and a frontend capable of interacting with it.
</file>

<file path="docs/completed/setup/implementation_sub_sprint_6_develop_settings_ui.md">
### Implementation Guide: Sub-Sprint 6 - Develop Settings UI

**Objective:** To create the user-facing settings panel where users can configure the extension's behavior.

#### **Analysis**

This sub-sprint focuses on providing a user-friendly interface for configuring the extension. It involves extending the `package.json` to declare new configuration properties and a command to open the settings UI. The settings UI itself will be a SvelteKit webview, leveraging Fluent UI components for a consistent look and feel. Crucially, the UI will interact with the VS Code configuration API to read and write settings, ensuring persistence and proper application of user preferences across the extension's backend services.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 2 Completion:** A working SvelteKit webview integrated into the VS Code extension.
2.  **Sub-Sprint 5 Completion:** The backend services are in place, which will eventually consume these settings.
3.  **Fluent UI Web Components:** Ensure `@fluentui/web-components` is installed in your `webview` project.

#### **Implementation Guide**

Here's a step-by-step guide to developing the Settings UI:

**1. Register Settings Command in `package.json`**

First, define a new command that users can execute from the VS Code Command Palette to open your settings UI.

  *   **File:** `package.json`
  *   **Key Concept:** The `contributes.commands` section in `package.json` is used to declare commands that your extension provides.

  *   **Implementation Example (add to `contributes.commands` array):**
    ```json
    {
        "command": "code-context-engine.openSettings",
        "title": "Code Context Engine: Open Settings",
        "category": "Code Context Engine"
    }
    ```

**2. Create and Show Settings Webview in `extension.ts`**

Implement the logic in your main extension file (`extension.ts`) to handle the `openSettings` command. This will involve creating a new `WebviewPanel` specifically for your settings UI.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.commands.registerCommand()`: To link your declared command to a function.
      *   `vscode.window.createWebviewPanel()`: To create the webview instance.
      *   `panel.webview.html`: To load the SvelteKit app into the webview.
      *   `path.join()` and `vscode.Uri.file()`: For constructing correct paths to your SvelteKit build output.

  *   **Implementation Example (within `activate` function):**
    ```typescript
    import * as vscode from 'vscode';
    import * as path from 'path';
    import * as fs from 'fs';

    // ... (existing code for main panel, if any)

    let settingsPanel: vscode.WebviewPanel | undefined; // Declare a variable to hold the settings panel instance

    context.subscriptions.push(
        vscode.commands.registerCommand('code-context-engine.openSettings', () => {
            const columnToShowIn = vscode.window.activeTextEditor
                ? vscode.window.activeTextEditor.viewColumn
                : undefined;

            if (settingsPanel) {
                settingsPanel.reveal(columnToShowIn); // If panel already exists, just reveal it
            } else {
                // Create a new webview panel
                settingsPanel = vscode.window.createWebviewPanel(
                    'codeContextEngineSettings', // Unique ID
                    'Code Context Engine Settings', // Title
                    columnToShowIn || vscode.ViewColumn.One, // Column to show in
                    {
                        enableScripts: true,
                        localResourceRoots: [
                            vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                        ]
                    }
                );

                // Get path to SvelteKit's built index.html
                const svelteAppPath = vscode.Uri.file(
                    path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                );

                // Read and set the HTML content
                let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');
                // Important: Adjust paths for webview to load SvelteKit assets correctly
                htmlContent = htmlContent.replace(/\/\_app\//g, settingsPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                settingsPanel.webview.html = htmlContent;

                // Handle panel disposal (e.g., when user closes it)
                settingsPanel.onDidDispose(
                    () => {
                        settingsPanel = undefined;
                    },
                    null,
                    context.subscriptions
                );
            }
        })
    );
    ```

**3. Build Svelte UI for Settings**

Create a new Svelte component (e.g., `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte`) that will serve as your settings page. Use Fluent UI components for input fields.

  *   **File:** `webview/src/routes/settings/+page.svelte` (or similar)
  *   **API Information:**
      *   `@fluentui/web-components`: Provides `<fluent-select>`, `<fluent-option>`, `<fluent-text-field>`, `<fluent-button>`.
      *   `bind:value`: Svelte directive for two-way data binding with input elements.
      *   `onMount`: Svelte lifecycle hook to run code after the component is first rendered.
      *   `postMessage`, `onMessage` (from `vscodeApi.ts`): For communication with the extension backend.

  *   **Implementation Example:**
    ```html
    <script lang="ts">
      import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";
      import { onMount } from 'svelte';
      import { postMessage, onMessage } from '../../lib/vscodeApi'; // Adjust path as needed

      // Register Fluent UI components
      provideFluentDesignSystem().register(
        fluentSelect(),
        fluentOption(),
        fluentTextField(),
        fluentButton()
      );

      let embeddingProvider: string = 'Ollama'; // Default value, will be overwritten by loaded settings
      let databaseConnectionString: string = '';

      onMount(() => {
        // Request current settings from extension backend on component mount
        postMessage({ command: 'getSettings' });

        // Listen for settings data from the extension backend
        onMessage(message => {
          if (message.command === 'settingsResult') {
            embeddingProvider = message.settings.embeddingProvider || 'Ollama';
            databaseConnectionString = message.settings.databaseConnectionString || '';
          }
        });
      });

      function saveSettings() {
        const settings = {
          embeddingProvider,
          databaseConnectionString,
        };
        // Send updated settings to the extension backend to be saved
        postMessage({ command: 'saveSettings', settings });
      }
    </script>

    <main>
      <h1>Extension Settings</h1>

      <fluent-text-field
        appearance="outline"
        placeholder="Database Connection String"
        bind:value={databaseConnectionString}
        style="width: 100%; margin-bottom: 15px;"
      >
        Database Connection String
      </fluent-text-field>

      <fluent-select
        appearance="outline"
        bind:value={embeddingProvider}
        style="width: 100%; margin-bottom: 20px;"
      >
        <fluent-option value="Ollama">Ollama</fluent-option>
        <fluent-option value="OpenAI">OpenAI</fluent-option>
        <!-- Add more options as needed -->
      </fluent-select>

      <fluent-button appearance="accent" @click={saveSettings}>Save Settings</fluent-button>
    </main>

    <style>
      /* Basic styling for the page and Fluent UI components to match VS Code theme */
      main {
        padding: 20px;
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
      }
      h1 {
        color: var(--vscode-editor-foreground);
      }
      fluent-text-field,
      fluent-select {
        --neutral-fill-rest: var(--vscode-input-background);
        --neutral-foreground-rest: var(--vscode-input-foreground);
        --neutral-stroke-rest: var(--vscode-input-border);
        --neutral-fill-stealth-rest: var(--vscode-input-background);
        --neutral-fill-stealth-hover: var(--vscode-input-background);
        --neutral-fill-stealth-active: var(--vscode-input-background);
        --neutral-foreground-hover: var(--vscode-input-foreground);
        --neutral-foreground-active: var(--vscode-input-foreground);
        --neutral-stroke-hover: var(--vscode-input-border);
        --neutral-stroke-active: var(--vscode-input-border);
      }
      fluent-button {
        --accent-fill-rest: var(--vscode-button-background);
        --accent-foreground-rest: var(--vscode-button-foreground);
        --accent-fill-hover: var(--vscode-button-hoverBackground);
      }
    </style>
    ```

**4. Implement State Management and VS Code Configuration Interaction**

This is the core of saving and loading settings. You'll use VS Code's `workspace.getConfiguration()` API.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.workspace.getConfiguration('your-extension-id')`: Gets a configuration object for your extension.
      *   `config.get<T>(key, defaultValue)`: Reads a setting.
      *   `config.update(key, value, target)`: Writes a setting. `target` can be `vscode.ConfigurationTarget.Global`, `Workspace`, or `WorkspaceFolder`.
      *   `panel.webview.postMessage()` and `panel.webview.onDidReceiveMessage()`: For communication between extension and webview.

  *   **Implementation Example (within `extension.ts` `onDidReceiveMessage` handler for `settingsPanel`):**
    ```typescript
    // ... (inside settingsPanel.webview.onDidReceiveMessage)
    switch (message.command) {
        case 'getSettings':
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const currentSettings = {
                embeddingProvider: config.get<string>('embeddingProvider', 'Ollama'),
                databaseConnectionString: config.get<string>('databaseConnectionString', 'http://localhost:6333'),
            };
            settingsPanel?.webview.postMessage({ command: 'settingsResult', settings: currentSettings });
            return;

        case 'saveSettings':
            const newSettings = message.settings;
            const configToUpdate = vscode.workspace.getConfiguration('code-context-engine');
            
            // Update settings. Use Global target for user-level settings, or Workspace for workspace-specific
            await configToUpdate.update('embeddingProvider', newSettings.embeddingProvider, vscode.ConfigurationTarget.Global);
            await configToUpdate.update('databaseConnectionString', newSettings.databaseConnectionString, vscode.ConfigurationTarget.Global);
            
            vscode.window.showInformationMessage('Code Context Engine settings saved!');
            return;
    }
    ```

**5. Define Configuration Schema in `package.json`**

To make your settings discoverable and provide type-checking and descriptions in VS Code's built-in settings UI, you must define them in `package.json`.

  *   **File:** `package.json`
  *   **Key Concept:** The `contributes.configuration` section defines the properties for your extension's settings.

  *   **Implementation Example (add to `contributes` section):**
    ```json
    "configuration": {
        "title": "Code Context Engine Configuration",
        "properties": {
            "code-context-engine.embeddingProvider": {
                "type": "string",
                "enum": ["Ollama", "OpenAI"],
                "default": "Ollama",
                "description": "Select the embedding provider to use for generating code embeddings."
            },
            "code-context-engine.databaseConnectionString": {
                "type": "string",
                "default": "http://localhost:6333",
                "description": "The connection string for the Qdrant vector database."
            }
        }
    }
    ```

**6. Refactor Services to Use Configuration**

Finally, ensure your `IndexingService` and `QdrantService` (and any other services that need configuration) read their values from the VS Code configuration instead of hardcoded defaults.

  *   **File:** `src/indexing/indexingService.ts`, `src/db/qdrantService.ts`
  *   **API Information:** `vscode.workspace.getConfiguration('your-extension-id').get<T>(key, defaultValue)`.

  *   **Implementation Example (`src/indexing/indexingService.ts` constructor):**
    ```typescript
    import * as vscode from 'vscode';
    // ... other imports

    export class IndexingService {
        // ... other properties
        private embeddingProvider: IEmbeddingProvider;

        constructor(private workspaceRoot: string) {
            // ...
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const providerName = config.get<string>('embeddingProvider', 'Ollama');

            if (providerName === 'OpenAI') {
                this.embeddingProvider = new OpenAIProvider(); // Assuming OpenAIProvider exists
            } else {
                this.embeddingProvider = new OllamaProvider(); // Assuming OllamaProvider exists
            }
        }
        // ...
    }
    ```

  *   **Implementation Example (`src/db/qdrantService.ts` constructor):**
    ```typescript
    import { QdrantClient } from '@qdrant/js-client-rest';
    import * as vscode from 'vscode';

    export class QdrantService {
        private client: QdrantClient;

        constructor() {
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const connectionString = config.get<string>('databaseConnectionString', 'http://localhost:6333');
            this.client = new QdrantClient({ url: connectionString });
        }
        // ...
    }
    ```

This completes the implementation guide for Sub-Sprint 6. You now have a fully functional settings UI that allows users to configure your extension, with those settings being correctly consumed by your backend services.
</file>

<file path="docs/completed/setup/prd.md">
<prd>Of course. I've analyzed the roadmap and will now generate the detailed Product Requirements Documents (PRDs) for each phase of the VS Code extension project.

Here is the first PRD, which covers the foundational setup of the extension.

-----

### **New Document: PRD 1: Foundational - Extension Boilerplate & UI Setup**

**1. Title & Overview**

  * **Project:** Code Context Engine - VS Code Extension
  * **Summary:** This phase establishes the core technical foundation for the VS Code extension. It includes setting up the project with the chosen technology stack (SvelteKit and TypeScript), creating the basic user interface using Microsoft's Fluent UI, and ensuring the basic extension can be loaded and run within a VS Code development environment.
  * **Dependencies:** Requires Node.js, npm/yarn, and the VS Code Extension Development Kit.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Rapidly create a tangible, runnable prototype to validate the chosen technology stack.
      * Establish a solid foundation for the user interface that can be easily extended in future phases.
  * **Developer & System Success Metrics:**
      * The VS Code extension can be successfully compiled, loaded, and activated in a development host.
      * The main SvelteKit-based UI panel renders correctly within VS Code.
      * Core UI components (buttons, progress bars) from the Fluent UI library are successfully integrated and functional.
      * The project structure is well-organized, with clear separation between the extension's backend (TypeScript) and frontend (SvelteKit) concerns.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin works on large, complex codebases and needs a tool to help him quickly understand code context. He expects a clean, intuitive, and responsive user interface that feels native to the VS Code environment.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Foundation** | **Sprint 1: Boilerplate & UI Scaffolding** | As a developer, I want a VS Code extension project set up with SvelteKit for the UI and TypeScript for the backend logic, so we have a standard, modern technology stack. | 1. A new VS Code extension project is generated using the official templates.\<br\>2. SvelteKit is successfully integrated as the webview provider for the extension's UI.\<br\>3. TypeScript is configured for both the extension's main process (backend) and the SvelteKit frontend.\<br\>4. The project can be compiled and run without errors. | **2 Weeks** |
| | | As Devin, I want to see a main panel for the extension with a clear "Index Now" button, so I know how to start the core process. | 1. The extension contributes a new view/panel to the VS Code UI.\<br\>2. This panel renders a SvelteKit component.\<br\>3. The component displays a prominent button with the text "Index Now" using a Fluent UI `Button` component.\<br\>4. A placeholder for a progress bar is visible on the UI. | |
| | | As a developer, I want to integrate Microsoft's Fluent UI library into the SvelteKit project, so we can build a consistent and professional-looking UI quickly. | 1. The Fluent UI Svelte library is added as a project dependency.\<br\>2. A sample Fluent UI component (e.g., a button or card) is successfully rendered within the extension's webview.\<br\>3. The styling of the Fluent UI components matches the user's current VS Code theme (light/dark). | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 1:** Boilerplate & UI Scaffolding (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** SvelteKit can be integrated smoothly as a webview UI for a VS Code extension without significant compatibility issues.
  * **Risk:** Integrating Fluent UI with SvelteKit might have unforeseen styling conflicts or component incompatibilities.
      * **Mitigation:** Dedicate early time in the sprint to create a small proof-of-concept integrating a few key Fluent UI components to identify and resolve any issues.
  * **Risk:** The initial project setup and build configuration for a hybrid TypeScript/SvelteKit extension might be more complex than anticipated.
      * **Mitigation:** Allocate sufficient time for research and follow best practices from official documentation and community examples.

-----

### **New Document: Sub-Sprint 1: VS Code Extension Boilerplate Setup**

**Objective:**
To create the fundamental file structure and configuration for a new VS Code extension using TypeScript.

**Parent Sprint:**
PRD 1, Sprint 1: Boilerplate & UI Scaffolding

**Tasks:**

1.  **Generate Extension:** Use `yo code` to generate a new TypeScript-based VS Code extension.
2.  **Configure `package.json`:** Define the extension's name, publisher, and activation events.
3.  **Establish Project Structure:** Create separate directories for the `extension` (backend) and `webview` (frontend) source code.
4.  **Initial Backend Logic:** Write the initial `extension.ts` file, including the `activate` and `deactivate` functions.

**Acceptance Criteria:**

  * The extension can be launched in a VS Code development host.
  * A "Hello World" command from the extension can be successfully executed from the command palette.
  * The project structure is clean and logically separated.

**Dependencies:**

  * Node.js and `yo code` generator installed.

**Timeline:**

  * **Start Date:** 2025-10-27
  * **End Date:** 2025-10-31

-----

### **New Document: Sub-Sprint 2: SvelteKit and Fluent UI Integration**

**Objective:**
To set up the SvelteKit frontend and integrate the Fluent UI component library, creating the initial user interface.

**Parent Sprint:**
PRD 1, Sprint 1: Boilerplate & UI Scaffolding

**Tasks:**

1.  **Initialize SvelteKit:** Set up a new SvelteKit project within the `webview` directory.
2.  **Configure Webview:** In `extension.ts`, create the logic to render the SvelteKit app inside a VS Code webview panel.
3.  **Install Fluent UI:** Add the Fluent UI Svelte library as a dependency to the SvelteKit project.
4.  **Implement UI:** Create a Svelte component for the main panel that includes an "Index Now" button and a progress bar from the Fluent UI library.
5.  **Theme Integration:** Ensure the UI components automatically adapt to VS Code's light and dark themes.

**Acceptance Criteria:**

  * The SvelteKit application renders correctly inside the VS Code extension panel.
  * The "Index Now" button is visible and interactive.
  * UI components correctly reflect the active VS Code theme.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2025-11-03
  * **End Date:** 2025-11-07

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Boilerplate & UI Scaffolding

**Goal:** To establish the project's foundation by setting up the VS Code extension with a SvelteKit frontend and Fluent UI.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Generate VS Code Extension:** Run `npx yo code` and select "New Extension (TypeScript)". | `(Project Root)` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** In a new `webview` directory, run `npm create svelte@latest .` and configure it for a single-page app. | `webview/` |
| **1.3** |  To Do | **Install Dependencies:** Add `svelte-fluent-ui` to the `webview`'s `package.json` and install. | `webview/package.json` |
| **1.4** |  To Do | **Create Webview Panel Logic:** In `extension.ts`, write the TypeScript code to create and manage a `WebviewPanel`. | `src/extension.ts` |
| **1.5** |  To Do | **Load Svelte App in Webview:** Configure the webview to load the compiled `index.html` from the SvelteKit `build` directory. | `src/extension.ts` |
| **1.6** |  To Do | **Build Main UI Component:** Create a `MainPanel.svelte` component displaying a `<Button>` and `<ProgressBar>` from Fluent UI. | `webview/src/lib/MainPanel.svelte` |
| **1.7** |  To Do | **Implement Theme Handling:** Use VS Code theme CSS variables to ensure Fluent UI components adapt to light/dark modes. | `webview/src/app.html` |
| **1.8** |  To Do | **Test Extension:** Run the extension in a development host to verify the UI panel opens and displays the SvelteKit app correctly. | `(Launch Configuration)` |

Of course. Here are the final PRDs and task lists to complete the project plan for your VS Code extension.

-----

### **New Document: PRD 3: Context Engine API & Feature Enhancement**

**1. Title & Overview**

  * **Project:** Code Context Engine - API & Settings
  * **Summary:** This phase focuses on exposing the indexed data through an internal API and building the user-facing settings UI. This will enable the core functionality of the extensionquerying the codebase for contextand allow users to configure the extension to their specific needs, such as changing the database connection or selecting a different embedding provider.
  * **Dependencies:** PRD 2 must be complete. The codebase must be successfully indexed and stored in a Qdrant instance.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Deliver the primary value proposition of the extension by allowing users to query their code contextually.
      * Increase user retention and satisfaction by providing customization options.
  * **Developer & System Success Metrics:**
      * The internal API successfully handles queries like "list files related to X" and "get content of Y" by performing a vector search.
      * API response times for typical queries are under 500ms.
      * The settings UI correctly reads from and writes to the VS Code workspace configuration.
      * Changing a setting (e.g., the embedding provider) is correctly reflected in the indexing service on the next run.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin wants to ask his codebase questions in plain English. He needs to be able to ask for the content of a specific file or find other files related to the one he's working on to speed up his development workflow. He also wants to easily configure the extension to use his preferred embedding model.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: API & Settings** | **Sprint 4: Context Query API** | As Devin, I want to be able to ask the extension to retrieve the content of a specific file so I can view it without having to manually search for it. | 1. An internal API endpoint is created to handle "get file content" requests.\<br/\>2. The API performs a search in the vector index to find the most likely file matching the query.\<br/\>3. The full, up-to-date content of the identified file is returned. | **2 Weeks** |
| | | As Devin, I want to ask for a list of files related to a specific file or concept so I can understand the connections within my codebase. | 1. An internal API endpoint is created for "find related files" requests.\<br/\>2. The API vectorizes the input query and performs a similarity search in Qdrant.\<br/\>3. A ranked list of the top 5 most relevant file paths is returned based on the search results. | |
| **Phase 3: API & Settings** | **Sprint 5: Settings UI & Configuration** | As Devin, I want a dedicated settings page for the extension so I can configure the database and embedding provider for each of my projects. | 1. A new webview panel is created for the extension's settings.\<br/\>2. The UI includes a dropdown to select an embedding provider (Ollama, OpenAI, etc.).\<br/\>3. The UI includes a text input for the database connection string.\<br/\>4. The settings are saved to the workspace's `settings.json` file under a unique extension-specific key. | **2 Weeks** |
| | | As a developer, I want the extension's backend services to read their configuration from the workspace settings so that user changes are applied correctly. | 1. The `IndexingService` reads the selected embedding provider from the VS Code workspace configuration.\<br/\>2. The `QdrantService` reads the database connection string from the configuration.\<br/\>3. The extension gracefully handles missing or invalid configuration values by falling back to sensible defaults. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 4:** Context Query API (2 Weeks)
  * **Sprint 5:** Settings UI & Configuration (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** Simple vector similarity search will be sufficient to find "related" files accurately for the initial version.
  * **Risk:** The quality of search results might be poor if the user's query is ambiguous, leading to user frustration.
      * **Mitigation:** For the initial version, focus on clear query patterns. In a future phase, introduce an LLM to refine user queries before they are sent to the vector search.
  * **Risk:** Securely storing and handling user-provided secrets (like an OpenAI API key) is critical.
      * **Mitigation:** Use VS Code's official `SecretStorage` API for any sensitive information instead of storing it in plain text in the settings file.

-----

### **New Document: Sub-Sprint 5: Implement Context Query API**

**Objective:**
To build the internal backend API that will allow the frontend to query the indexed codebase.

**Parent Sprint:**
PRD 3, Sprint 4: Context Query API

**Tasks:**

1.  **Create `ContextService`:** Develop a new service in the TypeScript backend to orchestrate context retrieval.
2.  **Implement `getFileContent`:** Create a method that takes a file path query, uses the embedding provider and Qdrant client to find the best match, and then reads the file content from the disk.
3.  **Implement `findRelatedFiles`:** Create a method that takes a concept or file path, generates an embedding for it, and performs a vector similarity search in Qdrant to find the top N most similar file chunks.
4.  **Expose via Message Passing:** Use the standard VS Code webview message passing interface to allow the SvelteKit frontend to call these backend service methods.

**Acceptance Criteria:**

  * Sending a "getFileContent" message from the webview returns the correct file's content.
  * Sending a "findRelatedFiles" message returns an array of relevant file paths.
  * The API handles cases where no relevant files are found gracefully.

**Dependencies:**

  * PRD 2 must be complete.

**Timeline:**

  * **Start Date:** 2025-11-24
  * **End Date:** 2025-11-28

-----

### **New Document: Sub-Sprint 6: Develop Settings UI**

**Objective:**
To create the user-facing settings panel where users can configure the extension's behavior.

**Parent Sprint:**
PRD 3, Sprint 5: Settings UI & Configuration

**Tasks:**

1.  **Register Settings Command:** Add a new command to `package.json` that will open the settings webview.
2.  **Create Settings Webview:** Develop the TypeScript logic in `extension.ts` to create and show a new webview panel for settings.
3.  **Build Svelte UI:** Create a `Settings.svelte` component using Fluent UI components (`<Select>`, `<TextField>`) for the provider and database configuration.
4.  **Implement State Management:** The Svelte component should read the current configuration from VS Code settings on load and use message passing to send updated values back to the extension backend to be saved.

**Acceptance Criteria:**

  * A new command in the command palette successfully opens the settings UI.
  * The UI correctly displays the currently saved settings.
  * Changing a value in the UI and clicking "Save" correctly updates the workspace `settings.json` file.

**Dependencies:**

  * Sub-Sprint 5 must be complete.

**Timeline:**

  * **Start Date:** 2025-12-01
  * **End Date:** 2025-12-05

-----

### **New Document: tasklist\_sprint\_04.md**

# Task List: Sprint 4 - Context Query API

**Goal:** To build and expose the internal API for querying the indexed code context.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `ContextService`:** In the backend, create a new `contextService.ts` file to house the query logic. | `src/context/contextService.ts` |
| **4.2** |  To Do | **Implement `getFileContent` method:** Add logic to perform a vector search for the file path and then read the content from disk using `vscode.workspace.fs`. | `src/context/contextService.ts` |
| **4.3** |  To Do | **Implement `findRelatedFiles` method:** Add logic to perform a similarity search in Qdrant and return a list of unique file paths from the results. | `src/context/contextService.ts` |
| **4.4** |  To Do | **Set up Webview Message Handling:** In `extension.ts`, add a `message` listener to the webview panel to handle incoming requests from the frontend. | `src/extension.ts` |
| **4.5** |  To Do | **Route API Calls:** In the message handler, create a `switch` statement to route requests (e.g., `'getFileContent'`) to the appropriate method in `ContextService`. | `src/extension.ts` |
| **4.6** |  To Do | **Send Results to Frontend:** Use the `webview.postMessage` method to send the results from the service back to the SvelteKit UI. | `src/extension.ts` |
| **4.7** |  To Do | **Create Frontend API Client:** In the SvelteKit app, create a wrapper service (`vscodeApi.ts`) that simplifies posting and listening for messages from the extension backend. | `webview/src/lib/vscodeApi.ts` |

-----

### **New Document: tasklist\_sprint\_05.md**

# Task List: Sprint 5 - Settings UI & Configuration

**Goal:** To build the settings UI and connect it to the VS Code configuration system.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** |  To Do | **Define Configuration Schema:** In `package.json`, under the `contributes.configuration` section, define the properties for the settings (e.g., `code-context.embeddingProvider`). | `package.json` |
| **5.2** |  To Do | **Register `openSettings` command:** In `package.json`, add a new command to the `contributes.commands` section. | `package.json` |
| **5.3** |  To Do | **Implement command in `extension.ts`:** Register the command to create and show the settings webview panel. | `src/extension.ts` |
| **5.4** |  To Do | **Create `Settings.svelte` component:** Build the UI with a `<Select>` for providers and a `<TextField>` for the database URI. | `webview/src/routes/settings.svelte` |
| **5.5** |  To Do | **Load Initial Settings:** In the Svelte component, use the `vscodeApi` service to request the current configuration when the component mounts. | `webview/src/routes/settings.svelte` |
| **5.6** |  To Do | **Save Settings:** On button click, send a message with the updated settings object to the extension backend. | `webview/src/routes/settings.svelte` |
| **5.7** |  To Do | **Implement `saveConfiguration` handler:** In the backend message listener, handle the "saveSettings" message by calling `vscode.workspace.getConfiguration().update()`. | `src/extension.ts` |
| **5.8** |  To Do | **Refactor Services to Use Config:** Update `IndexingService` and `QdrantService` to read their settings from `vscode.workspace.getConfiguration()` instead of hardcoded values. | `src/indexing/indexingService.ts`, `src/db/qdrantService.ts` |

-----

### **New Document: PRD 4: Advanced Features & Polish**

**1. Title & Overview**

  * **Project:** Code Context Engine - Advanced Indexing & Publishing
  * **Summary:** This final phase focuses on enhancing the quality of the index by integrating data from the Language Server Protocol (LSP), establishing a professional release process with a CI/CD pipeline, and creating comprehensive documentation to support users and future contributors.
  * **Dependencies:** PRD 3 must be complete.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Gain a competitive advantage by creating a more intelligent and contextually-aware index than simple AST parsing can provide.
      * Ensure long-term project health and user trust through a reliable release process and clear documentation.
  * **Developer & System Success Metrics:**
      * The indexing process can successfully capture and store LSP data like "go to definition" and "find all references" links between code chunks.
      * A GitHub Actions workflow is created that automatically builds, lints, tests, and packages the extension on every push to the `main` branch.
      * The extension is successfully published to the Visual Studio Code Marketplace.
      * A `README.md` and contributing guide are created that meet open-source community standards.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 4: Polish** | **Sprint 6: LSP Integration & DevOps** | As Alisha, I want to enhance the index by capturing data from the Language Server Protocol (LSP) so that we can understand relationships between code. | 1. The extension can programmatically access the active LSP for supported languages.\<br/\>2. During indexing, the system queries the LSP for information like definitions and references for each code chunk.\<br/\>3. This relationship data is stored as metadata alongside the vectors in Qdrant. | **2 Weeks** |
| | | As Alisha, I want to create a CI/CD pipeline using GitHub Actions so that we can automate the build, test, and release process. | 1. A new GitHub Actions workflow file is created.\<br/\>2. The workflow is triggered on pushes and pull requests.\<br/\>3. The workflow includes stages for installing dependencies, linting, running unit tests, and building the extension package (`.vsix`). | |
| **Phase 4: Polish** | **Sprint 7: Documentation & Publishing** | As Devin, I want clear, comprehensive documentation for the extension so that I know how to install, configure, and use it effectively. | 1. The `README.md` file is updated with a feature list, installation instructions, and a guide on configuring the settings.\<br/\>2. An animated GIF is included in the README to demonstrate the core workflow.\<br/\>3. A `CONTRIBUTING.md` file is created with guidelines for new developers. | **2 Weeks** |
| | | As a project owner, I want to publish the extension to the VS Code Marketplace so that it is easily discoverable and accessible to all users. | 1. A publisher identity is created on the VS Code Marketplace.\<br/\>2. The GitHub Actions pipeline is updated with a manual "release" trigger.\<br/\>3. When triggered, the pipeline automatically packages and publishes the latest version of the extension to the marketplace. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 6:** LSP Integration & DevOps (2 Weeks)
  * **Sprint 7:** Documentation & Publishing (2 Weeks)

-----

### **New Document: tasklist\_sprint\_06.md**

# Task List: Sprint 6 - LSP Integration & DevOps

**Goal:** To enrich the index with LSP data and automate the build and test process.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** |  To Do | **Research LSP Interaction:** Investigate how to programmatically interact with a language server using the `vscode.lsp` API. | `(Documentation)` |
| **6.2** |  To Do | **Update `IndexingService` for LSP:** Modify the service to, for each chunk, invoke LSP commands like `vscode.executeDefinitionProvider` to find related symbols. | `src/indexing/indexingService.ts` |
| **6.3** |  To Do | **Extend Qdrant Metadata:** Update the `QdrantService` to store the new relationship metadata (e.g., `definesSymbol`, `referencesSymbol`) along with the vector. | `src/db/qdrantService.ts` |
| **6.4** |  To Do | **Create GitHub Actions Workflow:** Create a `.github/workflows/ci.yml` file. | `.github/workflows/ci.yml` |
| **6.5** |  To Do | **Add Linting and Testing Steps:** Add jobs to the workflow for running `eslint` and `vitest`. | `.github/workflows/ci.yml` |
| **6.6** |  To Do | **Add Build Step:** Add a job that runs `vsce package` to create the `.vsix` extension file and uploads it as a build artifact. | `.github/workflows/ci.yml` |

-----

### **New Document: tasklist\_sprint\_07.md**

# Task List: Sprint 7 - Documentation & Publishing

**Goal:** To create high-quality documentation and publish the extension to the marketplace.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **7.1** |  To Do | **Write `README.md` Content:** Draft the main sections: Features, Requirements, Installation, and Configuration. | `README.md` |
| **7.2** |  To Do | **Create Demo GIF:** Use screen recording software to capture the indexing and querying workflow and save it as an optimized GIF. | `assets/demo.gif` |
| **7.3** |  To Do | **Write `CONTRIBUTING.md`:** Create a guide for developers on how to set up the project, run tests, and submit pull requests. | `CONTRIBUTING.md` |
| **7.4** |  To Do | **Create Marketplace Publisher:** Register a new publisher ID in the Microsoft Partner Center. | `(External)` |
| **7.5** |  To Do | **Add Release Workflow:** Update the `ci.yml` file to include a manually triggered `release` job. | `.github/workflows/ci.yml` |
| **7.6** |  To Do | **Implement Publishing Step:** The `release` job should use `vsce publish` with a personal access token (stored as a GitHub secret) to upload the extension. | `.github/workflows/ci.yml` |
| **7.7** |  To Do | **Test the Release:** Manually trigger the release workflow for a `v1.0.0` tag and verify that the extension appears on the VS Code Marketplace. | `(External)` |

This completes the full set of PRDs and task lists for the Code Context Engine project. You now have a comprehensive, phased plan to guide you from the initial boilerplate to a published and feature-rich VS Code extension.

Of course. Here is a comprehensive guide to implementing Sprint 2: "AST Parser & Code Chunking" for your VS Code extension. This guide includes analysis, code examples, and API information based on the PRD and my research.

### **Analysis of `repomix-roocode.xml`**

The provided `repomix-roocode.xml` file confirms that the project is a standard SvelteKit application using TypeScript and Vitest for testing. The presence of `setup.ts` with JSDOM mocks indicates a robust testing environment. The project structure appears to be conventional, which makes integrating the new services straightforward. The key takeaway is that the new backend services should be written in TypeScript and can be unit-tested using the existing Vitest setup.

-----

### **Prerequisites and Setup**

Before you start coding, you'll need to add a few dependencies to your project for file parsing and AST manipulation.

**1. Install `tree-sitter` and Language Grammars:**

`tree-sitter` is a powerful parser generator tool. You'll need the core library and the specific grammar for each language you want to support.

```bash
npm install tree-sitter tree-sitter-typescript tree-sitter-python tree-sitter-c-sharp
```

**2. Install Helper Libraries:**

You'll also need a library to handle `.gitignore` files and another for efficient file system traversal.

```bash
npm install glob ignore
```

-----

### **Implementation Guide**

Here's a step-by-step guide to building the services outlined in `tasklist_sprint_02.md`.

#### **1. The `FileWalker` Service**

This service is responsible for finding all the files in the workspace that need to be indexed, while respecting the rules in `.gitignore`.

**API Information:**

  * **`vscode.workspace.fs`:** The official VS Code API for reading files and directories. It's asynchronous and designed to work with virtual file systems.
  * **`glob` package:** A library for matching files using patterns.
  * **`ignore` package:** A high-performance library for parsing `.gitignore` files.

**Code Example (`src/indexing/fileWalker.ts`):**

```typescript
import * as vscode from 'vscode';
import { glob } from 'glob';
import { promises as fs } from 'fs';
import path from 'path';
import ignore from 'ignore';

export class FileWalker {
    private ig = ignore();

    constructor(private workspaceRoot: string) {}

    private async loadGitignore(): Promise<void> {
        try {
            const gitignorePath = path.join(this.workspaceRoot, '.gitignore');
            const gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');
            this.ig.add(gitignoreContent);
        } catch (error) {
            console.log("No .gitignore file found or could not be read.");
        }
    }

    public async findAllFiles(): Promise<string[]> {
        await this.loadGitignore();
        const files = await glob('**/*.{ts,js,py,cs}', {
            cwd: this.workspaceRoot,
            nodir: true,
            absolute: true,
        });

        return files.filter(file => !this.ig.ignores(path.relative(this.workspaceRoot, file)));
    }
}
```

#### **2. The `AstParser` Service**

This service takes a file and its content, and using `tree-sitter`, parses it into an Abstract Syntax Tree (AST).

**API Information:**

  * **`tree-sitter` package:** The core library for parsing.
  * **Language-specific `tree-sitter` packages:** (e.g., `tree-sitter-typescript`) provide the grammars.

**Code Example (`src/parsing/astParser.ts`):**

```typescript
import Parser from 'tree-sitter';
import TypeScript from 'tree-sitter-typescript';
import Python from 'tree-sitter-python';
import CSharp from 'tree-sitter-c-sharp';

export class AstParser {
    private parser = new Parser();

    public parse(language: 'typescript' | 'python' | 'csharp', code: string): Parser.Tree {
        switch (language) {
            case 'typescript':
                this.parser.setLanguage(TypeScript.typescript);
                break;
            case 'python':
                this.parser.setLanguage(Python);
                break;
            case 'csharp':
                this.parser.setLanguage(CSharp);
                break;
        }
        return this.parser.parse(code);
    }
}
```

#### **3. The `Chunker` Service**

This service takes an AST and chunks the code into meaningful segments (e.g., functions, classes).

**API Information:**

  * **`tree-sitter` `Query` API:** This allows you to find specific nodes in the AST using a LISP-like query language.

**Code Example (`src/parsing/chunker.ts`):**

```typescript
import Parser from 'tree-sitter';

export interface CodeChunk {
    filePath: string;
    content: string;
    startLine: number;
    endLine: number;
    type: string;
}

export class Chunker {
    public chunk(filePath: string, tree: Parser.Tree, code: string): CodeChunk[] {
        const query = new Parser.Query(tree.getLanguage(), `
            (function_declaration) @function
            (class_declaration) @class
            (method_declaration) @method
        `);

        const matches = query.matches(tree.rootNode);
        const chunks: CodeChunk[] = [];

        for (const match of matches) {
            for (const capture of match.captures) {
                const node = capture.node;
                chunks.push({
                    filePath,
                    content: node.text,
                    startLine: node.startPosition.row,
                    endLine: node.endPosition.row,
                    type: capture.name,
                });
            }
        }
        return chunks;
    }
}
```

#### **4. The `IndexingService` (Orchestrator)**

This service brings everything together. It uses the `FileWalker` to get the files, the `AstParser` to parse them, and the `Chunker` to create the final code chunks.

**API Information:**

  * **`vscode.window.withProgress`:** A VS Code API for showing progress notifications to the user.

**Code Example (`src/indexing/indexingService.ts`):**

```typescript
import * as vscode from 'vscode';
import { FileWalker } from './fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker, CodeChunk } from '../parsing/chunker';

export class IndexingService {
    private fileWalker: FileWalker;
    private astParser = new AstParser();
    private chunker = new Chunker();

    constructor(private workspaceRoot: string) {
        this.fileWalker = new FileWalker(workspaceRoot);
    }

    public async startIndexing(): Promise<CodeChunk[]> {
        return vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Indexing Repository",
            cancellable: true
        }, async (progress, token) => {
            if (token.isCancellationRequested) {
                return [];
            }

            progress.report({ message: "Discovering files..." });
            const files = await this.fileWalker.findAllFiles();
            const totalFiles = files.length;
            let indexedFiles = 0;
            const allChunks: CodeChunk[] = [];

            for (const file of files) {
                if (token.isCancellationRequested) {
                    break;
                }

                indexedFiles++;
                progress.report({
                    message: `Parsing ${file}`,
                    increment: (1 / totalFiles) * 100
                });

                const content = await vscode.workspace.fs.readFile(vscode.Uri.file(file)).then(buffer => buffer.toString());
                const language = this.getLanguage(file);
                if (language) {
                    const tree = this.astParser.parse(language, content);
                    const chunks = this.chunker.chunk(file, tree, content);
                    allChunks.push(...chunks);
                }
            }

            return allChunks;
        });
    }

    private getLanguage(filePath: string): 'typescript' | 'python' | 'csharp' | null {
        if (filePath.endsWith('.ts') || filePath.endsWith('.js')) {
            return 'typescript';
        }
        if (filePath.endsWith('.py')) {
            return 'python';
        }
        if (filePath.endsWith('.cs')) {
            return 'csharp';
        }
        return null;
    }
}
```

### **Putting It All Together**

You would trigger the `IndexingService` from your main `extension.ts` file, likely when the user clicks the "Index Now" button you created in Sprint 1.

**Code Example (`src/extension.ts`):**

```typescript
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';

export function activate(context: vscode.ExtensionContext) {
    // ... other activation code

    let disposable = vscode.commands.registerCommand('your-extension.startIndexing', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            const workspaceRoot = workspaceFolders[0].uri.fsPath;
            const indexingService = new IndexingService(workspaceRoot);
            const chunks = await indexingService.startIndexing();
            console.log(`Indexing complete. Found ${chunks.length} chunks.`);
            // Here you would proceed to Sprint 3: Vectorization & DB Integration
        } else {
            vscode.window.showErrorMessage("Please open a folder or workspace to index.");
        }
    });

    context.subscriptions.push(disposable);
}
```

This guide provides the core implementation for Sprint 2. You now have a robust system for walking the file tree, parsing code with `tree-sitter`, and chunking it into meaningful segments. The next step will be to take these chunks and vectorize them for storage in Qdrant, as outlined in Sprint 3.

Of course. Here is the implementation guide for Sprint 3, which focuses on vectorizing the code chunks and storing them in the Qdrant database.

### **Analysis of `repomix-roocode.xml`**

The `repomix-roocode.xml` file shows a standard SvelteKit project setup. The key takeaway is that the project is well-structured, uses TypeScript, and has a testing framework in place. This means that the new services for vectorization and database interaction can be seamlessly integrated and tested within the existing architecture. The presence of a `setup.ts` file for tests also indicates that we can easily mock external services like Ollama, OpenAI, and the Qdrant client for robust unit testing.

-----

### **Prerequisites and Setup**

Before you begin, you need to set up the necessary tools and dependencies for this sprint.

**1. Install Docker:**

If you don't already have it, install **Docker Desktop** on your development machine. This is required to run the Qdrant vector database locally.

**2. Install Dependencies:**

You'll need the official Qdrant client and a library for making HTTP requests to Ollama or other embedding providers.

```bash
npm install @qdrant/js-client-rest axios
```

**3. Set up a `.env` file (Optional but Recommended):**

Create a `.env` file in the root of your project to store API keys and other secrets. Make sure to add `.env` to your `.gitignore` file.

```
OPENAI_API_KEY="your-openai-api-key"
```

-----

### **Implementation Guide**

Here's a step-by-step guide to building the services outlined in `tasklist_sprint_03.md`.

#### **1. Docker Compose for Qdrant**

Create a `docker-compose.yml` file in the root of your project. This will allow you to easily start and stop the Qdrant database.

**Code Example (`docker-compose.yml`):**

```yaml
version: '3.8'
services:
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - ./qdrant_storage:/qdrant/storage
```

You can now start Qdrant by running `docker-compose up` in your terminal.

#### **2. The `QdrantService`**

This service will handle all communication with the Qdrant database, including creating collections and upserting data.

**API Information:**

  * **`@qdrant/js-client-rest` package:** The official JavaScript/TypeScript client for Qdrant.
  * **Key methods:**
      * `QdrantClient`: The main class for interacting with the Qdrant API.
      * `client.getCollections()`: Lists all available collections.
      * `client.createCollection()`: Creates a new collection with a specified schema.
      * `client.upsert()`: Inserts or updates points (vectors and their payloads) in a collection.

**Code Example (`src/db/qdrantService.ts`):**

```typescript
import { QdrantClient } from '@qdrant/js-client-rest';
import type { CodeChunk } from '../parsing/chunker';

export class QdrantService {
    private client = new QdrantClient({ url: 'http://localhost:6333' });

    public async createCollectionIfNotExists(collectionName: string): Promise<void> {
        const collections = await this.client.getCollections();
        if (!collections.collections.find(c => c.name === collectionName)) {
            await this.client.createCollection(collectionName, {
                vectors: { size: 768, distance: 'Cosine' }, // Adjust size based on your embedding model
            });
        }
    }

    public async upsertChunks(collectionName: string, chunks: CodeChunk[], vectors: number[][]): Promise<void> {
        const points = chunks.map((chunk, i) => ({
            id: `${chunk.filePath}:${chunk.startLine}-${chunk.endLine}`,
            vector: vectors[i],
            payload: {
                filePath: chunk.filePath,
                content: chunk.content,
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                type: chunk.type,
            },
        }));

        await this.client.upsert(collectionName, {
            wait: true,
            points,
        });
    }
}
```

#### **3. The Embedding Provider Interface and Implementations**

To keep the code clean and extensible, you'll create an interface for embedding providers and then implement it for Ollama and OpenAI.

**Code Example (`src/embeddings/embeddingProvider.ts`):**

```typescript
export interface IEmbeddingProvider {
    generateEmbeddings(chunks: string[]): Promise<number[][]>;
}
```

**Code Example (`src/embeddings/ollamaProvider.ts`):**

```typescript
import axios from 'axios';
import { IEmbeddingProvider } from './embeddingProvider';

export class OllamaProvider implements IEmbeddingProvider {
    public async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        const embeddings: number[][] = [];
        for (const chunk of chunks) {
            const response = await axios.post('http://localhost:11434/api/embeddings', {
                model: 'nomic-embed-text', // Or your preferred model
                prompt: chunk,
            });
            embeddings.push(response.data.embedding);
        }
        return embeddings;
    }
}
```

**Code Example (`src/embeddings/openaiProvider.ts`):**

```typescript
import axios from 'axios';
import { IEmbeddingProvider } from './embeddingProvider';
import * as vscode from 'vscode';


export class OpenAIProvider implements IEmbeddingProvider {
    private apiKey: string | undefined;

    constructor() {
        this.apiKey = vscode.workspace.getConfiguration('your-extension').get('openaiApiKey');
    }

    public async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        if (!this.apiKey) {
            vscode.window.showErrorMessage("OpenAI API key not found. Please set it in the extension settings.");
            return [];
        }

        const response = await axios.post('https://api.openai.com/v1/embeddings', {
            model: 'text-embedding-ada-002',
            input: chunks,
        }, {
            headers: {
                'Authorization': `Bearer ${this.apiKey}`,
            },
        });

        return response.data.data.map((item: any) => item.embedding);
    }
}
```

#### **4. Updating the `IndexingService`**

Finally, you'll update the `IndexingService` to use the new `QdrantService` and an embedding provider to complete the indexing process.

**Code Example (`src/indexing/indexingService.ts`):**

```typescript
import * as vscode from 'vscode';
import { FileWalker } from './fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker, CodeChunk } from '../parsing/chunker';
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { OllamaProvider } from '../embeddings/ollamaProvider'; // Default provider

export class IndexingService {
    private fileWalker: FileWalker;
    private astParser = new AstParser();
    private chunker = new Chunker();
    private qdrantService = new QdrantService();
    private embeddingProvider: IEmbeddingProvider;

    constructor(private workspaceRoot: string) {
        this.fileWalker = new FileWalker(workspaceRoot);
        // This will be updated in a later sprint to be configurable
        this.embeddingProvider = new OllamaProvider();
    }

    public async startIndexing(): Promise<void> {
        return vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Indexing Repository",
            cancellable: true
        }, async (progress, token) => {
            // ... (file walking, parsing, and chunking logic from Sprint 2)

            const allChunks: CodeChunk[] = []; // Assume this is populated

            progress.report({ message: "Generating embeddings..." });
            const contents = allChunks.map(chunk => chunk.content);
            const vectors = await this.embeddingProvider.generateEmbeddings(contents);

            progress.report({ message: "Storing in vector database..." });
            const collectionName = path.basename(this.workspaceRoot);
            await this.qdrantService.createCollectionIfNotExists(collectionName);
            await this.qdrantService.upsertChunks(collectionName, allChunks, vectors);

            vscode.window.showInformationMessage("Indexing complete!");
        });
    }

    // ... (getLanguage method from Sprint 2)
}
```

This completes the implementation guide for Sprint 3. You now have a complete pipeline for finding, parsing, chunking, vectorizing, and storing your code. The next logical step is to build the API and UI to actually *use* this indexed data, as outlined in the subsequent PRDs.
</prd>


[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/completed/setup/tasklist_sprint_01.md">
# Task List: Sprint 1 - Boilerplate & UI Scaffolding

**Goal:** To establish the project's foundation by setting up the VS Code extension with a SvelteKit frontend and Fluent UI.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Generate VS Code Extension:** Run `npx yo code` in your project's root directory. When prompted, select "New Extension (TypeScript)", provide a suitable name (e.g., "Code Context Engine"), and accept default configurations for linting and Git initialization. | `(Project Root)` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** Navigate into the newly created `webview` directory (e.g., `cd webview`). Run `npm create svelte@latest .` and select "Skeleton project", "TypeScript", "ESLint", "Prettier", and "Vitest" when prompted. | `webview/` |
| **1.3** |  To Do | **Install SvelteKit Dependencies:** After initializing SvelteKit, run `npm install` inside the `webview` directory to install its dependencies. | `webview/package.json` |
| **1.4** |  To Do | **Install Fluent UI Dependencies:** While still in the `webview` directory, install the Fluent UI web components: `npm install @fluentui/web-components`. | `webview/package.json` |
| **1.5** |  To Do | **Create Webview Panel Logic:** Open `src/extension.ts`. Add TypeScript code within the `activate` function to create and manage a `WebviewPanel` that will host the SvelteKit application. This involves using `vscode.window.createWebviewPanel` and setting `enableScripts: true`. | `src/extension.ts` |
| **1.6** |  To Do | **Load Svelte App in Webview:** In `src/extension.ts`, configure the webview to load the compiled `index.html` from the SvelteKit `dist` directory. Ensure you use `vscode.Uri.file` and `path.join` to construct the correct absolute path, and handle relative paths for SvelteKit assets (e.g., `/_app/`) by converting them to `webview.asWebviewUri`. | `src/extension.ts` |
| **1.7** |  To Do | **Build SvelteKit App:** Navigate to the `webview` directory (`cd webview`) and run `npm run build` to compile the SvelteKit application into the `dist` folder. This step must be completed before the extension can load the webview. | `webview/` |
| **1.8** |  To Do | **Build Main UI Component:** Create a new Svelte component (e.g., `webview/src/routes/+page.svelte` or `webview/src/lib/MainPanel.svelte`). Implement a basic UI displaying a `<fluent-button>` with the text "Index Now" and a `<fluent-progress-ring>` from the Fluent UI library. Register the Fluent UI components using `provideFluentDesignSystem().register()`. | `webview/src/routes/+page.svelte` or `webview/src/lib/MainPanel.svelte` |
| **1.9** |  To Do | **Implement Theme Handling:** In `webview/src/app.css` (or within your Svelte component's `<style>` tags), use VS Code theme CSS variables (e.g., `--vscode-editor-background`, `--vscode-button-background`) to ensure Fluent UI components automatically adapt to light/dark modes. Apply these to the `body` and relevant Fluent UI custom properties. | `webview/src/app.css` or `webview/src/routes/+page.svelte` |
| **1.10** |  To Do | **Test Extension:** Press `F5` in VS Code to run the extension in a development host. Execute the command to open your extension's UI panel. Verify that the SvelteKit app loads correctly, the "Index Now" button and progress bar are visible, and the UI adapts to theme changes. | `(Launch Configuration)` |
</file>

<file path="docs/completed/setup/tasklist_sprint_02.md">
# Task List: Sprint 2 - AST Parser & Code Chunking

**Goal:** To implement the core logic for parsing code into Abstract Syntax Trees (ASTs) and chunking them into meaningful segments.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Install Tree-sitter and Language Grammars:** In your project's root directory, run `npm install tree-sitter tree-sitter-typescript tree-sitter-python tree-sitter-c-sharp` to install the core parser and necessary language grammars. | `package.json` |
| **2.2** |  To Do | **Install File System Helper Libraries:** In your project's root directory, run `npm install glob ignore` to install libraries for file matching and `.gitignore` parsing. | `package.json` |
| **2.3** |  To Do | **Create `FileWalker` Service File:** Create a new TypeScript file at `src/indexing/fileWalker.ts`. | `src/indexing/fileWalker.ts` |
| **2.4** |  To Do | **Implement `FileWalker` Constructor:** In `src/indexing/fileWalker.ts`, add a constructor that takes `workspaceRoot: string` and initializes an `ignore` instance. | `src/indexing/fileWalker.ts` |
| **2.5** |  To Do | **Implement `FileWalker.loadGitignore` Method:** In `src/indexing/fileWalker.ts`, add an asynchronous private method `loadGitignore` that reads the `.gitignore` file from `workspaceRoot` and adds its patterns to the `ignore` instance. Handle cases where `.gitignore` is not found. | `src/indexing/fileWalker.ts` |
| **2.6** |  To Do | **Implement `FileWalker.findAllFiles` Method:** In `src/indexing/fileWalker.ts`, add an asynchronous public method `findAllFiles` that first calls `loadGitignore`, then uses `glob` to find all relevant code files (e.g., `**/*.{ts,js,py,cs}`), and finally filters them using the `ignore` instance. | `src/indexing/fileWalker.ts` |
| **2.7** |  To Do | **Create `AstParser` Service File:** Create a new TypeScript file at `src/parsing/astParser.ts`. | `src/parsing/astParser.ts` |
| **2.8** |  To Do | **Implement `AstParser` Constructor:** In `src/parsing/astParser.ts`, add a constructor that initializes a `tree-sitter` `Parser` instance. | `src/parsing/astParser.ts` |
| **2.9** |  To Do | **Implement `AstParser.parse` Method:** In `src/parsing/astParser.ts`, add a public method `parse` that takes `language: 'typescript' | 'python' | 'csharp'` and `code: string`. Use a `switch` statement to set the correct `tree-sitter` language grammar and then parse the provided `code` into an AST, returning the `Parser.Tree`. | `src/parsing/astParser.ts` |
| **2.10** |  To Do | **Create `Chunker` Service File:** Create a new TypeScript file at `src/parsing/chunker.ts`. Define the `CodeChunk` interface within this file, including `filePath`, `content`, `startLine`, `endLine`, and `type`. | `src/parsing/chunker.ts` |
| **2.11** |  To Do | **Implement `Chunker.chunk` Method:** In `src/parsing/chunker.ts`, add a public method `chunk` that takes `filePath: string`, `tree: Parser.Tree`, and `code: string`. Use `tree-sitter`'s `Query` API to find specific nodes (e.g., function declarations, class declarations) in the AST. Iterate through matches and create `CodeChunk` objects, populating their properties from the AST nodes. | `src/parsing/chunker.ts` |
| **2.12** |  To Do | **Update `IndexingService` File:** Open `src/indexing/indexingService.ts`. If it doesn't exist, create it. This file will orchestrate the `FileWalker`, `AstParser`, and `Chunker`. | `src/indexing/indexingService.ts` |
| **2.13** |  To Do | **Implement `IndexingService` Constructor:** In `src/indexing/indexingService.ts`, add a constructor that takes `workspaceRoot: string` and initializes instances of `FileWalker`, `AstParser`, and `Chunker`. | `src/indexing/indexingService.ts` |
| **2.14** |  To Do | **Implement `IndexingService.startIndexing` Method:** In `src/indexing/indexingService.ts`, add an asynchronous public method `startIndexing`. This method should use `vscode.window.withProgress` to show a progress notification. Inside, call `fileWalker.findAllFiles()`. For each file, read its content using `vscode.workspace.fs.readFile`, determine its language, parse it with `astParser.parse()`, and then chunk it with `chunker.chunk()`. Collect all generated `CodeChunk` objects. | `src/indexing/indexingService.ts` |
| **2.15** |  To Do | **Implement `IndexingService.getLanguage` Method:** In `src/indexing/indexingService.ts`, add a private helper method `getLanguage` that takes a `filePath` and returns the corresponding language (e.g., 'typescript', 'python', 'csharp') or `null` based on the file extension. | `src/indexing/indexingService.ts` |
| **2.16** |  To Do | **Integrate `IndexingService` into `extension.ts`:** In `src/extension.ts`, modify the `activate` function to instantiate `IndexingService` and call `startIndexing` when a specific command (e.g., "Index Now") is executed. Ensure proper error handling and user feedback (e.g., `vscode.window.showInformationMessage`). | `src/extension.ts` |
</file>

<file path="docs/completed/setup/tasklist_sprint_03.md">
# Task List: Sprint 3 - Vectorization & DB Integration

**Goal:** To vectorize the code chunks and store them in the Qdrant database.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Install Qdrant Client and Axios:** In your project's root directory, run `npm install @qdrant/js-client-rest axios` to install the Qdrant JavaScript client and an HTTP client for embedding providers. | `package.json` |
| **3.2** |  To Do | **Create Docker Compose File for Qdrant:** In your project's root directory, create a new file named `docker-compose.yml`. | `docker-compose.yml` |
| **3.3** |  To Do | **Add Qdrant Service Definition to Docker Compose:** In `docker-compose.yml`, define the Qdrant service, specifying the `qdrant/qdrant:latest` image, port mappings (`6333:6333`, `6334:6334`), and a volume for persistent storage (`./qdrant_storage:/qdrant/storage`). | `docker-compose.yml` |
| **3.4** |  To Do | **Start Qdrant Container:** From your project's root directory, run `docker-compose up -d` to start the Qdrant database in the background. | `(Terminal Command)` |
| **3.5** |  To Do | **Create `QdrantService` File:** Create a new TypeScript file at `src/db/qdrantService.ts`. | `src/db/qdrantService.ts` |
| **3.6** |  To Do | **Implement `QdrantService` Constructor:** In `src/db/qdrantService.ts`, add a constructor that initializes a `QdrantClient` instance, connecting to the local Qdrant instance (e.g., `http://localhost:6333`). | `src/db/qdrantService.ts` |
| **3.7** |  To Do | **Implement `QdrantService.createCollectionIfNotExists` Method:** In `src/db/qdrantService.ts`, add an asynchronous public method `createCollectionIfNotExists` that takes `collectionName: string`. This method should check if the collection already exists using `client.getCollections()` and, if not, create it using `client.createCollection()` with appropriate vector size and distance (e.g., `size: 768, distance: 'Cosine'`). | `src/db/qdrantService.ts` |
| **3.8** |  To Do | **Implement `QdrantService.upsertChunks` Method:** In `src/db/qdrantService.ts`, add an asynchronous public method `upsertChunks` that takes `collectionName: string`, `chunks: CodeChunk[]`, and `vectors: number[][]`. This method should map `CodeChunk` and `vector` data into `PointStruct` objects and then use `client.upsert()` to insert or update them in the specified collection. | `src/db/qdrantService.ts` |
| **3.9** |  To Do | **Create `IEmbeddingProvider` Interface File:** Create a new TypeScript file at `src/embeddings/embeddingProvider.ts`. Define the `IEmbeddingProvider` interface with a `generateEmbeddings(chunks: string[]): Promise<number[][]>` method. | `src/embeddings/embeddingProvider.ts` |
| **3.10** |  To Do | **Create `OllamaProvider` File:** Create a new TypeScript file at `src/embeddings/ollamaProvider.ts`. | `src/embeddings/ollamaProvider.ts` |
| **3.11** |  To Do | **Implement `OllamaProvider`:** In `src/embeddings/ollamaProvider.ts`, implement the `IEmbeddingProvider` interface. The `generateEmbeddings` method should make HTTP POST requests to the local Ollama API (`http://localhost:11434/api/embeddings`) for each chunk, using a specified model (e.g., `nomic-embed-text`), and return the generated embeddings. | `src/embeddings/ollamaProvider.ts` |
| **3.12** |  To Do | **Create `OpenAIProvider` File:** Create a new TypeScript file at `src/embeddings/openaiProvider.ts`. | `src/embeddings/openaiProvider.ts` |
| **3.13** |  To Do | **Implement `OpenAIProvider`:** In `src/embeddings/openaiProvider.ts`, implement the `IEmbeddingProvider` interface. The `generateEmbeddings` method should make HTTP POST requests to the OpenAI embeddings API (`https://api.openai.com/v1/embeddings`), using a specified model (e.g., `text-embedding-ada-002`), and include the API key from VS Code settings in the authorization header. Handle cases where the API key is missing. | `src/embeddings/openaiProvider.ts` |
| **3.14** |  To Do | **Update `IndexingService` to Use Embedding Provider and Qdrant:** Open `src/indexing/indexingService.ts`. Modify the `IndexingService` to include instances of `QdrantService` and `IEmbeddingProvider`. | `src/indexing/indexingService.ts` |
| **3.15** |  To Do | **Modify `IndexingService.startIndexing` Method:** In `src/indexing/indexingService.ts`, after chunking is complete, add steps to: 1) Extract content from all chunks, 2) Call `embeddingProvider.generateEmbeddings()` to get vectors, 3) Determine a collection name (e.g., based on workspace root), 4) Call `qdrantService.createCollectionIfNotExists()`, and 5) Call `qdrantService.upsertChunks()` to store the chunks and vectors in Qdrant. | `src/indexing/indexingService.ts` |
| **3.16** |  To Do | **Add Progress Reporting for Embedding and Storage:** In `IndexingService.startIndexing`, update `vscode.window.withProgress` to report progress messages for "Generating embeddings..." and "Storing in vector database...". | `src/indexing/indexingService.ts` |
| **3.17** |  To Do | **Add Completion Message:** In `IndexingService.startIndexing`, after successful storage, display a completion message using `vscode.window.showInformationMessage("Indexing complete!")`. | `src/indexing/indexingService.Service` |
</file>

<file path="docs/completed/setup/tasklist_sprint_04.md">
# Task List: Sprint 4 - Context Query API

**Goal:** To build and expose the internal API for querying the indexed code context.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `ContextService`:** In the backend, create a new `contextService.ts` file at `src/context/contextService.ts` to house the query logic. | `src/context/contextService.ts` |
| **4.2** |  To Do | **Implement `getFileContent` method:** In `src/context/contextService.ts`, add logic to perform a vector search for the file path (using embedding provider and Qdrant) and then read the content from disk using `vscode.workspace.fs.readFile`. | `src/context/contextService.ts` |
| **4.3** |  To Do | **Implement `findRelatedFiles` method:** In `src/context/contextService.ts`, add logic to perform a similarity search in Qdrant (using embedding provider) and return a list of unique file paths from the results. | `src/context/contextService.ts` |
| **4.4** |  To Do | **Set up Webview Message Handling:** In `src/extension.ts`, add a `panel.webview.onDidReceiveMessage` listener to the webview panel to handle incoming requests from the frontend. | `src/extension.ts` |
| **4.5** |  To Do | **Route API Calls:** In the message handler within `src/extension.ts`, create a `switch` statement to route requests (e.g., `'getFileContent'`, `'findRelatedFiles'`) to the appropriate method in `ContextService`. | `src/extension.ts` |
| **4.6** |  To Do | **Send Results to Frontend:** In `src/extension.ts`, use the `webview.postMessage` method to send the results from the `ContextService` back to the SvelteKit UI. | `src/extension.ts` |
| **4.7** |  To Do | **Create Frontend API Client:** In the SvelteKit app, create a wrapper service (`webview/src/lib/vscodeApi.ts`) that simplifies posting and listening for messages from the extension backend using `acquireVsCodeApi()`. | `webview/src/lib/vscodeApi.ts` |
| **4.8** |  To Do | **Integrate Frontend with API Client:** In your Svelte components (e.g., `webview/src/routes/+page.svelte`), use the `vscodeApi.ts` client to send requests (e.g., for file content or related files) and handle the responses received from the extension backend. | `webview/src/routes/+page.svelte` |
</file>

<file path="docs/completed/setup/tasklist_sprint_05.md">
# Task List: Sprint 5 - Settings UI & Configuration

**Goal:** To build the settings UI and connect it to the VS Code configuration system.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** |  To Do | **Define Configuration Schema:** In `package.json`, under the `contributes.configuration` section, define the properties for the settings (e.g., `code-context.embeddingProvider`, `code-context.databaseConnectionString`), including their types, defaults, and descriptions. | `package.json` |
| **5.2** |  To Do | **Register `openSettings` command:** In `package.json`, add a new command to the `contributes.commands` section (e.g., `code-context-engine.openSettings`) that will be used to open the settings UI. | `package.json` |
| **5.3** |  To Do | **Implement command in `extension.ts`:** In `src/extension.ts`, register the `openSettings` command. The command handler should create and show a new `WebviewPanel` specifically for the settings UI, loading the SvelteKit app into it. | `src/extension.ts` |
| **5.4** |  To Do | **Create `Settings.svelte` component:** Create a new Svelte component (e.g., `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte`). Build the UI using Fluent UI components like `<fluent-select>` for embedding providers and `<fluent-text-field>` for the database URI. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.5** |  To Do | **Load Initial Settings:** In the `Settings.svelte` component, use the `onMount` lifecycle hook to send a message to the extension backend (via `vscodeApi.ts`) requesting the current configuration values. Listen for the response and populate the UI fields with the loaded settings. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.6** |  To Do | **Implement `getSettings` handler in `extension.ts`:** In `src/extension.ts`, add a message handler for the `getSettings` command. This handler should read the current configuration values from `vscode.workspace.getConfiguration('code-context-engine')` and send them back to the webview. | `src/extension.ts` |
| **5.7** |  To Do | **Save Settings from UI:** In the `Settings.svelte` component, add a button (e.g., "Save Settings"). On click, gather the current values from the UI fields and send them as a message (e.g., `saveSettings`) to the extension backend. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.8** |  To Do | **Implement `saveConfiguration` handler in `extension.ts`:** In `src/extension.ts`, add a message handler for the `saveSettings` command. This handler should receive the updated settings from the webview and use `vscode.workspace.getConfiguration().update()` to persist them to the VS Code configuration (e.g., `vscode.ConfigurationTarget.Global`). | `src/extension.ts` |
| **5.9** |  To Do | **Refactor Services to Use Config:** Update `src/indexing/indexingService.ts` and `src/db/qdrantService.ts` (and any other relevant services) to read their configuration (e.g., embedding provider, database connection string) from `vscode.workspace.getConfiguration('code-context-engine')` instead of hardcoded values. | `src/indexing/indexingService.ts`, `src/db/qdrantService.ts` |
</file>

<file path="docs/completed/setup/tasklist_sprint_06.md">
# Task List: Sprint 6 - LSP Integration & DevOps

**Goal:** To enrich the index with LSP data and automate the build and test process.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** |  To Do | **Research LSP Interaction:** Investigate how to programmatically interact with a language server using the `vscode.commands.executeCommand` API for LSP-related commands (e.g., `vscode.executeDefinitionProvider`, `vscode.executeReferenceProvider`). Understand the expected input parameters (URI, Position) and output formats. | `(Documentation)` |
| **6.2** |  To Do | **Update `IndexingService` for LSP:** In `src/indexing/indexingService.ts`, modify the `startIndexing` method (or create a helper method like `processChunkWithLSP`). For each code chunk, call the relevant `vscode.commands.executeCommand` for LSP data (definitions, references) using the chunk's file URI and start position. | `src/indexing/indexingService.ts` |
| **6.3** |  To Do | **Process LSP Results:** Within `IndexingService`, parse the results from the LSP commands. Extract relevant information (e.g., target URIs, ranges, symbol names) and structure it into a suitable format to be stored as metadata. | `src/indexing/indexingService.ts` |
| **6.4** |  To Do | **Extend `CodeChunk` Interface:** If not already done, update the `CodeChunk` interface (e.g., in `src/parsing/chunker.ts`) to include new properties for LSP-derived metadata (e.g., `lspDefinitions`, `lspReferences`). | `src/parsing/chunker.ts` |
| **6.5** |  To Do | **Extend Qdrant Metadata:** In `src/db/qdrantService.ts`, modify the `upsertChunks` method. Ensure that the `payload` object sent to Qdrant includes the newly added LSP metadata from the `CodeChunk` objects. | `src/db/qdrantService.ts` |
| **6.6** |  To Do | **Create GitHub Actions Workflow File:** In your project's root directory, create a new directory `.github/workflows/` if it doesn't exist. Inside this directory, create a new YAML file named `ci.yml`. | `.github/workflows/ci.yml` |
| **6.7** |  To Do | **Configure Workflow Triggers:** In `.github/workflows/ci.yml`, set the `on` section to trigger the workflow on `push` events to the `main` branch and on `pull_request` events targeting the `main` branch. | `.github/workflows/ci.yml` |
| **6.8** |  To Do | **Define Build Job:** In `.github/workflows/ci.yml`, define a `build` job that runs on `ubuntu-latest`. | `.github/workflows/ci.yml` |
| **6.9** |  To Do | **Add Checkout Step:** In the `build` job, add a step to `uses: actions/checkout@v3` to check out the repository code. | `.github/workflows/ci.yml` |
| **6.10** |  To Do | **Add Node.js Setup Step:** In the `build` job, add a step to `uses: actions/setup-node@v3` to set up the Node.js environment (specify your project's Node.js version, e.g., `node-version: '18'`). | `.github/workflows/ci.yml` |
| **6.11** |  To Do | **Add Install Dependencies Step:** In the `build` job, add a step to run `npm install` to install all project dependencies. | `.github/workflows/ci.yml` |
| **6.12** |  To Do | **Add Linting Step:** In the `build` job, add a step to run your project's linting command (e.g., `npm run lint`). | `.github/workflows/ci.yml` |
| **6.13** |  To Do | **Add Testing Step:** In the `build` job, add a step to run your project's test command (e.g., `npm test`). | `.github/workflows/ci.yml` |
| **6.14** |  To Do | **Add Build Extension Step:** In the `build` job, add a step to run the command that builds your VS Code extension package (e.g., `npm run vscode:prepublish` or `vsce package`). | `.github/workflows/ci.yml` |
| **6.15** |  To Do | **Add Upload Artifact Step:** In the `build` job, add a step to `uses: actions/upload-artifact@v3` to upload the generated `.vsix` file as a build artifact (e.g., `name: vsix-package`, `path: '*.vsix'`). | `.github/workflows/ci.yml` |
</file>

<file path="docs/completed/setup/tasklist_sprint_07.md">
# Task List: Sprint 7 - Documentation & Publishing

**Goal:** To create high-quality documentation and publish the extension to the marketplace.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **7.1** |  To Do | **Write `README.md` Content:** Open `README.md` in the project root. Draft the main sections: Features, Requirements, Installation, Configuration, and Usage. Ensure clear and concise language. | `README.md` |
| **7.2** |  To Do | **Create Demo GIF:** Use screen recording software to capture the core indexing and querying workflow of the extension. Optimize the recording and convert it into an animated GIF (e.g., `assets/demo.gif`). | `assets/demo.gif` |
| **7.3** |  To Do | **Embed GIF in `README.md`:** In `README.md`, add markdown syntax to display the `demo.gif` at an appropriate location (e.g., `![Demo GIF](assets/demo.gif)`). | `README.md` |
| **7.4** |  To Do | **Write `CONTRIBUTING.md`:** Create a new file named `CONTRIBUTING.md` in the project root. Write a guide for developers on how to set up the project, run tests, adhere to code style, and submit pull requests. | `CONTRIBUTING.md` |
| **7.5** |  To Do | **Create Marketplace Publisher:** Follow the official VS Code documentation to create a publisher identity on the Visual Studio Code Marketplace. This involves setting up an Azure DevOps organization and generating a Personal Access Token (PAT) with `Marketplace (Publish)` scope. | `(External - VS Code Marketplace)` |
| **7.6** |  To Do | **Add `VSCE_TOKEN` as GitHub Secret:** In your GitHub repository settings, navigate to `Settings` -> `Secrets and variables` -> `Actions`. Add a new repository secret named `VSCE_TOKEN` and paste the PAT generated in the previous step as its value. | `(GitHub Repository Settings)` |
| **7.7** |  To Do | **Add Manual Release Trigger to CI Workflow:** Open `.github/workflows/ci.yml`. In the `on` section, add `workflow_dispatch:` to enable manual triggering of the workflow from the GitHub Actions UI. | `.github/workflows/ci.yml` |
| **7.8** |  To Do | **Define Release Job in CI Workflow:** In `.github/workflows/ci.yml`, add a new job named `release` after the `build` job. This job should `needs: build` and run conditionally `if: github.event_name == 'workflow_dispatch'`. | `.github/workflows/ci.yml` |
| **7.9** |  To Do | **Add Steps to Release Job:** In the `release` job, add steps to: checkout the repository, set up Node.js, install `vsce` globally (`npm install -g vsce`), download the `.vsix` artifact from the `build` job, and finally run `vsce publish -p ${{ secrets.VSCE_TOKEN }}` to publish the extension. | `.github/workflows/ci.yml` |
| **7.10** |  To Do | **Test the Release Process:** Go to your GitHub repository's `Actions` tab. Select the `CI/CD` workflow and click `Run workflow`. Choose the `main` branch and click `Run workflow`. Monitor the job execution to ensure it completes successfully. | `(GitHub Actions UI)` |
| **7.11** |  To Do | **Verify Publication:** After the release workflow completes, search for your extension on the Visual Studio Code Marketplace to confirm it has been successfully published and is publicly accessible. | `(External - VS Code Marketplace)` |
</file>

<file path="docs/completed/ux/prd.md">
<prd>Of course. Here are the detailed PRDs focusing specifically on the frontend UI/UX development for your VS Code extension, broken down by each user-facing view.

-----

### **New Document: PRD 1: Foundational - Onboarding & Setup UI**

**1. Title & Overview**

  * **Project:** Code Context Engine - Onboarding UI/UX
  * **Summary:** This phase focuses on building the user's first interaction with the extension: the onboarding and setup view. This UI is critical for user activation and must clearly guide the user through configuring the necessary database and embedding providers for a new, un-indexed repository.
  * **Dependencies:** Requires the foundational SvelteKit and Fluent UI boilerplate (from the previous UI/UX roadmap) to be in place. The VS Code extension must be able to detect whether a repository has an existing configuration.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Maximize the rate of successful user onboarding (i.e., users who complete the setup and start indexing).
      * Minimize user confusion and support requests by making the setup process intuitive and self-explanatory.
  * **User Success Metrics:**
      * A new user can successfully configure and start the indexing process in under 2 minutes.
      * The UI provides clear feedback and status indicators (e.g., "database is running") to build user confidence.
      * The setup completion rate (users who click "Index Now") is above 85% for first-time users.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin has just installed the extension and opened a project. He needs a simple, step-by-step process to get started. He doesn't want to read lengthy documentation; the UI should guide him through the necessary choices and actions.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Onboarding** | **Sprint 1: Setup View Implementation** | As Devin, when I open an un-indexed project, I want to see a clear setup screen so I know what I need to do to get started. | 1. The extension correctly identifies when no `code-context.json` file is present and displays the `SetupView` component.\<br/\>2. The view contains distinct sections for "Database Configuration" and "Embedding Provider".\<br/\>3. The primary call-to-action button ("Index Now") is initially disabled. | **2 Weeks** |
| | | As Devin, I want to select my desired vector database and get help starting it if it's not running. | 1. A dropdown allows selecting "Qdrant".\<br/\>2. A button labeled "Start Local Qdrant" is visible.\<br/\>3. Clicking the button opens a new VS Code terminal and executes the `docker-compose up` command.\<br/\>4. A status icon next to the dropdown changes from "Not Running" to "Running" after a successful health check to the backend service. | |
| | | As Devin, I want to choose which embedding model to use for indexing my code. | 1. A dropdown allows selecting an embedding provider (e.g., "Ollama", "OpenAI").\<br/\>2. The "Index Now" button becomes enabled only after both the database is confirmed running and an embedding provider has been selected.\<br/\>3. The chosen configuration is saved to a state management store. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 1:** Setup View Implementation (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** Users will have Docker installed and running on their machine for local database setup.
  * **Risk:** The logic for detecting if a local service (like Qdrant) is running could be unreliable across different user machine setups.
      * **Mitigation:** Rely on the C\# backend to perform the health check and pass a simple boolean status to the frontend. This centralizes the logic and makes the UI's job simpler.
  * **Risk:** The user might be confused about what to do if the Docker command fails.
      * **Mitigation:** The TypeScript extension should monitor the terminal process it creates. If the process exits with a non-zero code, display a VS Code error notification with a link to a troubleshooting guide in the `README`.

-----

### **New Document: Sub-Sprint 1: Database Configuration Component**

**Objective:**
To build the Svelte component for the database selection and management part of the setup view.

**Parent Sprint:**
PRD 1, Sprint 1: Setup View Implementation

**Tasks:**

1.  **Create `DatabaseSetup.svelte` component:** Build the UI with a Fluent UI `<Select>` component for the database choice.
2.  **Implement "Start" button:** Add a Fluent UI `<Button>` that, when clicked, sends a message to the TypeScript extension backend to execute the Docker command.
3.  **Display Status Indicator:** Add a small status icon and text (e.g., " Not Running" / " Running") that is bound to a reactive variable from a Svelte store.
4.  **Backend Message Handling:** The TypeScript extension will listen for the "startDatabase" message, create a new VS Code `Terminal`, and run the command.

**Acceptance Criteria:**

  * The dropdown displays "Qdrant" as an option.
  * Clicking the button successfully opens a terminal and runs `docker-compose up`.
  * The UI status correctly reflects the health status received from the backend.

**Dependencies:**

  * VS Code extension boilerplate must be complete.
  * A `docker-compose.yml` file must exist in the project root.

**Timeline:**

  * **Start Date:** 2026-01-05
  * **End Date:** 2026-01-09

-----

### **New Document: Sub-Sprint 2: Embedding Provider & Workflow Logic**

**Objective:**
To build the embedding provider selection component and the final workflow logic to enable indexing.

**Parent Sprint:**
PRD 1, Sprint 1: Setup View Implementation

**Tasks:**

1.  **Create `EmbeddingSetup.svelte` component:** Build the UI with a Fluent UI `<Select>` to choose between "Ollama" and "OpenAI".
2.  **Implement Main "Index Now" Button:** Create the primary call-to-action button for the setup view.
3.  **Create Svelte Store for State:** Implement a Svelte writable store to manage the overall setup state (e.g., `databaseReady`, `providerSelected`).
4.  **Conditional Button Logic:** The "Index Now" button's `disabled` attribute should be reactively bound to the store's state, enabling only when all conditions are met.
5.  **Trigger Indexing:** When clicked, the button sends a "startIndexing" message to the backend with the selected configuration.

**Acceptance Criteria:**

  * The dropdown displays "Ollama" and "OpenAI" as options.
  * The "Index Now" button is disabled by default.
  * The button becomes enabled after the database is running AND a provider is selected.
  * Clicking the button successfully sends the configuration details to the extension backend.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2026-01-12
  * **End Date:** 2026-01-16

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Setup View Implementation

**Goal:** To build the complete user onboarding and setup UI within the VS Code extension's webview.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Create `SetupView.svelte` main component:** This component will act as the container for the setup process. | `webview/src/lib/views/SetupView.svelte` |
| **1.2** |  To Do | **Implement `DatabaseSetup.svelte` component:** Build the UI for database selection, the "Start" button, and status indicator. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.3** |  To Do | **Implement `EmbeddingSetup.svelte` component:** Build the UI for embedding provider selection. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.4** |  To Do | **Create `setupStore.ts`:** Define a Svelte store to manage the configuration state (`database`, `provider`, `isDbRunning`). | `webview/src/lib/stores/setupStore.ts` |
| **1.5** |  To Do | **Add `runCommandInTerminal` to extension backend:** In `extension.ts`, create a handler that receives a command string from the webview and executes it in a new VS Code terminal. | `src/extension.ts` |
| **1.6** |  To Do | **Implement state logic:** Connect the components to the store so that selecting options updates the state. | `webview/src/lib/views/SetupView.svelte` |
| **1.7** |  To Do | **Bind "Index Now" button's disabled state:** Use a reactive statement in Svelte (`$:`) to derive the button's state from the store. | `webview/src/lib/views/SetupView.svelte` |
| **1.8** |  To Do | **Test full UI flow:** Manually test the entire onboarding process: start database, select provider, and ensure the "Index Now" button enables correctly. | `(Manual Test)` |

</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/completed/ux/tasklist_sprint_01.md">
# Task List: Sprint 1 - Onboarding & Setup UI

**Goal:** To build the complete user onboarding and setup UI, from initializing the SvelteKit project to enabling the final "Index Now" button based on user configuration.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Project Setup:** In the `webview` directory, initialize a new SvelteKit project with TypeScript support. | `webview/` |
| **1.2** |  To Do | **Project Setup:** Run `npm install` within the new `webview` directory. | `webview/` |
| **1.3** |  To Do | **Configuration:** Install `@sveltejs/adapter-static`. | `webview/package.json` |
| **1.4** |  To Do | **Configuration:** Configure `svelte.config.js` to use `adapter-static` and set the `fallback` page to `index.html`. | `webview/svelte.config.js` |
| **1.5** |  To Do | **UI Framework:** Install Fluent UI dependencies: `@svelte-fui/core` and `@svelte-fui/tailwindcss`. | `webview/package.json` |
| **1.6** |  To Do | **UI Framework:** Configure `tailwind.config.js` to use the `svelte-fui` preset. | `webview/tailwind.config.js` |
| **1.7** |  To Do | **State Management:** Create the Svelte store file `setupStore.ts` with `databaseReady` and `providerSelected` properties. | `webview/src/lib/stores/setupStore.ts` |
| **1.8** |  To Do | **TDD:** Write a basic test for the store to ensure its default state is correct. | `webview/src/lib/stores/setupStore.test.ts` |
| **1.9** |  To Do | **Component:** Create the `DatabaseSetup.svelte` component file. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.10**|  To Do | **TDD:** Write a failing test to check that `DatabaseSetup.svelte` renders a select, a button, and a status indicator. | `webview/src/lib/components/DatabaseSetup.test.ts` |
| **1.11**|  To Do | **Component:** Implement the UI for `DatabaseSetup.svelte` using Fluent UI components. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.12**|  To Do | **Component:** In `DatabaseSetup.svelte`, bind the status indicator to the `databaseReady` property of the store. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.13**|  To Do | **Component:** In `DatabaseSetup.svelte`, implement the `on:click` handler for the "Start" button to send a `startDatabase` message to the extension. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.14**|  To Do | **Component:** In `DatabaseSetup.svelte`, add a message listener to handle `databaseStatus` messages from the extension and update the store. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.15**|  To Do | **TDD:** Pass the rendering test for `DatabaseSetup.svelte`. | `webview/src/lib/components/DatabaseSetup.test.ts` |
| **1.16**|  To Do | **Component:** Create the `EmbeddingSetup.svelte` component file. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.17**|  To Do | **TDD:** Write a failing test to check that `EmbeddingSetup.svelte` renders a select component. | `webview/src/lib/components/EmbeddingSetup.test.ts` |
| **1.18**|  To Do | **Component:** Implement the UI for `EmbeddingSetup.svelte` with "Ollama" and "OpenAI" options. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.19**|  To Do | **Component:** In `EmbeddingSetup.svelte`, implement the `on:change` handler to update the `providerSelected` property in the store. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.20**|  To Do | **TDD:** Pass the rendering test for `EmbeddingSetup.svelte`. | `webview/src/lib/components/EmbeddingSetup.test.ts` |
| **1.21**|  To Do | **Main View:** Create the main view file `+page.svelte` and import the `DatabaseSetup` and `EmbeddingSetup` components. | `webview/src/routes/+page.svelte` |
| **1.22**|  To Do | **Main View:** In `+page.svelte`, add the "Index Now" button. | `webview/src/routes/+page.svelte` |
| **1.23**|  To Do | **Main View:** In `+page.svelte`, create the derived state `$: canStartIndex` based on the store. | `webview/src/routes/+page.svelte` |
| **1.24**|  To Do | **Main View:** Bind the "Index Now" button's `disabled` state to the `canStartIndex` derived property. | `webview/src/routes/+page.svelte` |
| **1.25**|  To Do | **Main View:** Implement the `startIndexing` click handler to send the configuration from the store to the extension. | `webview/src/routes/+page.svelte` |
| **1.26**|  To Do | **Extension:** In `extension.ts`, add the command `code-context.setup` to create and load the webview panel. | `src/extension.ts` |
| **1.27**|  To Do | **Extension:** In `extension.ts`, implement the message listener to handle `startDatabase` and `startIndexing` commands. | `src/extension.ts` |
| **1.28**|  To Do | **Extension:** In the `startDatabase` handler, implement the logic to create a terminal and run `docker-compose up`. | `src/extension.ts` |
| **1.29**|  To Do | **Extension:** Implement the `pollQdrantHealth` function and call it after starting the database. | `src/extension.ts` |
| **1.30**|  To Do | **Extension:** On successful health check, send the `databaseStatus` message back to the webview. | `src/extension.ts` |
| **1.31**|  To Do | **Integration Test:** Manually test the complete end-to-end flow as described in the PRD's acceptance criteria. | `(Manual Test)` |
</file>

<file path="docs/completed/ux2/backlog_sub_sprint_1_hotkey_native_settings.md">
### User Story 1: Efficient Keyboard Navigation
**As a** developer (Devin), **I want to** use keyboard shortcuts to open the main panel and start indexing, **so that** I can work more efficiently without using the mouse.

**Actions to Undertake:**
1.  **Filepath**: `package.json`
    -   **Action**: Add the `keybindings` contribution to the `contributes` section.
    -   **Implementation**:
        ```json
        "keybindings": [
          {
            "command": "code-context-engine.openMainPanel",
            "key": "ctrl+alt+c",
            "mac": "cmd+alt+c",
            "when": "editorTextFocus"
          },
          {
            "command": "code-context-engine.startIndexing",
            "key": "ctrl+alt+i",
            "mac": "cmd+alt+i",
            "when": "editorTextFocus"
          }
        ]
        ```
    -   **Imports**: None.
2.  **Filepath**: `src/commandManager.ts`
    -   **Action**: Ensure the commands `code-context-engine.openMainPanel` and `code-context-engine.startIndexing` are properly registered and handled.
    -   **Implementation**: (No change, assuming commands are already registered).
    -   **Imports**: None.

**Acceptance Criteria:**
-   A `keybindings` contribution is added to `package.json`.
-   Pressing `Ctrl+Alt+C` (or `Cmd+Alt+C` on macOS) opens the main webview panel.
-   Pressing `Ctrl+Alt+I` (or `Cmd+Alt+I` on macOS) starts the indexing process.
-   The keybindings are functional and do not conflict with common VS Code shortcuts.

**Testing Plan:**
-   **Test Case 1**: Reload the extension. Press the keybinding for opening the main panel and verify it appears.
-   **Test Case 2**: Press the keybinding for starting indexing and verify the process begins (e.g., check for logs or UI updates).

---

### User Story 2: Familiar Configuration Experience
**As a** developer (Devin), **I want** the "Open Settings" command to take me directly to the native VS Code settings UI for the extension, **so that** I can manage configuration in a familiar way.

**Actions to Undertake:**
1.  **Filepath**: `src/commandManager.ts`
    -   **Action**: Refactor the `handleOpenSettings` method to use the built-in `workbench.action.openSettings` command.
    -   **Implementation**:
        ```typescript
        private handleOpenSettings() {
            vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';` (should already exist).
2.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: Mark the old `showSettingsPanel` method as deprecated.
    -   **Implementation**:
        ```typescript
        /**
         * @deprecated The settings are now managed in the native VS Code Settings UI.
         * This webview will be repurposed for diagnostics.
         */
        public showSettingsPanel() {
            // ... existing implementation
        }
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   The `handleOpenSettings` method in `CommandManager` is refactored.
-   Executing the `code-context-engine.openSettings` command opens the native VS Code Settings UI, filtered to show only settings for this extension.
-   The old Svelte-based settings panel is no longer shown by this command.
-   The `showSettingsPanel` method in `WebviewManager` is marked with a `@deprecated` JSDoc comment.

**Testing Plan:**
-   **Test Case 1**: Run the "Code Context Engine: Open Settings" command from the Command Palette.
-   **Test Case 2**: Verify that the native VS Code Settings tab opens and the search bar is pre-filled with `@ext:bramburn.code-context-engine`.
-   **Test Case 3**: Check the source code to confirm the JSDoc comment is present on `showSettingsPanel`.
</file>

<file path="docs/completed/ux2/backlog_sub_sprint_2_diagnostics_view.md">
### User Story 1: Centralized Diagnostics View
**As a** developer (Alisha), **I want to** repurpose the existing Svelte settings page into a "Status & Diagnostics" panel, **so that** we can provide users with useful actions like connection testing without managing configuration in a custom UI.

**Actions to Undertake:**
1.  **Filepath**: `package.json`
    -   **Action**: Add a new command `code-context-engine.openDiagnostics` to the `contributes.commands` array.
    -   **Implementation**:
        ```json
        {
          "command": "code-context-engine.openDiagnostics",
          "title": "Code Context Engine: Open Diagnostics"
        }
        ```
    -   **Imports**: None.
2.  **Filepath**: `src/commandManager.ts`
    -   **Action**: Register the new `openDiagnostics` command and add a handler that calls a new method in `WebviewManager`.
    -   **Implementation**:
        ```typescript
        // In the constructor or registration method:
        this.registerCommand('code-context-engine.openDiagnostics', this.handleOpenDiagnostics.bind(this));

        // New handler method:
        private handleOpenDiagnostics() {
            this.webviewManager.showDiagnosticsPanel();
        }
        ```
    -   **Imports**: None.
3.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: Implement the `showDiagnosticsPanel` method, using a singleton pattern to manage the webview panel.
    -   **Implementation**: (See implementation guide for full example).
    -   **Imports**: `import * as vscode from 'vscode';`
4.  **Filepath**: `webview/src/lib/views/SettingsView.svelte` -> `webview/src/lib/views/DiagnosticsView.svelte`
    -   **Action**: Rename the file and update all imports that reference it.
    -   **Implementation**: (File rename operation).
    -   **Imports**: N/A.
5.  **Filepath**: `webview/src/lib/views/DiagnosticsView.svelte`
    -   **Action**: Remove all configuration input elements (`<select>`, `<input>`). Refactor the component to display settings in a read-only format.
    -   **Implementation**: (Svelte code refactoring).
    -   **Imports**: `import { setupStore } from '../stores/setupStore';`

**Acceptance Criteria:**
-   The Svelte settings component is renamed to `DiagnosticsView.svelte`.
-   All configuration input fields are removed from the component.
-   Action buttons like "Test Database Connection" remain functional.
-   The view displays current configuration values in a read-only format.

**Testing Plan:**
-   **Test Case 1**: Open the `DiagnosticsView.svelte` file and verify no input elements for configuration exist.
-   **Test Case 2**: Run the extension, open the diagnostics panel, and confirm the "Test..." buttons are present and functional.
-   **Test Case 3**: Verify that current settings are displayed as text.

---

### User Story 2: Easy Access to Diagnostics
**As a** developer (Devin), **I want to** be able to open the new "Status & Diagnostics" panel from a command, **so that** I can easily test my connections and view system status.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/views/DiagnosticsView.svelte`
    -   **Action**: Add a new button labeled "Edit Configuration".
    -   **Implementation**: `<FluentButton on:click={openSettings}>Edit Configuration</FluentButton>`
    -   **Imports**: `import { Button as FluentButton } from "@fluentui/web-components";`
2.  **Filepath**: `webview/src/lib/views/DiagnosticsView.svelte`
    -   **Action**: Implement the `on:click` handler to send a `MapToSettings` message to the extension.
    -   **Implementation**:
        ```javascript
        import { vscode } from '../lib/vscodeApi';

        function openSettings() {
            vscode.postMessage({ command: 'MapToSettings' });
        }
        ```
    -   **Imports**: `import { vscode } from '../lib/vscodeApi';`
3.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: Add a case to the message handler to process the `MapToSettings` message.
    -   **Implementation**:
        ```typescript
        case 'MapToSettings':
            vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');
            break;
        ```
    -   **Imports**: `import * as vscode from 'vscode';`

**Acceptance Criteria:**
-   A new command, `code-context-engine.openDiagnostics`, is available in the Command Palette.
-   The command opens a new webview panel titled "Status & Diagnostics".
-   The panel contains a button that, when clicked, opens the native VS Code Settings UI filtered for the extension.

**Testing Plan:**
-   **Test Case 1**: Run the "Code Context Engine: Open Diagnostics" command and verify the panel opens.
-   **Test Case 2**: Click the "Edit Configuration" button in the webview.
-   **Test Case 3**: Confirm that the native VS Code Settings UI opens, filtered correctly.
</file>

<file path="docs/completed/ux2/implementation_sub_sprint_1_hotkey_native_settings.md">
## Implementation Guide: Sprint 1 - Hotkey & Native Settings Integration

This guide provides the technical details, code examples, and API information needed to complete Sprint 1.

### **Objective**
To add keyboard shortcuts for key actions and integrate with the native VS Code settings UI.

---

### **Part 1: Adding Keybindings**

To add keyboard shortcuts, you will use the `keybindings` contribution point in the `package.json` file. This allows you to declare keybindings that are active when your extension is enabled.

**Relevant API/Documentation:**
*   **VS Code Keybindings Contribution:** [https://code.visualstudio.com/api/references/contribution-points#contributes.keybindings](https://code.visualstudio.com/api/references/contribution-points#contributes.keybindings)

**Implementation Steps:**

1.  **Modify `package.json`:**
    Open your `package.json` file and locate the `contributes` section. Add the `keybindings` array as shown below. The `when` clause can be used to control when the keybinding is active; `editorTextFocus` is a common choice.

    **Filepath**: `package.json`

    ```json
    {
      "name": "code-context-engine",
      "contributes": {
        "commands": [
          // ... your existing commands
        ],
        "keybindings": [
          {
            "command": "code-context-engine.openMainPanel",
            "key": "ctrl+alt+c",
            "mac": "cmd+alt+c",
            "when": "editorTextFocus"
          },
          {
            "command": "code-context-engine.startIndexing",
            "key": "ctrl+alt+i",
            "mac": "cmd+alt+i",
            "when": "editorTextFocus"
          }
        ]
      }
    }
    ```

---

### **Part 2: Integrating with Native Settings UI**

To provide a more native user experience, the "Open Settings" command will be changed to open the built-in VS Code settings window, pre-filtered for your extension.

**Relevant API/Documentation:**
*   **VS Code Commands API:** [https://code.visualstudio.com/api/references/vscode-api#commands](https://code.visualstudio.com/api/references/vscode-api#commands)
*   **Built-in Commands:** [https://code.visualstudio.com/api/references/commands](https://code.visualstudio.com/api/references/commands) (search for `workbench.action.openSettings`)

**Implementation Steps:**

1.  **Refactor `handleOpenSettings`:**
    In `src/commandManager.ts`, you will replace the logic that shows your custom webview with a call to `vscode.commands.executeCommand`.

    **Filepath**: `src/commandManager.ts`

    ```typescript
    import * as vscode from 'vscode';
    // ... other imports

    export class CommandManager {
        // ... other methods

        private handleOpenSettings() {
            // The string argument filters the settings UI for your extension's settings.
            // Ensure the extension ID 'bramburn.code-context-engine' matches your package.json publisher and name.
            vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');
        }

        // ... other methods
    }
    ```

2.  **Deprecate the Old Webview Method:**
    To prevent accidental use of the old settings panel, add a JSDoc `@deprecated` tag to the `showSettingsPanel` method in `src/webviewManager.ts`.

    **Filepath**: `src/webviewManager.ts`

    ```typescript
    // ... other imports

    export class WebviewManager {
        // ... other properties

        /**
         * @deprecated The settings are now managed in the native VS Code Settings UI.
         * This method will be repurposed or removed in a future sprint.
         */
        public showSettingsPanel() {
            // The existing implementation remains for now.
        }

        // ... other methods
    }
    ```

By following this guide, you will successfully implement the user stories for Sprint 1, creating a more seamless and efficient experience for your users.
</file>

<file path="docs/completed/ux2/implementation_sub_sprint_2_diagnostics_view.md">
## Implementation Guide: Sprint 2 - Diagnostics View Refactoring

This guide provides the technical details for refactoring the Svelte settings page into a read-only diagnostics and status view.

### **Objective**
To create a dedicated "Status & Diagnostics" panel that displays read-only configuration and provides action buttons for testing connections, accessible via a new VS Code command.

---

### **Part 1: Creating the Diagnostics Command and Panel**

First, you'll register a new command and create the `WebviewManager` logic to show the panel.

**Relevant API/Documentation:**
*   **VS Code Commands:** [https://code.visualstudio.com/api/references/contribution-points#contributes.commands](https://code.visualstudio.com/api/references/contribution-points#contributes.commands)
*   **Webview Panel API:** [https://code.visualstudio.com/api/extension-guides/webview](https://code.visualstudio.com/api/extension-guides/webview)

**Implementation Steps:**

1.  **Add Command in `package.json`**
    **Filepath**: `package.json`
    ```json
    "commands": [
        // ... other commands
        {
            "command": "code-context-engine.openDiagnostics",
            "title": "Code Context Engine: Open Diagnostics"
        }
    ]
    ```

2.  **Register Command in `commandManager.ts`**
    **Filepath**: `src/commandManager.ts`
    ```typescript
    // In constructor or registration method
    this.registerCommand('code-context-engine.openDiagnostics', this.handleOpenDiagnostics.bind(this));

    // New handler method
    private handleOpenDiagnostics() {
        this.webviewManager.showDiagnosticsPanel();
    }
    ```

3.  **Implement `showDiagnosticsPanel` in `webviewManager.ts`**
    Use a singleton pattern to ensure only one diagnostics panel exists at a time.
    **Filepath**: `src/webviewManager.ts`
    ```typescript
    export class WebviewManager {
        private diagnosticsPanel: vscode.WebviewPanel | undefined;
        // ... other properties

        public showDiagnosticsPanel() {
            if (this.diagnosticsPanel) {
                this.diagnosticsPanel.reveal(vscode.ViewColumn.One);
            } else {
                this.diagnosticsPanel = vscode.window.createWebviewPanel(
                    'diagnosticsView', // Identifies the type of the webview. Used internally
                    'Status & Diagnostics', // Title of the panel displayed to the user
                    vscode.ViewColumn.One, // Editor column to show the new webview panel in.
                    { enableScripts: true, localResourceRoots: [/*...*/] } // Webview options.
                );

                this.diagnosticsPanel.webview.html = this.getWebviewContent('diagnostics'); // You will need a way to get specific HTML content
                this.diagnosticsPanel.onDidDispose(() => {
                    this.diagnosticsPanel = undefined;
                }, null, this.context.subscriptions);

                // Handle messages from the webview
                this.diagnosticsPanel.webview.onDidReceiveMessage(
                    message => this.messageRouter.handleMessage(message),
                    undefined,
                    this.context.subscriptions
                );
            }
        }
        // ...
    }
    ```

---

### **Part 2: Refactoring the Svelte Component**

Next, you'll modify the Svelte component to serve its new purpose.

**Relevant API/Documentation:**
*   **Svelte Lifecycle:** [https://svelte.dev/docs#onMount](https://svelte.dev/docs#onMount)
*   **Webview Message Passing:** [https://code.visualstudio.com/api/extension-guides/webview#scripts-and-message-passing](https://code.visualstudio.com/api/extension-guides/webview#scripts-and-message-passing)

**Implementation Steps:**

1.  **Rename the File:**
    -   From: `webview/src/lib/views/SettingsView.svelte`
    -   To: `webview/src/lib/views/DiagnosticsView.svelte`
    -   Remember to update any `import` statements that refer to the old filename.

2.  **Refactor `DiagnosticsView.svelte`**
    Remove input elements and display data from your `setupStore`. Add a button to message the extension.
    **Filepath**: `webview/src/lib/views/DiagnosticsView.svelte`
    ```html
    <script lang="ts">
        import { onMount } from 'svelte';
        import { setupStore, type Settings } from '../stores/setupStore';
        import { vscode } from '../lib/vscodeApi';
        // Assuming you have a Button component
        // import { Button as FluentButton } from "@fluentui/web-components";

        let settings: Settings;
        const unsubscribe = setupStore.subscribe(value => {
            settings = value;
        });

        onMount(() => {
            // Request initial settings from the extension
            vscode.postMessage({ command: 'getSettings' });
        });

        function openSettings() {
            vscode.postMessage({ command: 'MapToSettings' });
        }

        function testDatabase() {
            vscode.postMessage({ command: 'testDatabaseConnection' });
        }
    </script>

    <h1>Status & Diagnostics</h1>

    <div>
        <h2>Current Configuration</h2>
        <p>Provider: {settings?.embeddingProvider || 'Not set'}</p>
        <p>Model: {settings?.embeddingModel || 'Not set'}</p>
        <p>Database: {settings?.databaseType || 'Not set'}</p>
        <button on:click={openSettings}>Edit Configuration</button>
    </div>

    <div>
        <h2>Actions</h2>
        <button on:click={testDatabase}>Test Database Connection</button>
        <!-- Add other test buttons here -->
    </div>
    ```

3.  **Handle `MapToSettings` Message in `messageRouter.ts`**
    Add a case to your message handler to trigger the native settings UI.
    **Filepath**: `src/messageRouter.ts`
    ```typescript
    public handleMessage(message: any) {
        switch (message.command) {
            // ... other cases
            case 'MapToSettings':
                vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');
                break;
            // ... other cases
        }
    }
    ```
</file>

<file path="docs/completed/ux2/prd.md">
<prd>Excellent plan. Improving the user experience by integrating more deeply with VS Code's native features like the settings UI and keybindings is a great strategic move. It makes the extension feel more polished and intuitive for developers.

Based on my review of your codebase, this is a very achievable goal. The foundation you've built with the `ConfigService` and the declared settings in `package.json` makes this transition straightforward.

Here is the PRD for this initiative.

-----

### **New Document: PRD 1: Foundational - UX Enhancements with Native Settings & Hotkeys**

**1. Title & Overview**

  * **Project:** Code Context Engine - UX Enhancements
  * **Summary:** This phase focuses on improving the overall user experience by integrating keybindings for common actions and migrating configuration management to VS Code's native settings UI. We will also repurpose our existing Svelte settings page into a "Status & Diagnostics" panel, providing users with a central place to test connections and view system status without mixing it with configuration.
  * **Dependencies:** The extension must have a working command structure and a defined configuration schema in `package.json`.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Increase user adoption and satisfaction by providing a more native, seamless, and efficient user experience.
      * Reduce user friction by aligning with standard VS Code patterns for configuration and shortcuts.
  * **Developer & System Success Metrics:**
      * Key commands (Open Panel, Start Indexing) are accessible via keyboard shortcuts.
      * The extension's configuration is fully manageable through the built-in VS Code Settings UI (`Ctrl+,`).
      * The custom Svelte "Settings" page is successfully repurposed as a "Status & Diagnostics" view.
      * The `ConfigService` continues to correctly read all settings without modification.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin is a power user who prefers keyboard-driven workflows. He wants to open the context engine and start indexing without reaching for the mouse. He also expects to manage his settings in the same place he manages all his other VS Code settings.
  * **Alisha (Backend Developer):** Alisha wants to ensure that the settings are managed in a standard, reliable way. Using the native VS Code settings reduces the amount of custom UI code she has to maintain and debug.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: UX Enhancements** | **Sprint 1: Hotkey Integration** | As Devin, I want to use keyboard shortcuts to open the main panel and start indexing, so I can work more efficiently without using the mouse. | 1. A new `keybindings` contribution is added to `package.json`.\<br/\>2. A default keybinding (e.g., `Ctrl+Alt+C`) is assigned to the `code-context-engine.openMainPanel` command.\<br/\>3. A default keybinding (e.g., `Ctrl+Alt+I`) is assigned to the `code-context-engine.startIndexing` command.\<br/\>4. The keybindings are functional and do not conflict with common VS Code shortcuts. | **2 Weeks** |
| | | As Devin, I want the "Open Settings" command to take me directly to the native VS Code settings UI for the extension, so I can manage configuration in a familiar way. | 1. The `handleOpenSettings` method in `CommandManager` is refactored.\<br/\>2. The method now uses the `vscode.commands.executeCommand('workbench.action.openSettings', ...)` API.\<br/\>3. The command is configured to directly filter the settings UI to show only "code-context-engine" settings.\<br/\>4. The old `WebviewManager.showSettingsPanel` method can be deprecated or removed. | |
| **Phase 1: UX Enhancements** | **Sprint 2: Repurpose Settings Page** | As Alisha, I want to repurpose the existing Svelte settings page into a "Status & Diagnostics" panel, so we can keep useful actions like connection testing without managing configuration in a custom UI. | 1. The Svelte settings component is renamed to `DiagnosticsView.svelte`.\<br/\>2. All configuration input fields (dropdowns, text inputs for values) are removed from the component.\<br/\>3. Action buttons like "Test Database Connection" and "Test Embedding Provider" remain functional.\<br/\>4. The view is updated to display the current configuration values in a read-only format. | **2 Weeks** |
| | | As Devin, I want to be able to open the new "Status & Diagnostics" panel from a command, so I can easily test my connections. | 1. A new command, `code-context-engine.openDiagnostics`, is added in `package.json`.\<br/\>2. A new handler is added to `CommandManager` for this command.\<br/\>3. The handler calls a new method in `WebviewManager` (`showDiagnosticsPanel`) to display the repurposed Svelte view. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** Hotkey & Native Settings Integration (2 Weeks)
  * **Sprint 2:** Repurpose Settings Page to Diagnostics View (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The settings defined in `package.json`'s `contributes.configuration` section are comprehensive and correctly structured for VS Code's native UI to render them.
  * **Risk:** The chosen default keybindings might conflict with a user's custom shortcuts or other extensions.
      * **Mitigation:** Choose key combinations that are less common. Clearly document the default shortcuts in the `README.md` and mention that users can rebind them in VS Code's Keyboard Shortcuts editor.
  * **Risk:** Users may be confused if they can't find the old settings page.
      * **Mitigation:** Add a section to the `README.md` explaining the change. The new "Status & Diagnostics" page can also include a read-only view of the current settings with a button that says "Edit Settings," which would then execute the command to open the native VS Code settings UI.

-----

### **New Document: Sub-Sprint 1: Hotkey Definition & Native Settings Command**

**Objective:**
To define and implement keyboard shortcuts for core commands and to redirect the "Open Settings" command to the native VS Code settings UI.

**Parent Sprint:**
PRD 1, Sprint 1: Hotkey Integration

**Tasks:**

1.  **Define Keybindings in `package.json`:** Add the `keybindings` contribution point to the `package.json` file.
2.  **Assign Hotkey for Main Panel:** Assign a key combination (e.g., `ctrl+alt+c` on Windows/Linux, `cmd+alt+c` on macOS) to the `code-context-engine.openMainPanel` command.
3.  **Assign Hotkey for Indexing:** Assign a key combination (e.g., `ctrl+alt+i` / `cmd+alt+i`) to the `code-context-engine.startIndexing` command.
4.  **Refactor `handleOpenSettings`:** Modify the `handleOpenSettings` method in `src/commandManager.ts` to use `vscode.commands.executeCommand` to open the native settings UI, filtered for the extension.
5.  **Deprecate `showSettingsPanel`:** Mark the `showSettingsPanel` method in `src/webviewManager.ts` as deprecated, as it will no longer be used by the primary settings command.

**Acceptance Criteria:**

  * Pressing the defined hotkeys correctly triggers the corresponding commands.
  * Running the "Code Context Engine: Open Settings" command from the command palette opens the native VS Code settings window, pre-filtered to "code-context-engine".
  * The old Svelte-based settings webview is no longer opened by the main settings command.

**Dependencies:**

  * Existing commands must be correctly registered in `CommandManager`.

**Timeline:**

  * **Start Date:** 2026-02-02
  * **End Date:** 2026-02-06

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Hotkey & Native Settings Integration

**Goal:** To add keyboard shortcuts for key actions and integrate with the native VS Code settings UI.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Add `keybindings` to `package.json`:** In the `contributes` section of `package.json`, add a new `keybindings` array. | `package.json` |
| **1.2** |  To Do | **Define `openMainPanel` Keybinding:** Inside the `keybindings` array, add an object for the `openMainPanel` command with `key` properties for `win`/`linux` (`ctrl+alt+c`) and `mac` (`cmd+alt+c`). | `package.json` |
| **1.3** |  To Do | **Define `startIndexing` Keybinding:** Add another object to the `keybindings` array for the `startIndexing` command with `key` properties for `win`/`linux` (`ctrl+alt+i`) and `mac` (`cmd+alt+i`). | `package.json` |
| **1.4** |  To Do | **Refactor `handleOpenSettings`:** Open `src/commandManager.ts`. Change the implementation of the `handleOpenSettings` method to execute a built-in VS Code command. | `src/commandManager.ts` |
| **1.5** |  To Do | **Implement Native Settings Command:** The new implementation for `handleOpenSettings` should be: `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');` (replace publisher and extension name as needed). | `src/commandManager.ts` |
| **1.6** |  To Do | **Deprecate Old Webview Method:** In `src/webviewManager.ts`, add a `/** @deprecated */` JSDoc comment above the `showSettingsPanel` method to indicate it should no longer be used for primary settings. | `src/webviewManager.ts` |
| **1.7** |  To Do | **Test Hotkeys:** Reload the extension and test both new keyboard shortcuts to ensure they trigger the correct actions. | `(Manual Test)` |
| **1.8** |  To Do | **Test Settings Command:** Run the "Code Context Engine: Open Settings" command from the command palette and verify it opens the native settings UI, correctly filtered. | `(Manual Test)` |

Of course. Here is the final PRD to complete the user experience enhancements for your extension.

-----

### **New Document: PRD 2: UI/UX - Status & Diagnostics Panel**

**1. Title & Overview**

  * **Project:** Code Context Engine - Status & Diagnostics Panel
  * **Summary:** This phase completes the user experience overhaul by repurposing the now-legacy Svelte settings page into a dedicated "Status & Diagnostics" panel. This provides a clear, focused UI for users to perform actions like testing service connections and viewing system status, cleanly separating these actions from the configuration, which is now handled by VS Code's native settings UI.
  * **Dependencies:** PRD 1 (Hotkey & Native Settings Integration) must be complete. The command to open the native settings UI must be functional.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Improve user confidence and reduce support issues by providing clear, actionable diagnostic tools.
      * Create a more logical and streamlined UX by separating "what you configure" (VS Code Settings) from "what you do" (Diagnostics Panel).
  * **User Success Metrics:**
      * Users can successfully test their connection to the database and embedding providers from the UI.
      * The panel displays the current configuration in a clear, read-only format, reducing confusion about what settings are active.
      * The user journey from diagnostics to configuration is seamless (e.g., a button in the panel links directly to the native settings UI).

-----

**3. User Personas**

  * **Devin (Developer - End User):** When setting up the extension or troubleshooting, Devin needs a simple way to confirm that his local services (like Qdrant and Ollama) are correctly connected to the extension. This panel gives him a one-click way to verify his setup.
  * **Alisha (Backend Developer):** Alisha benefits from having a dedicated UI for actions that trigger backend processes. This keeps the main query UI clean and provides a specific area for adding future administrative or diagnostic features.

-----

**4. Requirements Breakdown**

| Phase                 | Sprint                            | User Story                                                                                                                                                             | Acceptance Criteria                                                                                                                                                                                                                                                                                                                        | Duration |
| :-------------------- | :-------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------- |
| **Phase 2: UX Polish** | **Sprint 2: Repurpose Settings Page** | As Alisha, I want to repurpose the existing Svelte settings page into a "Status & Diagnostics" panel, so we can keep useful actions like connection testing without managing configuration in a custom UI. | 1. The Svelte settings component is renamed to `DiagnosticsView.svelte`.\<br/\>2. All configuration input fields (dropdowns, text inputs for values) are removed from the component.\<br/\>3. Action buttons like "Test Database Connection" and "Test Embedding Provider" remain functional.\<br/\>4. The view is updated to display the current configuration values in a read-only format. | **2 Weeks** |
|                       |                                   | As Devin, I want to be able to open the new "Status & Diagnostics" panel from a command, so I can easily test my connections.                                              | 1. A new command, `code-context-engine.openDiagnostics`, is added in `package.json`.\<br/\>2. A new handler is added to `CommandManager` for this command.\<br/\>3. The handler calls a new method in `WebviewManager` (`showDiagnosticsPanel`) to display the repurposed Svelte view.                                                   |          |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 2:** Repurpose Settings Page to Diagnostics View (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The Svelte components are modular enough that removing the configuration inputs will not break the layout or functionality of the remaining action buttons.
  * **Risk:** The new "Diagnostics" panel could cause user confusion if its purpose is not clearly communicated.
      * **Mitigation:** The UI should have a clear title like "Status & Diagnostics". It should also contain a prominent button or link labeled "Edit Configuration" that executes the `workbench.action.openSettings` command, guiding users to the correct location for making changes.

-----

### **New Document: Sub-Sprint 2: Diagnostics View Refactoring**

**Objective:**
To refactor the Svelte settings page into a read-only diagnostics and status view, and create a new command to open it.

**Parent Sprint:**
PRD 2, Sprint 2: Repurpose Settings Page

**Tasks:**

1.  **Create New Command:** Define and register a new command `code-context-engine.openDiagnostics` in `package.json` and `CommandManager`.
2.  **Create `showDiagnosticsPanel` Method:** In `WebviewManager`, create a new method to show the diagnostics webview, ensuring it's managed as a singleton panel.
3.  **Refactor Svelte Component:** Rename the settings Svelte component to `DiagnosticsView.svelte`.
4.  **Remove Input Elements:** Remove all interactive form elements for *setting* values (e.g., `<select>`, `<input>`).
5.  **Display Read-Only Settings:** Fetch the current configuration and display it as read-only text.
6.  **Add "Edit Settings" Button:** Add a new button that, when clicked, sends a message to the extension to execute the `workbench.action.openSettings` command.
7.  **Preserve Action Buttons:** Ensure that buttons for "Test Connection" remain and are functional.

**Acceptance Criteria:**

  * A new "Code Context Engine: Open Diagnostics" command is available.
  * The new panel displays current settings as text and does not allow editing them.
  * The "Test Connection" buttons work as before.
  * A new "Edit Settings" button correctly opens the native VS Code settings UI.

**Dependencies:**

  * PRD 1 must be complete.

**Timeline:**

  * **Start Date:** 2026-02-09
  * **End Date:** 2026-02-20

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Repurpose Settings Page to Diagnostics View

**Goal:** To refactor the Svelte settings webview into a dedicated "Status & Diagnostics" panel.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Add `openDiagnostics` Command:** In `package.json`, add a new command definition for `code-context-engine.openDiagnostics` with the title "Code Context Engine: Open Diagnostics". | `package.json` |
| **2.2** |  To Do | **Register `openDiagnostics` Command:** In `src/commandManager.ts`, register the new command. The handler should call a new method on the `WebviewManager`, e.g., `this.webviewManager.showDiagnosticsPanel()`. | `src/commandManager.ts` |
| **2.3** |  To Do | **Implement `showDiagnosticsPanel`:** In `src/webviewManager.ts`, create the new method `showDiagnosticsPanel`. It should manage a new panel instance (`diagnosticsPanel`) using the same singleton pattern as `showMainPanel`. | `src/webviewManager.ts` |
| **2.4** |  To Do | **Rename Svelte Component:** Rename the Svelte settings component file to `DiagnosticsView.svelte`. Update any import paths that reference it. | `webview/src/lib/views/SettingsView.svelte` -\> `DiagnosticsView.svelte` |
| **2.5** |  To Do | **Remove Configuration Inputs:** In `DiagnosticsView.svelte`, delete all `<select>` and `<input>` elements used for setting configuration values. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.6** |  To Do | **Display Read-Only Settings:** Add logic to fetch the current settings on mount and display them as plain text (e.g., `<div>Provider: {$settings.embeddingProvider}</div>`). | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.7** |  To Do | **Add "Edit Settings" Button:** Add a new Fluent UI button to `DiagnosticsView.svelte` labeled "Edit Configuration". | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.8** |  To Do | **Implement "Edit Settings" Action:** The new button's `on:click` handler should send a `MapsToSettings` message to the extension. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.9** |  To Do | **Handle `MapsToSettings` Message:** In `src/messageRouter.ts`, add a case for `MapsToSettings` that calls `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');`. | `src/messageRouter.ts` |
| **2.10** |  To Do | **Verify Action Buttons:** Ensure the "Test Connection" buttons remain in `DiagnosticsView.svelte` and their message-passing logic is still functional. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.11** |  To Do | **Test Full Flow:** Manually test opening the new Diagnostics panel, verifying settings are read-only, and confirming the "Edit Configuration" button opens the correct native UI. | `(Manual Test)` |

This completes the full set of PRDs and task lists for the user experience enhancements. You now have a comprehensive plan to integrate native VS Code features and provide a more streamlined and intuitive interface for your users.</prd>
[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/completed/ux2/tasklist_sprint_01.md">
# Task List: Sprint 1 - Hotkey & Native Settings Integration

**Goal:** To add keyboard shortcuts for key actions and integrate with the native VS Code settings UI.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Add `keybindings` to `package.json`:** In the `contributes` section of `package.json`, add a new `keybindings` array. | `package.json` |
| **1.2** |  To Do | **Define `openMainPanel` Keybinding:** Inside the `keybindings` array, add an object for the `openMainPanel` command with `key` properties for `win`/`linux` (`ctrl+alt+c`) and `mac` (`cmd+alt+c`). | `package.json` |
| **1.3** |  To Do | **Define `startIndexing` Keybinding:** Add another object to the `keybindings` array for the `startIndexing` command with `key` properties for `win`/`linux` (`ctrl+alt+i`) and `mac` (`cmd+alt+i`). | `package.json` |
| **1.4** |  To Do | **Refactor `handleOpenSettings`:** Open `src/commandManager.ts`. Change the implementation of the `handleOpenSettings` method to execute a built-in VS Code command. | `src/commandManager.ts` |
| **1.5** |  To Do | **Implement Native Settings Command:** The new implementation for `handleOpenSettings` should be: `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');` (replace publisher and extension name as needed). | `src/commandManager.ts` |
| **1.6** |  To Do | **Deprecate Old Webview Method:** In `src/webviewManager.ts`, add a `/** @deprecated */` JSDoc comment above the `showSettingsPanel` method to indicate it should no longer be used for primary settings. | `src/webviewManager.ts` |
| **1.7** |  To Do | **Test Hotkeys:** Reload the extension and test both new keyboard shortcuts to ensure they trigger the correct actions. | `(Manual Test)` |
| **1.8** |  To Do | **Test Settings Command:** Run the "Code Context Engine: Open Settings" command from the command palette and verify it opens the native settings UI, correctly filtered. | `(Manual Test)` |
</file>

<file path="docs/completed/ux2/tasklist_sprint_02.md">
# Task List: Sprint 2 - Repurpose Settings Page to Diagnostics View

**Goal:** To refactor the Svelte settings webview into a dedicated "Status & Diagnostics" panel.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Add `openDiagnostics` Command:** In `package.json`, add a new command definition for `code-context-engine.openDiagnostics` with the title "Code Context Engine: Open Diagnostics". | `package.json` |
| **2.2** |  To Do | **Register `openDiagnostics` Command:** In `src/commandManager.ts`, register the new command. The handler should call a new method on the `WebviewManager`, e.g., `this.webviewManager.showDiagnosticsPanel()`. | `src/commandManager.ts` |
| **2.3** |  To Do | **Implement `showDiagnosticsPanel`:** In `src/webviewManager.ts`, create the new method `showDiagnosticsPanel`. It should manage a new panel instance (`diagnosticsPanel`) using the same singleton pattern as `showMainPanel`. | `src/webviewManager.ts` |
| **2.4** |  To Do | **Rename Svelte Component:** Rename the Svelte settings component file to `DiagnosticsView.svelte`. Update any import paths that reference it. | `webview/src/lib/views/SettingsView.svelte` -> `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.5** |  To Do | **Remove Configuration Inputs:** In `DiagnosticsView.svelte`, delete all `<select>` and `<input>` elements used for setting configuration values. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.6** |  To Do | **Display Read-Only Settings:** Add logic to fetch the current settings on mount and display them as plain text (e.g., `<div>Provider: {$settings.embeddingProvider}</div>`). | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.7** |  To Do | **Add "Edit Settings" Button:** Add a new Fluent UI button to `DiagnosticsView.svelte` labeled "Edit Configuration". | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.8** |  To Do | **Implement "Edit Settings" Action:** The new button's `on:click` handler should send a `MapsToSettings` message to the extension. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.9** |  To Do | **Handle `MapsToSettings` Message:** In `src/messageRouter.ts`, add a case for `MapsToSettings` that calls `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');`. | `src/messageRouter.ts` |
| **2.10** |  To Do | **Verify Action Buttons:** Ensure the "Test Connection" buttons remain in `DiagnosticsView.svelte` and their message-passing logic is still functional. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.11** |  To Do | **Test Full Flow:** Manually test opening the new Diagnostics panel, verifying settings are read-only, and confirming the "Edit Configuration" button opens the correct native UI. | `(Manual Test)` |
</file>

<file path="docs/todo/missing/backlog_sub_sprint_1_sveltekit_migration.md">
# Task List: Sprint 1 - SvelteKit Migration

**Goal:** To migrate the existing webview from plain TypeScript to a modern SvelteKit application.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Backup and Clean `webview/`:** Make a backup of the current `webview/` directory, then delete its contents. | `webview/` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** Run `npm create svelte@latest webview` and select "Skeleton project" with TypeScript support. | `webview/` (New project) |
| **1.3** |  To Do | **Install Static Adapter:** In the `webview/` directory, run `npm install -D @sveltejs/adapter-static`. | `webview/package.json` |
| **1.4** |  To Do | **Configure Static Build:** Modify `webview/svelte.config.js` to use the static adapter, outputting to a `build` directory with `index.html` as the fallback. | `webview/svelte.config.js` |
| **1.5** |  To Do | **Recreate `DatabaseSetup.svelte`:** Create the component and implement the UI and logic from `DatabaseSetup.ts` using Svelte syntax. | `webview/src/lib/components/DatabaseSetup.svelte` (New) |
| **1.6** |  To Do | **Recreate `EmbeddingSetup.svelte`:** Create the component and implement the UI and logic from `EmbeddingSetup.ts`. | `webview/src/lib/components/EmbeddingSetup.svelte` (New) |
| **1.7** |  To Do | **Update `setupStore.ts`:** Ensure the Svelte store (`setupStore.ts`) correctly manages the state for the new components. | `webview/src/lib/stores/setupStore.ts` |
| **1.8** |  To Do | **Create Main Page Layout:** In `webview/src/routes/+page.svelte`, use the store to manage the view and conditionally render the setup components. | `webview/src/routes/+page.svelte` |
| **1.9** |  To Do | **Update `WebviewManager`:** Modify `getWebviewContent` to load `webview/build/index.html` and correctly rewrite asset paths using `asWebviewUri`. | `src/webviewManager.ts` |
</file>

<file path="docs/todo/missing/backlog_sub_sprint_2_diagnostics_view.md">
# Task List: Sprint 2 - Repurpose Settings Page to Diagnostics View

**Goal:** To refactor the Svelte settings webview into a dedicated "Status & Diagnostics" panel.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Add `openDiagnostics` Command:** In `package.json`, add a new command definition for `code-context-engine.openDiagnostics` with the title "Code Context Engine: Open Diagnostics". | `package.json` |
| **2.2** |  To Do | **Register `openDiagnostics` Command:** In `src/commandManager.ts`, register the new command. The handler should call a new method on the `WebviewManager`, e.g., `this.webviewManager.showDiagnosticsPanel()`. | `src/commandManager.ts` |
| **2.3** |  To Do | **Implement `showDiagnosticsPanel`:** In `src/webviewManager.ts`, create the new method `showDiagnosticsPanel`. It should manage a new panel instance (`diagnosticsPanel`) using the same singleton pattern as `showMainPanel`. | `src/webviewManager.ts` |
| **2.4** |  To Do | **Rename Svelte Component:** Rename the Svelte settings component file to `DiagnosticsView.svelte`. Update any import paths that reference it. | `webview/src/lib/views/SettingsView.svelte` -> `DiagnosticsView.svelte` |
| **2.5** |  To Do | **Remove Configuration Inputs:** In `DiagnosticsView.svelte`, delete all `<select>` and `<input>` elements used for setting configuration values. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.6** |  To Do | **Display Read-Only Settings:** Add logic to fetch the current settings on mount and display them as plain text (e.g., `<div>Provider: {$settings.embeddingProvider}</div>`). | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.7** |  To Do | **Add "Edit Settings" Button:** Add a new Fluent UI button to `DiagnosticsView.svelte` labeled "Edit Configuration". | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.8** |  To Do | **Implement "Edit Settings" Action:** The new button's `on:click` handler should send a `openSettings` message to the extension. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.9** |  To Do | **Handle `openSettings` Message:** In `src/messageRouter.ts`, add a case for `openSettings` that calls `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');`. | `src/messageRouter.ts` |
| **2.10** |  To Do | **Verify Action Buttons:** Ensure the "Test Connection" buttons remain in `DiagnosticsView.svelte` and their message-passing logic is still functional. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.11** |  To Do | **Test Full Flow:** Manually test opening the new Diagnostics panel, verifying settings are read-only, and confirming the "Edit Configuration" button opens the correct native UI. | `(Manual Test)` |
</file>

<file path="docs/todo/missing/backlog_sub_sprint_2_native_settings_hotkeys_state_management.md">
# Task List: Sprint 2 - Native Settings & Hotkeys

**Goal:** To improve UX by adding keyboard shortcuts, using the native VS Code settings UI, and implementing a robust state manager.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Add `keybindings` to `package.json`:** Add a `contributes.keybindings` section and define shortcuts for `openMainPanel` and `startIndexing`. | `package.json` |
| **2.2** |  To Do | **Refactor `handleOpenSettings` Command:** In `src/commandManager.ts`, change the handler to call `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine')`. | `src/commandManager.ts` |
| **2.3** |  To Do | **Create `openDiagnostics` Command:** Add a new command `code-context-engine.openDiagnostics` in `package.json` and `commandManager.ts`. | `package.json`, `src/commandManager.ts` |
| **2.4** |  To Do | **Create `showDiagnosticsPanel` Method:** In `src/webviewManager.ts`, add a method to show a panel that will render the diagnostics view. | `src/webviewManager.ts` |
| **2.5** |  To Do | **Create `DiagnosticsView.svelte`:** Repurpose the old Svelte settings page. Remove configuration inputs and add a button that calls the `openSettings` command. | `webview/src/lib/views/DiagnosticsView.svelte` (New) |
| **2.6** |  To Do | **Create `StateManager.ts`:** Create the new file and implement the `StateManager` class with an `isIndexing` flag. | `src/stateManager.ts` (New) |
| **2.7** |  To Do | **Integrate `StateManager`:** Instantiate the manager in `ExtensionManager` and inject it into `IndexingService` and `MessageRouter`. | `src/extensionManager.ts`, `src/indexing/indexingService.ts`, `src/messageRouter.ts` |
| **2.8** |  To Do | **Add Guard Clause:** In `MessageRouter`, add a check for `stateManager.isIndexing()` before starting a new indexing job. | `src/messageRouter.ts` |
</file>

<file path="docs/todo/missing/implementation_sub_sprint_1_sveltekit_migration.md">
# Implementation Guide: Sprint 1 - SvelteKit Migration

**Goal:** To migrate the existing webview from plain TypeScript to a modern SvelteKit application.

This guide provides the technical steps to replace the current `webview/` directory with a new SvelteKit project, configure it for static output, and integrate it back into the VS Code extension.

---

### **Part 1: SvelteKit Project Scaffolding**

#### **1.1: Clean and Re-initialize `webview/` Directory**

First, ensure you have a backup of the existing `webview/` directory if needed, then clear it.

Next, scaffold a new SvelteKit project. You will be prompted to select a template; choose "Skeleton project" and add TypeScript support.

```bash
# Navigate to the project root
# Make a backup if you need one
# mv webview webview_backup

# Remove the old directory
rm -rf webview

# Create the new SvelteKit project
npm create svelte@latest webview
```

#### **1.2: Install and Configure Static Adapter**

The `@sveltejs/adapter-static` allows us to build the SvelteKit app into a collection of static HTML, CSS, and JavaScript files, which is ideal for a VS Code Webview.

1.  **Install the adapter:**
    ```bash
    cd webview
    npm install -D @sveltejs/adapter-static
    cd ..
    ```

2.  **Configure `svelte.config.js`:**
    Modify `webview/svelte.config.js` to use the static adapter. We will configure it to output a Single-Page Application (SPA) by specifying a fallback page. This is crucial for the webview's routing to work correctly.

    ```javascript
    // webview/svelte.config.js
    import adapter from '@sveltejs/adapter-static';
    import { vitePreprocess } from '@sveltejs/kit/vite';

    /** @type {import('@sveltejs/kit').Config} */
    const config = {
        preprocess: vitePreprocess(),

        kit: {
            adapter: adapter({
                // Default options are fine
                pages: 'build',
                assets: 'build',
                // This is the key for SPA mode
                fallback: 'index.html', 
                precompress: false,
                strict: true
            }),
            // Ensure client-side routing for the SPA
            prerender: {
                handleHttpError: 'ignore'
            }
        }
    };

    export default config;
    ```

After this step, running `npm run build` inside the `webview/` directory will generate a `build/` folder with the static assets.

---

### **Part 2: Recreating UI and State Management**

#### **2.1: Recreate Svelte Components**

Re-implement the functionality from the old `DatabaseSetup.ts` and `EmbeddingSetup.ts` files into new `.svelte` components.

*   **File:** `webview/src/lib/components/DatabaseSetup.svelte`
*   **File:** `webview/src/lib/components/EmbeddingSetup.svelte`

The goal is to replicate the existing UI and logic using Svelte's component-based structure. You can use standard HTML or a component library like Fluent UI for Svelte.

#### **2.2: Update State Management (`setupStore.ts`)**

Ensure the existing `webview/src/lib/stores/setupStore.ts` is adapted to work with the new Svelte components. The store should hold the state for the setup process, and the components should subscribe to it to react to changes.

#### **2.3: Create the Main Page (`+page.svelte`)**

The main entry point for the UI will be `webview/src/routes/+page.svelte`. This page will import the components and use the `setupStore` to conditionally render the correct setup view.

```html
<!-- webview/src/routes/+page.svelte -->
<script lang="ts">
    import DatabaseSetup from '$lib/components/DatabaseSetup.svelte';
    import EmbeddingSetup from '$lib/components/EmbeddingSetup.svelte';
    import { setupStore } from '$lib/stores/setupStore';

    // Example logic to switch between views
    let currentStep;
    setupStore.subscribe(store => {
        currentStep = store.step;
    });
</script>

<main>
    {#if currentStep === 'database'}
        <DatabaseSetup />
    {:else if currentStep === 'embedding'}
        <EmbeddingSetup />
    {/if}
</main>

<style>
    main {
        padding: 1rem;
    }
</style>
```

---

### **Part 3: Integrating with VS Code Webview**

#### **3.1: Update `WebviewManager.ts`**

The final step is to make the extension load the new SvelteKit build. The `getWebviewContent` method in `src/webviewManager.ts` needs to be updated.

The core tasks are:
1.  Read the `index.html` from the `webview/build` directory.
2.  Use `panel.webview.asWebviewUri` to generate correct, security-compliant URIs for all CSS and JS assets referenced in the HTML.
3.  Inject a Content Security Policy (CSP) meta tag to allow the webview to load the scripts and styles.

```typescript
// src/webviewManager.ts (Example Snippet)
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

// ... inside the WebviewManager class ...

private getWebviewContent(panel: vscode.WebviewPanel): string {
    const buildPath = path.join(this.context.extensionPath, 'webview', 'build');
    const indexPath = path.join(buildPath, 'index.html');

    let html = fs.readFileSync(indexPath, 'utf8');
    const nonce = this.getNonce();

    // 1. Replace all relative paths with webview-safe URIs
    html = html.replace(/(href|src)="\/([^"]*)"/g, (match, p1, p2) => {
        const resourcePath = path.join(buildPath, p2);
        const resourceUri = vscode.Uri.file(resourcePath);
        const webviewUri = panel.webview.asWebviewUri(resourceUri);
        return `${p1}="${webviewUri}"`;
    });

    // 2. Add nonce to all script tags for CSP
    html = html.replace(/<script/g, `<script nonce="${nonce}"`);

    // 3. Inject the Content Security Policy
    const csp = `
        <meta http-equiv="Content-Security-Policy" content="
            default-src 'none';
            style-src ${panel.webview.cspSource};
            script-src 'nonce-${nonce}';
            img-src ${panel.webview.cspSource} https:;
        ">
    `;
    html = html.replace('<meta charset="utf-8" />', `<meta charset="utf-8" />${csp}`);

    return html;
}

private getNonce(): string {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
```

This completes the migration. The extension will now serve a modern, maintainable SvelteKit application as its webview UI.
</file>

<file path="docs/todo/missing/implementation_sub_sprint_2_diagnostics_view.md">
# Implementation Guide: Sprint 2 - Diagnostics View Refactoring

**Goal:** To refactor the Svelte settings webview into a dedicated "Status & Diagnostics" panel.

This guide provides the technical steps to create the new diagnostics panel, refactor the Svelte component, and establish communication between the webview and the extension.

---

### **Part 1: Command and Panel Creation**

This follows the established pattern in the extension for adding new commands and webview panels.

1.  **Add Command in `package.json`**: Define the new `openDiagnostics` command.

    ```json
    // package.json -> contributes.commands
    {
        "command": "code-context-engine.openDiagnostics",
        "title": "Code Context Engine: Open Diagnostics"
    }
    ```

2.  **Register Command in `commandManager.ts`**: The handler will call a new method on the `WebviewManager`.

    ```typescript
    // src/commandManager.ts
    // In registerCommands method
    this.registerCommand('code-context-engine.openDiagnostics', this.handleOpenDiagnostics.bind(this));

    // New handler method
    private handleOpenDiagnostics() {
        this.webviewManager.showDiagnosticsPanel();
    }
    ```

3.  **Implement `showDiagnosticsPanel` in `webviewManager.ts`**: This method should create and manage a singleton `WebviewPanel` for the diagnostics view, just like `showMainPanel`.

    ```typescript
    // src/webviewManager.ts
    private diagnosticsPanel: vscode.WebviewPanel | undefined;

    public showDiagnosticsPanel() {
        if (this.diagnosticsPanel) {
            this.diagnosticsPanel.reveal(vscode.ViewColumn.One);
        } else {
            this.diagnosticsPanel = vscode.window.createWebviewPanel(
                'diagnosticsView', 
                'Code Context Diagnostics', 
                vscode.ViewColumn.One, 
                { /* ... webview options ... */ }
            );
            this.diagnosticsPanel.webview.html = this.getWebviewContent(this.diagnosticsPanel);
            this.diagnosticsPanel.onDidDispose(() => { this.diagnosticsPanel = undefined; }, null, this.context.subscriptions);
        }
    }
    ```

---

### **Part 2: Refactoring the Svelte Component**

This involves turning the existing settings component into a read-only view.

1.  **Rename Component**: Rename `SettingsView.svelte` to `DiagnosticsView.svelte`.
2.  **Remove Inputs**: Delete all interactive form elements like `<select>` and `<input>` that were used for *setting* values.
3.  **Display Read-Only Settings**: Use the existing `setupStore` or a new message from the extension to fetch the current configuration and display it as text.

    ```html
    <!-- webview/src/lib/views/DiagnosticsView.svelte -->
    <script lang="ts">
        import { setupStore } from '../stores/setupStore';
    </script>

    <h2>Configuration</h2>
    <div>Provider: {$setupStore.embeddingProvider}</div>
    <div>Database: {$setupStore.database}</div>
    <!-- ... other read-only settings ... -->
    ```

4.  **Preserve Action Buttons**: Keep existing buttons like "Test Connection" and ensure their message-passing logic remains functional.

---

### **Part 3: Webview-to-Extension Communication**

This is the key to making the "Edit Configuration" button work. We will send a message from the Svelte component to the extension, which will then execute a VS Code command.

#### **3.1: Add the Button and Send Message**

In the Svelte component, use the `acquireVsCodeApi` to get a communication object and call `postMessage` when the button is clicked.

**File to Modify:** `webview/src/lib/views/DiagnosticsView.svelte`

```html
<script lang="ts">
    import { onMount } from 'svelte';

    // It's best practice to get the vscode api object once.
    // A good place for this is in a separate vscodeApi.ts file.
    import { vscode } from '../vscodeApi'; // Assuming vscodeApi.ts exports it

    function handleEditSettings() {
        vscode.postMessage({
            command: 'openSettings'
        });
    }
</script>

<h2>Configuration</h2>
<!-- ... read-only settings ... -->

<button on:click={handleEditSettings}>Edit Configuration</button>

<!-- ... other buttons like Test Connection ... -->
```

**New Helper File:** `webview/src/lib/vscodeApi.ts`

```typescript
// webview/src/lib/vscodeApi.ts
declare const acquireVsCodeApi: any;
export const vscode = acquireVsCodeApi();
```

#### **3.2: Handle the Message in `messageRouter.ts`**

The `MessageRouter` will listen for the `openSettings` command from the webview and execute the native VS Code command to open the settings UI.

**File to Modify:** `src/messageRouter.ts`

```typescript
// src/messageRouter.ts
// ... inside handleMessage method ...

public handleMessage(panel: vscode.WebviewPanel, message: any) {
    switch (message.command) {
        // ... other cases
        case 'openSettings':
            vscode.commands.executeCommand(
                'workbench.action.openSettings', 
                '@ext:bramburn.code-context-engine'
            );
            break;
    }
}
```

This creates a seamless flow: the user clicks a button in the webview, which tells the extension to open the native settings UI, providing a much more integrated and familiar user experience.
</file>

<file path="docs/todo/missing/implementation_sub_sprint_2_native_settings_hotkeys_state_management.md">
# Implementation Guide: Sprint 2 - Native Settings, Hotkeys & State Management

**Goal:** To improve UX by adding keyboard shortcuts, using the native VS Code settings UI, and implementing a robust state manager.

This guide provides the technical steps to integrate the extension more deeply with VS Code.

---

### **Part 1: Keybindings and Native Settings**

#### **1.1: Add Keybindings to `package.json`**

To add keyboard shortcuts, you need to add a `contributes.keybindings` section to the `package.json` file. This allows users to trigger commands without using the command palette.

**File to Modify:** `package.json`

```json
// package.json
{
  "name": "code-context-engine",
  "contributes": {
    "commands": [
      {
        "command": "code-context-engine.openMainPanel",
        "title": "Code Context Engine: Open Main Panel"
      },
      {
        "command": "code-context-engine.startIndexing",
        "title": "Code Context Engine: Start Indexing"
      }
      // ... other commands
    ],
    "keybindings": [
      {
        "command": "code-context-engine.openMainPanel",
        "key": "ctrl+alt+c",
        "mac": "cmd+alt+c",
        "when": "editorTextFocus"
      },
      {
        "command": "code-context-engine.startIndexing",
        "key": "ctrl+alt+i",
        "mac": "cmd+alt+i",
        "when": "editorTextFocus"
      }
    ]
  }
}
```

*   **`command`**: The ID of the command to execute.
*   **`key` / `mac`**: The key combination for Windows/Linux and macOS.
*   **`when`**: A [when clause](https://code.visualstudio.com/api/references/when-clause-contexts) that determines when the keybinding is active. `editorTextFocus` is a common choice.

#### **1.2: Refactor "Open Settings" Command**

To provide a native experience, we will change the `openSettings` command to open the standard VS Code Settings UI, filtered to show only our extension's settings.

**File to Modify:** `src/commandManager.ts`

```typescript
// src/commandManager.ts
import * as vscode from 'vscode';

// ... inside CommandManager class ...

private handleOpenSettings() {
    // The extension ID is defined in package.json (e.g., "bramburn.code-context-engine")
    vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');
}

// Make sure this handler is registered to the correct command ID.
```

--- 

### **Part 2: Diagnostics View and State Management**

#### **2.1: Create `openDiagnostics` Command and Panel**

This involves creating a new command and a `WebviewManager` method to show the new diagnostics panel. This will follow the same pattern as the existing `showMainPanel`.

1.  **`package.json`**: Add the new `code-context-engine.openDiagnostics` command.
2.  **`src/commandManager.ts`**: Register the new command and have it call `this.webviewManager.showDiagnosticsPanel()`.
3.  **`src/webviewManager.ts`**: Implement `showDiagnosticsPanel`, which will create and manage a new `WebviewPanel` instance for the diagnostics view.

#### **2.2: Create `StateManager.ts`**

A simple, centralized state manager will help prevent race conditions and manage the extension's state, such as whether indexing is in progress.

**New File:** `src/stateManager.ts`

```typescript
// src/stateManager.ts

interface ExtensionState {
    isIndexing: boolean;
}

export class StateManager {
    private state: ExtensionState;

    constructor() {
        this.state = {
            isIndexing: false,
        };
    }

    public getState(): Readonly<ExtensionState> {
        return this.state;
    }

    public setIndexing(isIndexing: boolean): void {
        this.state.isIndexing = isIndexing;
        // Here you could add listeners/event emitters if other parts
        // of the extension need to react to state changes.
    }
}
```

#### **2.3: Integrate `StateManager`**

The `StateManager` should be instantiated once and shared across the extension. The `ExtensionManager` is the ideal place to create and inject it.

**File to Modify:** `src/extensionManager.ts`

```typescript
// src/extensionManager.ts
import { StateManager } from './stateManager';
// ... other imports

export class ExtensionManager {
    private stateManager: StateManager;
    // ... other services

    constructor(context: vscode.ExtensionContext) {
        this.stateManager = new StateManager();
        // Pass the stateManager instance to the services that need it.
        this.indexingService = new IndexingService(this.stateManager);
        this.messageRouter = new MessageRouter(this.stateManager, this.indexingService);
        // ... initialize other managers
    }
}
```

#### **2.4: Add Guard Clause in `MessageRouter`**

Finally, use the `StateManager` in the `MessageRouter` to prevent starting a new indexing job if one is already running.

**File to Modify:** `src/messageRouter.ts`

```typescript
// src/messageRouter.ts
// ... imports

export class MessageRouter {
    private stateManager: StateManager;
    private indexingService: IndexingService;

    constructor(stateManager: StateManager, indexingService: IndexingService) {
        this.stateManager = stateManager;
        this.indexingService = indexingService;
    }

    private handleMessage(message: any) {
        switch (message.command) {
            case 'startIndexing':
                if (this.stateManager.getState().isIndexing) {
                    vscode.window.showInformationMessage('An indexing process is already running.');
                    return; // Guard clause
                }
                // Set state to true before starting
                this.stateManager.setIndexing(true);
                this.indexingService.startIndexing().finally(() => {
                    // Set state to false when finished
                    this.stateManager.setIndexing(false);
                });
                break;
            // ... other cases
        }
    }
}
```

And in the `IndexingService`, you would also set the state.

**File to Modify:** `src/indexing/indexingService.ts`

```typescript
// src/indexing/indexingService.ts
// ... imports

export class IndexingService {
    private stateManager: StateManager;

    constructor(stateManager: StateManager) {
        this.stateManager = stateManager;
    }

    public async startIndexing() {
        this.stateManager.setIndexing(true);
        try {
            // ... your indexing logic ...
        } catch (error) {
            // ... error handling ...
        } finally {
            this.stateManager.setIndexing(false);
        }
    }
}
```
</file>

<file path="docs/todo/missing/prd.md">
<prd>Excellent, I've conducted a full review of the codebase in `repomix-output.xml` against the completed PRDs and task lists. The analysis shows that while significant architectural work has been done to decouple the backend services, there are several key features and refactors from the planning documents that have not yet been implemented.

The most significant unimplemented items are the migration of the frontend to SvelteKit and the UX improvements to integrate with VS Code's native settings and hotkeys.

To get the project to a "complete" state as envisioned in your documents, I have created a final, consolidated PRD. This PRD addresses all remaining activities.

-----

### **New Document: PRD 1: Foundational - Final Architecture & UX Polish**

**1. Title & Overview**

  * **Project:** Code Context Engine - Final Implementation
  * **Summary:** This phase focuses on completing the extension's architecture and user experience as originally planned. The primary goals are to migrate the frontend from a TypeScript DOM-based approach to a modern SvelteKit application, integrate with VS Code's native settings UI for a more seamless experience, and add keyboard shortcuts for power users. This PRD combines the unimplemented goals from the "Svelte Migration" and "UX Enhancements" PRDs.
  * **Dependencies:** The existing decoupled backend architecture (`ExtensionManager`, `CommandManager`, etc.) must be in place.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Deliver a polished, professional, and intuitive user experience that aligns with VS Code's native patterns.
      * Establish a modern and maintainable frontend architecture to accelerate future UI development.
  * **Developer & System Success Metrics:**
      * The `webview/` directory is a fully functional SvelteKit project, and all UI is rendered using `.svelte` components.
      * The extension's settings are managed exclusively through the native VS Code Settings UI, and the old Svelte settings page is repurposed as a "Status & Diagnostics" panel.
      * Key commands are accessible via keyboard shortcuts defined in `package.json`.
      * A `StateManager` is implemented and used to prevent conflicting operations like concurrent indexing.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin wants to manage settings in the same way he does for all his other extensions. He also wants to use keyboard shortcuts to speed up his workflow without reaching for the mouse.
  * **Frank (Frontend Developer):** Frank needs a proper SvelteKit development environment to efficiently build and maintain the UI, rather than manipulating the DOM with plain TypeScript.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Final Polish** | **Sprint 1: SvelteKit Migration** | As Frank, I want to replace the current webview implementation with a SvelteKit application configured with a static adapter, so I have a proper foundation for the UI. | 1. The `webview/` directory is replaced with a new SvelteKit project.\<br/\>2. The project is configured with `@sveltejs/adapter-static` to build into a `build` directory.\<br/\>3. The `WebviewManager` is updated to load the `index.html` from the SvelteKit build output and correctly rewrite asset paths. | **2 Weeks** |
| | | As Frank, I want to recreate the `DatabaseSetup` and `EmbeddingSetup` UI as Svelte components, so the UI is modular and state-driven. | 1. The functionality of `DatabaseSetup.ts` is replicated in a `DatabaseSetup.svelte` component.\<br/\>2. The functionality of `EmbeddingSetup.ts` is replicated in a `EmbeddingSetup.svelte` component.\<br/\>3. A `setupStore.ts` Svelte store is used to manage the onboarding state. | |
| **Phase 1: Final Polish** | **Sprint 2: Native Settings & Hotkeys** | As Devin, I want to use keyboard shortcuts to open the main panel and start indexing, so I can work more efficiently. | 1. A `keybindings` section is added to `package.json`.\<br/\>2. Default shortcuts (e.g., `Ctrl+Alt+C` and `Ctrl+Alt+I`) are assigned to the `openMainPanel` and `startIndexing` commands.\<br/\>3. The shortcuts are functional and documented in the `README.md`. | **2 Weeks** |
| | | As Devin, I want to manage settings in the native VS Code UI, not a custom webview, for a familiar experience. | 1. The `handleOpenSettings` method in `CommandManager` is changed to execute `workbench.action.openSettings` to open the native UI.\<br/\>2. The old Svelte settings page is repurposed into a read-only "Status & Diagnostics" panel.\<br/\>3. A new `openDiagnostics` command is created to show this panel. | |
| | | As Alisha, I want to implement a `StateManager` to prevent concurrent operations, so the extension is more robust. | 1. A `StateManager.ts` file is created.\<br/\>2. The `IndexingService` uses the `StateManager` to set an `isIndexing` flag during operation.\<br/\>3. The `MessageRouter` checks this flag to prevent a new indexing job from starting if one is already running. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** SvelteKit Migration (2 Weeks)
  * **Sprint 2:** Native Settings & Hotkeys (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Risk:** The SvelteKit migration is a significant frontend refactor and might take longer than estimated if the existing DOM manipulation logic is complex.
      * **Mitigation:** Treat the existing TypeScript classes (`DatabaseSetup.ts`, `EmbeddingSetup.ts`) as a clear specification for the Svelte components' functionality to guide the rewrite.
  * **Risk:** Users might be confused by the settings moving to the native UI.
      * **Mitigation:** The new "Status & Diagnostics" panel must have a clear button that links directly to the native settings UI to guide users. Update the `README.md` to explain the change.

-----

### **New Document: Sub-Sprint 1: SvelteKit Project Scaffolding & Migration**

**Objective:**
To replace the current TypeScript DOM-based webview with a new, properly configured SvelteKit project and replicate the existing UI as Svelte components.

**Parent Sprint:**
PRD 1, Sprint 1: SvelteKit Migration

**Tasks:**

1.  **Clear and Re-initialize `webview/`:** Remove all existing content from the `webview/` directory. Run `npm create svelte@latest webview` to scaffold a new SvelteKit project with TypeScript support.
2.  **Configure Static Build:** Install `@sveltejs/adapter-static` and modify `webview/svelte.config.js` to configure a static build into a `build` directory.
3.  **Create UI Components:** Create `DatabaseSetup.svelte` and `EmbeddingSetup.svelte` components, replicating the UI and logic from the existing `.ts` files using Fluent UI components.
4.  **Implement State Management:** Use the existing `setupStore.ts` to manage the state for the new Svelte components, ensuring the "Index Now" button enables correctly.

**Acceptance Criteria:**

  * The `webview/` directory is a SvelteKit project.
  * Running `npm run build` in `webview/` generates a static site in `webview/build/`.
  * The new Svelte UI functionally matches the old TypeScript-based UI.

**Dependencies:**

  * The existing TypeScript UI classes (`DatabaseSetup.ts`, `EmbeddingSetup.ts`) serve as the specification.

**Timeline:**

  * **Start Date:** 2025-08-25
  * **End Date:** 2025-09-05

-----

### **New Document: Sub-Sprint 2: Native Settings, Hotkeys & State Management**

**Objective:**
To integrate the extension more deeply with VS Code by adding keyboard shortcuts, using the native settings UI, and implementing a central state manager.

**Parent Sprint:**
PRD 1, Sprint 2: Native Settings & Hotkeys

**Tasks:**

1.  **Add Keybindings:** Modify `package.json` to add a `contributes.keybindings` section. Define shortcuts for `openMainPanel` and `startIndexing`.
2.  **Refactor "Open Settings" Command:** Change the `handleOpenSettings` method in `src/commandManager.ts` to execute `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:your.extension-id')`.
3.  **Create Diagnostics View:** Repurpose the old settings UI into a read-only "Status & Diagnostics" Svelte component. Add a new `openDiagnostics` command to show it.
4.  **Implement StateManager:** Create the `StateManager.ts` file and class. Inject it via the `ExtensionManager` and use it in `IndexingService` and `MessageRouter` to manage the `isIndexing` state.

**Acceptance Criteria:**

  * Hotkeys successfully trigger their corresponding commands.
  * The "Open Settings" command opens the native VS Code Settings UI, filtered for the extension.
  * A new "Open Diagnostics" command shows a panel with status info and a link to the settings.
  * Attempting to start indexing while another job is running is correctly blocked.

**Dependencies:**

  * Sprint 1 (SvelteKit Migration) must be complete.

**Timeline:**

  * **Start Date:** 2025-09-08
  * **End Date:** 2025-09-19

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - SvelteKit Migration

**Goal:** To migrate the existing webview from plain TypeScript to a modern SvelteKit application.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Backup and Clean `webview/`:** Make a backup of the current `webview/` directory, then delete its contents. | `webview/` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** Run `npm create svelte@latest webview` and select "Skeleton project" with TypeScript support. | `webview/` (New project) |
| **1.3** |  To Do | **Install Static Adapter:** In the `webview/` directory, run `npm install -D @sveltejs/adapter-static`. | `webview/package.json` |
| **1.4** |  To Do | **Configure Static Build:** Modify `webview/svelte.config.js` to use the static adapter, outputting to a `build` directory with `index.html` as the fallback. | `webview/svelte.config.js` |
| **1.5** |  To Do | **Recreate `DatabaseSetup.svelte`:** Create the component and implement the UI and logic from `DatabaseSetup.ts` using Svelte syntax. | `webview/src/lib/components/DatabaseSetup.svelte` (New) |
| **1.6** |  To Do | **Recreate `EmbeddingSetup.svelte`:** Create the component and implement the UI and logic from `EmbeddingSetup.ts`. | `webview/src/lib/components/EmbeddingSetup.svelte` (New) |
| **1.7** |  To Do | **Update `setupStore.ts`:** Ensure the Svelte store (`setupStore.ts`) correctly manages the state for the new components. | `webview/src/lib/stores/setupStore.ts` |
| **1.8** |  To Do | **Create Main Page Layout:** In `webview/src/routes/+page.svelte`, use the store to manage the view and conditionally render the setup components. | `webview/src/routes/+page.svelte` |
| **1.9** |  To Do | **Update `WebviewManager`:** Modify `getWebviewContent` to load `webview/build/index.html` and correctly rewrite asset paths using `asWebviewUri`. | `src/webviewManager.ts` |

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Native Settings & Hotkeys

**Goal:** To improve UX by adding keyboard shortcuts, using the native VS Code settings UI, and implementing a robust state manager.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Add `keybindings` to `package.json`:** Add a `contributes.keybindings` section and define shortcuts for `openMainPanel` and `startIndexing`. | `package.json` |
| **2.2** |  To Do | **Refactor `handleOpenSettings` Command:** In `src/commandManager.ts`, change the handler to call `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine')`. | `src/commandManager.ts` |
| **2.3** |  To Do | **Create `openDiagnostics` Command:** Add a new command `code-context-engine.openDiagnostics` in `package.json` and `commandManager.ts`. | `package.json`, `src/commandManager.ts` |
| **2.4** |  To Do | **Create `showDiagnosticsPanel` Method:** In `src/webviewManager.ts`, add a method to show a panel that will render the diagnostics view. | `src/webviewManager.ts` |
| **2.5** |  To Do | **Create `DiagnosticsView.svelte`:** Repurpose the old Svelte settings page. Remove configuration inputs and add a button that calls the `openSettings` command. | `webview/src/lib/views/DiagnosticsView.svelte` (New) |
| **2.6** |  To Do | **Create `StateManager.ts`:** Create the new file and implement the `StateManager` class with an `isIndexing` flag. | `src/stateManager.ts` (New) |
| **2.7** |  To Do | **Integrate `StateManager`:** Instantiate the manager in `ExtensionManager` and inject it into `IndexingService` and `MessageRouter`. | `src/extensionManager.ts`, `src/indexing/indexingService.ts`, `src/messageRouter.ts` |
| **2.8** |  To Do | **Add Guard Clause:** In `MessageRouter`, add a check for `stateManager.isIndexing()` before starting a new indexing job. | `src/messageRouter.ts` |Of course. Here is the final PRD to complete the user experience enhancements for your extension.

-----

### **New Document: PRD 2: UI/UX - Status & Diagnostics Panel**

**1. Title & Overview**

  * **Project:** Code Context Engine - Status & Diagnostics Panel
  * **Summary:** This phase completes the user experience overhaul by repurposing the now-legacy Svelte settings page into a dedicated "Status & Diagnostics" panel. This provides a clear, focused UI for users to perform actions like testing service connections and viewing system status, cleanly separating these actions from the configuration, which is now handled by VS Code's native settings UI.
  * **Dependencies:** PRD 1 (Hotkey & Native Settings Integration) must be complete. The command to open the native settings UI must be functional.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Improve user confidence and reduce support issues by providing clear, actionable diagnostic tools.
      * Create a more logical and streamlined UX by separating "what you configure" (VS Code Settings) from "what you do" (Diagnostics Panel).
  * **User Success Metrics:**
      * Users can successfully test their connection to the database and embedding providers from the UI.
      * The panel displays the current configuration in a clear, read-only format, reducing confusion about what settings are active.
      * The user journey from diagnostics to configuration is seamless (e.g., a button in the panel links directly to the native settings UI).

-----

**3. User Personas**

  * **Devin (Developer - End User):** When setting up the extension or troubleshooting, Devin needs a simple way to confirm that his local services (like Qdrant and Ollama) are correctly connected to the extension. This panel gives him a one-click way to verify his setup.
  * **Alisha (Backend Developer):** Alisha benefits from having a dedicated UI for actions that trigger backend processes. This keeps the main query UI clean and provides a specific area for adding future administrative or diagnostic features.

-----

**4. Requirements Breakdown**

| Phase                 | Sprint                            | User Story                                                                                                                                                             | Acceptance Criteria                                                                                                                                                                                                                                                                                                                        | Duration |
| :-------------------- | :-------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------- |
| **Phase 2: UX Polish** | **Sprint 2: Repurpose Settings Page** | As Alisha, I want to repurpose the existing Svelte settings page into a "Status & Diagnostics" panel, so we can keep useful actions like connection testing without managing configuration in a custom UI. | 1. The Svelte settings component is renamed to `DiagnosticsView.svelte`.\<br/\>2. All configuration input fields (dropdowns, text inputs for values) are removed from the component.\<br/\>3. Action buttons like "Test Database Connection" and "Test Embedding Provider" remain functional.\<br/\>4. The view is updated to display the current configuration values in a read-only format. | **2 Weeks** |
|                       |                                   | As Devin, I want to be able to open the new "Status & Diagnostics" panel from a command, so I can easily test my connections.                                              | 1. A new command, `code-context-engine.openDiagnostics`, is added in `package.json`.\<br/\>2. A new handler is added to `CommandManager` for this command.\<br/\>3. The handler calls a new method in `WebviewManager` (`showDiagnosticsPanel`) to display the repurposed Svelte view.                                                   |          |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 2:** Repurpose Settings Page to Diagnostics View (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The Svelte components are modular enough that removing the configuration inputs will not break the layout or functionality of the remaining action buttons.
  * **Risk:** The new "Diagnostics" panel could cause user confusion if its purpose is not clearly communicated.
      * **Mitigation:** The UI should have a clear title like "Status & Diagnostics". It should also contain a prominent button or link labeled "Edit Configuration" that executes the `workbench.action.openSettings` command, guiding users to the correct location for making changes.

-----

### **New Document: Sub-Sprint 2: Diagnostics View Refactoring**

**Objective:**
To refactor the Svelte settings page into a read-only diagnostics and status view, and create a new command to open it.

**Parent Sprint:**
PRD 2, Sprint 2: Repurpose Settings Page

**Tasks:**

1.  **Create New Command:** Define and register a new command `code-context-engine.openDiagnostics` in `package.json` and `CommandManager`.
2.  **Create `showDiagnosticsPanel` Method:** In `WebviewManager`, create a new method to show the diagnostics webview, ensuring it's managed as a singleton panel.
3.  **Refactor Svelte Component:** Rename the settings Svelte component to `DiagnosticsView.svelte`.
4.  **Remove Input Elements:** Remove all interactive form elements for *setting* values (e.g., `<select>`, `<input>`).
5.  **Display Read-Only Settings:** Fetch the current configuration and display it as read-only text.
6.  **Add "Edit Settings" Button:** Add a new button that, when clicked, sends a message to the extension to execute the `workbench.action.openSettings` command.
7.  **Preserve Action Buttons:** Ensure that buttons for "Test Connection" remain and are functional.

**Acceptance Criteria:**

  * A new "Code Context Engine: Open Diagnostics" command is available.
  * The new panel displays current settings as text and does not allow editing them.
  * The "Test Connection" buttons work as before.
  * A new "Edit Settings" button correctly opens the native VS Code settings UI.

**Dependencies:**

  * PRD 1 must be complete.

**Timeline:**

  * **Start Date:** 2026-02-09
  * **End Date:** 2026-02-20

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Repurpose Settings Page to Diagnostics View

**Goal:** To refactor the Svelte settings webview into a dedicated "Status & Diagnostics" panel.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Add `openDiagnostics` Command:** In `package.json`, add a new command definition for `code-context-engine.openDiagnostics` with the title "Code Context Engine: Open Diagnostics". | `package.json` |
| **2.2** |  To Do | **Register `openDiagnostics` Command:** In `src/commandManager.ts`, register the new command. The handler should call a new method on the `WebviewManager`, e.g., `this.webviewManager.showDiagnosticsPanel()`. | `src/commandManager.ts` |
| **2.3** |  To Do | **Implement `showDiagnosticsPanel`:** In `src/webviewManager.ts`, create the new method `showDiagnosticsPanel`. It should manage a new panel instance (`diagnosticsPanel`) using the same singleton pattern as `showMainPanel`. | `src/webviewManager.ts` |
| **2.4** |  To Do | **Rename Svelte Component:** Rename the Svelte settings component file to `DiagnosticsView.svelte`. Update any import paths that reference it. | `webview/src/lib/views/SettingsView.svelte` -\> `DiagnosticsView.svelte` |
| **2.5** |  To Do | **Remove Configuration Inputs:** In `DiagnosticsView.svelte`, delete all `<select>` and `<input>` elements used for setting configuration values. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.6** |  To Do | **Display Read-Only Settings:** Add logic to fetch the current settings on mount and display them as plain text (e.g., `<div>Provider: {$settings.embeddingProvider}</div>`). | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.7** |  To Do | **Add "Edit Settings" Button:** Add a new Fluent UI button to `DiagnosticsView.svelte` labeled "Edit Configuration". | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.8** |  To Do | **Implement "Edit Settings" Action:** The new button's `on:click` handler should send a `MapsToSettings` message to the extension. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.9** |  To Do | **Handle `MapsToSettings` Message:** In `src/messageRouter.ts`, add a case for `MapsToSettings` that calls `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');`. | `src/messageRouter.ts` |
| **2.10** |  To Do | **Verify Action Buttons:** Ensure the "Test Connection" buttons remain in `DiagnosticsView.svelte` and their message-passing logic is still functional. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **2.11** |  To Do | **Test Full Flow:** Manually test opening the new Diagnostics panel, verifying settings are read-only, and confirming the "Edit Configuration" button opens the correct native UI. | `(Manual Test)` |

This completes the full set of PRDs and task lists for the user experience enhancements. You now have a comprehensive plan to integrate native VS Code features and provide a more streamlined and intuitive interface for your users.</prd> [backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/missing/tasklist_sub_sprint_01.md">
# Task List: Sub-Sprint 1 - SvelteKit Migration

**Goal:** To migrate the existing webview from plain TypeScript to a modern SvelteKit application.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Backup and Clean `webview/`:** Make a backup of the current `webview/` directory, then delete its contents to prepare for the new project. | `webview/` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** Run `npm create svelte@latest webview` in the root directory. Select the "Skeleton project" option and choose "Yes, using TypeScript syntax". | `webview/` (New project) |
| **1.3** |  To Do | **Install Static Adapter:** Navigate into the new `webview` directory and run `npm install -D @sveltejs/adapter-static`. | `webview/package.json` |
| **1.4** |  To Do | **Configure Static Build for SPA:** Modify `webview/svelte.config.js` to import and use `adapter-static`, ensuring you set the `fallback: 'index.html'` property to enable SPA mode. | `webview/svelte.config.js` |
| **1.5** |  To Do | **Create `vscodeApi.ts` Helper:** Create a new file `webview/src/lib/vscodeApi.ts` that exports the `acquireVsCodeApi()` instance for easy use in components. | `webview/src/lib/vscodeApi.ts` (New) |
| **1.6** |  To Do | **Recreate `DatabaseSetup.svelte` Component:** Create the component file. Replicate the UI and logic from the original `DatabaseSetup.ts` using Svelte syntax and Fluent UI components. | `webview/src/lib/components/DatabaseSetup.svelte` (New) |
| **1.7** |  To Do | **Recreate `EmbeddingSetup.svelte` Component:** Create the component file and implement the UI and logic from the original `EmbeddingSetup.ts`. | `webview/src/lib/components/EmbeddingSetup.svelte` (New) |
| **1.8** |  To Do | **Update `setupStore.ts` for Svelte:** Ensure the Svelte store at `webview/src/lib/stores/setupStore.ts` correctly manages the state for the new Svelte components. No changes may be needed if it's already a standard Svelte store. | `webview/src/lib/stores/setupStore.ts` |
| **1.9** |  To Do | **Create Main Page Layout (`+page.svelte`):** In `webview/src/routes/+page.svelte`, import the store and the new setup components. Use the store's state to conditionally render the correct component. | `webview/src/routes/+page.svelte` (New) |
| **1.10** |  To Do | **Update `WebviewManager` to Use Build Output:** Modify the `getWebviewContent` method in `src/webviewManager.ts` to read `webview/build/index.html`. | `src/webviewManager.ts` |
| **1.11** |  To Do | **Implement Asset Path Rewriting in `WebviewManager`:** In `getWebviewContent`, add the logic to replace all `href` and `src` paths with correctly formatted `panel.webview.asWebviewUri` paths. | `src/webviewManager.ts` |
| **1.12** |  To Do | **Add Content Security Policy (CSP):** In `getWebviewContent`, inject the necessary `<meta>` tag for the CSP, including a `nonce` for all script tags, to ensure the webview loads securely. | `src/webviewManager.ts` |
| **1.13** |  To Do | **Test: Build and Load Webview:** Run `npm run build` in the `webview` directory. Launch the extension and verify the new Svelte-based UI loads correctly. | `(Manual Test)` |
</file>

<file path="docs/todo/missing/tasklist_sub_sprint_02.md">
# Task List: Sub-Sprint 2 - Native Settings, Hotkeys & State Management

**Goal:** To improve UX by adding keyboard shortcuts, using the native VS Code settings UI, and implementing a robust state manager.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Define Keybinding Contribution Point:** In `package.json`, add the `contributes.keybindings` section. | `package.json` |
| **2.2** |  To Do | **Add `openMainPanel` Keybinding:** Within `contributes.keybindings`, define a keybinding for the `code-context-engine.openMainPanel` command (e.g., `cmd+alt+c`). | `package.json` |
| **2.3** |  To Do | **Add `startIndexing` Keybinding:** Define a second keybinding for the `code-context-engine.startIndexing` command (e.g., `cmd+alt+i`). | `package.json` |
| **2.4** |  To Do | **Refactor `handleOpenSettings` Command:** In `src/commandManager.ts`, locate the `handleOpenSettings` method (or the command registration for it). | `src/commandManager.ts` |
| **2.5** |  To Do | **Implement Native Settings UI Call:** Change the body of the `handleOpenSettings` handler to `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine')`. | `src/commandManager.ts` |
| **2.6** |  To Do | **Create `StateManager.ts` File:** Create a new file `src/stateManager.ts` and define the `StateManager` class. | `src/stateManager.ts` (New) |
| **2.7** |  To Do | **Implement `isIndexing` State:** Inside `StateManager`, add a private boolean property `isIndexing` and public methods `getState()` and `setIndexing(boolean)`. | `src/stateManager.ts` |
| **2.8** |  To Do | **Instantiate `StateManager` in `ExtensionManager`:** In `src/extensionManager.ts`, import and create a single instance of `StateManager`. | `src/extensionManager.ts` |
| **2.9** |  To Do | **Inject `StateManager` into Services:** Pass the `StateManager` instance to the constructors of `IndexingService` and `MessageRouter`. | `src/extensionManager.ts`, `src/indexing/indexingService.ts`, `src/messageRouter.ts` |
| **2.10** |  To Do | **Set Indexing State in `IndexingService`:** In `startIndexing`, call `this.stateManager.setIndexing(true)` at the beginning of the method and `this.stateManager.setIndexing(false)` in a `finally` block. | `src/indexing/indexingService.ts` |
| **2.11** |  To Do | **Add Guard Clause in `MessageRouter`:** In the `handleMessage` case for `startIndexing`, add a guard clause: `if (this.stateManager.getState().isIndexing) { return; }`. | `src/messageRouter.ts` |
| **2.12** |  To Do | **Test: Hotkeys and Concurrent Indexing:** Launch the extension. Verify the new hotkeys work. Trigger indexing and immediately try to trigger it again; verify the second attempt is blocked. | `(Manual Test)` |
</file>

<file path="docs/todo/missing/tasklist_sub_sprint_03.md">
# Task List: Sub-Sprint 3 - Diagnostics View Refactoring

**Goal:** To refactor the Svelte settings webview into a dedicated "Status & Diagnostics" panel.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Add `openDiagnostics` Command Definition:** In `package.json`, add a new command to the `contributes.commands` array: `code-context-engine.openDiagnostics`. | `package.json` |
| **3.2** |  To Do | **Register `openDiagnostics` Command Handler:** In `src/commandManager.ts`, register the new command and point it to a new handler, `handleOpenDiagnostics`. | `src/commandManager.ts` |
| **3.3** |  To Do | **Implement `handleOpenDiagnostics`:** The new handler in `CommandManager` should simply call `this.webviewManager.showDiagnosticsPanel()`. | `src/commandManager.ts` |
| **3.4** |  To Do | **Implement `showDiagnosticsPanel` Method:** In `src/webviewManager.ts`, create the new method `showDiagnosticsPanel`. It should manage a new `diagnosticsPanel` instance using the same singleton pattern as `showMainPanel`. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Rename Svelte Component File:** In the `webview` project, rename the Svelte settings component file to `DiagnosticsView.svelte`. Update any import paths that reference it. | `webview/src/lib/views/SettingsView.svelte` -> `DiagnosticsView.svelte` |
| **3.6** |  To Do | **Remove Configuration Inputs from Component:** In `DiagnosticsView.svelte`, delete all `<select>` and `<input>` elements used for setting configuration values. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **3.7** |  To Do | **Display Read-Only Settings:** Add logic to the component to fetch the current settings on mount (e.g., from the `setupStore`) and display them as plain text. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **3.8** |  To Do | **Add "Edit Configuration" Button:** Add a new Fluent UI button to `DiagnosticsView.svelte` labeled "Edit Configuration". | `webview/src/lib/views/DiagnosticsView.svelte` |
| **3.9** |  To Do | **Implement `openSettings` Message:** The new button's `on:click` handler should call `vscode.postMessage({ command: 'openSettings' })`. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **3.10** |  To Do | **Handle `openSettings` Message in `MessageRouter`:** In `src/messageRouter.ts`, add a new `case` for `openSettings` that calls `vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');`. | `src/messageRouter.ts` |
| **3.11** |  To Do | **Verify Action Buttons Remain:** Ensure the "Test Connection" buttons are still present in `DiagnosticsView.svelte` and their message-passing logic is still functional. | `webview/src/lib/views/DiagnosticsView.svelte` |
| **3.12** |  To Do | **Test Full Flow:** Manually test opening the new Diagnostics panel via the command palette. Verify settings are read-only. Confirm the "Edit Configuration" button opens the native VS Code settings UI. | `(Manual Test)` |
</file>

<file path="docs/sprint3-usage.md">
# Sprint 3: Vectorization & DB Integration - Usage Guide

## Overview

Sprint 3 adds AI-powered semantic search capabilities to the Code Context Engine. Your code is now vectorized using embedding models and stored in a Qdrant vector database for intelligent similarity search.

## Prerequisites

### 1. Start Qdrant Database

```bash
# Start Qdrant using Docker Compose
docker-compose up -d

# Verify Qdrant is running
curl http://localhost:6333/health
```

### 2. Choose Embedding Provider

#### Option A: Ollama (Local, Free)
```bash
# Install Ollama
curl -fsSL https://ollama.ai/install.sh | sh

# Pull the embedding model
ollama pull nomic-embed-text

# Verify Ollama is running
curl http://localhost:11434/api/tags
```

#### Option B: OpenAI (Cloud, Requires API Key)
1. Get an API key from [OpenAI](https://platform.openai.com/api-keys)
2. Set it in VS Code settings: `code-context-engine.openaiApiKey`
3. Set provider to "openai": `code-context-engine.embeddingProvider`

## Configuration

Open VS Code settings and configure:

```json
{
  "code-context-engine.embeddingProvider": "ollama", // or "openai"
  "code-context-engine.databaseConnectionString": "http://localhost:6333",
  "code-context-engine.openaiApiKey": "your-api-key-here" // Only for OpenAI
}
```

## Usage

### 1. Index Your Repository

1. Open your project in VS Code
2. Run command: `Code Context Engine: Open Main Panel`
3. Click "Index Repository"
4. Watch the progress through phases:
   - **Discovering**: Finding code files
   - **Parsing**: Creating ASTs with tree-sitter
   - **Chunking**: Breaking code into segments
   - **Embedding**: Generating vector embeddings
   - **Storing**: Saving to Qdrant database

### 2. Search Your Code

1. In the Code Context Engine panel, enter a search query
2. Examples:
   - "function that handles user authentication"
   - "error handling for API requests"
   - "database connection setup"
   - "React component for user profile"

3. Results show:
   - **File path** and **line numbers**
   - **Code snippet** with context
   - **Similarity score** (higher = more relevant)
   - **Code type** (function, class, method, etc.)

## How It Works

### Indexing Pipeline

1. **File Discovery**: Finds all code files, respects .gitignore
2. **AST Parsing**: Uses tree-sitter to parse code structure
3. **Code Chunking**: Breaks code into meaningful segments:
   - Functions and methods
   - Classes and interfaces
   - Modules and namespaces
   - Important code blocks

4. **Vectorization**: Converts code chunks to embeddings:
   - **Ollama**: Uses local `nomic-embed-text` model (768 dimensions)
   - **OpenAI**: Uses `text-embedding-ada-002` (1536 dimensions)

5. **Storage**: Saves vectors and metadata to Qdrant:
   - Collection name: `code_context_{workspace_name}`
   - Includes file path, line numbers, code type, content
   - Optimized for similarity search

### Search Process

1. **Query Embedding**: Your search query is converted to a vector
2. **Similarity Search**: Qdrant finds most similar code chunks
3. **Ranking**: Results ranked by cosine similarity score
4. **Formatting**: Results formatted for VS Code display

## Supported Languages

- **TypeScript** (.ts, .tsx)
- **JavaScript** (.js, .jsx)
- **Python** (.py)
- **C#** (.cs)

## Troubleshooting

### Qdrant Issues
```bash
# Check if Qdrant is running
docker ps | grep qdrant

# View Qdrant logs
docker-compose logs qdrant

# Restart Qdrant
docker-compose restart qdrant
```

### Ollama Issues
```bash
# Check if Ollama is running
curl http://localhost:11434/api/tags

# Pull embedding model
ollama pull nomic-embed-text

# List available models
ollama list
```

### OpenAI Issues
- Verify API key is correct in VS Code settings
- Check API quota and billing status
- Ensure internet connectivity

### Search Returns No Results
1. Verify indexing completed successfully
2. Check Qdrant collection exists: `curl http://localhost:6333/collections`
3. Try broader search terms
4. Re-index if collection is empty

## Performance Tips

- **Large repositories**: Indexing may take several minutes
- **Batch processing**: Embeddings are processed in batches for efficiency
- **Memory usage**: Large codebases require more RAM for vector storage
- **Search speed**: First search may be slower due to model loading

## Next Steps

Sprint 4 will add:
- Advanced query capabilities
- File content retrieval
- Related files discovery
- Context-aware suggestions
</file>

<file path="docs/sprint4-usage.md">
# Sprint 4: Context Query API - Usage Guide

## Overview

Sprint 4 adds advanced context query capabilities to the Code Context Engine. You can now retrieve file content, discover related files, and perform sophisticated queries with filtering and metadata.

## New Features

### 1. Enhanced Search Interface

The search interface now provides:
- **Similarity scores** for each result (percentage match)
- **Code type indicators** (function, class, method, etc.)
- **Language badges** for each code chunk
- **Direct file opening** from search results
- **Related files discovery** automatically shown with search results

### 2. Service Status Monitoring

Real-time status display showing:
- **Database Connection**: Qdrant connectivity status
- **Embedding Provider**: Current provider (Ollama/OpenAI) status
- **Collection Status**: Whether your workspace is indexed

### 3. File Content Viewer

Click "Open" on any search result to:
- View complete file content in a modal
- See file metadata (size, last modified, language)
- Navigate to specific line numbers
- View related code chunks from the same file

### 4. Related Files Discovery

For each search, the system automatically finds:
- Files with similar code patterns
- Related functionality across your codebase
- Similarity scores and reasoning for each suggestion
- Chunk counts showing how much related code exists

## API Capabilities

### File Content Retrieval

```typescript
// Get file content with related chunks
const content = await vscodeApi.getFileContent('src/utils/helper.ts', true);

// Result includes:
// - Full file content
// - File metadata (size, modified date, language)
// - Related code chunks from the same file
```

### Related Files Discovery

```typescript
// Find files related to a query
const relatedFiles = await vscodeApi.findRelatedFiles(
    'authentication logic',
    'src/auth/login.ts',  // exclude current file
    10,                   // max results
    0.6                   // minimum similarity threshold
);

// Results include:
// - File paths with similarity scores
// - Reasoning for why files are related
// - Chunk counts and language information
```

### Advanced Context Queries

```typescript
// Perform sophisticated queries with filtering
const result = await vscodeApi.queryContext({
    query: 'error handling patterns',
    includeRelated: true,
    maxResults: 20,
    minSimilarity: 0.7,
    fileTypes: ['typescript', 'javascript']  // filter by language
});

// Results include:
// - Matching code chunks with metadata
// - Related files automatically discovered
// - Processing time and total result counts
```

### Service Status Monitoring

```typescript
// Check service health and configuration
const status = await vscodeApi.getServiceStatus();

// Returns:
// - Qdrant database connectivity
// - Embedding provider status
// - Collection existence and info
```

## Enhanced UI Features

### Search Results

Each search result now displays:
- **File path** with clickable "Open" button
- **Code snippet** with syntax highlighting
- **Similarity percentage** as a badge
- **Code type and name** (e.g., "function: authenticateUser")
- **Line number and language** information

### Related Files Panel

Automatically populated with each search:
- **File paths** with similarity scores
- **Reasoning** explaining why files are related
- **Chunk counts** showing amount of related code
- **Language indicators** for each file

### Service Status Bar

Always visible status indicators:
- **Database**: Connected/Disconnected status
- **Embeddings**: Current provider (ollama:nomic-embed-text, openai:text-embedding-ada-002)
- **Collection**: Ready/Not indexed status

### File Content Modal

Click any "Open" button to see:
- **Complete file content** with syntax highlighting
- **File metadata** (size, modification date, language)
- **Related chunks** from the same file (if requested)
- **Easy navigation** with scroll and search

## Message-Based Architecture

The new API uses a robust message-passing system:

### Request/Response Pattern
- **Unique request IDs** for tracking
- **Timeout handling** (30 seconds default)
- **Error propagation** with detailed messages
- **Type-safe interfaces** for all operations

### Event Handling
- **Real-time updates** for indexing progress
- **Service status changes** automatically reflected
- **Search result streaming** for large result sets

## Performance Optimizations

### Batch Processing
- **Related files** discovered in parallel with search
- **File content** loaded on-demand
- **Service status** cached and updated periodically

### Smart Caching
- **Request deduplication** for identical queries
- **Status caching** to reduce API calls
- **Result pagination** for large datasets

## Error Handling

Comprehensive error handling for:
- **Network timeouts** with retry logic
- **Service unavailability** with graceful degradation
- **Invalid queries** with helpful error messages
- **File access errors** with fallback options

## Integration Points

### VS Code Integration
- **Command palette** access to all features
- **Settings synchronization** with VS Code preferences
- **Theme integration** for consistent appearance
- **Keyboard shortcuts** for common operations

### Extension API
- **Message routing** for all webview communication
- **Context service** handling all business logic
- **Type safety** throughout the request/response cycle
- **Extensible architecture** for future enhancements

## Next Steps

Sprint 5 will add:
- **Settings UI** for configuring providers and preferences
- **Advanced filtering** options in the interface
- **Workspace-specific** configurations
- **Performance tuning** controls

The Context Query API provides a solid foundation for intelligent code exploration and discovery!
</file>

<file path="src/configuration/configurationManager.ts">
/**
 * Configuration Manager
 * 
 * This service handles configuration import/export, backup/restore, versioning,
 * and multi-environment configuration management for the Code Context Engine.
 */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { ConfigurationSchema, ConfigurationValidator, ValidationResult } from './configurationSchema';

export interface ConfigurationTemplate {
    id: string;
    name: string;
    description: string;
    category: 'development' | 'production' | 'team' | 'custom';
    configuration: ConfigurationSchema;
    tags: string[];
    author?: string;
    version: string;
}

export interface ConfigurationBackup {
    id: string;
    name: string;
    timestamp: string;
    configuration: ConfigurationSchema;
    metadata: {
        reason: 'manual' | 'auto' | 'migration';
        description?: string;
        previousVersion?: string;
    };
}

export interface ConfigurationMigration {
    fromVersion: string;
    toVersion: string;
    migrate: (config: any) => ConfigurationSchema;
    description: string;
}

export class ConfigurationManager {
    private context: vscode.ExtensionContext;
    private configurationPath: string;
    private backupPath: string;
    private templatesPath: string;
    private migrations: Map<string, ConfigurationMigration> = new Map();

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
        this.configurationPath = path.join(context.globalStorageUri.fsPath, 'configurations');
        this.backupPath = path.join(context.globalStorageUri.fsPath, 'backups');
        this.templatesPath = path.join(context.globalStorageUri.fsPath, 'templates');
        
        this.initializeDirectories();
        this.initializeMigrations();
    }

    /**
     * Initialize storage directories
     */
    private async initializeDirectories(): Promise<void> {
        try {
            await fs.promises.mkdir(this.configurationPath, { recursive: true });
            await fs.promises.mkdir(this.backupPath, { recursive: true });
            await fs.promises.mkdir(this.templatesPath, { recursive: true });
        } catch (error) {
            console.error('Failed to initialize configuration directories:', error);
        }
    }

    /**
     * Initialize configuration migrations
     */
    private initializeMigrations(): void {
        // Add future migrations here
        // Example:
        // this.migrations.set('1.0.0->1.1.0', {
        //     fromVersion: '1.0.0',
        //     toVersion: '1.1.0',
        //     migrate: (config) => { /* migration logic */ },
        //     description: 'Add new security features'
        // });
    }

    /**
     * Export configuration to JSON file
     */
    async exportConfiguration(
        configuration: ConfigurationSchema,
        filePath?: string,
        options?: {
            includeSecrets?: boolean;
            minify?: boolean;
            validate?: boolean;
        }
    ): Promise<{ success: boolean; filePath?: string; error?: string }> {
        try {
            const opts = {
                includeSecrets: false,
                minify: false,
                validate: true,
                ...options
            };

            // Validate configuration if requested
            if (opts.validate) {
                const validation = ConfigurationValidator.validate(configuration);
                if (!validation.isValid) {
                    return {
                        success: false,
                        error: `Configuration validation failed: ${validation.errors.map(e => e.message).join(', ')}`
                    };
                }
            }

            // Create export configuration
            const exportConfig = { ...configuration };
            
            // Remove secrets if not included
            if (!opts.includeSecrets) {
                this.removeSecrets(exportConfig);
            }

            // Update metadata
            exportConfig.metadata.updatedAt = new Date().toISOString();

            // Determine file path
            const exportPath = filePath || await this.getExportPath(configuration.metadata.name);
            
            // Write configuration
            const jsonContent = opts.minify 
                ? JSON.stringify(exportConfig)
                : JSON.stringify(exportConfig, null, 2);
                
            await fs.promises.writeFile(exportPath, jsonContent, 'utf8');

            return { success: true, filePath: exportPath };

        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * Import configuration from JSON file
     */
    async importConfiguration(
        filePath: string,
        options?: {
            validate?: boolean;
            backup?: boolean;
            merge?: boolean;
        }
    ): Promise<{ success: boolean; configuration?: ConfigurationSchema; error?: string; warnings?: string[] }> {
        try {
            const opts = {
                validate: true,
                backup: true,
                merge: false,
                ...options
            };

            // Read configuration file
            const fileContent = await fs.promises.readFile(filePath, 'utf8');
            const importedConfig = JSON.parse(fileContent) as ConfigurationSchema;

            // Validate configuration
            if (opts.validate) {
                const validation = ConfigurationValidator.validate(importedConfig);
                if (!validation.isValid) {
                    return {
                        success: false,
                        error: `Invalid configuration: ${validation.errors.map(e => e.message).join(', ')}`,
                        warnings: validation.warnings.map(w => w.message)
                    };
                }
            }

            // Create backup if requested
            if (opts.backup) {
                const currentConfig = await this.getCurrentConfiguration();
                if (currentConfig) {
                    await this.createBackup(currentConfig, 'manual', 'Pre-import backup');
                }
            }

            // Handle version migration if needed
            const migratedConfig = await this.migrateConfiguration(importedConfig);

            // Update metadata
            migratedConfig.metadata.updatedAt = new Date().toISOString();

            return { 
                success: true, 
                configuration: migratedConfig,
                warnings: opts.validate ? ConfigurationValidator.validate(migratedConfig).warnings.map(w => w.message) : []
            };

        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * Create configuration backup
     */
    async createBackup(
        configuration: ConfigurationSchema,
        reason: 'manual' | 'auto' | 'migration',
        description?: string
    ): Promise<{ success: boolean; backupId?: string; error?: string }> {
        try {
            const backupId = `backup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            const backup: ConfigurationBackup = {
                id: backupId,
                name: `${configuration.metadata.name} - ${new Date().toLocaleString()}`,
                timestamp: new Date().toISOString(),
                configuration: { ...configuration },
                metadata: {
                    reason,
                    description,
                    previousVersion: configuration.version
                }
            };

            const backupFilePath = path.join(this.backupPath, `${backupId}.json`);
            await fs.promises.writeFile(backupFilePath, JSON.stringify(backup, null, 2), 'utf8');

            // Clean up old backups (keep last 10)
            await this.cleanupOldBackups();

            return { success: true, backupId };

        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * Restore configuration from backup
     */
    async restoreBackup(backupId: string): Promise<{ success: boolean; configuration?: ConfigurationSchema; error?: string }> {
        try {
            const backupFilePath = path.join(this.backupPath, `${backupId}.json`);
            const backupContent = await fs.promises.readFile(backupFilePath, 'utf8');
            const backup = JSON.parse(backupContent) as ConfigurationBackup;

            // Validate restored configuration
            const validation = ConfigurationValidator.validate(backup.configuration);
            if (!validation.isValid) {
                return {
                    success: false,
                    error: `Backup contains invalid configuration: ${validation.errors.map(e => e.message).join(', ')}`
                };
            }

            // Update metadata
            backup.configuration.metadata.updatedAt = new Date().toISOString();

            return { success: true, configuration: backup.configuration };

        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * List available backups
     */
    async listBackups(): Promise<ConfigurationBackup[]> {
        try {
            const backupFiles = await fs.promises.readdir(this.backupPath);
            const backups: ConfigurationBackup[] = [];

            for (const file of backupFiles) {
                if (file.endsWith('.json')) {
                    try {
                        const filePath = path.join(this.backupPath, file);
                        const content = await fs.promises.readFile(filePath, 'utf8');
                        const backup = JSON.parse(content) as ConfigurationBackup;
                        backups.push(backup);
                    } catch (error) {
                        console.warn(`Failed to read backup file ${file}:`, error);
                    }
                }
            }

            // Sort by timestamp (newest first)
            return backups.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

        } catch (error) {
            console.error('Failed to list backups:', error);
            return [];
        }
    }

    /**
     * Save configuration template
     */
    async saveTemplate(
        configuration: ConfigurationSchema,
        templateInfo: {
            name: string;
            description: string;
            category: 'development' | 'production' | 'team' | 'custom';
            tags?: string[];
            author?: string;
        }
    ): Promise<{ success: boolean; templateId?: string; error?: string }> {
        try {
            const templateId = `template_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Remove secrets from template
            const templateConfig = { ...configuration };
            this.removeSecrets(templateConfig);

            const template: ConfigurationTemplate = {
                id: templateId,
                name: templateInfo.name,
                description: templateInfo.description,
                category: templateInfo.category,
                configuration: templateConfig,
                tags: templateInfo.tags || [],
                author: templateInfo.author,
                version: configuration.version
            };

            const templateFilePath = path.join(this.templatesPath, `${templateId}.json`);
            await fs.promises.writeFile(templateFilePath, JSON.stringify(template, null, 2), 'utf8');

            return { success: true, templateId };

        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * List available templates
     */
    async listTemplates(): Promise<ConfigurationTemplate[]> {
        try {
            const templateFiles = await fs.promises.readdir(this.templatesPath);
            const templates: ConfigurationTemplate[] = [];

            for (const file of templateFiles) {
                if (file.endsWith('.json')) {
                    try {
                        const filePath = path.join(this.templatesPath, file);
                        const content = await fs.promises.readFile(filePath, 'utf8');
                        const template = JSON.parse(content) as ConfigurationTemplate;
                        templates.push(template);
                    } catch (error) {
                        console.warn(`Failed to read template file ${file}:`, error);
                    }
                }
            }

            return templates.sort((a, b) => a.name.localeCompare(b.name));

        } catch (error) {
            console.error('Failed to list templates:', error);
            return [];
        }
    }

    /**
     * Load template by ID
     */
    async loadTemplate(templateId: string): Promise<{ success: boolean; template?: ConfigurationTemplate; error?: string }> {
        try {
            const templateFilePath = path.join(this.templatesPath, `${templateId}.json`);
            const content = await fs.promises.readFile(templateFilePath, 'utf8');
            const template = JSON.parse(content) as ConfigurationTemplate;

            return { success: true, template };

        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * Validate configuration
     */
    validateConfiguration(configuration: Partial<ConfigurationSchema>): ValidationResult {
        return ConfigurationValidator.validate(configuration);
    }

    /**
     * Create default configuration
     */
    createDefaultConfiguration(): ConfigurationSchema {
        return ConfigurationValidator.createDefault();
    }

    /**
     * Helper methods
     */
    private removeSecrets(config: ConfigurationSchema): void {
        // Remove API keys and other sensitive information
        if (config.database?.connection?.apiKey) {
            delete config.database.connection.apiKey;
        }
        if (config.embedding?.connection?.apiKey) {
            delete config.embedding.connection.apiKey;
        }
    }

    private async getExportPath(configName: string): Promise<string> {
        const sanitizedName = configName.replace(/[^a-zA-Z0-9-_]/g, '_');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `${sanitizedName}_${timestamp}.json`;
        
        // Use VS Code's file dialog if available
        const uri = await vscode.window.showSaveDialog({
            defaultUri: vscode.Uri.file(path.join(this.configurationPath, fileName)),
            filters: {
                'JSON Configuration': ['json']
            }
        });

        return uri ? uri.fsPath : path.join(this.configurationPath, fileName);
    }

    private async getCurrentConfiguration(): Promise<ConfigurationSchema | null> {
        // This would typically load from VS Code settings or a current config file
        // For now, return null as this would be implemented based on your current config storage
        return null;
    }

    private async migrateConfiguration(config: ConfigurationSchema): Promise<ConfigurationSchema> {
        // Check if migration is needed
        const currentVersion = ConfigurationValidator.createDefault().version;
        if (config.version === currentVersion) {
            return config;
        }

        // Apply migrations if available
        const migrationKey = `${config.version}->${currentVersion}`;
        const migration = this.migrations.get(migrationKey);
        
        if (migration) {
            console.log(`Migrating configuration from ${config.version} to ${currentVersion}`);
            return migration.migrate(config);
        }

        // If no migration available, return as-is with updated version
        return { ...config, version: currentVersion };
    }

    private async cleanupOldBackups(): Promise<void> {
        try {
            const backups = await this.listBackups();
            if (backups.length > 10) {
                const oldBackups = backups.slice(10);
                for (const backup of oldBackups) {
                    const backupFilePath = path.join(this.backupPath, `${backup.id}.json`);
                    await fs.promises.unlink(backupFilePath);
                }
            }
        } catch (error) {
            console.warn('Failed to cleanup old backups:', error);
        }
    }

    /**
     * Get configuration presets for common setups
     */
    getConfigurationPresets(): ConfigurationTemplate[] {
        return [
            {
                id: 'development-local',
                name: 'Development (Local)',
                description: 'Local development setup with Qdrant and Ollama',
                category: 'development',
                tags: ['local', 'development', 'qdrant', 'ollama'],
                version: '1.0.0',
                configuration: {
                    ...ConfigurationValidator.createDefault(),
                    metadata: {
                        name: 'Development Configuration',
                        description: 'Local development setup',
                        environment: 'development',
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    }
                }
            },
            {
                id: 'production-cloud',
                name: 'Production (Cloud)',
                description: 'Production setup with Pinecone and OpenAI',
                category: 'production',
                tags: ['cloud', 'production', 'pinecone', 'openai'],
                version: '1.0.0',
                configuration: {
                    ...ConfigurationValidator.createDefault(),
                    metadata: {
                        name: 'Production Configuration',
                        description: 'Cloud production setup',
                        environment: 'production',
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    },
                    database: {
                        provider: 'pinecone',
                        connection: {
                            apiKey: '', // To be filled by user
                            environment: '', // To be filled by user
                            timeout: 30000
                        },
                        collections: {
                            defaultCollection: 'code_context_prod',
                            collections: [{
                                name: 'code_context_prod',
                                vectorSize: 1536,
                                distance: 'cosine'
                            }]
                        },
                        advanced: {
                            batchSize: 100,
                            maxRetries: 3,
                            retryDelay: 1000
                        }
                    },
                    embedding: {
                        provider: 'openai',
                        connection: {
                            apiKey: '', // To be filled by user
                            timeout: 30000
                        },
                        model: {
                            name: 'text-embedding-3-small',
                            dimensions: 1536
                        },
                        advanced: {
                            batchSize: 10,
                            rateLimiting: {
                                requestsPerMinute: 3000,
                                tokensPerMinute: 1000000
                            }
                        }
                    }
                }
            },
            {
                id: 'team-hybrid',
                name: 'Team (Hybrid)',
                description: 'Team setup with ChromaDB and flexible embedding',
                category: 'team',
                tags: ['team', 'hybrid', 'chromadb', 'flexible'],
                version: '1.0.0',
                configuration: {
                    ...ConfigurationValidator.createDefault(),
                    metadata: {
                        name: 'Team Configuration',
                        description: 'Team collaboration setup',
                        environment: 'staging',
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    },
                    database: {
                        provider: 'chromadb',
                        connection: {
                            url: 'http://localhost:8000',
                            timeout: 30000
                        },
                        collections: {
                            defaultCollection: 'team_context',
                            collections: [{
                                name: 'team_context',
                                vectorSize: 384,
                                distance: 'cosine'
                            }]
                        },
                        advanced: {
                            batchSize: 50,
                            maxRetries: 3,
                            retryDelay: 1000
                        }
                    },
                    indexing: {
                        patterns: {
                            include: ['**/*.ts', '**/*.js', '**/*.py', '**/*.java', '**/*.md'],
                            exclude: ['**/node_modules/**', '**/dist/**', '**/build/**', '**/.git/**'],
                            fileTypes: ['typescript', 'javascript', 'python', 'java', 'markdown'],
                            maxFileSize: 2097152 // 2MB
                        },
                        processing: {
                            chunkSize: 1500,
                            chunkOverlap: 300,
                            batchSize: 25,
                            parallelism: 2
                        },
                        scheduling: {
                            autoIndex: true,
                            watchFiles: true,
                            incrementalUpdates: true
                        },
                        advanced: {
                            languageDetection: true,
                            codeAnalysis: true,
                            semanticChunking: true,
                            metadataExtraction: ['language', 'functions', 'classes', 'imports', 'comments']
                        }
                    }
                }
            }
        ];
    }

    /**
     * Apply a configuration preset
     */
    async applyPreset(presetId: string): Promise<{ success: boolean; configuration?: ConfigurationSchema; error?: string }> {
        try {
            const presets = this.getConfigurationPresets();
            const preset = presets.find(p => p.id === presetId);

            if (!preset) {
                return {
                    success: false,
                    error: `Configuration preset not found: ${presetId}`
                };
            }

            // Create backup before applying preset
            const currentConfig = await this.getCurrentConfiguration();
            if (currentConfig) {
                await this.createBackup(currentConfig, 'auto', `Pre-preset application: ${preset.name}`);
            }

            // Update metadata
            const configuration = {
                ...preset.configuration,
                metadata: {
                    ...preset.configuration.metadata,
                    updatedAt: new Date().toISOString()
                }
            };

            return { success: true, configuration };

        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }
}
</file>

<file path="src/configuration/configurationSchema.ts">
/**
 * Configuration Schema and Validation
 * 
 * This module defines the complete configuration schema for the Code Context Engine,
 * including validation rules, type definitions, and schema versioning for migrations.
 */

export interface ConfigurationSchema {
    version: string;
    metadata: ConfigurationMetadata;
    database: DatabaseConfiguration;
    embedding: EmbeddingConfiguration;
    indexing: IndexingConfiguration;
    search: SearchConfiguration;
    performance: PerformanceConfiguration;
    security: SecurityConfiguration;
}

export interface ConfigurationMetadata {
    name: string;
    description?: string;
    environment: 'development' | 'staging' | 'production' | 'custom';
    createdAt: string;
    updatedAt: string;
    createdBy?: string;
    tags?: string[];
    workspace?: string;
}

export interface DatabaseConfiguration {
    provider: 'qdrant' | 'chromadb' | 'pinecone';
    connection: {
        url?: string;
        apiKey?: string;
        environment?: string;
        index?: string;
        namespace?: string;
        port?: number;
        timeout?: number;
    };
    collections: {
        defaultCollection: string;
        collections: Array<{
            name: string;
            vectorSize: number;
            distance: 'cosine' | 'euclidean' | 'dot';
            metadata?: Record<string, any>;
        }>;
    };
    advanced: {
        batchSize?: number;
        maxRetries?: number;
        retryDelay?: number;
        compression?: boolean;
        replication?: {
            enabled: boolean;
            factor: number;
        };
    };
}

export interface EmbeddingConfiguration {
    provider: 'ollama' | 'openai';
    connection: {
        url?: string;
        apiKey?: string;
        organization?: string;
        timeout?: number;
        maxRetries?: number;
    };
    model: {
        name: string;
        dimensions: number;
        maxTokens?: number;
        parameters?: Record<string, any>;
    };
    advanced: {
        batchSize?: number;
        rateLimiting?: {
            requestsPerMinute: number;
            tokensPerMinute: number;
        };
        caching?: {
            enabled: boolean;
            ttl: number;
            maxSize: number;
        };
    };
}

export interface IndexingConfiguration {
    patterns: {
        include: string[];
        exclude: string[];
        fileTypes: string[];
        maxFileSize: number;
    };
    processing: {
        chunkSize: number;
        chunkOverlap: number;
        batchSize: number;
        parallelism: number;
    };
    scheduling: {
        autoIndex: boolean;
        watchFiles: boolean;
        indexInterval?: number;
        incrementalUpdates: boolean;
    };
    advanced: {
        languageDetection: boolean;
        codeAnalysis: boolean;
        semanticChunking: boolean;
        metadataExtraction: string[];
    };
}

export interface SearchConfiguration {
    defaults: {
        maxResults: number;
        minSimilarity: number;
        includeMetadata: boolean;
        includeContent: boolean;
    };
    ranking: {
        algorithm: 'similarity' | 'hybrid' | 'semantic';
        weights: {
            similarity: number;
            recency: number;
            relevance: number;
            popularity: number;
        };
    };
    filters: {
        enabledFilters: string[];
        defaultFilters: Record<string, any>;
    };
    advanced: {
        queryExpansion: boolean;
        semanticSearch: boolean;
        fuzzyMatching: boolean;
        contextWindow: number;
    };
}

export interface PerformanceConfiguration {
    memory: {
        maxHeapSize?: string;
        cacheSize: number;
        gcStrategy?: 'default' | 'aggressive' | 'conservative';
    };
    concurrency: {
        maxConcurrentRequests: number;
        queueSize: number;
        workerThreads: number;
    };
    optimization: {
        enableProfiling: boolean;
        metricsCollection: boolean;
        performanceLogging: boolean;
        autoTuning: boolean;
    };
}

export interface SecurityConfiguration {
    encryption: {
        enabled: boolean;
        algorithm?: string;
        keyRotation?: {
            enabled: boolean;
            interval: number;
        };
    };
    access: {
        authentication: boolean;
        authorization: boolean;
        allowedOrigins?: string[];
        rateLimiting: {
            enabled: boolean;
            requestsPerMinute: number;
        };
    };
    audit: {
        enabled: boolean;
        logLevel: 'error' | 'warn' | 'info' | 'debug';
        retentionDays: number;
    };
}

export interface ValidationResult {
    isValid: boolean;
    errors: ValidationError[];
    warnings: ValidationWarning[];
}

export interface ValidationError {
    path: string;
    message: string;
    code: string;
    severity: 'error' | 'warning';
}

export interface ValidationWarning {
    path: string;
    message: string;
    suggestion?: string;
}

export class ConfigurationValidator {
    private static readonly CURRENT_VERSION = '1.0.0';
    private static readonly SUPPORTED_VERSIONS = ['1.0.0'];

    /**
     * Validate a complete configuration object
     */
    static validate(config: Partial<ConfigurationSchema>): ValidationResult {
        const errors: ValidationError[] = [];
        const warnings: ValidationWarning[] = [];

        // Version validation
        if (!config.version) {
            errors.push({
                path: 'version',
                message: 'Configuration version is required',
                code: 'MISSING_VERSION',
                severity: 'error'
            });
        } else if (!this.SUPPORTED_VERSIONS.includes(config.version)) {
            errors.push({
                path: 'version',
                message: `Unsupported configuration version: ${config.version}`,
                code: 'UNSUPPORTED_VERSION',
                severity: 'error'
            });
        }

        // Metadata validation
        if (config.metadata) {
            this.validateMetadata(config.metadata, errors, warnings);
        } else {
            errors.push({
                path: 'metadata',
                message: 'Configuration metadata is required',
                code: 'MISSING_METADATA',
                severity: 'error'
            });
        }

        // Database validation
        if (config.database) {
            this.validateDatabase(config.database, errors, warnings);
        } else {
            errors.push({
                path: 'database',
                message: 'Database configuration is required',
                code: 'MISSING_DATABASE',
                severity: 'error'
            });
        }

        // Embedding validation
        if (config.embedding) {
            this.validateEmbedding(config.embedding, errors, warnings);
        } else {
            errors.push({
                path: 'embedding',
                message: 'Embedding configuration is required',
                code: 'MISSING_EMBEDDING',
                severity: 'error'
            });
        }

        // Optional section validation
        if (config.indexing) {
            this.validateIndexing(config.indexing, errors, warnings);
        }

        if (config.search) {
            this.validateSearch(config.search, errors, warnings);
        }

        if (config.performance) {
            this.validatePerformance(config.performance, errors, warnings);
        }

        if (config.security) {
            this.validateSecurity(config.security, errors, warnings);
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }

    private static validateMetadata(
        metadata: ConfigurationMetadata,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (!metadata.name || metadata.name.trim().length === 0) {
            errors.push({
                path: 'metadata.name',
                message: 'Configuration name is required',
                code: 'MISSING_NAME',
                severity: 'error'
            });
        }

        if (!metadata.environment) {
            warnings.push({
                path: 'metadata.environment',
                message: 'Environment not specified, defaulting to development',
                suggestion: 'Specify environment for better configuration management'
            });
        }

        if (!metadata.createdAt) {
            warnings.push({
                path: 'metadata.createdAt',
                message: 'Creation timestamp missing',
                suggestion: 'Add timestamp for better version tracking'
            });
        }
    }

    private static validateDatabase(
        database: DatabaseConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (!database.provider) {
            errors.push({
                path: 'database.provider',
                message: 'Database provider is required',
                code: 'MISSING_PROVIDER',
                severity: 'error'
            });
        }

        // Provider-specific validation
        switch (database.provider) {
            case 'qdrant':
                this.validateQdrantConfig(database, errors, warnings);
                break;
            case 'chromadb':
                this.validateChromaDBConfig(database, errors, warnings);
                break;
            case 'pinecone':
                this.validatePineconeConfig(database, errors, warnings);
                break;
        }

        // Collections validation
        if (!database.collections?.defaultCollection) {
            errors.push({
                path: 'database.collections.defaultCollection',
                message: 'Default collection name is required',
                code: 'MISSING_DEFAULT_COLLECTION',
                severity: 'error'
            });
        }
    }

    private static validateEmbedding(
        embedding: EmbeddingConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (!embedding.provider) {
            errors.push({
                path: 'embedding.provider',
                message: 'Embedding provider is required',
                code: 'MISSING_PROVIDER',
                severity: 'error'
            });
        }

        if (!embedding.model?.name) {
            errors.push({
                path: 'embedding.model.name',
                message: 'Embedding model name is required',
                code: 'MISSING_MODEL',
                severity: 'error'
            });
        }

        if (!embedding.model?.dimensions || embedding.model.dimensions <= 0) {
            errors.push({
                path: 'embedding.model.dimensions',
                message: 'Valid embedding dimensions are required',
                code: 'INVALID_DIMENSIONS',
                severity: 'error'
            });
        }

        // Provider-specific validation
        switch (embedding.provider) {
            case 'openai':
                if (!embedding.connection?.apiKey) {
                    errors.push({
                        path: 'embedding.connection.apiKey',
                        message: 'OpenAI API key is required',
                        code: 'MISSING_API_KEY',
                        severity: 'error'
                    });
                }
                break;
            case 'ollama':
                if (!embedding.connection?.url) {
                    warnings.push({
                        path: 'embedding.connection.url',
                        message: 'Ollama URL not specified, using default',
                        suggestion: 'Specify custom URL if not using default localhost:11434'
                    });
                }
                break;
        }
    }

    private static validateQdrantConfig(
        database: DatabaseConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (!database.connection?.url) {
            warnings.push({
                path: 'database.connection.url',
                message: 'Qdrant URL not specified, using default',
                suggestion: 'Specify custom URL if not using default localhost:6333'
            });
        }
    }

    private static validateChromaDBConfig(
        database: DatabaseConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (!database.connection?.url) {
            warnings.push({
                path: 'database.connection.url',
                message: 'ChromaDB URL not specified, using default',
                suggestion: 'Specify custom URL if not using default localhost:8000'
            });
        }
    }

    private static validatePineconeConfig(
        database: DatabaseConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (!database.connection?.apiKey) {
            errors.push({
                path: 'database.connection.apiKey',
                message: 'Pinecone API key is required',
                code: 'MISSING_API_KEY',
                severity: 'error'
            });
        }

        if (!database.connection?.environment) {
            errors.push({
                path: 'database.connection.environment',
                message: 'Pinecone environment is required',
                code: 'MISSING_ENVIRONMENT',
                severity: 'error'
            });
        }
    }

    private static validateIndexing(
        indexing: IndexingConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (indexing.processing?.chunkSize && indexing.processing.chunkSize <= 0) {
            errors.push({
                path: 'indexing.processing.chunkSize',
                message: 'Chunk size must be positive',
                code: 'INVALID_CHUNK_SIZE',
                severity: 'error'
            });
        }

        if (indexing.processing?.parallelism && indexing.processing.parallelism <= 0) {
            errors.push({
                path: 'indexing.processing.parallelism',
                message: 'Parallelism must be positive',
                code: 'INVALID_PARALLELISM',
                severity: 'error'
            });
        }
    }

    private static validateSearch(
        search: SearchConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (search.defaults?.maxResults && search.defaults.maxResults <= 0) {
            errors.push({
                path: 'search.defaults.maxResults',
                message: 'Max results must be positive',
                code: 'INVALID_MAX_RESULTS',
                severity: 'error'
            });
        }

        if (search.defaults?.minSimilarity && 
            (search.defaults.minSimilarity < 0 || search.defaults.minSimilarity > 1)) {
            errors.push({
                path: 'search.defaults.minSimilarity',
                message: 'Min similarity must be between 0 and 1',
                code: 'INVALID_MIN_SIMILARITY',
                severity: 'error'
            });
        }
    }

    private static validatePerformance(
        performance: PerformanceConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (performance.concurrency?.maxConcurrentRequests && 
            performance.concurrency.maxConcurrentRequests <= 0) {
            errors.push({
                path: 'performance.concurrency.maxConcurrentRequests',
                message: 'Max concurrent requests must be positive',
                code: 'INVALID_CONCURRENCY',
                severity: 'error'
            });
        }
    }

    private static validateSecurity(
        security: SecurityConfiguration,
        errors: ValidationError[],
        warnings: ValidationWarning[]
    ): void {
        if (security.access?.rateLimiting?.requestsPerMinute && 
            security.access.rateLimiting.requestsPerMinute <= 0) {
            errors.push({
                path: 'security.access.rateLimiting.requestsPerMinute',
                message: 'Rate limiting requests per minute must be positive',
                code: 'INVALID_RATE_LIMIT',
                severity: 'error'
            });
        }
    }

    /**
     * Create a default configuration
     */
    static createDefault(): ConfigurationSchema {
        return {
            version: this.CURRENT_VERSION,
            metadata: {
                name: 'Default Configuration',
                description: 'Default Code Context Engine configuration',
                environment: 'development',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            },
            database: {
                provider: 'qdrant',
                connection: {
                    url: 'http://localhost:6333',
                    timeout: 30000
                },
                collections: {
                    defaultCollection: 'code_context',
                    collections: [{
                        name: 'code_context',
                        vectorSize: 384,
                        distance: 'cosine'
                    }]
                },
                advanced: {
                    batchSize: 100,
                    maxRetries: 3,
                    retryDelay: 1000
                }
            },
            embedding: {
                provider: 'ollama',
                connection: {
                    url: 'http://localhost:11434',
                    timeout: 30000
                },
                model: {
                    name: 'nomic-embed-text',
                    dimensions: 384
                },
                advanced: {
                    batchSize: 10
                }
            },
            indexing: {
                patterns: {
                    include: ['**/*.ts', '**/*.js', '**/*.py', '**/*.java', '**/*.cpp', '**/*.c', '**/*.h'],
                    exclude: ['**/node_modules/**', '**/dist/**', '**/build/**', '**/.git/**'],
                    fileTypes: ['typescript', 'javascript', 'python', 'java', 'cpp', 'c'],
                    maxFileSize: 1048576 // 1MB
                },
                processing: {
                    chunkSize: 1000,
                    chunkOverlap: 200,
                    batchSize: 50,
                    parallelism: 4
                },
                scheduling: {
                    autoIndex: true,
                    watchFiles: true,
                    incrementalUpdates: true
                },
                advanced: {
                    languageDetection: true,
                    codeAnalysis: true,
                    semanticChunking: false,
                    metadataExtraction: ['language', 'functions', 'classes', 'imports']
                }
            },
            search: {
                defaults: {
                    maxResults: 20,
                    minSimilarity: 0.7,
                    includeMetadata: true,
                    includeContent: true
                },
                ranking: {
                    algorithm: 'similarity',
                    weights: {
                        similarity: 0.7,
                        recency: 0.1,
                        relevance: 0.15,
                        popularity: 0.05
                    }
                },
                filters: {
                    enabledFilters: ['fileType', 'language', 'dateRange'],
                    defaultFilters: {}
                },
                advanced: {
                    queryExpansion: false,
                    semanticSearch: true,
                    fuzzyMatching: true,
                    contextWindow: 5
                }
            },
            performance: {
                memory: {
                    cacheSize: 100,
                    gcStrategy: 'default'
                },
                concurrency: {
                    maxConcurrentRequests: 10,
                    queueSize: 100,
                    workerThreads: 4
                },
                optimization: {
                    enableProfiling: false,
                    metricsCollection: true,
                    performanceLogging: false,
                    autoTuning: false
                }
            },
            security: {
                encryption: {
                    enabled: false
                },
                access: {
                    authentication: false,
                    authorization: false,
                    rateLimiting: {
                        enabled: false,
                        requestsPerMinute: 100
                    }
                },
                audit: {
                    enabled: false,
                    logLevel: 'info',
                    retentionDays: 30
                }
            }
        };
    }
}
</file>

<file path="src/lsp/lspService.ts">
/**
 * Language Server Protocol (LSP) Service
 * 
 * This service provides integration with VS Code's language servers to enrich
 * code chunks with semantic information like definitions, references, symbols,
 * and type information. It leverages the existing language servers that VS Code
 * uses for features like Go to Definition, Find References, etc.
 */

import * as vscode from 'vscode';
import { SupportedLanguage } from '../parsing/astParser';

/**
 * Represents a symbol definition from the LSP
 */
export interface LSPDefinition {
    /** The URI of the file containing the definition */
    uri: string;
    /** The range of the definition in the file */
    range: vscode.Range;
    /** The name of the symbol */
    name: string;
    /** The kind of symbol (function, class, variable, etc.) */
    kind: vscode.SymbolKind;
    /** Additional detail about the symbol */
    detail?: string;
}

/**
 * Represents a reference to a symbol from the LSP
 */
export interface LSPReference {
    /** The URI of the file containing the reference */
    uri: string;
    /** The range of the reference in the file */
    range: vscode.Range;
    /** Whether this is a definition or just a reference */
    isDefinition: boolean;
}

/**
 * Represents a symbol from the LSP
 */
export interface LSPSymbol {
    /** The name of the symbol */
    name: string;
    /** The kind of symbol */
    kind: vscode.SymbolKind;
    /** The range of the symbol */
    range: vscode.Range;
    /** The selection range (typically the name) */
    selectionRange: vscode.Range;
    /** Additional detail about the symbol */
    detail?: string;
    /** Child symbols (for classes, namespaces, etc.) */
    children?: LSPSymbol[];
}

/**
 * Represents hover information from the LSP
 */
export interface LSPHoverInfo {
    /** The hover content as markdown */
    contents: vscode.MarkdownString[];
    /** The range the hover applies to */
    range?: vscode.Range;
}

/**
 * LSP metadata that can be attached to code chunks
 */
export interface LSPMetadata {
    /** Symbols defined in this chunk */
    definitions: LSPDefinition[];
    /** References to other symbols from this chunk */
    references: LSPReference[];
    /** All symbols in this chunk */
    symbols: LSPSymbol[];
    /** Hover information for key symbols */
    hoverInfo: Record<string, LSPHoverInfo>;
    /** The language this metadata applies to */
    language: SupportedLanguage;
    /** Whether LSP data was successfully retrieved */
    hasLSPData: boolean;
}

/**
 * Service for interacting with VS Code's Language Server Protocol
 */
export class LSPService {
    private workspaceRoot: string;

    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
    }

    /**
     * Get LSP metadata for a code chunk
     * 
     * @param filePath - The path to the file
     * @param content - The content of the code chunk
     * @param startLine - The starting line of the chunk
     * @param endLine - The ending line of the chunk
     * @param language - The programming language
     * @returns Promise resolving to LSP metadata
     */
    async getMetadataForChunk(
        filePath: string,
        content: string,
        startLine: number,
        endLine: number,
        language: SupportedLanguage
    ): Promise<LSPMetadata> {
        try {
            const uri = vscode.Uri.file(filePath);
            const document = await vscode.workspace.openTextDocument(uri);
            
            // Create range for the chunk
            const range = new vscode.Range(
                new vscode.Position(startLine, 0),
                new vscode.Position(endLine, Number.MAX_SAFE_INTEGER)
            );

            // Get symbols in the document
            const symbols = await this.getDocumentSymbols(document);
            const chunkSymbols = this.filterSymbolsInRange(symbols, range);

            // Get definitions and references for symbols in the chunk
            const definitions: LSPDefinition[] = [];
            const references: LSPReference[] = [];
            const hoverInfo: Record<string, LSPHoverInfo> = {};

            for (const symbol of chunkSymbols) {
                // Get definition information
                const symbolDefinitions = await this.getDefinitions(document, symbol.selectionRange.start);
                definitions.push(...symbolDefinitions);

                // Get references
                const symbolReferences = await this.getReferences(document, symbol.selectionRange.start);
                references.push(...symbolReferences);

                // Get hover information
                const hover = await this.getHoverInfo(document, symbol.selectionRange.start);
                if (hover) {
                    hoverInfo[symbol.name] = hover;
                }
            }

            return {
                definitions,
                references,
                symbols: chunkSymbols,
                hoverInfo,
                language,
                hasLSPData: true
            };
        } catch (error) {
            console.warn(`Failed to get LSP metadata for ${filePath}:`, error);
            return {
                definitions: [],
                references: [],
                symbols: [],
                hoverInfo: {},
                language,
                hasLSPData: false
            };
        }
    }

    /**
     * Get document symbols from the LSP
     */
    private async getDocumentSymbols(document: vscode.TextDocument): Promise<LSPSymbol[]> {
        try {
            const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
                'vscode.executeDocumentSymbolProvider',
                document.uri
            );

            return symbols ? this.convertDocumentSymbols(symbols) : [];
        } catch (error) {
            console.warn('Failed to get document symbols:', error);
            return [];
        }
    }

    /**
     * Convert VS Code DocumentSymbol to our LSPSymbol format
     */
    private convertDocumentSymbols(symbols: vscode.DocumentSymbol[]): LSPSymbol[] {
        return symbols.map(symbol => ({
            name: symbol.name,
            kind: symbol.kind,
            range: symbol.range,
            selectionRange: symbol.selectionRange,
            detail: symbol.detail,
            children: symbol.children ? this.convertDocumentSymbols(symbol.children) : undefined
        }));
    }

    /**
     * Filter symbols that are within the specified range
     */
    private filterSymbolsInRange(symbols: LSPSymbol[], range: vscode.Range): LSPSymbol[] {
        const result: LSPSymbol[] = [];

        for (const symbol of symbols) {
            if (range.intersection(symbol.range)) {
                const filteredSymbol: LSPSymbol = {
                    ...symbol,
                    children: symbol.children ? this.filterSymbolsInRange(symbol.children, range) : undefined
                };
                result.push(filteredSymbol);
            }
        }

        return result;
    }

    /**
     * Get definitions for a symbol at a specific position
     */
    private async getDefinitions(document: vscode.TextDocument, position: vscode.Position): Promise<LSPDefinition[]> {
        try {
            const locations = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeDefinitionProvider',
                document.uri,
                position
            );

            if (!locations) return [];

            return locations.map(location => ({
                uri: location.uri.toString(),
                range: location.range,
                name: '', // Will be filled by caller
                kind: vscode.SymbolKind.Null, // Will be determined by caller
                detail: undefined
            }));
        } catch (error) {
            console.warn('Failed to get definitions:', error);
            return [];
        }
    }

    /**
     * Get references for a symbol at a specific position
     */
    private async getReferences(document: vscode.TextDocument, position: vscode.Position): Promise<LSPReference[]> {
        try {
            const locations = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeReferenceProvider',
                document.uri,
                position
            );

            if (!locations) return [];

            return locations.map(location => ({
                uri: location.uri.toString(),
                range: location.range,
                isDefinition: false // This would need more sophisticated logic to determine
            }));
        } catch (error) {
            console.warn('Failed to get references:', error);
            return [];
        }
    }

    /**
     * Get hover information for a symbol at a specific position
     */
    private async getHoverInfo(document: vscode.TextDocument, position: vscode.Position): Promise<LSPHoverInfo | null> {
        try {
            const hover = await vscode.commands.executeCommand<vscode.Hover>(
                'vscode.executeHoverProvider',
                document.uri,
                position
            );

            if (!hover) return null;

            return {
                contents: hover.contents as vscode.MarkdownString[],
                range: hover.range
            };
        } catch (error) {
            console.warn('Failed to get hover info:', error);
            return null;
        }
    }

    /**
     * Check if LSP is available for a given language
     */
    async isLSPAvailable(language: SupportedLanguage): Promise<boolean> {
        try {
            // Create a temporary document to test LSP availability
            const tempContent = this.getTestContent(language);
            const tempDoc = await vscode.workspace.openTextDocument({
                content: tempContent,
                language: this.getVSCodeLanguageId(language)
            });

            // Try to get symbols - if this works, LSP is available
            const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
                'vscode.executeDocumentSymbolProvider',
                tempDoc.uri
            );

            return symbols !== undefined;
        } catch (error) {
            console.warn(`LSP not available for ${language}:`, error);
            return false;
        }
    }

    /**
     * Get test content for checking LSP availability
     */
    private getTestContent(language: SupportedLanguage): string {
        switch (language) {
            case 'typescript':
                return 'function test() { return "hello"; }';
            case 'javascript':
                return 'function test() { return "hello"; }';
            case 'python':
                return 'def test():\n    return "hello"';
            case 'csharp':
                return 'public class Test { public string Method() { return "hello"; } }';
            default:
                return '';
        }
    }

    /**
     * Convert our language enum to VS Code language identifiers
     */
    private getVSCodeLanguageId(language: SupportedLanguage): string {
        switch (language) {
            case 'typescript':
                return 'typescript';
            case 'javascript':
                return 'javascript';
            case 'python':
                return 'python';
            case 'csharp':
                return 'csharp';
            default:
                return 'plaintext';
        }
    }
}
</file>

<file path="src/test/suite/configService.test.ts">
import * as assert from 'assert';
import * as vscode from 'vscode';
import { ConfigService } from '../../configService';

/**
 * Test suite for ConfigService
 *
 * These tests verify that the ConfigService correctly reads and provides
 * configuration values from VS Code settings.
 */
suite('ConfigService Tests', () => {
    let configService: ConfigService;

    setup(() => {
        configService = new ConfigService();
    });

    test('should provide default Qdrant connection string', () => {
        const connectionString = configService.getQdrantConnectionString();
        assert.strictEqual(typeof connectionString, 'string');
        assert.ok(connectionString.length > 0);
    });

    test('should provide database configuration', () => {
        const dbConfig = configService.getDatabaseConfig();
        assert.strictEqual(dbConfig.type, 'qdrant');
        assert.strictEqual(typeof dbConfig.connectionString, 'string');
    });

    test('should provide embedding provider type', () => {
        const provider = configService.getEmbeddingProvider();
        assert.ok(provider === 'ollama' || provider === 'openai');
    });

    test('should provide Ollama configuration', () => {
        const ollamaConfig = configService.getOllamaConfig();
        assert.strictEqual(typeof ollamaConfig.apiUrl, 'string');
        assert.strictEqual(typeof ollamaConfig.model, 'string');
        assert.strictEqual(typeof ollamaConfig.timeout, 'number');
        assert.strictEqual(typeof ollamaConfig.maxBatchSize, 'number');
    });

    test('should provide OpenAI configuration', () => {
        const openaiConfig = configService.getOpenAIConfig();
        assert.strictEqual(typeof openaiConfig.apiKey, 'string');
        assert.strictEqual(typeof openaiConfig.model, 'string');
        assert.strictEqual(typeof openaiConfig.timeout, 'number');
        assert.strictEqual(typeof openaiConfig.maxBatchSize, 'number');
    });

    test('should provide indexing configuration', () => {
        const indexingConfig = configService.getIndexingConfig();
        assert.ok(Array.isArray(indexingConfig.excludePatterns));
        assert.ok(Array.isArray(indexingConfig.supportedLanguages));
        assert.strictEqual(typeof indexingConfig.maxFileSize, 'number');
        assert.strictEqual(typeof indexingConfig.chunkSize, 'number');
        assert.strictEqual(typeof indexingConfig.chunkOverlap, 'number');
    });

    test('should provide full configuration', () => {
        const fullConfig = configService.getFullConfig();
        assert.ok(fullConfig.database);
        assert.ok(fullConfig.embeddingProvider);
        assert.ok(fullConfig.ollama);
        assert.ok(fullConfig.openai);
        assert.ok(fullConfig.indexing);
    });

    test('should check provider configuration status', () => {
        const ollamaConfigured = configService.isProviderConfigured('ollama');
        const openaiConfigured = configService.isProviderConfigured('openai');
        
        assert.strictEqual(typeof ollamaConfigured, 'boolean');
        assert.strictEqual(typeof openaiConfigured, 'boolean');
    });

    test('should get current provider configuration', () => {
        const currentConfig = configService.getCurrentProviderConfig();
        assert.ok(currentConfig);
        
        // Should have either Ollama or OpenAI properties
        const hasOllamaProps = 'apiUrl' in currentConfig;
        const hasOpenAIProps = 'apiKey' in currentConfig;
        assert.ok(hasOllamaProps || hasOpenAIProps);
    });

    test('should refresh configuration', () => {
        // This test verifies that refresh doesn't throw an error
        assert.doesNotThrow(() => {
            configService.refresh();
        });
    });
});
</file>

<file path="src/test/suite/dependencyInjection.test.ts">
import * as assert from 'assert';
import { ConfigService } from '../../configService';
import { QdrantService } from '../../db/qdrantService';
import { ContextService } from '../../context/contextService';
import { IndexingService } from '../../indexing/indexingService';
import { StateManager } from '../../stateManager';
import {
    MockQdrantService,
    MockEmbeddingProvider,
    MockFileWalker,
    MockAstParser,
    MockChunker,
    MockLspService
} from '../mocks';

/**
 * Test suite for Dependency Injection
 * 
 * These tests verify that our services can be properly instantiated with
 * injected dependencies and that they work correctly in isolation.
 */
suite('Dependency Injection Tests', () => {
    let configService: ConfigService;
    let mockQdrantService: MockQdrantService;
    let mockEmbeddingProvider: MockEmbeddingProvider;

    setup(() => {
        configService = new ConfigService();
        mockQdrantService = new MockQdrantService();
        mockEmbeddingProvider = new MockEmbeddingProvider();
    });

    test('should create QdrantService with injected connection string', () => {
        const connectionString = 'http://test:6333';
        const qdrantService = new QdrantService(connectionString);
        
        assert.ok(qdrantService);
        // QdrantService should be created without throwing
    });

    test('should create ContextService with injected dependencies', () => {
        const workspaceRoot = '/test/workspace';
        const mockFileWalker = new MockFileWalker(workspaceRoot);
        const mockAstParser = new MockAstParser();
        const mockChunker = new MockChunker();
        const mockLspService = new MockLspService(workspaceRoot);
        
        const mockStateManager = new StateManager();
        const mockIndexingService = new IndexingService(
            workspaceRoot,
            mockFileWalker as any,
            mockAstParser as any,
            mockChunker as any,
            mockQdrantService as any,
            mockEmbeddingProvider,
            mockLspService as any,
            mockStateManager
        );

        const contextService = new ContextService(
            workspaceRoot,
            mockQdrantService as any,
            mockEmbeddingProvider,
            mockIndexingService
        );

        assert.ok(contextService);
        // ContextService should be created without throwing
    });

    test('should create IndexingService with all injected dependencies', () => {
        const workspaceRoot = '/test/workspace';
        const mockFileWalker = new MockFileWalker(workspaceRoot);
        const mockAstParser = new MockAstParser();
        const mockChunker = new MockChunker();
        const mockLspService = new MockLspService(workspaceRoot);

        const mockStateManager = new StateManager();
        const indexingService = new IndexingService(
            workspaceRoot,
            mockFileWalker as any,
            mockAstParser as any,
            mockChunker as any,
            mockQdrantService as any,
            mockEmbeddingProvider,
            mockLspService as any,
            mockStateManager
        );

        assert.ok(indexingService);
        // IndexingService should be created without throwing
    });

    test('should allow mocking of QdrantService behavior', async () => {
        // Test that we can control mock behavior
        mockQdrantService.setHealthy(false);
        const isHealthy = await mockQdrantService.healthCheck();
        assert.strictEqual(isHealthy, false);

        mockQdrantService.setHealthy(true);
        const isHealthyNow = await mockQdrantService.healthCheck();
        assert.strictEqual(isHealthyNow, true);
    });

    test('should allow mocking of EmbeddingProvider behavior', async () => {
        // Test that we can control mock behavior
        mockEmbeddingProvider.setAvailable(false);
        const isAvailable = await mockEmbeddingProvider.isAvailable();
        assert.strictEqual(isAvailable, false);

        mockEmbeddingProvider.setAvailable(true);
        const isAvailableNow = await mockEmbeddingProvider.isAvailable();
        assert.strictEqual(isAvailableNow, true);
    });

    test('should generate mock embeddings', async () => {
        const chunks = ['test chunk 1', 'test chunk 2'];
        const embeddings = await mockEmbeddingProvider.generateEmbeddings(chunks);
        
        assert.strictEqual(embeddings.length, 2);
        assert.strictEqual(embeddings[0].length, mockEmbeddingProvider.getDimensions());
        assert.strictEqual(embeddings[1].length, mockEmbeddingProvider.getDimensions());
    });

    test('should allow configuration of mock dimensions', () => {
        const newDimensions = 1024;
        mockEmbeddingProvider.setDimensions(newDimensions);
        assert.strictEqual(mockEmbeddingProvider.getDimensions(), newDimensions);
    });

    test('should allow configuration of mock provider name', () => {
        const newName = 'test-provider';
        mockEmbeddingProvider.setProviderName(newName);
        assert.strictEqual(mockEmbeddingProvider.getProviderName(), newName);
    });

    test('should support mock file operations', async () => {
        const mockFileWalker = new MockFileWalker('/test');
        const testFiles = ['file1.ts', 'file2.js', 'file3.py'];
        
        mockFileWalker.setMockFiles(testFiles);
        const files = await mockFileWalker.getFiles();
        
        assert.deepStrictEqual(files, testFiles);
    });

    test('should support mock chunking operations', () => {
        const mockChunker = new MockChunker();
        const testContent = 'function test() { return "hello"; }';
        
        const chunks = mockChunker.chunkCode(testContent, 'test.ts', 'typescript');
        
        assert.ok(Array.isArray(chunks));
        assert.ok(chunks.length > 0);
        assert.strictEqual(chunks[0].filePath, 'test.ts');
        assert.strictEqual(chunks[0].language, 'typescript');
    });
});
</file>

<file path="src/test/suite/index.ts">
import * as path from 'path';
import { glob } from 'glob';

export function run(): Promise<void> {
    // Create the mocha test
    const Mocha = require('mocha');
    const mocha = new Mocha({
        ui: 'tdd',
        color: true
    });

    const testsRoot = path.resolve(__dirname, '..');

    return new Promise((c, e) => {
        glob('**/**.test.js', { cwd: testsRoot }, (err: Error | null, files: string[]) => {
            if (err) {
                return e(err);
            }

            // Add files to the test suite
            files.forEach((f: string) => mocha.addFile(path.resolve(testsRoot, f)));

            try {
                // Run the mocha test
                mocha.run((failures: number) => {
                    if (failures > 0) {
                        e(new Error(`${failures} tests failed.`));
                    } else {
                        c();
                    }
                });
            } catch (err) {
                console.error(err);
                e(err);
            }
        });
    });
}
</file>

<file path="src/test/mocks.ts">
/**
 * Mock implementations for testing services in isolation
 * 
 * This file contains mock classes that implement the same interfaces as the real services
 * but provide predictable, controllable behavior for unit testing.
 */

import { QdrantPoint, SearchResult } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { CodeChunk, ChunkType } from '../parsing/chunker';
import { SupportedLanguage } from '../parsing/astParser';

/**
 * Mock implementation of QdrantService for testing
 */
export class MockQdrantService {
    private collections: Set<string> = new Set();
    private points: Map<string, QdrantPoint[]> = new Map();
    private isHealthy = true;

    async healthCheck(): Promise<boolean> {
        return this.isHealthy;
    }

    async createCollectionIfNotExists(
        collectionName: string,
        vectorSize: number = 768,
        distance: 'Cosine' | 'Dot' | 'Euclid' = 'Cosine'
    ): Promise<boolean> {
        this.collections.add(collectionName);
        if (!this.points.has(collectionName)) {
            this.points.set(collectionName, []);
        }
        return true;
    }

    async deleteCollection(collectionName: string): Promise<boolean> {
        this.collections.delete(collectionName);
        this.points.delete(collectionName);
        return true;
    }

    async upsertPoints(collectionName: string, points: QdrantPoint[]): Promise<boolean> {
        if (!this.collections.has(collectionName)) {
            await this.createCollectionIfNotExists(collectionName);
        }
        
        const existingPoints = this.points.get(collectionName) || [];
        
        // Update or insert points
        for (const newPoint of points) {
            const existingIndex = existingPoints.findIndex(p => p.id === newPoint.id);
            if (existingIndex >= 0) {
                existingPoints[existingIndex] = newPoint;
            } else {
                existingPoints.push(newPoint);
            }
        }
        
        this.points.set(collectionName, existingPoints);
        return true;
    }

    async search(
        collectionName: string,
        queryVector: number[],
        limit: number = 10,
        filter?: any
    ): Promise<SearchResult[]> {
        const points = this.points.get(collectionName) || [];
        
        // Simple mock search - return first N points with random scores
        return points.slice(0, limit).map((point, index) => ({
            id: point.id,
            score: 0.9 - (index * 0.1), // Decreasing scores
            payload: point.payload
        }));
    }

    async getCollectionInfo(collectionName: string): Promise<any> {
        if (!this.collections.has(collectionName)) {
            throw new Error(`Collection ${collectionName} does not exist`);
        }
        
        const points = this.points.get(collectionName) || [];
        return {
            status: 'green',
            vectors_count: points.length,
            indexed_vectors_count: points.length,
            points_count: points.length
        };
    }

    // Test helper methods
    setHealthy(healthy: boolean): void {
        this.isHealthy = healthy;
    }

    getPointsCount(collectionName: string): number {
        return this.points.get(collectionName)?.length || 0;
    }

    clearAllData(): void {
        this.collections.clear();
        this.points.clear();
    }
}

/**
 * Mock implementation of IEmbeddingProvider for testing
 */
export class MockEmbeddingProvider implements IEmbeddingProvider {
    private isAvailableFlag = true;
    private dimensions = 768;
    private providerName = 'mock-provider';

    async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        // Generate mock embeddings - arrays of random numbers
        return chunks.map(() => 
            Array.from({ length: this.dimensions }, () => Math.random() - 0.5)
        );
    }

    getDimensions(): number {
        return this.dimensions;
    }

    getProviderName(): string {
        return this.providerName;
    }

    async isAvailable(): Promise<boolean> {
        return this.isAvailableFlag;
    }

    // Test helper methods
    setAvailable(available: boolean): void {
        this.isAvailableFlag = available;
    }

    setDimensions(dims: number): void {
        this.dimensions = dims;
    }

    setProviderName(name: string): void {
        this.providerName = name;
    }
}

/**
 * Mock implementation of FileWalker for testing
 */
export class MockFileWalker {
    private workspaceRoot: string;
    private ignoreInstance: any;
    private mockFiles: string[] = [];

    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
        this.ignoreInstance = { add: () => {}, ignores: () => false };
    }

    private async loadGitignore(): Promise<void> {
        // Mock implementation
    }

    public async findAllFiles(): Promise<string[]> {
        return this.mockFiles;
    }

    public async getFileStats(): Promise<{ totalFiles: number; filesByExtension: Record<string, number> }> {
        const filesByExtension: Record<string, number> = {};
        this.mockFiles.forEach(file => {
            const ext = file.substring(file.lastIndexOf('.'));
            filesByExtension[ext] = (filesByExtension[ext] || 0) + 1;
        });

        return {
            totalFiles: this.mockFiles.length,
            filesByExtension
        };
    }

    public isCodeFile(filePath: string): boolean {
        const codeExtensions = ['.ts', '.tsx', '.js', '.jsx', '.py', '.cs', '.java'];
        return codeExtensions.some(ext => filePath.endsWith(ext));
    }

    async getFiles(
        extensions: string[] = [],
        excludePatterns: string[] = []
    ): Promise<string[]> {
        return this.mockFiles.filter(file => {
            if (extensions.length > 0) {
                return extensions.some(ext => file.endsWith(ext));
            }
            return true;
        });
    }

    // Test helper methods
    setMockFiles(files: string[]): void {
        this.mockFiles = files;
    }

    addMockFile(file: string): void {
        this.mockFiles.push(file);
    }

    clearMockFiles(): void {
        this.mockFiles = [];
    }
}

/**
 * Mock implementation of AstParser for testing
 */
export class MockAstParser {
    private mockParseResult: any = null;

    async parseFile(filePath: string, language: SupportedLanguage): Promise<any> {
        return this.mockParseResult || {
            functions: [],
            classes: [],
            imports: [],
            exports: []
        };
    }

    // Test helper methods
    setMockParseResult(result: any): void {
        this.mockParseResult = result;
    }
}

/**
 * Mock implementation of Chunker for testing
 */
export class MockChunker {
    private mockChunks: CodeChunk[] = [];

    chunkCode(
        content: string,
        filePath: string,
        language: SupportedLanguage,
        astResult?: any
    ): CodeChunk[] {
        if (this.mockChunks.length > 0) {
            return this.mockChunks;
        }

        // Default mock chunks
        return [
            {
                content: content.substring(0, Math.min(100, content.length)),
                filePath,
                startLine: 1,
                endLine: 10,
                type: ChunkType.FUNCTION,
                language,
                metadata: {}
            }
        ];
    }

    // Test helper methods
    setMockChunks(chunks: CodeChunk[]): void {
        this.mockChunks = chunks;
    }

    clearMockChunks(): void {
        this.mockChunks = [];
    }
}

/**
 * Mock implementation of LspService for testing
 */
export class MockLspService {
    private isInitialized = false;

    constructor(workspaceRoot: string) {
        // Mock constructor
    }

    async initialize(): Promise<void> {
        this.isInitialized = true;
    }

    async dispose(): Promise<void> {
        this.isInitialized = false;
    }

    isReady(): boolean {
        return this.isInitialized;
    }

    // Test helper methods
    setInitialized(initialized: boolean): void {
        this.isInitialized = initialized;
    }
}
</file>

<file path="src/test/runTest.ts">
import * as path from 'path';
import { runTests } from '@vscode/test-electron';

async function main() {
    try {
        // The folder containing the Extension Manifest package.json
        // Passed to `--extensionDevelopmentPath`
        const extensionDevelopmentPath = path.resolve(__dirname, '../../');

        // The path to test runner
        // Passed to --extensionTestsPath
        const extensionTestsPath = path.resolve(__dirname, './suite/index');

        // Download VS Code, unzip it and run the integration test
        await runTests({ extensionDevelopmentPath, extensionTestsPath });
    } catch (err) {
        console.error('Failed to run tests');
        process.exit(1);
    }
}

main();
</file>

<file path="src/types/tree-sitter-languages.d.ts">
declare module 'tree-sitter-typescript' {
    const typescript: any;
    const javascript: any;
    export { typescript, javascript };
}

declare module 'tree-sitter-python' {
    const python: any;
    export = python;
}

declare module 'tree-sitter-c-sharp' {
    const csharp: any;
    export = csharp;
}

declare module 'glob' {
    interface GlobOptions {
        cwd?: string;
        absolute?: boolean;
        nodir?: boolean;
        dot?: boolean;
    }

    function glob(pattern: string, options: GlobOptions, callback: (err: Error | null, matches: string[]) => void): void;

    export { glob, GlobOptions };
}
</file>

<file path="src/validation/systemValidator.ts">
/**
 * SystemValidator - Pre-flight Checks and System Validation
 * 
 * This service performs comprehensive system validation before setup,
 * checking Docker availability, network connectivity, system requirements,
 * and port availability for local services.
 */

import * as vscode from 'vscode';
import * as os from 'os';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export interface ValidationResult {
    isValid: boolean;
    category: 'docker' | 'network' | 'system' | 'ports';
    check: string;
    status: 'pass' | 'fail' | 'warning';
    message: string;
    details?: string;
    fixSuggestion?: string;
    autoFixAvailable?: boolean;
}

export interface SystemValidationReport {
    overallStatus: 'pass' | 'warning' | 'fail';
    results: ValidationResult[];
    summary: {
        passed: number;
        warnings: number;
        failed: number;
    };
}

export class SystemValidator {
    private context: vscode.ExtensionContext;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
    }

    /**
     * Run comprehensive system validation
     */
    async validateSystem(): Promise<SystemValidationReport> {
        const results: ValidationResult[] = [];

        // Run all validation checks
        results.push(...await this.validateDocker());
        results.push(...await this.validateNetwork());
        results.push(...await this.validateSystemRequirements());
        results.push(...await this.validatePorts());

        // Calculate summary
        const summary = {
            passed: results.filter(r => r.status === 'pass').length,
            warnings: results.filter(r => r.status === 'warning').length,
            failed: results.filter(r => r.status === 'fail').length
        };

        // Determine overall status
        let overallStatus: 'pass' | 'warning' | 'fail' = 'pass';
        if (summary.failed > 0) {
            overallStatus = 'fail';
        } else if (summary.warnings > 0) {
            overallStatus = 'warning';
        }

        return {
            overallStatus,
            results,
            summary
        };
    }

    /**
     * Validate Docker installation and availability
     */
    private async validateDocker(): Promise<ValidationResult[]> {
        const results: ValidationResult[] = [];

        try {
            // Check if Docker is installed
            const { stdout: versionOutput } = await execAsync('docker --version');
            const dockerVersion = versionOutput.trim();

            results.push({
                isValid: true,
                category: 'docker',
                check: 'Docker Installation',
                status: 'pass',
                message: `Docker is installed: ${dockerVersion}`,
                details: dockerVersion
            });

            // Check if Docker daemon is running
            try {
                await execAsync('docker info');
                results.push({
                    isValid: true,
                    category: 'docker',
                    check: 'Docker Daemon',
                    status: 'pass',
                    message: 'Docker daemon is running and accessible'
                });

                // Check Docker version compatibility
                const versionMatch = dockerVersion.match(/Docker version (\d+)\.(\d+)/);
                if (versionMatch) {
                    const major = parseInt(versionMatch[1]);
                    const minor = parseInt(versionMatch[2]);
                    
                    if (major < 20) {
                        results.push({
                            isValid: false,
                            category: 'docker',
                            check: 'Docker Version',
                            status: 'warning',
                            message: 'Docker version is older than recommended (20.x)',
                            details: `Current version: ${dockerVersion}`,
                            fixSuggestion: 'Consider updating Docker to version 20.x or later for better compatibility'
                        });
                    } else {
                        results.push({
                            isValid: true,
                            category: 'docker',
                            check: 'Docker Version',
                            status: 'pass',
                            message: 'Docker version is compatible'
                        });
                    }
                }

            } catch (daemonError) {
                results.push({
                    isValid: false,
                    category: 'docker',
                    check: 'Docker Daemon',
                    status: 'fail',
                    message: 'Docker daemon is not running or not accessible',
                    details: String(daemonError),
                    fixSuggestion: 'Start Docker Desktop or Docker daemon service',
                    autoFixAvailable: true
                });
            }

        } catch (installError) {
            results.push({
                isValid: false,
                category: 'docker',
                check: 'Docker Installation',
                status: 'fail',
                message: 'Docker is not installed or not in PATH',
                details: String(installError),
                fixSuggestion: 'Install Docker Desktop from https://docker.com/products/docker-desktop',
                autoFixAvailable: false
            });
        }

        return results;
    }

    /**
     * Validate network connectivity for cloud providers
     */
    private async validateNetwork(): Promise<ValidationResult[]> {
        const results: ValidationResult[] = [];

        // Test connectivity to key services
        const endpoints = [
            { name: 'OpenAI API', url: 'https://api.openai.com', required: false },
            { name: 'Pinecone API', url: 'https://controller.us-east-1-aws.pinecone.io', required: false },
            { name: 'Docker Hub', url: 'https://registry-1.docker.io', required: true },
            { name: 'GitHub (for updates)', url: 'https://api.github.com', required: false }
        ];

        for (const endpoint of endpoints) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                const response = await fetch(endpoint.url, {
                    method: 'HEAD',
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (response.ok || response.status === 404) { // 404 is OK for connectivity test
                    results.push({
                        isValid: true,
                        category: 'network',
                        check: `${endpoint.name} Connectivity`,
                        status: 'pass',
                        message: `Can reach ${endpoint.name}`
                    });
                } else {
                    const status = endpoint.required ? 'fail' : 'warning';
                    results.push({
                        isValid: !endpoint.required,
                        category: 'network',
                        check: `${endpoint.name} Connectivity`,
                        status,
                        message: `Cannot reach ${endpoint.name} (HTTP ${response.status})`,
                        fixSuggestion: 'Check internet connection and firewall settings'
                    });
                }

            } catch (error) {
                const status = endpoint.required ? 'fail' : 'warning';
                results.push({
                    isValid: !endpoint.required,
                    category: 'network',
                    check: `${endpoint.name} Connectivity`,
                    status,
                    message: `Cannot reach ${endpoint.name}`,
                    details: error instanceof Error ? error.message : String(error),
                    fixSuggestion: 'Check internet connection, proxy settings, and firewall configuration'
                });
            }
        }

        return results;
    }

    /**
     * Validate system requirements (memory, disk space, etc.)
     */
    private async validateSystemRequirements(): Promise<ValidationResult[]> {
        const results: ValidationResult[] = [];

        // Check available memory
        const totalMemory = os.totalmem();
        const freeMemory = os.freemem();
        const totalMemoryGB = Math.round(totalMemory / (1024 * 1024 * 1024));
        const freeMemoryGB = Math.round(freeMemory / (1024 * 1024 * 1024));

        if (totalMemoryGB < 4) {
            results.push({
                isValid: false,
                category: 'system',
                check: 'System Memory',
                status: 'warning',
                message: `Low system memory: ${totalMemoryGB}GB total`,
                details: `Free: ${freeMemoryGB}GB, Total: ${totalMemoryGB}GB`,
                fixSuggestion: 'Consider upgrading to at least 8GB RAM for optimal performance'
            });
        } else {
            results.push({
                isValid: true,
                category: 'system',
                check: 'System Memory',
                status: 'pass',
                message: `Sufficient memory: ${totalMemoryGB}GB total, ${freeMemoryGB}GB free`
            });
        }

        // Check disk space in workspace (simplified approach)
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            try {
                const workspacePath = workspaceFolders[0].uri.fsPath;

                // Use platform-specific commands to check disk space
                let command: string;
                if (process.platform === 'win32') {
                    command = `dir "${workspacePath}" /-c | find "bytes free"`;
                } else {
                    command = `df -h "${workspacePath}" | tail -1 | awk '{print $4}'`;
                }

                const { stdout } = await execAsync(command);

                if (process.platform === 'win32') {
                    // Parse Windows output
                    const match = stdout.match(/(\d+) bytes free/);
                    if (match) {
                        const freeBytes = parseInt(match[1]);
                        const freeSpaceGB = Math.round(freeBytes / (1024 * 1024 * 1024));

                        if (freeSpaceGB < 2) {
                            results.push({
                                isValid: false,
                                category: 'system',
                                check: 'Disk Space',
                                status: 'warning',
                                message: `Low disk space: ${freeSpaceGB}GB free`,
                                fixSuggestion: 'Free up disk space or use a different workspace location'
                            });
                        } else {
                            results.push({
                                isValid: true,
                                category: 'system',
                                check: 'Disk Space',
                                status: 'pass',
                                message: `Sufficient disk space: ${freeSpaceGB}GB free`
                            });
                        }
                    } else {
                        throw new Error('Could not parse disk space output');
                    }
                } else {
                    // Parse Unix/Linux/macOS output
                    const freeSpace = stdout.trim();
                    const match = freeSpace.match(/(\d+(?:\.\d+)?)[GT]/);

                    if (match) {
                        const value = parseFloat(match[1]);
                        const unit = freeSpace.includes('G') ? 'GB' : 'TB';
                        const freeSpaceGB = unit === 'TB' ? value * 1024 : value;

                        if (freeSpaceGB < 2) {
                            results.push({
                                isValid: false,
                                category: 'system',
                                check: 'Disk Space',
                                status: 'warning',
                                message: `Low disk space: ${freeSpaceGB.toFixed(1)}GB free`,
                                fixSuggestion: 'Free up disk space or use a different workspace location'
                            });
                        } else {
                            results.push({
                                isValid: true,
                                category: 'system',
                                check: 'Disk Space',
                                status: 'pass',
                                message: `Sufficient disk space: ${freeSpaceGB.toFixed(1)}GB free`
                            });
                        }
                    } else {
                        throw new Error('Could not parse disk space output');
                    }
                }
            } catch (error) {
                results.push({
                    isValid: true,
                    category: 'system',
                    check: 'Disk Space',
                    status: 'warning',
                    message: 'Could not check disk space',
                    details: String(error)
                });
            }
        }

        // Check Node.js version
        const nodeVersion = process.version;
        const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);

        if (majorVersion < 16) {
            results.push({
                isValid: false,
                category: 'system',
                check: 'Node.js Version',
                status: 'warning',
                message: `Node.js version ${nodeVersion} is older than recommended`,
                fixSuggestion: 'Update to Node.js 16 or later for better performance'
            });
        } else {
            results.push({
                isValid: true,
                category: 'system',
                check: 'Node.js Version',
                status: 'pass',
                message: `Node.js version ${nodeVersion} is compatible`
            });
        }

        return results;
    }

    /**
     * Validate port availability for local services
     */
    private async validatePorts(): Promise<ValidationResult[]> {
        const results: ValidationResult[] = [];

        const portsToCheck = [
            { port: 6333, service: 'Qdrant' },
            { port: 8000, service: 'ChromaDB' },
            { port: 11434, service: 'Ollama' }
        ];

        for (const { port, service } of portsToCheck) {
            try {
                const isAvailable = await this.isPortAvailable(port);
                
                if (isAvailable) {
                    results.push({
                        isValid: true,
                        category: 'ports',
                        check: `Port ${port} (${service})`,
                        status: 'pass',
                        message: `Port ${port} is available for ${service}`
                    });
                } else {
                    results.push({
                        isValid: false,
                        category: 'ports',
                        check: `Port ${port} (${service})`,
                        status: 'warning',
                        message: `Port ${port} is already in use`,
                        details: `Another service may be using port ${port}`,
                        fixSuggestion: `Stop the service using port ${port} or configure ${service} to use a different port`
                    });
                }
            } catch (error) {
                results.push({
                    isValid: true,
                    category: 'ports',
                    check: `Port ${port} (${service})`,
                    status: 'warning',
                    message: `Could not check port ${port} availability`,
                    details: String(error)
                });
            }
        }

        return results;
    }

    /**
     * Check if a port is available
     */
    private async isPortAvailable(port: number): Promise<boolean> {
        return new Promise((resolve) => {
            const net = require('net');
            const server = net.createServer();

            server.listen(port, () => {
                server.once('close', () => {
                    resolve(true);
                });
                server.close();
            });

            server.on('error', () => {
                resolve(false);
            });
        });
    }

    /**
     * Attempt to auto-fix common issues
     */
    async autoFix(check: string): Promise<{ success: boolean; message: string }> {
        switch (check) {
            case 'Docker Daemon':
                try {
                    if (process.platform === 'darwin') {
                        await execAsync('open -a Docker');
                        return { success: true, message: 'Attempting to start Docker Desktop...' };
                    } else if (process.platform === 'win32') {
                        await execAsync('start "" "Docker Desktop"');
                        return { success: true, message: 'Attempting to start Docker Desktop...' };
                    } else {
                        await execAsync('sudo systemctl start docker');
                        return { success: true, message: 'Attempting to start Docker service...' };
                    }
                } catch (error) {
                    return { success: false, message: `Failed to start Docker: ${error}` };
                }

            default:
                return { success: false, message: 'No auto-fix available for this issue' };
        }
    }
}
</file>

<file path="src/validation/troubleshootingGuide.ts">
/**
 * TroubleshootingGuide - Interactive Troubleshooting System
 * 
 * This service provides step-by-step troubleshooting guides for common
 * setup and configuration issues, with provider-specific solutions.
 */

import * as vscode from 'vscode';
import { ValidationResult } from './systemValidator';

export interface TroubleshootingStep {
    id: string;
    title: string;
    description: string;
    action?: 'command' | 'link' | 'manual' | 'auto-fix';
    actionData?: string;
    expectedResult?: string;
    nextStepOnSuccess?: string;
    nextStepOnFailure?: string;
}

export interface TroubleshootingGuide {
    id: string;
    title: string;
    description: string;
    category: 'docker' | 'network' | 'database' | 'embedding' | 'general';
    severity: 'low' | 'medium' | 'high' | 'critical';
    estimatedTime: string;
    steps: TroubleshootingStep[];
    relatedIssues?: string[];
}

export class TroubleshootingSystem {
    private guides: Map<string, TroubleshootingGuide> = new Map();

    constructor() {
        this.initializeGuides();
    }

    /**
     * Initialize all troubleshooting guides
     */
    private initializeGuides(): void {
        // Docker-related guides
        this.addGuide(this.createDockerInstallationGuide());
        this.addGuide(this.createDockerDaemonGuide());
        this.addGuide(this.createDockerPermissionsGuide());

        // Network-related guides
        this.addGuide(this.createNetworkConnectivityGuide());
        this.addGuide(this.createProxyConfigurationGuide());
        this.addGuide(this.createFirewallGuide());

        // Database-specific guides
        this.addGuide(this.createQdrantTroubleshootingGuide());
        this.addGuide(this.createChromaDBTroubleshootingGuide());
        this.addGuide(this.createPineconeTroubleshootingGuide());

        // Embedding provider guides
        this.addGuide(this.createOllamaTroubleshootingGuide());
        this.addGuide(this.createOpenAITroubleshootingGuide());

        // General guides
        this.addGuide(this.createPortConflictGuide());
        this.addGuide(this.createPerformanceGuide());
    }

    /**
     * Add a guide to the system
     */
    private addGuide(guide: TroubleshootingGuide): void {
        this.guides.set(guide.id, guide);
    }

    /**
     * Get troubleshooting suggestions based on validation results
     */
    getSuggestedGuides(validationResults: ValidationResult[]): TroubleshootingGuide[] {
        const suggestions: TroubleshootingGuide[] = [];
        const addedGuides = new Set<string>();

        for (const result of validationResults) {
            if (result.status === 'fail' || result.status === 'warning') {
                const guideIds = this.getGuideIdsForIssue(result);
                
                for (const guideId of guideIds) {
                    if (!addedGuides.has(guideId)) {
                        const guide = this.guides.get(guideId);
                        if (guide) {
                            suggestions.push(guide);
                            addedGuides.add(guideId);
                        }
                    }
                }
            }
        }

        // Sort by severity and category
        return suggestions.sort((a, b) => {
            const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
            return severityOrder[b.severity] - severityOrder[a.severity];
        });
    }

    /**
     * Get guide IDs for a specific issue
     */
    private getGuideIdsForIssue(result: ValidationResult): string[] {
        const guideIds: string[] = [];

        switch (result.category) {
            case 'docker':
                if (result.check.includes('Installation')) {
                    guideIds.push('docker-installation');
                } else if (result.check.includes('Daemon')) {
                    guideIds.push('docker-daemon');
                } else if (result.check.includes('Permission')) {
                    guideIds.push('docker-permissions');
                }
                break;

            case 'network':
                guideIds.push('network-connectivity');
                if (result.message.includes('proxy')) {
                    guideIds.push('proxy-configuration');
                }
                if (result.message.includes('firewall')) {
                    guideIds.push('firewall-configuration');
                }
                break;

            case 'ports':
                guideIds.push('port-conflicts');
                break;

            case 'system':
                if (result.check.includes('Memory') || result.check.includes('Performance')) {
                    guideIds.push('performance-optimization');
                }
                break;
        }

        return guideIds;
    }

    /**
     * Get a specific guide by ID
     */
    getGuide(id: string): TroubleshootingGuide | undefined {
        return this.guides.get(id);
    }

    /**
     * Get all guides for a category
     */
    getGuidesByCategory(category: string): TroubleshootingGuide[] {
        return Array.from(this.guides.values()).filter(guide => guide.category === category);
    }

    /**
     * Search guides by keywords
     */
    searchGuides(keywords: string): TroubleshootingGuide[] {
        const searchTerms = keywords.toLowerCase().split(' ');
        return Array.from(this.guides.values()).filter(guide => {
            const searchText = `${guide.title} ${guide.description}`.toLowerCase();
            return searchTerms.some(term => searchText.includes(term));
        });
    }

    // Guide creation methods
    private createDockerInstallationGuide(): TroubleshootingGuide {
        return {
            id: 'docker-installation',
            title: 'Docker Installation Issues',
            description: 'Resolve Docker installation and setup problems',
            category: 'docker',
            severity: 'high',
            estimatedTime: '10-15 minutes',
            steps: [
                {
                    id: 'check-installation',
                    title: 'Check Docker Installation',
                    description: 'Verify if Docker is properly installed on your system',
                    action: 'command',
                    actionData: 'docker --version',
                    expectedResult: 'Docker version information should be displayed',
                    nextStepOnSuccess: 'check-daemon',
                    nextStepOnFailure: 'install-docker'
                },
                {
                    id: 'install-docker',
                    title: 'Install Docker',
                    description: 'Download and install Docker Desktop for your operating system',
                    action: 'link',
                    actionData: 'https://docs.docker.com/get-docker/',
                    expectedResult: 'Docker Desktop should be installed and running',
                    nextStepOnSuccess: 'verify-installation'
                },
                {
                    id: 'verify-installation',
                    title: 'Verify Installation',
                    description: 'Test Docker installation with a simple command',
                    action: 'command',
                    actionData: 'docker run hello-world',
                    expectedResult: 'Hello World message from Docker should appear'
                }
            ]
        };
    }

    private createDockerDaemonGuide(): TroubleshootingGuide {
        return {
            id: 'docker-daemon',
            title: 'Docker Daemon Not Running',
            description: 'Fix issues with Docker daemon not starting or being accessible',
            category: 'docker',
            severity: 'high',
            estimatedTime: '5-10 minutes',
            steps: [
                {
                    id: 'start-docker-desktop',
                    title: 'Start Docker Desktop',
                    description: 'Launch Docker Desktop application',
                    action: 'auto-fix',
                    actionData: 'start-docker',
                    expectedResult: 'Docker Desktop should start and show running status',
                    nextStepOnSuccess: 'verify-daemon',
                    nextStepOnFailure: 'manual-start'
                },
                {
                    id: 'manual-start',
                    title: 'Manual Start',
                    description: 'Manually start Docker Desktop from Applications/Programs',
                    action: 'manual',
                    expectedResult: 'Docker Desktop icon should appear in system tray/menu bar',
                    nextStepOnSuccess: 'verify-daemon'
                },
                {
                    id: 'verify-daemon',
                    title: 'Verify Daemon',
                    description: 'Check if Docker daemon is responding',
                    action: 'command',
                    actionData: 'docker info',
                    expectedResult: 'Docker system information should be displayed'
                }
            ]
        };
    }

    private createOllamaTroubleshootingGuide(): TroubleshootingGuide {
        return {
            id: 'ollama-troubleshooting',
            title: 'Ollama Connection Issues',
            description: 'Resolve Ollama installation and connection problems',
            category: 'embedding',
            severity: 'medium',
            estimatedTime: '10-15 minutes',
            steps: [
                {
                    id: 'check-ollama-installation',
                    title: 'Check Ollama Installation',
                    description: 'Verify if Ollama is installed and accessible',
                    action: 'command',
                    actionData: 'ollama --version',
                    expectedResult: 'Ollama version should be displayed',
                    nextStepOnSuccess: 'check-ollama-service',
                    nextStepOnFailure: 'install-ollama'
                },
                {
                    id: 'install-ollama',
                    title: 'Install Ollama',
                    description: 'Download and install Ollama from the official website',
                    action: 'link',
                    actionData: 'https://ollama.ai/',
                    expectedResult: 'Ollama should be installed and available in PATH',
                    nextStepOnSuccess: 'start-ollama-service'
                },
                {
                    id: 'check-ollama-service',
                    title: 'Check Ollama Service',
                    description: 'Verify if Ollama service is running',
                    action: 'command',
                    actionData: 'curl http://localhost:11434/api/tags',
                    expectedResult: 'JSON response with available models',
                    nextStepOnSuccess: 'test-model',
                    nextStepOnFailure: 'start-ollama-service'
                },
                {
                    id: 'start-ollama-service',
                    title: 'Start Ollama Service',
                    description: 'Start the Ollama service',
                    action: 'command',
                    actionData: 'ollama serve',
                    expectedResult: 'Ollama service should start and listen on port 11434',
                    nextStepOnSuccess: 'pull-model'
                },
                {
                    id: 'pull-model',
                    title: 'Pull Embedding Model',
                    description: 'Download a recommended embedding model',
                    action: 'command',
                    actionData: 'ollama pull nomic-embed-text',
                    expectedResult: 'Model should be downloaded and available for use'
                }
            ]
        };
    }

    private createPineconeTroubleshootingGuide(): TroubleshootingGuide {
        return {
            id: 'pinecone-troubleshooting',
            title: 'Pinecone API Issues',
            description: 'Resolve Pinecone API key and connection problems',
            category: 'database',
            severity: 'medium',
            estimatedTime: '5-10 minutes',
            steps: [
                {
                    id: 'verify-api-key',
                    title: 'Verify API Key Format',
                    description: 'Check if your Pinecone API key has the correct format',
                    action: 'manual',
                    expectedResult: 'API key should be a long alphanumeric string',
                    nextStepOnSuccess: 'test-api-key',
                    nextStepOnFailure: 'get-new-api-key'
                },
                {
                    id: 'get-new-api-key',
                    title: 'Get New API Key',
                    description: 'Generate a new API key from Pinecone console',
                    action: 'link',
                    actionData: 'https://app.pinecone.io/',
                    expectedResult: 'New API key should be generated and copied',
                    nextStepOnSuccess: 'test-api-key'
                },
                {
                    id: 'test-api-key',
                    title: 'Test API Key',
                    description: 'Verify API key works by listing indexes',
                    action: 'manual',
                    expectedResult: 'API should respond with list of indexes or empty array'
                }
            ]
        };
    }

    private createNetworkConnectivityGuide(): TroubleshootingGuide {
        return {
            id: 'network-connectivity',
            title: 'Network Connectivity Issues',
            description: 'Diagnose and fix internet connectivity problems',
            category: 'network',
            severity: 'medium',
            estimatedTime: '10-15 minutes',
            steps: [
                {
                    id: 'test-basic-connectivity',
                    title: 'Test Basic Internet Connection',
                    description: 'Check if you can reach external websites',
                    action: 'command',
                    actionData: 'ping google.com',
                    expectedResult: 'Should receive ping responses',
                    nextStepOnSuccess: 'test-https',
                    nextStepOnFailure: 'check-network-settings'
                },
                {
                    id: 'test-https',
                    title: 'Test HTTPS Connectivity',
                    description: 'Verify HTTPS connections work',
                    action: 'command',
                    actionData: 'curl -I https://api.openai.com',
                    expectedResult: 'Should receive HTTP headers',
                    nextStepOnFailure: 'check-proxy-settings'
                },
                {
                    id: 'check-proxy-settings',
                    title: 'Check Proxy Configuration',
                    description: 'Verify proxy settings if you are behind a corporate firewall',
                    action: 'manual',
                    expectedResult: 'Proxy settings should be correctly configured'
                }
            ]
        };
    }

    private createPortConflictGuide(): TroubleshootingGuide {
        return {
            id: 'port-conflicts',
            title: 'Port Conflict Resolution',
            description: 'Resolve conflicts when required ports are already in use',
            category: 'general',
            severity: 'medium',
            estimatedTime: '5-10 minutes',
            steps: [
                {
                    id: 'identify-process',
                    title: 'Identify Process Using Port',
                    description: 'Find which process is using the conflicting port',
                    action: 'command',
                    actionData: 'lsof -i :6333',
                    expectedResult: 'Should show process information',
                    nextStepOnSuccess: 'stop-process'
                },
                {
                    id: 'stop-process',
                    title: 'Stop Conflicting Process',
                    description: 'Stop the process that is using the required port',
                    action: 'manual',
                    expectedResult: 'Port should become available'
                }
            ]
        };
    }

    private createPerformanceGuide(): TroubleshootingGuide {
        return {
            id: 'performance-optimization',
            title: 'Performance Optimization',
            description: 'Improve system performance for better indexing and search',
            category: 'general',
            severity: 'low',
            estimatedTime: '15-20 minutes',
            steps: [
                {
                    id: 'check-memory-usage',
                    title: 'Check Memory Usage',
                    description: 'Monitor current memory consumption',
                    action: 'manual',
                    expectedResult: 'Should have at least 2GB free memory'
                },
                {
                    id: 'optimize-docker',
                    title: 'Optimize Docker Settings',
                    description: 'Adjust Docker memory and CPU limits',
                    action: 'manual',
                    expectedResult: 'Docker should have adequate resources allocated'
                }
            ]
        };
    }

    // Additional guide creation methods would go here...
    private createDockerPermissionsGuide(): TroubleshootingGuide {
        return {
            id: 'docker-permissions',
            title: 'Docker Permission Issues',
            description: 'Fix Docker permission denied errors',
            category: 'docker',
            severity: 'medium',
            estimatedTime: '5-10 minutes',
            steps: []
        };
    }

    private createProxyConfigurationGuide(): TroubleshootingGuide {
        return {
            id: 'proxy-configuration',
            title: 'Proxy Configuration',
            description: 'Configure proxy settings for corporate networks',
            category: 'network',
            severity: 'medium',
            estimatedTime: '10-15 minutes',
            steps: []
        };
    }

    private createFirewallGuide(): TroubleshootingGuide {
        return {
            id: 'firewall-configuration',
            title: 'Firewall Configuration',
            description: 'Configure firewall settings for required ports',
            category: 'network',
            severity: 'medium',
            estimatedTime: '10-15 minutes',
            steps: []
        };
    }

    private createQdrantTroubleshootingGuide(): TroubleshootingGuide {
        return {
            id: 'qdrant-troubleshooting',
            title: 'Qdrant Issues',
            description: 'Resolve Qdrant database problems',
            category: 'database',
            severity: 'medium',
            estimatedTime: '10-15 minutes',
            steps: []
        };
    }

    private createChromaDBTroubleshootingGuide(): TroubleshootingGuide {
        return {
            id: 'chromadb-troubleshooting',
            title: 'ChromaDB Issues',
            description: 'Resolve ChromaDB database problems',
            category: 'database',
            severity: 'medium',
            estimatedTime: '10-15 minutes',
            steps: []
        };
    }

    private createOpenAITroubleshootingGuide(): TroubleshootingGuide {
        return {
            id: 'openai-troubleshooting',
            title: 'OpenAI API Issues',
            description: 'Resolve OpenAI API key and quota problems',
            category: 'embedding',
            severity: 'medium',
            estimatedTime: '5-10 minutes',
            steps: []
        };
    }
}
</file>

<file path="src/configService.ts">
import * as vscode from 'vscode';

/**
 * Configuration interfaces for different providers
 */
export interface OllamaConfig {
    apiUrl: string;
    model: string;
    timeout?: number;
    maxBatchSize?: number;
}

export interface OpenAIConfig {
    apiKey: string;
    model: string;
    timeout?: number;
    maxBatchSize?: number;
}

export interface DatabaseConfig {
    type: 'qdrant';
    connectionString: string;
}

export interface IndexingConfig {
    excludePatterns: string[];
    supportedLanguages: string[];
    maxFileSize?: number;
    chunkSize?: number;
    chunkOverlap?: number;
}

/**
 * Main extension configuration interface
 */
export interface ExtensionConfig {
    database: DatabaseConfig;
    embeddingProvider: 'ollama' | 'openai';
    ollama: OllamaConfig;
    openai: OpenAIConfig;
    indexing: IndexingConfig;
}

/**
 * Centralized configuration service for the Code Context Engine extension.
 * 
 * This service encapsulates all extension settings, providing a single source of truth
 * and preventing direct vscode.workspace.getConfiguration() calls throughout the codebase.
 * It improves testability by centralizing configuration access and makes it easier to
 * manage configuration changes.
 */
export class ConfigService {
    private config: vscode.WorkspaceConfiguration;
    private readonly configSection = 'code-context-engine';

    constructor() {
        // Load the configuration once during instantiation
        this.config = vscode.workspace.getConfiguration(this.configSection);
    }

    /**
     * Refresh configuration from VS Code settings
     * Call this when configuration might have changed
     */
    public refresh(): void {
        this.config = vscode.workspace.getConfiguration(this.configSection);
    }

    /**
     * Get the Qdrant database connection string
     */
    public getQdrantConnectionString(): string {
        return this.config.get<string>('databaseConnectionString') || 'http://localhost:6333';
    }

    /**
     * Get the database configuration
     */
    public getDatabaseConfig(): DatabaseConfig {
        return {
            type: 'qdrant',
            connectionString: this.getQdrantConnectionString()
        };
    }

    /**
     * Get the current embedding provider type
     */
    public getEmbeddingProvider(): 'ollama' | 'openai' {
        return this.config.get<'ollama' | 'openai'>('embeddingProvider') || 'ollama';
    }

    /**
     * Get Ollama configuration
     */
    public getOllamaConfig(): OllamaConfig {
        return {
            apiUrl: this.config.get<string>('ollama.apiUrl') || 'http://localhost:11434',
            model: this.config.get<string>('ollama.model') || 'nomic-embed-text',
            timeout: this.config.get<number>('ollama.timeout') || 30000,
            maxBatchSize: this.config.get<number>('ollama.maxBatchSize') || 10
        };
    }

    /**
     * Get OpenAI configuration
     */
    public getOpenAIConfig(): OpenAIConfig {
        return {
            apiKey: this.config.get<string>('openai.apiKey') || '',
            model: this.config.get<string>('openai.model') || 'text-embedding-ada-002',
            timeout: this.config.get<number>('openai.timeout') || 30000,
            maxBatchSize: this.config.get<number>('openai.maxBatchSize') || 100
        };
    }

    /**
     * Get indexing configuration
     */
    public getIndexingConfig(): IndexingConfig {
        return {
            excludePatterns: this.config.get<string[]>('indexing.excludePatterns') || [
                '**/node_modules/**',
                '**/dist/**',
                '**/build/**',
                '**/.git/**',
                '**/coverage/**'
            ],
            supportedLanguages: this.config.get<string[]>('indexing.supportedLanguages') || [
                'typescript',
                'javascript',
                'python',
                'csharp',
                'java',
                'cpp',
                'rust'
            ],
            maxFileSize: this.config.get<number>('indexing.maxFileSize') || 1024 * 1024, // 1MB
            chunkSize: this.config.get<number>('indexing.chunkSize') || 1000,
            chunkOverlap: this.config.get<number>('indexing.chunkOverlap') || 200
        };
    }

    /**
     * Get the complete extension configuration
     */
    public getFullConfig(): ExtensionConfig {
        return {
            database: this.getDatabaseConfig(),
            embeddingProvider: this.getEmbeddingProvider(),
            ollama: this.getOllamaConfig(),
            openai: this.getOpenAIConfig(),
            indexing: this.getIndexingConfig()
        };
    }

    /**
     * Check if a specific provider is properly configured
     */
    public isProviderConfigured(provider: 'ollama' | 'openai'): boolean {
        switch (provider) {
            case 'ollama':
                const ollamaConfig = this.getOllamaConfig();
                return !!(ollamaConfig.apiUrl && ollamaConfig.model);
            case 'openai':
                const openaiConfig = this.getOpenAIConfig();
                return !!(openaiConfig.apiKey && openaiConfig.model);
            default:
                return false;
        }
    }

    /**
     * Get configuration for the currently selected embedding provider
     */
    public getCurrentProviderConfig(): OllamaConfig | OpenAIConfig {
        const provider = this.getEmbeddingProvider();
        return provider === 'ollama' ? this.getOllamaConfig() : this.getOpenAIConfig();
    }
}
</file>

<file path="src/extensionManager.ts">
import * as vscode from 'vscode';
import { ConfigService } from './configService';
import { QdrantService } from './db/qdrantService';
import { EmbeddingProviderFactory, IEmbeddingProvider } from './embeddings/embeddingProvider';
import { ContextService } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { FileWalker } from './indexing/fileWalker';
import { AstParser } from './parsing/astParser';
import { Chunker } from './parsing/chunker';
import { LSPService } from './lsp/lspService';
import { CommandManager } from './commandManager';
import { WebviewManager } from './webviewManager';
import { SearchManager } from './searchManager';
import { ConfigurationManager } from './configurationManager';
import { PerformanceManager } from './performanceManager';
import { StateManager } from './stateManager';

/**
 * ExtensionManager class responsible for managing the lifecycle of all core services
 * and coordinating the initialization and disposal of the extension.
 * 
 * This class serves as the main orchestrator for the extension, handling:
 * - Service initialization with dependency injection
 * - Command registration through CommandManager
 * - Resource cleanup and disposal
 * - Error handling during initialization
 */
export class ExtensionManager {
    private context: vscode.ExtensionContext;
    private disposables: vscode.Disposable[] = [];

    // Core services
    private configService!: ConfigService;
    private qdrantService!: QdrantService;
    private embeddingProvider!: IEmbeddingProvider;
    private contextService!: ContextService;
    private indexingService!: IndexingService;

    // Managers
    private commandManager!: CommandManager;
    private webviewManager!: WebviewManager;
    private searchManager!: SearchManager;
    private configurationManager!: ConfigurationManager;
    private performanceManager!: PerformanceManager;
    private stateManager!: StateManager;

    /**
     * Creates a new ExtensionManager instance
     * @param context - The VS Code extension context
     */
    constructor(context: vscode.ExtensionContext) {
        this.context = context;
    }

    /**
     * Initializes all core services and managers using dependency injection
     * This method sets up the entire extension architecture
     */
    async initialize(): Promise<void> {
        try {
            console.log('ExtensionManager: Starting service initialization...');

            // Step 1: Initialize StateManager first (no dependencies)
            this.stateManager = new StateManager();
            console.log('ExtensionManager: StateManager initialized');

            // Step 2: Initialize ConfigService (no dependencies)
            this.configService = new ConfigService();
            console.log('ExtensionManager: ConfigService initialized');

            // Step 3: Initialize QdrantService with configuration
            this.qdrantService = new QdrantService(this.configService.getQdrantConnectionString());
            console.log('ExtensionManager: QdrantService initialized');

            // Step 4: Initialize EmbeddingProvider using factory and configuration
            this.embeddingProvider = await EmbeddingProviderFactory.createProviderFromConfigService(this.configService);
            console.log('ExtensionManager: EmbeddingProvider initialized');

            // Step 5: Initialize workspace-dependent services
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (workspaceFolders && workspaceFolders.length > 0) {
                const workspaceRoot = workspaceFolders[0].uri.fsPath;

                // Create all dependencies for IndexingService
                const fileWalker = new FileWalker(workspaceRoot);
                const astParser = new AstParser();
                const chunker = new Chunker();
                const lspService = new LSPService(workspaceRoot);

                // Initialize IndexingService with all dependencies including StateManager
                this.indexingService = new IndexingService(
                    workspaceRoot,
                    fileWalker,
                    astParser,
                    chunker,
                    this.qdrantService,
                    this.embeddingProvider,
                    lspService,
                    this.stateManager
                );
                console.log('ExtensionManager: IndexingService initialized');

                // Initialize ContextService with dependencies
                this.contextService = new ContextService(
                    workspaceRoot,
                    this.qdrantService,
                    this.embeddingProvider,
                    this.indexingService
                );
                console.log('ExtensionManager: ContextService initialized');
            } else {
                console.warn('ExtensionManager: No workspace folder found, some services not initialized');
            }

            // Step 6: Initialize PerformanceManager
            this.performanceManager = new PerformanceManager();
            console.log('ExtensionManager: PerformanceManager initialized');

            // Step 7: Initialize ConfigurationManager
            this.configurationManager = new ConfigurationManager(this.configService);
            console.log('ExtensionManager: ConfigurationManager initialized');

            // Step 8: Initialize SearchManager
            this.searchManager = new SearchManager(this.contextService);
            console.log('ExtensionManager: SearchManager initialized');

            // Step 9: Initialize WebviewManager with StateManager
            this.webviewManager = new WebviewManager(this.context, this, this.stateManager);
            console.log('ExtensionManager: WebviewManager initialized');

            // Step 10: Initialize CommandManager and register commands
            this.commandManager = new CommandManager(this.indexingService, this.webviewManager);
            const commandDisposables = this.commandManager.registerCommands();
            this.disposables.push(...commandDisposables);
            console.log('ExtensionManager: CommandManager initialized and commands registered');

            console.log('ExtensionManager: All services initialized successfully');

        } catch (error) {
            console.error('ExtensionManager: Failed to initialize services:', error);
            throw error;
        }
    }

    /**
     * Disposes of all resources and cleans up services
     * This method should be called when the extension is deactivated
     */
    dispose(): void {
        console.log('ExtensionManager: Starting disposal...');

        // Dispose of managers in reverse order
        if (this.webviewManager) {
            this.webviewManager.dispose();
        }

        if (this.searchManager) {
            this.searchManager.dispose();
        }

        if (this.configurationManager) {
            this.configurationManager.dispose();
        }

        if (this.performanceManager) {
            this.performanceManager.dispose();
        }

        if (this.stateManager) {
            this.stateManager.dispose();
        }

        // Dispose of all registered disposables
        this.disposables.forEach(disposable => {
            try {
                disposable.dispose();
            } catch (error) {
                console.error('ExtensionManager: Error disposing resource:', error);
            }
        });

        this.disposables = [];
        console.log('ExtensionManager: Disposal completed');
    }

    /**
     * Gets the ConfigService instance
     * @returns The ConfigService instance
     */
    getConfigService(): ConfigService {
        return this.configService;
    }

    /**
     * Gets the QdrantService instance
     * @returns The QdrantService instance
     */
    getQdrantService(): QdrantService {
        return this.qdrantService;
    }

    /**
     * Gets the EmbeddingProvider instance
     * @returns The EmbeddingProvider instance
     */
    getEmbeddingProvider(): IEmbeddingProvider {
        return this.embeddingProvider;
    }

    /**
     * Gets the ContextService instance
     * @returns The ContextService instance
     */
    getContextService(): ContextService {
        return this.contextService;
    }

    /**
     * Gets the IndexingService instance
     * @returns The IndexingService instance
     */
    getIndexingService(): IndexingService {
        return this.indexingService;
    }

    /**
     * Gets the CommandManager instance
     * @returns The CommandManager instance
     */
    getCommandManager(): CommandManager {
        return this.commandManager;
    }

    /**
     * Gets the WebviewManager instance
     * @returns The WebviewManager instance
     */
    getWebviewManager(): WebviewManager {
        return this.webviewManager;
    }

    /**
     * Gets the SearchManager instance
     * @returns The SearchManager instance
     */
    getSearchManager(): SearchManager {
        return this.searchManager;
    }

    /**
     * Gets the ConfigurationManager instance
     * @returns The ConfigurationManager instance
     */
    getConfigurationManager(): ConfigurationManager {
        return this.configurationManager;
    }

    /**
     * Gets the PerformanceManager instance
     * @returns The PerformanceManager instance
     */
    getPerformanceManager(): PerformanceManager {
        return this.performanceManager;
    }

    /**
     * Gets the StateManager instance
     * @returns The StateManager instance
     */
    getStateManager(): StateManager {
        return this.stateManager;
    }

    /**
     * Gets the VS Code extension context
     * @returns The extension context
     */
    getContext(): vscode.ExtensionContext {
        return this.context;
    }
}
</file>

<file path="src/performanceManager.ts">
import * as vscode from 'vscode';

/**
 * Performance metrics for tracking system performance
 */
export interface PerformanceMetrics {
    searchLatency: number[];
    indexingTime: number;
    memoryUsage: number;
    cacheHitRate: number;
    activeConnections: number;
    lastUpdated: Date;
}

/**
 * Cache entry with expiration
 */
interface CacheEntry<T> {
    data: T;
    timestamp: number;
    ttl: number;
    accessCount: number;
}

/**
 * Performance optimization settings
 */
export interface OptimizationSettings {
    enableCaching: boolean;
    cacheSize: number;
    cacheTTL: number;
    enableCompression: boolean;
    batchSize: number;
    maxConcurrentOperations: number;
}

/**
 * PerformanceManager class responsible for performance optimization and monitoring.
 * 
 * This class provides performance enhancements including:
 * - Intelligent caching with LRU eviction
 * - Performance metrics collection and monitoring
 * - Memory usage optimization
 * - Request batching and throttling
 * - Background task scheduling
 */
export class PerformanceManager {
    private cache: Map<string, CacheEntry<any>> = new Map();
    private metrics: PerformanceMetrics;
    private settings: OptimizationSettings;
    private activeOperations: Set<string> = new Set();
    private operationQueue: Array<() => Promise<any>> = [];
    private isProcessingQueue = false;

    /**
     * Creates a new PerformanceManager instance
     */
    constructor() {
        this.metrics = {
            searchLatency: [],
            indexingTime: 0,
            memoryUsage: 0,
            cacheHitRate: 0,
            activeConnections: 0,
            lastUpdated: new Date()
        };

        this.settings = {
            enableCaching: true,
            cacheSize: 1000,
            cacheTTL: 5 * 60 * 1000, // 5 minutes
            enableCompression: false,
            batchSize: 10,
            maxConcurrentOperations: 5
        };

        this.startPerformanceMonitoring();
    }

    /**
     * Caches data with automatic expiration and LRU eviction
     * @param key - Cache key
     * @param data - Data to cache
     * @param ttl - Time to live in milliseconds (optional)
     */
    setCache<T>(key: string, data: T, ttl?: number): void {
        if (!this.settings.enableCaching) {
            return;
        }

        const entry: CacheEntry<T> = {
            data,
            timestamp: Date.now(),
            ttl: ttl || this.settings.cacheTTL,
            accessCount: 0
        };

        this.cache.set(key, entry);

        // Enforce cache size limit with LRU eviction
        if (this.cache.size > this.settings.cacheSize) {
            this.evictLRU();
        }
    }

    /**
     * Retrieves data from cache
     * @param key - Cache key
     * @returns Cached data or undefined if not found/expired
     */
    getCache<T>(key: string): T | undefined {
        if (!this.settings.enableCaching) {
            return undefined;
        }

        const entry = this.cache.get(key);
        if (!entry) {
            return undefined;
        }

        // Check if entry has expired
        if (Date.now() - entry.timestamp > entry.ttl) {
            this.cache.delete(key);
            return undefined;
        }

        // Update access count for LRU
        entry.accessCount++;
        entry.timestamp = Date.now();

        return entry.data as T;
    }

    /**
     * Clears cache entries
     * @param pattern - Optional pattern to match keys (supports wildcards)
     */
    clearCache(pattern?: string): void {
        if (!pattern) {
            this.cache.clear();
            return;
        }

        const regex = new RegExp(pattern.replace(/\*/g, '.*'));
        for (const key of this.cache.keys()) {
            if (regex.test(key)) {
                this.cache.delete(key);
            }
        }
    }

    /**
     * Measures and records operation performance
     * @param operationName - Name of the operation
     * @param operation - Function to execute and measure
     * @returns Result of the operation
     */
    async measurePerformance<T>(operationName: string, operation: () => Promise<T>): Promise<T> {
        const startTime = Date.now();
        const operationId = `${operationName}-${startTime}`;

        try {
            this.activeOperations.add(operationId);
            const result = await operation();
            
            const duration = Date.now() - startTime;
            this.recordMetric(operationName, duration);
            
            return result;
        } finally {
            this.activeOperations.delete(operationId);
        }
    }

    /**
     * Batches operations to improve performance
     * @param operations - Array of operations to batch
     * @returns Promise resolving to array of results
     */
    async batchOperations<T>(operations: Array<() => Promise<T>>): Promise<T[]> {
        const batches: Array<Array<() => Promise<T>>> = [];
        
        // Split operations into batches
        for (let i = 0; i < operations.length; i += this.settings.batchSize) {
            batches.push(operations.slice(i, i + this.settings.batchSize));
        }

        const results: T[] = [];

        // Process batches sequentially to avoid overwhelming the system
        for (const batch of batches) {
            const batchResults = await Promise.all(batch.map(op => op()));
            results.push(...batchResults);
        }

        return results;
    }

    /**
     * Queues operation for throttled execution
     * @param operation - Operation to queue
     * @returns Promise resolving to operation result
     */
    async queueOperation<T>(operation: () => Promise<T>): Promise<T> {
        return new Promise((resolve, reject) => {
            this.operationQueue.push(async () => {
                try {
                    const result = await operation();
                    resolve(result);
                    return result;
                } catch (error) {
                    reject(error);
                    throw error;
                }
            });

            this.processQueue();
        });
    }

    /**
     * Gets current performance metrics
     * @returns Current performance metrics
     */
    getMetrics(): PerformanceMetrics {
        this.updateMemoryUsage();
        this.updateCacheHitRate();
        this.metrics.activeConnections = this.activeOperations.size;
        this.metrics.lastUpdated = new Date();
        
        return { ...this.metrics };
    }

    /**
     * Updates optimization settings
     * @param newSettings - New optimization settings
     */
    updateSettings(newSettings: Partial<OptimizationSettings>): void {
        this.settings = { ...this.settings, ...newSettings };
        
        // Apply cache size limit if reduced
        if (newSettings.cacheSize && this.cache.size > newSettings.cacheSize) {
            while (this.cache.size > newSettings.cacheSize) {
                this.evictLRU();
            }
        }

        console.log('PerformanceManager: Settings updated', this.settings);
    }

    /**
     * Optimizes memory usage by cleaning up expired entries and running garbage collection
     */
    optimizeMemory(): void {
        // Clean expired cache entries
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (now - entry.timestamp > entry.ttl) {
                this.cache.delete(key);
            }
        }

        // Force garbage collection if available
        if (global.gc) {
            global.gc();
        }

        console.log('PerformanceManager: Memory optimization completed');
    }

    /**
     * Generates performance report
     * @returns Detailed performance report
     */
    generateReport(): string {
        const metrics = this.getMetrics();
        const avgSearchLatency = metrics.searchLatency.length > 0 
            ? metrics.searchLatency.reduce((a, b) => a + b, 0) / metrics.searchLatency.length 
            : 0;

        return `
Performance Report - ${metrics.lastUpdated.toISOString()}
========================================================

Search Performance:
- Average Latency: ${avgSearchLatency.toFixed(2)}ms
- Total Searches: ${metrics.searchLatency.length}

Indexing Performance:
- Last Indexing Time: ${metrics.indexingTime}ms

Memory Usage:
- Current Usage: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB

Cache Performance:
- Hit Rate: ${(metrics.cacheHitRate * 100).toFixed(1)}%
- Cache Size: ${this.cache.size} entries

System:
- Active Operations: ${metrics.activeConnections}
- Queue Length: ${this.operationQueue.length}

Settings:
- Caching Enabled: ${this.settings.enableCaching}
- Cache Size Limit: ${this.settings.cacheSize}
- Cache TTL: ${this.settings.cacheTTL}ms
- Batch Size: ${this.settings.batchSize}
- Max Concurrent Operations: ${this.settings.maxConcurrentOperations}
        `.trim();
    }

    /**
     * Evicts least recently used cache entry
     */
    private evictLRU(): void {
        let oldestKey: string | undefined;
        let oldestTime = Date.now();
        let lowestAccessCount = Infinity;

        for (const [key, entry] of this.cache.entries()) {
            if (entry.accessCount < lowestAccessCount || 
                (entry.accessCount === lowestAccessCount && entry.timestamp < oldestTime)) {
                oldestKey = key;
                oldestTime = entry.timestamp;
                lowestAccessCount = entry.accessCount;
            }
        }

        if (oldestKey) {
            this.cache.delete(oldestKey);
        }
    }

    /**
     * Records performance metric
     */
    private recordMetric(operationName: string, duration: number): void {
        if (operationName.includes('search')) {
            this.metrics.searchLatency.push(duration);
            
            // Keep only last 100 search latencies
            if (this.metrics.searchLatency.length > 100) {
                this.metrics.searchLatency = this.metrics.searchLatency.slice(-100);
            }
        } else if (operationName.includes('index')) {
            this.metrics.indexingTime = duration;
        }
    }

    /**
     * Updates memory usage metric
     */
    private updateMemoryUsage(): void {
        if (process.memoryUsage) {
            this.metrics.memoryUsage = process.memoryUsage().heapUsed;
        }
    }

    /**
     * Updates cache hit rate metric
     */
    private updateCacheHitRate(): void {
        // This would be calculated based on cache hits vs misses
        // For now, we'll estimate based on cache size
        this.metrics.cacheHitRate = Math.min(this.cache.size / this.settings.cacheSize, 1);
    }

    /**
     * Processes the operation queue with throttling
     */
    private async processQueue(): Promise<void> {
        if (this.isProcessingQueue || this.operationQueue.length === 0) {
            return;
        }

        this.isProcessingQueue = true;

        try {
            while (this.operationQueue.length > 0 && 
                   this.activeOperations.size < this.settings.maxConcurrentOperations) {
                
                const operation = this.operationQueue.shift();
                if (operation) {
                    // Execute operation without waiting
                    operation().catch(error => {
                        console.error('PerformanceManager: Queued operation failed:', error);
                    });
                }
            }
        } finally {
            this.isProcessingQueue = false;
            
            // Schedule next processing if queue is not empty
            if (this.operationQueue.length > 0) {
                setTimeout(() => this.processQueue(), 100);
            }
        }
    }

    /**
     * Starts background performance monitoring
     */
    private startPerformanceMonitoring(): void {
        // Update metrics every 30 seconds
        setInterval(() => {
            this.updateMemoryUsage();
            this.updateCacheHitRate();
        }, 30000);

        // Clean up expired cache entries every 5 minutes
        setInterval(() => {
            this.optimizeMemory();
        }, 5 * 60 * 1000);
    }

    /**
     * Disposes of the PerformanceManager and cleans up resources
     */
    dispose(): void {
        this.cache.clear();
        this.operationQueue = [];
        this.activeOperations.clear();
        console.log('PerformanceManager: Disposed');
    }
}
</file>

<file path="webview/e2e/demo.test.ts">
import { expect, test } from '@playwright/test';

test('home page has expected h1', async ({ page }) => {
	await page.goto('/');
	await expect(page.locator('h1')).toBeVisible();
});
</file>

<file path="webview/src/lib/assets/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="107" height="128" viewBox="0 0 107 128"><title>svelte-logo</title><path d="M94.157 22.819c-10.4-14.885-30.94-19.297-45.792-9.835L22.282 29.608A29.92 29.92 0 0 0 8.764 49.65a31.5 31.5 0 0 0 3.108 20.231 30 30 0 0 0-4.477 11.183 31.9 31.9 0 0 0 5.448 24.116c10.402 14.887 30.942 19.297 45.791 9.835l26.083-16.624A29.92 29.92 0 0 0 98.235 78.35a31.53 31.53 0 0 0-3.105-20.232 30 30 0 0 0 4.474-11.182 31.88 31.88 0 0 0-5.447-24.116" style="fill:#ff3e00"/><path d="M45.817 106.582a20.72 20.72 0 0 1-22.237-8.243 19.17 19.17 0 0 1-3.277-14.503 18 18 0 0 1 .624-2.435l.49-1.498 1.337.981a33.6 33.6 0 0 0 10.203 5.098l.97.294-.09.968a5.85 5.85 0 0 0 1.052 3.878 6.24 6.24 0 0 0 6.695 2.485 5.8 5.8 0 0 0 1.603-.704L69.27 76.28a5.43 5.43 0 0 0 2.45-3.631 5.8 5.8 0 0 0-.987-4.371 6.24 6.24 0 0 0-6.698-2.487 5.7 5.7 0 0 0-1.6.704l-9.953 6.345a19 19 0 0 1-5.296 2.326 20.72 20.72 0 0 1-22.237-8.243 19.17 19.17 0 0 1-3.277-14.502 17.99 17.99 0 0 1 8.13-12.052l26.081-16.623a19 19 0 0 1 5.3-2.329 20.72 20.72 0 0 1 22.237 8.243 19.17 19.17 0 0 1 3.277 14.503 18 18 0 0 1-.624 2.435l-.49 1.498-1.337-.98a33.6 33.6 0 0 0-10.203-5.1l-.97-.294.09-.968a5.86 5.86 0 0 0-1.052-3.878 6.24 6.24 0 0 0-6.696-2.485 5.8 5.8 0 0 0-1.602.704L37.73 51.72a5.42 5.42 0 0 0-2.449 3.63 5.79 5.79 0 0 0 .986 4.372 6.24 6.24 0 0 0 6.698 2.486 5.8 5.8 0 0 0 1.602-.704l9.952-6.342a19 19 0 0 1 5.295-2.328 20.72 20.72 0 0 1 22.237 8.242 19.17 19.17 0 0 1 3.277 14.503 18 18 0 0 1-8.13 12.053l-26.081 16.622a19 19 0 0 1-5.3 2.328" style="fill:#fff"/></svg>
</file>

<file path="webview/src/lib/components/ConnectionTester.svelte">
<script lang="ts">
    import { createEventDispatcher } from 'svelte';
    import { registerCoreComponents } from '$lib/utils/fluentUI';
    import { 
        testDatabaseConnection, 
        testProviderConnection,
        type ConnectionTestResult,
        type ConnectionTestStatus,
        type DatabaseTestConfig,
        type ProviderTestConfig
    } from '$lib/utils/connectionTesting';
    import ValidationMessage from './ValidationMessage.svelte';
    import { connectionTestToValidation } from '$lib/utils/connectionTesting';

    // Register Fluent UI components
    registerCoreComponents();

    // Props
    export let type: 'database' | 'provider';
    export let config: DatabaseTestConfig | ProviderTestConfig;
    export let disabled: boolean = false;
    export let autoTest: boolean = false;
    export let showDetails: boolean = true;
    export let compact: boolean = false;

    // State
    let status: ConnectionTestStatus = 'idle';
    let testResult: ConnectionTestResult | null = null;
    let lastTestedConfig: string = '';

    // Event dispatcher
    const dispatch = createEventDispatcher<{
        testStart: void;
        testComplete: { result: ConnectionTestResult };
        testError: { error: string };
    }>();

    // Reactive statements
    $: configString = JSON.stringify(config);
    $: hasConfigChanged = configString !== lastTestedConfig;
    $: canTest = !disabled && config && Object.keys(config).length > 0;
    $: showTestButton = status === 'idle' || status === 'success' || status === 'error';

    // Auto-test when config changes (if enabled)
    $: if (autoTest && hasConfigChanged && canTest && status === 'idle') {
        testConnection();
    }

    /**
     * Test the connection
     */
    async function testConnection(): Promise<void> {
        if (!canTest || status === 'testing') return;

        status = 'testing';
        testResult = null;
        dispatch('testStart');

        try {
            let result: ConnectionTestResult;
            
            if (type === 'database') {
                result = await testDatabaseConnection(config as DatabaseTestConfig);
            } else {
                result = await testProviderConnection(config as ProviderTestConfig);
            }

            testResult = result;
            status = result.success ? 'success' : 'error';
            lastTestedConfig = configString;
            
            dispatch('testComplete', { result });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            testResult = {
                success: false,
                message: `Connection test failed: ${errorMessage}`,
                details: 'Please check your configuration and try again'
            };
            status = 'error';
            
            dispatch('testError', { error: errorMessage });
        }
    }

    /**
     * Reset the test state
     */
    function resetTest(): void {
        status = 'idle';
        testResult = null;
        lastTestedConfig = '';
    }

    /**
     * Get status icon
     */
    function getStatusIcon(currentStatus: ConnectionTestStatus): string {
        switch (currentStatus) {
            case 'testing': return '';
            case 'success': return '';
            case 'error': return '';
            default: return '';
        }
    }

    /**
     * Get status message
     */
    function getStatusMessage(currentStatus: ConnectionTestStatus): string {
        switch (currentStatus) {
            case 'testing': return 'Testing connection...';
            case 'success': return 'Connection successful';
            case 'error': return 'Connection failed';
            default: return 'Ready to test';
        }
    }
</script>

<div class="connection-tester" class:compact>
    <div class="tester-header">
        <div class="status-indicator">
            <span class="status-icon">{getStatusIcon(status)}</span>
            <span class="status-text">{getStatusMessage(status)}</span>
        </div>

        {#if showTestButton}
            <fluent-button
                appearance={status === 'success' ? 'outline' : 'accent'}
                disabled={!canTest || disabled}
                on:click={testConnection}
                on:keydown={(e) => e.key === 'Enter' && testConnection()}
                size={compact ? 'small' : 'medium'}
                role="button"
                tabindex="0"
                aria-label="Test connection"
            >
                {#if hasConfigChanged && status !== 'idle'}
                     Retest
                {:else if status === 'success'}
                     Test Again
                {:else}
                     Test Connection
                {/if}
            </fluent-button>
        {:else if status === 'testing'}
            <div class="testing-indicator">
                <fluent-progress-ring size={compact ? 'small' : 'medium'}></fluent-progress-ring>
                <span class="testing-text">Testing...</span>
            </div>
        {/if}
    </div>

    {#if testResult && showDetails}
        <div class="test-results">
            <ValidationMessage 
                result={connectionTestToValidation(testResult)}
                showIcon={true}
                compact={compact}
                maxMessages={3}
            />

            {#if testResult.success && (testResult.latency || testResult.version)}
                <div class="connection-details">
                    {#if testResult.latency}
                        <div class="detail-item">
                            <span class="detail-label">Latency:</span>
                            <span class="detail-value">{testResult.latency}ms</span>
                        </div>
                    {/if}
                    
                    {#if testResult.version}
                        <div class="detail-item">
                            <span class="detail-label">Version:</span>
                            <span class="detail-value">{testResult.version}</span>
                        </div>
                    {/if}
                </div>
            {/if}
        </div>
    {/if}

    {#if hasConfigChanged && testResult}
        <div class="config-changed-notice">
            <span class="notice-icon"></span>
            <span class="notice-text">Configuration has changed. Test again to verify the new settings.</span>
        </div>
    {/if}
</div>

<style>
    .connection-tester {
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        padding: 16px;
        background-color: var(--vscode-textCodeBlock-background);
        margin: 12px 0;
    }

    .connection-tester.compact {
        padding: 12px;
        margin: 8px 0;
    }

    .tester-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
    }

    .compact .tester-header {
        margin-bottom: 8px;
    }

    .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .status-icon {
        font-size: 16px;
    }

    .compact .status-icon {
        font-size: 14px;
    }

    .status-text {
        font-size: 14px;
        font-weight: 500;
        color: var(--vscode-foreground);
    }

    .compact .status-text {
        font-size: 12px;
    }

    .testing-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .testing-text {
        font-size: 13px;
        color: var(--vscode-descriptionForeground);
    }

    .compact .testing-text {
        font-size: 11px;
    }

    .test-results {
        margin-top: 12px;
    }

    .compact .test-results {
        margin-top: 8px;
    }

    .connection-details {
        margin-top: 8px;
        padding: 8px;
        background-color: var(--vscode-editor-background);
        border-radius: 4px;
        border: 1px solid var(--vscode-panel-border);
    }

    .detail-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
        font-size: 12px;
    }

    .detail-item:last-child {
        margin-bottom: 0;
    }

    .detail-label {
        color: var(--vscode-descriptionForeground);
        font-weight: 500;
    }

    .detail-value {
        color: var(--vscode-foreground);
        font-family: var(--vscode-editor-font-family);
    }

    .config-changed-notice {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
        padding: 6px 8px;
        background-color: var(--vscode-inputValidation-warningBackground);
        border: 1px solid var(--vscode-inputValidation-warningBorder);
        border-radius: 4px;
        font-size: 11px;
        color: var(--vscode-inputValidation-warningForeground);
    }

    .notice-icon {
        flex-shrink: 0;
        font-size: 12px;
    }

    .notice-text {
        flex: 1;
        line-height: 1.3;
    }

    /* Animation for status changes */
    .status-indicator {
        transition: all 0.3s ease;
    }

    .testing-indicator {
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    /* Responsive design */
    @media (max-width: 600px) {
        .tester-header {
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
        }

        .status-indicator {
            justify-content: center;
        }

        .connection-details {
            font-size: 11px;
        }
    }
</style>
</file>

<file path="webview/src/lib/components/IndexingView.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import {
        provideFluentDesignSystem,
        fluentButton,
        fluentProgressRing,
        fluentCard,
        fluentBadge
    } from '@fluentui/web-components';
    import { postMessage, onMessage } from '$lib/vscodeApi';
    import {
        indexingState,
        indexingActions,
        appActions
    } from '$lib/stores/appStore';
    
    // Register Fluent UI components
    provideFluentDesignSystem().register(
        fluentButton(),
        fluentProgressRing(),
        fluentCard(),
        fluentBadge()
    );

    // Component state
    let isIndexing = false;
    let indexingProgress = 0;
    let indexingMessage = 'Ready to start indexing...';
    let filesProcessed = 0;
    let totalFiles = 0;
    let currentFile = '';
    let indexingStats = {
        totalChunks: 0,
        processedChunks: 0,
        errors: 0,
        startTime: null as Date | null,
        estimatedTimeRemaining: ''
    };
    let errorMessage = '';
    let successMessage = '';

    // Message handlers
    let unsubscribeFunctions: (() => void)[] = [];

    onMount(() => {
        // Set up message listeners using the wrapper
        unsubscribeFunctions.push(
            onMessage('indexingStarted', () => {
                indexingActions.startIndexing();
                errorMessage = '';
                successMessage = '';
            }),
            onMessage('indexingProgress', (message) => {
                indexingActions.updateProgress(
                    message.percentage || 0,
                    message.message || 'Indexing in progress...',
                    message.filesProcessed,
                    message.totalFiles,
                    message.currentFile
                );
            }),
            onMessage('indexingCompleted', (message) => {
                indexingActions.completeIndexing(message.success ?? false, message.totalFiles);

                if (message.success) {
                    successMessage = `Indexing completed successfully! Processed ${message.totalFiles || 0} files.`;
                } else {
                    errorMessage = 'Indexing failed. Please check the logs and try again.';
                }
            }),
            onMessage('indexingStopped', () => {
                indexingActions.stopIndexing();
            }),
            onMessage('indexingStatus', (message) => {
                if (message.isIndexing) {
                    indexingActions.startIndexing();
                }
                indexingActions.updateProgress(
                    message.progress || 0,
                    message.message || 'Ready to start indexing...'
                );
            }),
            onMessage('error', (message) => {
                errorMessage = message.message;
                appActions.setError(message.message);
            })
        );

        // Request current indexing status
        postMessage('getIndexingStatus');
    });

    onDestroy(() => {
        // Clean up message listeners
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    });



    function startIndexing() {
        errorMessage = '';
        successMessage = '';
        
        postMessage('startIndexing');
    }

    function stopIndexing() {
        postMessage('stopIndexing');
    }

    function clearMessages() {
        errorMessage = '';
        successMessage = '';
    }

    function formatTime(seconds: number): string {
        if (seconds < 60) {
            return `${Math.round(seconds)}s`;
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.round(seconds % 60);
            return `${minutes}m ${remainingSeconds}s`;
        } else {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }
    }

    function getElapsedTime(): string {
        if (!indexingStats.startTime) return '';
        const elapsed = (Date.now() - indexingStats.startTime.getTime()) / 1000;
        return formatTime(elapsed);
    }

    $: progressPercentage = Math.round(indexingProgress);
    $: fileProgressText = totalFiles > 0 ? `${filesProcessed} / ${totalFiles} files` : '';
</script>

<div class="indexing-view">
    <div class="indexing-header">
        <h1>Code Indexing</h1>
        <p>Monitor the progress of your codebase indexing process.</p>
    </div>

    <!-- Error/Success Messages -->
    {#if errorMessage}
        <div class="notification error">
            {errorMessage}
            <button class="notification-close" on:click={clearMessages}></button>
        </div>
    {/if}

    {#if successMessage}
        <div class="notification success">
            {successMessage}
            <button class="notification-close" on:click={clearMessages}></button>
        </div>
    {/if}

    <!-- Main Indexing Status -->
    <fluent-card class="indexing-status">
        <div class="status-header">
            <h2>Indexing Status</h2>
            <fluent-badge 
                appearance={isIndexing ? 'accent' : (successMessage ? 'success' : 'neutral')}
            >
                {isIndexing ? 'In Progress' : (successMessage ? 'Completed' : 'Ready')}
            </fluent-badge>
        </div>

        <div class="progress-section">
            <div class="progress-info">
                <span class="progress-label">{indexingMessage}</span>
                <span class="progress-percentage">{progressPercentage}%</span>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" style="width: {progressPercentage}%"></div>
            </div>

            {#if fileProgressText}
                <div class="file-progress">
                    {fileProgressText}
                </div>
            {/if}

            {#if currentFile}
                <div class="current-file">
                    Processing: <code>{currentFile}</code>
                </div>
            {/if}
        </div>

        <div class="action-section">
            {#if isIndexing}
                <fluent-button
                    appearance="accent"
                    on:click={stopIndexing}
                    role="button"
                    tabindex="0"
                    on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && stopIndexing()}
                >
                    Stop Indexing
                </fluent-button>
            {:else}
                <fluent-button
                    appearance="accent"
                    on:click={startIndexing}
                    role="button"
                    tabindex="0"
                    on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && startIndexing()}
                >
                    <span class="button-icon"></span>
                    Start Indexing
                </fluent-button>
            {/if}
        </div>
    </fluent-card>

    <!-- Indexing Statistics -->
    {#if isIndexing || indexingStats.totalChunks > 0}
        <fluent-card class="indexing-stats">
            <h3>Statistics</h3>
            
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Files Processed</span>
                    <span class="stat-value">{filesProcessed}</span>
                </div>
                
                <div class="stat-item">
                    <span class="stat-label">Total Files</span>
                    <span class="stat-value">{totalFiles}</span>
                </div>
                
                <div class="stat-item">
                    <span class="stat-label">Chunks Created</span>
                    <span class="stat-value">{indexingStats.processedChunks}</span>
                </div>
                
                <div class="stat-item">
                    <span class="stat-label">Errors</span>
                    <span class="stat-value" class:error={indexingStats.errors > 0}>
                        {indexingStats.errors}
                    </span>
                </div>
                
                {#if indexingStats.startTime}
                    <div class="stat-item">
                        <span class="stat-label">Elapsed Time</span>
                        <span class="stat-value">{getElapsedTime()}</span>
                    </div>
                {/if}
                
                {#if indexingStats.estimatedTimeRemaining}
                    <div class="stat-item">
                        <span class="stat-label">Est. Remaining</span>
                        <span class="stat-value">{indexingStats.estimatedTimeRemaining}</span>
                    </div>
                {/if}
            </div>
        </fluent-card>
    {/if}

    <!-- Progress Ring for Active Indexing -->
    {#if isIndexing}
        <div class="progress-ring-container">
            <fluent-progress-ring></fluent-progress-ring>
        </div>
    {/if}
</div>

<style>
    .indexing-view {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        font-family: var(--vscode-font-family);
    }

    .indexing-header {
        text-align: center;
        margin-bottom: 30px;
    }

    .indexing-header h1 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
        font-size: 28px;
    }

    .indexing-header p {
        margin: 0;
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
    }

    .indexing-status {
        margin-bottom: 20px;
        padding: 20px;
    }

    .status-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .status-header h2 {
        margin: 0;
        color: var(--vscode-textLink-foreground);
    }

    .progress-section {
        margin-bottom: 20px;
    }

    .progress-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .progress-label {
        color: var(--vscode-foreground);
        font-weight: 500;
    }

    .progress-percentage {
        color: var(--vscode-textLink-foreground);
        font-weight: bold;
    }

    .progress-bar {
        width: 100%;
        height: 12px;
        background-color: var(--vscode-progressBar-background);
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 10px;
    }

    .progress-fill {
        height: 100%;
        background-color: var(--vscode-progressBar-foreground);
        transition: width 0.3s ease;
        border-radius: 6px;
    }

    .file-progress {
        font-size: 14px;
        color: var(--vscode-descriptionForeground);
        margin-bottom: 5px;
    }

    .current-file {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
    }

    .current-file code {
        background-color: var(--vscode-textCodeBlock-background);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: var(--vscode-editor-font-family);
    }

    .action-section {
        text-align: center;
    }

    .button-icon {
        margin-right: 8px;
    }

    .indexing-stats {
        margin-bottom: 20px;
        padding: 20px;
    }

    .indexing-stats h3 {
        margin: 0 0 15px 0;
        color: var(--vscode-textLink-foreground);
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
    }

    .stat-item {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    .stat-label {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
        text-transform: uppercase;
        font-weight: 500;
    }

    .stat-value {
        font-size: 18px;
        font-weight: bold;
        color: var(--vscode-foreground);
    }

    .stat-value.error {
        color: var(--vscode-errorForeground);
    }

    .progress-ring-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
    }

    .notification {
        padding: 12px 16px;
        border-radius: 4px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .notification.error {
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        color: var(--vscode-inputValidation-errorForeground);
    }

    .notification.success {
        background-color: var(--vscode-charts-green);
        color: white;
    }

    .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
        margin-left: 10px;
    }
</style>
</file>

<file path="webview/src/lib/components/QueryView.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import {
        provideFluentDesignSystem,
        fluentButton,
        fluentTextField,
        fluentCard,
        fluentBadge,
        fluentAccordion,
        fluentAccordionItem
    } from '@fluentui/web-components';
    import { postMessage, onMessage } from '$lib/vscodeApi';
    import {
        searchState,
        searchActions,
        appActions
    } from '$lib/stores/appStore';
    
    // Register Fluent UI components
    provideFluentDesignSystem().register(
        fluentButton(),
        fluentTextField(),
        fluentCard(),
        fluentBadge(),
        fluentAccordion(),
        fluentAccordionItem()
    );

    // Component state
    let searchQuery = '';
    let isSearching = false;
    let searchResults: SearchResult[] = [];
    let searchHistory: string[] = [];
    let errorMessage = '';
    let searchStats = {
        totalResults: 0,
        searchTime: 0,
        query: ''
    };

    interface SearchResult {
        id: string;
        file: string;
        content: string;
        score: number;
        lineNumber?: number;
        context?: string;
        relatedFiles?: RelatedFile[];
    }

    interface RelatedFile {
        file: string;
        score: number;
        reason: string;
    }

    // Message handlers
    let unsubscribeFunctions: (() => void)[] = [];

    onMount(() => {
        // Set up message listeners using the wrapper
        unsubscribeFunctions.push(
            onMessage('searchResults', (message) => {
                isSearching = false;
                searchResults = message.results || [];
                searchStats = {
                    totalResults: message.totalResults || 0,
                    searchTime: message.searchTime || 0,
                    query: message.query || ''
                };

                if (searchResults.length === 0 && searchQuery.trim()) {
                    errorMessage = 'No results found for your query.';
                }
            }),
            onMessage('searchHistory', (message) => {
                searchHistory = message.history || [];
            }),
            onMessage('searchError', (message) => {
                isSearching = false;
                errorMessage = message.message || 'Search failed. Please try again.';
            }),
            onMessage('error', (message) => {
                errorMessage = message.message;
            })
        );

        // Request search history
        postMessage('getSearchHistory');
    });

    onDestroy(() => {
        // Clean up message listeners
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    });



    function handleSearch() {
        if (!searchQuery.trim()) {
            errorMessage = 'Please enter a search query.';
            return;
        }
        
        isSearching = true;
        errorMessage = '';
        searchResults = [];
        
        postMessage('search', {
            query: searchQuery.trim()
        });
    }

    function handleKeyPress(event: KeyboardEvent) {
        if (event.key === 'Enter') {
            handleSearch();
        }
    }

    function selectHistoryItem(query: string) {
        searchQuery = query;
        handleSearch();
    }

    function openFile(filePath: string, lineNumber?: number) {
        postMessage('openFile', {
            file: filePath,
            line: lineNumber
        });
    }

    function clearMessages() {
        errorMessage = '';
    }

    function formatSearchTime(ms: number): string {
        if (ms < 1000) {
            return `${Math.round(ms)}ms`;
        } else {
            return `${(ms / 1000).toFixed(2)}s`;
        }
    }

    function getScoreColor(score: number): string {
        if (score >= 0.8) return 'var(--vscode-charts-green)';
        if (score >= 0.6) return 'var(--vscode-charts-yellow)';
        if (score >= 0.4) return 'var(--vscode-charts-orange)';
        return 'var(--vscode-charts-red)';
    }

    function truncateContent(content: string, maxLength: number = 200): string {
        if (content.length <= maxLength) return content;
        return content.substring(0, maxLength) + '...';
    }
</script>

<div class="query-view">
    <div class="query-header">
        <h1>Code Search</h1>
        <p>Search through your indexed codebase using semantic similarity.</p>
    </div>

    <!-- Search Input -->
    <fluent-card class="search-section">
        <div class="search-input-container">
            <fluent-text-field
                placeholder="Enter your search query (e.g., 'function that handles user authentication')"
                value={searchQuery}
                on:input={(e: Event) => searchQuery = (e.target as HTMLInputElement).value}
                on:keypress={handleKeyPress}
                class="search-input"
                size="large"
                role="textbox"
                tabindex="0"
            ></fluent-text-field>

            <fluent-button
                appearance="accent"
                disabled={isSearching || !searchQuery.trim()}
                on:click={handleSearch}
                on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && handleSearch()}
                class="search-button"
                role="button"
                tabindex="0"
            >
                {#if isSearching}
                    Searching...
                {:else}
                     Search
                {/if}
            </fluent-button>
        </div>

        {#if searchStats.query && searchStats.totalResults > 0}
            <div class="search-stats">
                Found {searchStats.totalResults} results for "{searchStats.query}" 
                in {formatSearchTime(searchStats.searchTime)}
            </div>
        {/if}
    </fluent-card>

    <!-- Error Messages -->
    {#if errorMessage}
        <div class="notification error">
            {errorMessage}
            <button class="notification-close" on:click={clearMessages}></button>
        </div>
    {/if}

    <!-- Search History -->
    {#if searchHistory.length > 0 && !isSearching && searchResults.length === 0}
        <fluent-card class="search-history">
            <h3>Recent Searches</h3>
            <div class="history-items">
                {#each searchHistory.slice(0, 5) as historyItem}
                    <button 
                        class="history-item"
                        on:click={() => selectHistoryItem(historyItem)}
                    >
                        {historyItem}
                    </button>
                {/each}
            </div>
        </fluent-card>
    {/if}

    <!-- Search Results -->
    {#if searchResults.length > 0}
        <div class="results-section">
            {#each searchResults as result}
                <fluent-card class="result-item">
                    <div class="result-header">
                        <div class="result-file">
                            <button 
                                class="file-link"
                                on:click={() => openFile(result.file, result.lineNumber)}
                            >
                                 {result.file}
                                {#if result.lineNumber}
                                    <span class="line-number">:{result.lineNumber}</span>
                                {/if}
                            </button>
                        </div>
                        
                        <fluent-badge 
                            style="background-color: {getScoreColor(result.score)}"
                        >
                            {Math.round(result.score * 100)}%
                        </fluent-badge>
                    </div>

                    <div class="result-content">
                        <pre><code>{truncateContent(result.content)}</code></pre>
                    </div>

                    {#if result.context}
                        <div class="result-context">
                            <strong>Context:</strong> {result.context}
                        </div>
                    {/if}

                    {#if result.relatedFiles && result.relatedFiles.length > 0}
                        <fluent-accordion class="related-files">
                            <fluent-accordion-item>
                                <span slot="heading">Related Files ({result.relatedFiles.length})</span>
                                <div class="related-files-list">
                                    {#each result.relatedFiles as relatedFile}
                                        <div class="related-file">
                                            <button 
                                                class="file-link"
                                                on:click={() => openFile(relatedFile.file)}
                                            >
                                                 {relatedFile.file}
                                            </button>
                                            <span class="related-reason">{relatedFile.reason}</span>
                                            <fluent-badge>
                                                {Math.round(relatedFile.score * 100)}%
                                            </fluent-badge>
                                        </div>
                                    {/each}
                                </div>
                            </fluent-accordion-item>
                        </fluent-accordion>
                    {/if}
                </fluent-card>
            {/each}
        </div>
    {/if}

    <!-- Loading State -->
    {#if isSearching}
        <fluent-card class="loading-state">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <p>Searching through your codebase...</p>
            </div>
        </fluent-card>
    {/if}

    <!-- Empty State -->
    {#if !isSearching && searchResults.length === 0 && !searchQuery.trim() && searchHistory.length === 0}
        <fluent-card class="empty-state">
            <div class="empty-content">
                <div class="empty-icon"></div>
                <h3>Ready to Search</h3>
                <p>Enter a search query above to find relevant code in your indexed codebase.</p>
                <div class="search-tips">
                    <h4>Search Tips:</h4>
                    <ul>
                        <li>Use natural language: "function that validates email"</li>
                        <li>Describe functionality: "code that handles file uploads"</li>
                        <li>Ask questions: "how to connect to database"</li>
                    </ul>
                </div>
            </div>
        </fluent-card>
    {/if}
</div>

<style>
    .query-view {
        max-width: 1000px;
        margin: 0 auto;
        padding: 20px;
        font-family: var(--vscode-font-family);
    }

    .query-header {
        text-align: center;
        margin-bottom: 30px;
    }

    .query-header h1 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
        font-size: 28px;
    }

    .query-header p {
        margin: 0;
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
    }

    .search-section {
        margin-bottom: 20px;
        padding: 20px;
    }

    .search-input-container {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-bottom: 10px;
    }

    .search-input {
        flex: 1;
    }

    .search-button {
        min-width: 120px;
    }

    .search-stats {
        font-size: 14px;
        color: var(--vscode-descriptionForeground);
        text-align: center;
    }

    .search-history {
        margin-bottom: 20px;
        padding: 20px;
    }

    .search-history h3 {
        margin: 0 0 15px 0;
        color: var(--vscode-textLink-foreground);
    }

    .history-items {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
    }

    .history-item {
        padding: 8px 12px;
        border: 1px solid var(--vscode-panel-border);
        border-radius: 4px;
        background-color: var(--vscode-sideBar-background);
        color: var(--vscode-foreground);
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        transition: background-color 0.2s ease;
    }

    .history-item:hover {
        background-color: var(--vscode-list-hoverBackground);
    }

    .results-section {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .result-item {
        padding: 20px;
    }

    .result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .result-file {
        flex: 1;
    }

    .file-link {
        background: none;
        border: none;
        color: var(--vscode-textLink-foreground);
        cursor: pointer;
        font-family: inherit;
        font-size: 16px;
        font-weight: 500;
        text-decoration: underline;
        padding: 0;
    }

    .file-link:hover {
        color: var(--vscode-textLink-activeForeground);
    }

    .line-number {
        color: var(--vscode-descriptionForeground);
        font-weight: normal;
    }

    .result-content {
        margin-bottom: 15px;
    }

    .result-content pre {
        margin: 0;
        padding: 15px;
        background-color: var(--vscode-textCodeBlock-background);
        border-radius: 4px;
        overflow-x: auto;
        font-family: var(--vscode-editor-font-family);
        font-size: 14px;
        line-height: 1.4;
    }

    .result-content code {
        color: var(--vscode-foreground);
    }

    .result-context {
        margin-bottom: 15px;
        padding: 10px;
        background-color: var(--vscode-sideBar-background);
        border-radius: 4px;
        font-size: 14px;
        color: var(--vscode-foreground);
    }

    .related-files {
        margin-top: 15px;
    }

    .related-files-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 10px 0;
    }

    .related-file {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px;
        background-color: var(--vscode-sideBar-background);
        border-radius: 4px;
    }

    .related-reason {
        flex: 1;
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
    }

    .loading-state {
        padding: 40px;
        text-align: center;
    }

    .loading-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    .loading-spinner {
        width: 32px;
        height: 32px;
        border: 3px solid var(--vscode-panel-border);
        border-top: 3px solid var(--vscode-button-background);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .empty-state {
        padding: 40px;
        text-align: center;
    }

    .empty-content {
        max-width: 500px;
        margin: 0 auto;
    }

    .empty-icon {
        font-size: 48px;
        margin-bottom: 20px;
    }

    .empty-content h3 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
    }

    .empty-content p {
        margin: 0 0 20px 0;
        color: var(--vscode-descriptionForeground);
    }

    .search-tips {
        text-align: left;
        background-color: var(--vscode-sideBar-background);
        padding: 20px;
        border-radius: 6px;
    }

    .search-tips h4 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
    }

    .search-tips ul {
        margin: 0;
        padding-left: 20px;
        color: var(--vscode-foreground);
    }

    .search-tips li {
        margin-bottom: 5px;
    }

    .notification {
        padding: 12px 16px;
        border-radius: 4px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .notification.error {
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        color: var(--vscode-inputValidation-errorForeground);
    }

    .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
        margin-left: 10px;
    }
</style>
</file>

<file path="webview/src/lib/components/ValidatedInput.svelte">
<script lang="ts">
    import { onMount, createEventDispatcher } from 'svelte';
    import type { ValidationResult } from '$lib/utils/validation';
    import { createDebouncedValidator } from '$lib/utils/validation';
    import { registerFormComponents } from '$lib/utils/fluentUI';

    // Register required Fluent UI components
    registerFormComponents();

    // Props
    export let value: string = '';
    export let type: 'text' | 'password' | 'url' | 'number' | 'select' = 'text';
    export let placeholder: string = '';
    export let label: string = '';
    export let required: boolean = false;
    export let disabled: boolean = false;
    export let options: { value: string; label: string }[] = []; // For select type
    export let validator: ((value: string) => ValidationResult) | null = null;
    export let validateOnChange: boolean = true;
    export let validateOnBlur: boolean = true;
    export let debounceMs: number = 300;
    export let showValidationIcon: boolean = true;
    export let size: 'small' | 'medium' | 'large' = 'medium';

    // State
    let validationResult: ValidationResult | null = null;
    let isValidating: boolean = false;
    let hasBeenTouched: boolean = false;
    let inputElement: HTMLElement | null = null;

    // Event dispatcher
    const dispatch = createEventDispatcher<{
        input: { value: string; isValid: boolean };
        validation: { result: ValidationResult };
        blur: { value: string };
        focus: { value: string };
    }>();

    // Create debounced validator
    let debouncedValidator: ((value: string) => Promise<ValidationResult>) | null = null;
    
    $: if (validator) {
        debouncedValidator = createDebouncedValidator(validator, debounceMs);
    }

    // Validation state
    $: isValid = validationResult?.isValid ?? true;
    $: hasErrors = (validationResult?.errors?.length ?? 0) > 0;
    $: hasWarnings = (validationResult?.warnings?.length ?? 0) > 0;
    $: hasSuggestions = (validationResult?.suggestions?.length ?? 0) > 0;

    // CSS classes based on validation state
    $: validationClass = hasBeenTouched ? (hasErrors ? 'error' : isValid ? 'valid' : '') : '';

    /**
     * Perform validation
     */
    async function performValidation(inputValue: string, immediate: boolean = false): Promise<void> {
        if (!validator || !hasBeenTouched) return;

        isValidating = true;

        try {
            let result: ValidationResult;
            
            if (immediate || !debouncedValidator) {
                result = validator(inputValue);
            } else {
                result = await debouncedValidator(inputValue);
            }

            validationResult = result;
            dispatch('validation', { result });
        } catch (error) {
            console.error('Validation error:', error);
            validationResult = {
                isValid: false,
                errors: ['Validation failed'],
                warnings: [],
                suggestions: []
            };
        } finally {
            isValidating = false;
        }
    }

    /**
     * Handle input change
     */
    function handleInput(event: Event): void {
        const target = event.target as HTMLInputElement | HTMLSelectElement;
        value = target.value;
        hasBeenTouched = true;

        dispatch('input', { value, isValid });

        if (validateOnChange) {
            performValidation(value);
        }
    }

    /**
     * Handle input blur
     */
    function handleBlur(event: Event): void {
        const target = event.target as HTMLInputElement | HTMLSelectElement;
        hasBeenTouched = true;
        
        dispatch('blur', { value: target.value });

        if (validateOnBlur) {
            performValidation(value, true);
        }
    }

    /**
     * Handle input focus
     */
    function handleFocus(event: Event): void {
        const target = event.target as HTMLInputElement | HTMLSelectElement;
        dispatch('focus', { value: target.value });
    }

    /**
     * Clear validation state
     */
    export function clearValidation(): void {
        validationResult = null;
        hasBeenTouched = false;
        isValidating = false;
    }

    /**
     * Trigger immediate validation
     */
    export function validate(): Promise<ValidationResult | null> {
        hasBeenTouched = true;
        if (validator) {
            performValidation(value, true);
            return Promise.resolve(validationResult);
        }
        return Promise.resolve(null);
    }

    /**
     * Focus the input
     */
    export function focus(): void {
        if (inputElement) {
            inputElement.focus();
        }
    }

    onMount(() => {
        // Initial validation if value is provided
        if (value && validator) {
            performValidation(value, true);
        }
    });
</script>

<div class="validated-input {validationClass}" class:disabled>
    {#if label}
        <label for="input-{label}" class="input-label">
            {label}
            {#if required}
                <span class="required-indicator">*</span>
            {/if}
        </label>
    {/if}

    <div class="input-container">
        {#if type === 'select'}
            <fluent-select
                bind:this={inputElement}
                id="input-{label}"
                {value}
                {disabled}
                on:change={handleInput}
                on:blur={handleBlur}
                on:focus={handleFocus}
                class="input-field {size}"
                role="combobox"
                aria-label={label || placeholder}
                aria-invalid={hasErrors}
                aria-expanded="false"
                aria-controls="options-{label}"
                aria-describedby={hasErrors || hasWarnings || hasSuggestions ? `validation-${label}` : undefined}
            >
                {#if placeholder}
                    <fluent-option value="">{placeholder}</fluent-option>
                {/if}
                {#each options as option}
                    <fluent-option value={option.value}>{option.label}</fluent-option>
                {/each}
            </fluent-select>
        {:else}
            <fluent-text-field
                bind:this={inputElement}
                id="input-{label}"
                {type}
                {value}
                {placeholder}
                {disabled}
                on:input={handleInput}
                on:blur={handleBlur}
                on:focus={handleFocus}
                class="input-field {size}"
                role="textbox"
                aria-label={label || placeholder}
                aria-invalid={hasErrors}
                aria-describedby={hasErrors || hasWarnings || hasSuggestions ? `validation-${label}` : undefined}
            ></fluent-text-field>
        {/if}

        {#if showValidationIcon && hasBeenTouched}
            <div class="validation-icon">
                {#if isValidating}
                    <div class="loading-spinner"></div>
                {:else if hasErrors}
                    <span class="error-icon" title="Validation errors"></span>
                {:else if isValid}
                    <span class="success-icon" title="Valid"></span>
                {/if}
            </div>
        {/if}
    </div>

    {#if validationResult && hasBeenTouched && (hasErrors || hasWarnings || hasSuggestions)}
        <div id="validation-{label}" class="validation-messages" role="alert" aria-live="polite">
            {#if hasErrors}
                <div class="validation-errors">
                    {#each validationResult.errors as error}
                        <div class="validation-message error">
                            <span class="message-icon"></span>
                            <span class="message-text">{error}</span>
                        </div>
                    {/each}
                </div>
            {/if}

            {#if hasWarnings}
                <div class="validation-warnings">
                    {#each validationResult.warnings as warning}
                        <div class="validation-message warning">
                            <span class="message-icon"></span>
                            <span class="message-text">{warning}</span>
                        </div>
                    {/each}
                </div>
            {/if}

            {#if hasSuggestions}
                <div class="validation-suggestions">
                    {#each validationResult.suggestions as suggestion}
                        <div class="validation-message suggestion">
                            <span class="message-icon"></span>
                            <span class="message-text">{suggestion}</span>
                        </div>
                    {/each}
                </div>
            {/if}
        </div>
    {/if}
</div>

<style>
    .validated-input {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
    }

    .validated-input.disabled {
        opacity: 0.6;
        pointer-events: none;
    }

    .input-label {
        font-size: 14px;
        font-weight: 500;
        color: var(--vscode-foreground);
        margin-bottom: 4px;
    }

    .required-indicator {
        color: var(--vscode-errorForeground);
        margin-left: 2px;
    }

    .input-container {
        position: relative;
        display: flex;
        align-items: center;
    }

    .input-field {
        flex: 1;
        transition: border-color 0.2s ease;
    }

    .input-field.small {
        font-size: 12px;
    }

    .input-field.medium {
        font-size: 14px;
    }

    .input-field.large {
        font-size: 16px;
    }

    .validated-input.error .input-field {
        border-color: var(--vscode-inputValidation-errorBorder);
        background-color: var(--vscode-inputValidation-errorBackground);
    }

    .validated-input.valid .input-field {
        border-color: var(--vscode-charts-green);
    }

    .validation-icon {
        position: absolute;
        right: 8px;
        display: flex;
        align-items: center;
        pointer-events: none;
    }

    .loading-spinner {
        width: 16px;
        height: 16px;
        border: 2px solid var(--vscode-panel-border);
        border-top: 2px solid var(--vscode-button-background);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .error-icon, .success-icon {
        font-size: 16px;
    }

    .validation-messages {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .validation-message {
        display: flex;
        align-items: flex-start;
        gap: 6px;
        font-size: 12px;
        line-height: 1.4;
        padding: 4px 0;
    }

    .validation-message.error {
        color: var(--vscode-inputValidation-errorForeground);
    }

    .validation-message.warning {
        color: var(--vscode-inputValidation-warningForeground);
    }

    .validation-message.suggestion {
        color: var(--vscode-textLink-foreground);
    }

    .message-icon {
        flex-shrink: 0;
        font-size: 12px;
        margin-top: 1px;
    }

    .message-text {
        flex: 1;
    }

    /* Responsive design */
    @media (max-width: 600px) {
        .validated-input {
            margin-bottom: 12px;
        }

        .validation-message {
            font-size: 11px;
        }
    }
</style>
</file>

<file path="webview/src/lib/components/ValidatedInput.test.ts">
/**
 * ValidatedInput Component Integration Tests
 * 
 * Tests for the ValidatedInput component including user interactions,
 * validation behavior, and event handling.
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, fireEvent, waitFor } from '@testing-library/svelte';
import ValidatedInput from './ValidatedInput.svelte';
import { validators } from '$lib/utils/validation';

describe('ValidatedInput Component', () => {
	beforeEach(() => {
		vi.clearAllMocks();
	});

	describe('Basic Rendering', () => {
		it('should render text input with label', () => {
			const { getByLabelText, getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					placeholder: 'Enter text'
				}
			});

			expect(getByText('Test Input')).toBeInTheDocument();
			expect(getByLabelText('Test Input')).toBeInTheDocument();
		});

		it('should render select input with options', () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'select',
					label: 'Test Select',
					value: '',
					options: [
						{ value: 'option1', label: 'Option 1' },
						{ value: 'option2', label: 'Option 2' }
					]
				}
			});

			const select = getByLabelText('Test Select');
			expect(select).toBeInTheDocument();
			expect(select.tagName.toLowerCase()).toBe('fluent-select');
		});

		it('should show required indicator when required', () => {
			const { getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Required Input',
					required: true
				}
			});

			expect(getByText('*')).toBeInTheDocument();
		});

		it('should be disabled when disabled prop is true', () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Disabled Input',
					disabled: true
				}
			});

			const input = getByLabelText('Disabled Input');
			expect(input).toHaveAttribute('disabled');
		});
	});

	describe('User Interactions', () => {
		it('should emit input event when value changes', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: ''
				}
			});

			const inputEvents: any[] = [];
			component.$on('input', (event) => {
				inputEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'test value' } });

			expect(inputEvents).toHaveLength(1);
			expect(inputEvents[0]).toEqual({
				value: 'test value',
				isValid: true
			});
		});

		it('should emit blur event when input loses focus', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'initial'
				}
			});

			const blurEvents: any[] = [];
			component.$on('blur', (event) => {
				blurEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			await fireEvent.blur(input);

			expect(blurEvents).toHaveLength(1);
			expect(blurEvents[0]).toEqual({ value: 'initial' });
		});

		it('should emit focus event when input gains focus', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'initial'
				}
			});

			const focusEvents: any[] = [];
			component.$on('focus', (event) => {
				focusEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			await fireEvent.focus(input);

			expect(focusEvents).toHaveLength(1);
			expect(focusEvents[0]).toEqual({ value: 'initial' });
		});
	});

	describe('Validation Behavior', () => {
		it('should validate on input when validateOnChange is true', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required,
					validateOnChange: true
				}
			});

			const validationEvents: any[] = [];
			component.$on('validation', (event) => {
				validationEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			
			// First input should trigger validation
			await fireEvent.input(input, { target: { value: '' } });
			await waitFor(() => {
				expect(validationEvents.length).toBeGreaterThan(0);
			});

			// Should show validation error for empty required field
			expect(validationEvents[0].result.isValid).toBe(false);
			expect(validationEvents[0].result.errors).toContain('Field is required');
		});

		it('should validate on blur when validateOnBlur is true', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required,
					validateOnChange: false,
					validateOnBlur: true
				}
			});

			const validationEvents: any[] = [];
			component.$on('validation', (event) => {
				validationEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			
			// Input should not trigger validation
			await fireEvent.input(input, { target: { value: '' } });
			expect(validationEvents).toHaveLength(0);

			// Blur should trigger validation
			await fireEvent.blur(input);
			await waitFor(() => {
				expect(validationEvents.length).toBeGreaterThan(0);
			});

			expect(validationEvents[0].result.isValid).toBe(false);
		});

		it('should show validation icon when validation is complete', async () => {
			const { getByLabelText, container } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'valid value',
					validator: validators.required,
					showValidationIcon: true
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'valid value' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				const successIcon = container.querySelector('.success-icon');
				expect(successIcon).toBeInTheDocument();
			});
		});

		it('should show error icon for invalid input', async () => {
			const { getByLabelText, container } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required,
					showValidationIcon: true
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				const errorIcon = container.querySelector('.error-icon');
				expect(errorIcon).toBeInTheDocument();
			});
		});

		it('should show loading spinner during validation', async () => {
			const slowValidator = vi.fn(() => {
				return new Promise(resolve => {
					setTimeout(() => resolve(validators.required('test')), 100);
				});
			});

			const { getByLabelText, container } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: slowValidator,
					showValidationIcon: true,
					debounceMs: 0
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'test' } });

			// Should show loading spinner
			const loadingSpinner = container.querySelector('.loading-spinner');
			expect(loadingSpinner).toBeInTheDocument();
		});
	});

	describe('Validation Messages', () => {
		it('should display error messages', async () => {
			const { getByLabelText, getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				expect(getByText('Field is required')).toBeInTheDocument();
			});
		});

		it('should display warning messages', async () => {
			const warningValidator = () => ({
				isValid: true,
				errors: [],
				warnings: ['This is a warning'],
				suggestions: []
			});

			const { getByLabelText, getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'test',
					validator: warningValidator
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'test' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				expect(getByText('This is a warning')).toBeInTheDocument();
			});
		});

		it('should display suggestion messages', async () => {
			const suggestionValidator = () => ({
				isValid: true,
				errors: [],
				warnings: [],
				suggestions: ['This is a suggestion']
			});

			const { getByLabelText, getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'test',
					validator: suggestionValidator
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'test' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				expect(getByText('This is a suggestion')).toBeInTheDocument();
			});
		});
	});

	describe('Accessibility', () => {
		it('should have proper ARIA attributes', () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: ''
				}
			});

			const input = getByLabelText('Test Input');
			expect(input).toHaveAttribute('role', 'textbox');
			expect(input).toHaveAttribute('aria-label', 'Test Input');
		});

		it('should set aria-invalid when validation fails', async () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				expect(input).toHaveAttribute('aria-invalid', 'true');
			});
		});

		it('should associate validation messages with input', async () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				const describedBy = input.getAttribute('aria-describedby');
				expect(describedBy).toContain('validation-Test Input');
			});
		});
	});

	describe('Component Methods', () => {
		it('should clear validation when clearValidation is called', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			// Wait for validation to complete
			await waitFor(() => {
				expect(input).toHaveAttribute('aria-invalid', 'true');
			});

			// Clear validation
			component.clearValidation();

			// Validation should be cleared
			expect(input).not.toHaveAttribute('aria-invalid');
		});

		it('should trigger validation when validate is called', async () => {
			const { component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const validationEvents: any[] = [];
			component.$on('validation', (event) => {
				validationEvents.push(event.detail);
			});

			// Trigger validation manually
			await component.validate();

			expect(validationEvents).toHaveLength(1);
			expect(validationEvents[0].result.isValid).toBe(false);
		});
	});
});
</file>

<file path="webview/src/lib/components/ValidationMessage.svelte">
<script lang="ts">
    import { createEventDispatcher } from 'svelte';
    import type { ValidationResult } from '$lib/utils/validation';

    // Props
    export let result: ValidationResult | null = null;
    export let showIcon: boolean = true;
    export let showDismiss: boolean = false;
    export let compact: boolean = false;
    export let maxMessages: number = 5;

    // Event dispatcher
    const dispatch = createEventDispatcher<{
        dismiss: void;
    }>();

    // Computed properties
    $: hasErrors = result?.errors.length > 0;
    $: hasWarnings = result?.warnings.length > 0;
    $: hasSuggestions = result?.suggestions.length > 0;
    $: hasAnyMessages = hasErrors || hasWarnings || hasSuggestions;

    // Get the primary message type for styling
    $: primaryType = hasErrors ? 'error' : hasWarnings ? 'warning' : 'suggestion';

    // Truncate messages if needed
    $: displayErrors = result?.errors.slice(0, maxMessages) || [];
    $: displayWarnings = result?.warnings.slice(0, maxMessages) || [];
    $: displaySuggestions = result?.suggestions.slice(0, maxMessages) || [];
    $: hasMoreMessages = (result?.errors.length || 0) + (result?.warnings.length || 0) + (result?.suggestions.length || 0) > maxMessages;

    function handleDismiss(): void {
        dispatch('dismiss');
    }

    function getIcon(type: 'error' | 'warning' | 'suggestion'): string {
        switch (type) {
            case 'error': return '';
            case 'warning': return '';
            case 'suggestion': return '';
            default: return '';
        }
    }
</script>

{#if result && hasAnyMessages}
    <div 
        class="validation-message-container {primaryType}" 
        class:compact
        role="alert" 
        aria-live="polite"
    >
        <div class="validation-content">
            {#if showIcon}
                <div class="validation-icon">
                    {getIcon(primaryType)}
                </div>
            {/if}

            <div class="validation-messages">
                <!-- Error messages -->
                {#if hasErrors}
                    <div class="message-group errors">
                        {#each displayErrors as error}
                            <div class="message-item error">
                                {#if !showIcon || compact}
                                    <span class="inline-icon">{getIcon('error')}</span>
                                {/if}
                                <span class="message-text">{error}</span>
                            </div>
                        {/each}
                    </div>
                {/if}

                <!-- Warning messages -->
                {#if hasWarnings}
                    <div class="message-group warnings">
                        {#each displayWarnings as warning}
                            <div class="message-item warning">
                                {#if !showIcon || compact}
                                    <span class="inline-icon">{getIcon('warning')}</span>
                                {/if}
                                <span class="message-text">{warning}</span>
                            </div>
                        {/each}
                    </div>
                {/if}

                <!-- Suggestion messages -->
                {#if hasSuggestions}
                    <div class="message-group suggestions">
                        {#each displaySuggestions as suggestion}
                            <div class="message-item suggestion">
                                {#if !showIcon || compact}
                                    <span class="inline-icon">{getIcon('suggestion')}</span>
                                {/if}
                                <span class="message-text">{suggestion}</span>
                            </div>
                        {/each}
                    </div>
                {/if}

                <!-- More messages indicator -->
                {#if hasMoreMessages}
                    <div class="more-messages">
                        <span class="more-text">
                            ... and {((result?.errors.length || 0) + (result?.warnings.length || 0) + (result?.suggestions.length || 0)) - maxMessages} more message{((result?.errors.length || 0) + (result?.warnings.length || 0) + (result?.suggestions.length || 0)) - maxMessages === 1 ? '' : 's'}
                        </span>
                    </div>
                {/if}
            </div>

            {#if showDismiss}
                <button 
                    class="dismiss-button"
                    on:click={handleDismiss}
                    on:keydown={(e) => e.key === 'Enter' && handleDismiss()}
                    aria-label="Dismiss validation messages"
                    title="Dismiss"
                >
                    
                </button>
            {/if}
        </div>
    </div>
{/if}

<style>
    .validation-message-container {
        border-radius: 4px;
        padding: 12px;
        margin: 8px 0;
        border-left: 4px solid;
        background-color: var(--vscode-textCodeBlock-background);
        transition: all 0.2s ease;
    }

    .validation-message-container.compact {
        padding: 8px;
        margin: 4px 0;
    }

    .validation-message-container.error {
        border-left-color: var(--vscode-inputValidation-errorBorder);
        background-color: var(--vscode-inputValidation-errorBackground);
    }

    .validation-message-container.warning {
        border-left-color: var(--vscode-inputValidation-warningBorder);
        background-color: var(--vscode-inputValidation-warningBackground);
    }

    .validation-message-container.suggestion {
        border-left-color: var(--vscode-textLink-foreground);
        background-color: var(--vscode-textCodeBlock-background);
    }

    .validation-content {
        display: flex;
        align-items: flex-start;
        gap: 8px;
    }

    .validation-icon {
        flex-shrink: 0;
        font-size: 16px;
        margin-top: 2px;
    }

    .compact .validation-icon {
        font-size: 14px;
        margin-top: 1px;
    }

    .validation-messages {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .compact .validation-messages {
        gap: 4px;
    }

    .message-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .compact .message-group {
        gap: 2px;
    }

    .message-item {
        display: flex;
        align-items: flex-start;
        gap: 6px;
        font-size: 13px;
        line-height: 1.4;
    }

    .compact .message-item {
        font-size: 12px;
        gap: 4px;
    }

    .message-item.error {
        color: var(--vscode-inputValidation-errorForeground);
    }

    .message-item.warning {
        color: var(--vscode-inputValidation-warningForeground);
    }

    .message-item.suggestion {
        color: var(--vscode-textLink-foreground);
    }

    .inline-icon {
        flex-shrink: 0;
        font-size: 12px;
        margin-top: 1px;
    }

    .compact .inline-icon {
        font-size: 10px;
    }

    .message-text {
        flex: 1;
        word-break: break-word;
    }

    .more-messages {
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px solid var(--vscode-panel-border);
    }

    .more-text {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
        font-style: italic;
    }

    .dismiss-button {
        flex-shrink: 0;
        background: none;
        border: none;
        color: var(--vscode-foreground);
        cursor: pointer;
        font-size: 14px;
        padding: 2px 4px;
        border-radius: 2px;
        transition: background-color 0.2s ease;
        margin-top: -2px;
    }

    .dismiss-button:hover {
        background-color: var(--vscode-list-hoverBackground);
    }

    .dismiss-button:focus {
        outline: 1px solid var(--vscode-focusBorder);
        outline-offset: 1px;
    }

    /* Animation for new messages */
    .validation-message-container {
        animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Responsive design */
    @media (max-width: 600px) {
        .validation-message-container {
            padding: 8px;
            margin: 6px 0;
        }

        .message-item {
            font-size: 12px;
        }

        .validation-icon {
            font-size: 14px;
        }
    }
</style>
</file>

<file path="webview/src/lib/stores/appStore.test.ts">
/**
 * App Store Unit Tests
 * 
 * Tests for the centralized application state management stores.
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { get } from 'svelte/store';
import {
	appState,
	setupState,
	indexingState,
	searchState,
	appActions,
	setupActions,
	indexingActions,
	searchActions,
	isSetupComplete,
	canStartIndexing,
	hasSearchResults,
	currentError,
	resetAllState
} from './appStore';

describe('App Store', () => {
	beforeEach(() => {
		// Reset all state before each test
		resetAllState();
	});

	describe('appState', () => {
		it('should have correct initial state', () => {
			const state = get(appState);
			expect(state).toEqual({
				isInitialized: false,
				isLoading: false,
				error: null,
				lastActivity: null
			});
		});

		it('should initialize correctly', () => {
			appActions.initialize();
			const state = get(appState);
			
			expect(state.isInitialized).toBe(true);
			expect(state.lastActivity).toBeInstanceOf(Date);
		});

		it('should set loading state', () => {
			appActions.setLoading(true);
			expect(get(appState).isLoading).toBe(true);
			
			appActions.setLoading(false);
			expect(get(appState).isLoading).toBe(false);
		});

		it('should set and clear errors', () => {
			const errorMessage = 'Test error';
			appActions.setError(errorMessage);
			expect(get(appState).error).toBe(errorMessage);
			
			appActions.clearError();
			expect(get(appState).error).toBe(null);
		});

		it('should update activity timestamp', () => {
			const beforeTime = Date.now();
			appActions.updateActivity();
			const afterTime = Date.now();
			
			const lastActivity = get(appState).lastActivity;
			expect(lastActivity).toBeInstanceOf(Date);
			expect(lastActivity!.getTime()).toBeGreaterThanOrEqual(beforeTime);
			expect(lastActivity!.getTime()).toBeLessThanOrEqual(afterTime);
		});
	});

	describe('setupState', () => {
		it('should have correct initial state', () => {
			const state = get(setupState);
			expect(state).toEqual({
				databaseStatus: 'idle',
				providerStatus: 'idle',
				selectedDatabase: '',
				selectedProvider: '',
				isSetupComplete: false,
				setupErrors: []
			});
		});

		it('should update database status', () => {
			setupActions.setDatabaseStatus('starting');
			expect(get(setupState).databaseStatus).toBe('starting');
			
			setupActions.setDatabaseStatus('ready');
			expect(get(setupState).databaseStatus).toBe('ready');
		});

		it('should update provider status', () => {
			setupActions.setProviderStatus('starting');
			expect(get(setupState).providerStatus).toBe('starting');
			
			setupActions.setProviderStatus('ready');
			expect(get(setupState).providerStatus).toBe('ready');
		});

		it('should update selected database and reset status', () => {
			setupActions.setDatabaseStatus('ready');
			setupActions.setSelectedDatabase('qdrant');
			
			const state = get(setupState);
			expect(state.selectedDatabase).toBe('qdrant');
			expect(state.databaseStatus).toBe('idle');
		});

		it('should manage setup errors', () => {
			const error1 = 'Database connection failed';
			const error2 = 'Provider authentication failed';
			
			setupActions.addSetupError(error1);
			expect(get(setupState).setupErrors).toEqual([error1]);
			
			setupActions.addSetupError(error2);
			expect(get(setupState).setupErrors).toEqual([error1, error2]);
			
			setupActions.clearSetupErrors();
			expect(get(setupState).setupErrors).toEqual([]);
		});
	});

	describe('indexingState', () => {
		it('should have correct initial state', () => {
			const state = get(indexingState);
			expect(state.isIndexing).toBe(false);
			expect(state.progress).toBe(0);
			expect(state.message).toBe('Ready to start indexing...');
			expect(state.filesProcessed).toBe(0);
			expect(state.totalFiles).toBe(0);
			expect(state.currentFile).toBe('');
		});

		it('should start indexing', () => {
			const beforeTime = Date.now();
			indexingActions.startIndexing();
			const afterTime = Date.now();
			
			const state = get(indexingState);
			expect(state.isIndexing).toBe(true);
			expect(state.progress).toBe(0);
			expect(state.message).toBe('Starting indexing process...');
			expect(state.stats.startTime).toBeInstanceOf(Date);
			expect(state.stats.startTime!.getTime()).toBeGreaterThanOrEqual(beforeTime);
			expect(state.stats.startTime!.getTime()).toBeLessThanOrEqual(afterTime);
		});

		it('should update progress', () => {
			indexingActions.updateProgress(50, 'Processing files...', 25, 50, 'test.js');
			
			const state = get(indexingState);
			expect(state.progress).toBe(50);
			expect(state.message).toBe('Processing files...');
			expect(state.filesProcessed).toBe(25);
			expect(state.totalFiles).toBe(50);
			expect(state.currentFile).toBe('test.js');
		});

		it('should complete indexing successfully', () => {
			indexingActions.startIndexing();
			indexingActions.completeIndexing(true, 100);
			
			const state = get(indexingState);
			expect(state.isIndexing).toBe(false);
			expect(state.progress).toBe(100);
			expect(state.message).toBe('Indexing completed successfully!');
			expect(state.totalFiles).toBe(100);
		});

		it('should handle indexing failure', () => {
			indexingActions.startIndexing();
			indexingActions.completeIndexing(false);
			
			const state = get(indexingState);
			expect(state.isIndexing).toBe(false);
			expect(state.message).toBe('Indexing failed.');
		});

		it('should stop indexing', () => {
			indexingActions.startIndexing();
			indexingActions.stopIndexing();
			
			const state = get(indexingState);
			expect(state.isIndexing).toBe(false);
			expect(state.message).toBe('Indexing stopped by user.');
		});
	});

	describe('searchState', () => {
		it('should have correct initial state', () => {
			const state = get(searchState);
			expect(state.query).toBe('');
			expect(state.isSearching).toBe(false);
			expect(state.results).toEqual([]);
			expect(state.history).toEqual([]);
		});

		it('should set query', () => {
			searchActions.setQuery('test query');
			expect(get(searchState).query).toBe('test query');
		});

		it('should start search', () => {
			searchActions.setResults([{ id: '1', file: 'test.js', content: 'test', score: 0.9 }], {
				totalResults: 1,
				searchTime: 100,
				query: 'test'
			});
			
			searchActions.startSearch();
			const state = get(searchState);
			expect(state.isSearching).toBe(true);
			expect(state.results).toEqual([]);
		});

		it('should set search results and update history', () => {
			const results = [
				{ id: '1', file: 'test.js', content: 'test content', score: 0.9 },
				{ id: '2', file: 'app.js', content: 'app content', score: 0.8 }
			];
			const stats = {
				totalResults: 2,
				searchTime: 150,
				query: 'test query'
			};

			searchActions.setQuery('test query');
			searchActions.setResults(results, stats);
			
			const state = get(searchState);
			expect(state.isSearching).toBe(false);
			expect(state.results).toEqual(results);
			expect(state.stats).toEqual(stats);
			expect(state.history).toContain('test query');
		});

		it('should not duplicate queries in history', () => {
			searchActions.setQuery('test query');
			searchActions.setResults([], { totalResults: 0, searchTime: 100, query: 'test query' });
			searchActions.setResults([], { totalResults: 0, searchTime: 100, query: 'test query' });
			
			const state = get(searchState);
			expect(state.history.filter(q => q === 'test query')).toHaveLength(1);
		});

		it('should limit history to 10 items', () => {
			for (let i = 0; i < 15; i++) {
				searchActions.setQuery(`query ${i}`);
				searchActions.setResults([], { totalResults: 0, searchTime: 100, query: `query ${i}` });
			}
			
			const state = get(searchState);
			expect(state.history).toHaveLength(10);
			expect(state.history[0]).toBe('query 14'); // Most recent first
		});
	});

	describe('Derived Stores', () => {
		it('isSetupComplete should be true when both database and provider are ready', () => {
			expect(get(isSetupComplete)).toBe(false);
			
			setupActions.setDatabaseStatus('ready');
			expect(get(isSetupComplete)).toBe(false);
			
			setupActions.setProviderStatus('ready');
			expect(get(isSetupComplete)).toBe(true);
		});

		it('canStartIndexing should be true when setup is complete and not indexing', () => {
			expect(get(canStartIndexing)).toBe(false);
			
			setupActions.setDatabaseStatus('ready');
			setupActions.setProviderStatus('ready');
			expect(get(canStartIndexing)).toBe(true);
			
			indexingActions.startIndexing();
			expect(get(canStartIndexing)).toBe(false);
		});

		it('hasSearchResults should reflect search results state', () => {
			expect(get(hasSearchResults)).toBe(false);
			
			searchActions.setResults([{ id: '1', file: 'test.js', content: 'test', score: 0.9 }], {
				totalResults: 1,
				searchTime: 100,
				query: 'test'
			});
			expect(get(hasSearchResults)).toBe(true);
		});

		it('currentError should return the first available error', () => {
			expect(get(currentError)).toBe(null);
			
			appActions.setError('App error');
			expect(get(currentError)).toBe('App error');
			
			appActions.clearError();
			setupActions.addSetupError('Setup error');
			expect(get(currentError)).toBe('Setup error');
		});
	});

	describe('resetAllState', () => {
		it('should reset all stores to initial state', () => {
			// Modify all stores
			appActions.initialize();
			appActions.setError('Test error');
			setupActions.setDatabaseStatus('ready');
			setupActions.setSelectedDatabase('qdrant');
			indexingActions.startIndexing();
			searchActions.setQuery('test');
			
			// Reset all state
			resetAllState();
			
			// Verify all stores are back to initial state
			expect(get(appState).isInitialized).toBe(false);
			expect(get(appState).error).toBe(null);
			expect(get(setupState).databaseStatus).toBe('idle');
			expect(get(setupState).selectedDatabase).toBe('');
			expect(get(indexingState).isIndexing).toBe(false);
			expect(get(searchState).query).toBe('');
		});
	});
});
</file>

<file path="webview/src/lib/stores/appStore.ts">
/**
 * Application State Store
 * 
 * Centralized state management for the Code Context Engine application.
 * This store manages the overall application state and coordinates between different feature stores.
 */

import { writable, derived, type Readable } from 'svelte/store';
import { currentView, type ViewType } from './viewStore';

// Application-wide state interfaces
export interface AppState {
    isInitialized: boolean;
    isLoading: boolean;
    error: string | null;
    lastActivity: Date | null;
}

export interface SetupState {
    databaseStatus: 'idle' | 'starting' | 'ready' | 'error';
    providerStatus: 'idle' | 'starting' | 'ready' | 'error';
    selectedDatabase: string;
    selectedProvider: string;
    isSetupComplete: boolean;
    setupErrors: string[];
}

export interface IndexingState {
    isIndexing: boolean;
    progress: number;
    message: string;
    filesProcessed: number;
    totalFiles: number;
    currentFile: string;
    stats: {
        totalChunks: number;
        processedChunks: number;
        errors: number;
        startTime: Date | null;
        estimatedTimeRemaining: string;
    };
}

export interface SearchState {
    query: string;
    isSearching: boolean;
    results: SearchResult[];
    history: string[];
    stats: {
        totalResults: number;
        searchTime: number;
        query: string;
    };
}

export interface SearchResult {
    id: string;
    file: string;
    content: string;
    score: number;
    lineNumber?: number;
    context?: string;
    relatedFiles?: RelatedFile[];
}

export interface RelatedFile {
    file: string;
    score: number;
    reason: string;
}

// Create individual stores
export const appState = writable<AppState>({
    isInitialized: false,
    isLoading: false,
    error: null,
    lastActivity: null
});

export const setupState = writable<SetupState>({
    databaseStatus: 'idle',
    providerStatus: 'idle',
    selectedDatabase: '',
    selectedProvider: '',
    isSetupComplete: false,
    setupErrors: []
});

export const indexingState = writable<IndexingState>({
    isIndexing: false,
    progress: 0,
    message: 'Ready to start indexing...',
    filesProcessed: 0,
    totalFiles: 0,
    currentFile: '',
    stats: {
        totalChunks: 0,
        processedChunks: 0,
        errors: 0,
        startTime: null,
        estimatedTimeRemaining: ''
    }
});

export const searchState = writable<SearchState>({
    query: '',
    isSearching: false,
    results: [],
    history: [],
    stats: {
        totalResults: 0,
        searchTime: 0,
        query: ''
    }
});

// Derived stores for computed values
export const isSetupComplete: Readable<boolean> = derived(
    setupState,
    ($setupState) => $setupState.databaseStatus === 'ready' && $setupState.providerStatus === 'ready'
);

export const canStartIndexing: Readable<boolean> = derived(
    [setupState, indexingState],
    ([$setupState, $indexingState]) => 
        $setupState.databaseStatus === 'ready' && 
        $setupState.providerStatus === 'ready' && 
        !$indexingState.isIndexing
);

export const hasSearchResults: Readable<boolean> = derived(
    searchState,
    ($searchState) => $searchState.results.length > 0
);

export const currentError: Readable<string | null> = derived(
    [appState, setupState],
    ([$appState, $setupState]) => {
        if ($appState.error) return $appState.error;
        if ($setupState.setupErrors.length > 0) return $setupState.setupErrors[0];
        return null;
    }
);

// Action creators for updating state
export const appActions = {
    initialize: () => {
        appState.update(state => ({
            ...state,
            isInitialized: true,
            lastActivity: new Date()
        }));
    },

    setLoading: (loading: boolean) => {
        appState.update(state => ({
            ...state,
            isLoading: loading,
            lastActivity: new Date()
        }));
    },

    setError: (error: string | null) => {
        appState.update(state => ({
            ...state,
            error,
            lastActivity: new Date()
        }));
    },

    clearError: () => {
        appState.update(state => ({
            ...state,
            error: null
        }));
        setupState.update(state => ({
            ...state,
            setupErrors: []
        }));
    },

    updateActivity: () => {
        appState.update(state => ({
            ...state,
            lastActivity: new Date()
        }));
    }
};

export const setupActions = {
    setDatabaseStatus: (status: SetupState['databaseStatus']) => {
        setupState.update(state => ({
            ...state,
            databaseStatus: status
        }));
    },

    setProviderStatus: (status: SetupState['providerStatus']) => {
        setupState.update(state => ({
            ...state,
            providerStatus: status
        }));
    },

    setSelectedDatabase: (database: string) => {
        setupState.update(state => ({
            ...state,
            selectedDatabase: database,
            databaseStatus: 'idle'
        }));
    },

    setSelectedProvider: (provider: string) => {
        setupState.update(state => ({
            ...state,
            selectedProvider: provider,
            providerStatus: 'idle'
        }));
    },

    addSetupError: (error: string) => {
        setupState.update(state => ({
            ...state,
            setupErrors: [...state.setupErrors, error]
        }));
    },

    clearSetupErrors: () => {
        setupState.update(state => ({
            ...state,
            setupErrors: []
        }));
    }
};

export const indexingActions = {
    startIndexing: () => {
        indexingState.update(state => ({
            ...state,
            isIndexing: true,
            progress: 0,
            message: 'Starting indexing process...',
            stats: {
                ...state.stats,
                startTime: new Date(),
                errors: 0
            }
        }));
    },

    updateProgress: (progress: number, message: string, filesProcessed?: number, totalFiles?: number, currentFile?: string) => {
        indexingState.update(state => ({
            ...state,
            progress,
            message,
            filesProcessed: filesProcessed ?? state.filesProcessed,
            totalFiles: totalFiles ?? state.totalFiles,
            currentFile: currentFile ?? state.currentFile
        }));
    },

    completeIndexing: (success: boolean, totalFiles?: number) => {
        indexingState.update(state => ({
            ...state,
            isIndexing: false,
            progress: success ? 100 : state.progress,
            message: success ? 'Indexing completed successfully!' : 'Indexing failed.',
            totalFiles: totalFiles ?? state.totalFiles
        }));
    },

    stopIndexing: () => {
        indexingState.update(state => ({
            ...state,
            isIndexing: false,
            message: 'Indexing stopped by user.'
        }));
    }
};

export const searchActions = {
    setQuery: (query: string) => {
        searchState.update(state => ({
            ...state,
            query
        }));
    },

    startSearch: () => {
        searchState.update(state => ({
            ...state,
            isSearching: true,
            results: []
        }));
    },

    setResults: (results: SearchResult[], stats: SearchState['stats']) => {
        searchState.update(state => ({
            ...state,
            isSearching: false,
            results,
            stats,
            history: state.query && !state.history.includes(state.query) 
                ? [state.query, ...state.history.slice(0, 9)] 
                : state.history
        }));
    },

    setSearchError: () => {
        searchState.update(state => ({
            ...state,
            isSearching: false,
            results: []
        }));
    },

    setHistory: (history: string[]) => {
        searchState.update(state => ({
            ...state,
            history
        }));
    }
};

// Helper function to reset all state (useful for testing or cleanup)
export const resetAllState = () => {
    appState.set({
        isInitialized: false,
        isLoading: false,
        error: null,
        lastActivity: null
    });

    setupState.set({
        databaseStatus: 'idle',
        providerStatus: 'idle',
        selectedDatabase: '',
        selectedProvider: '',
        isSetupComplete: false,
        setupErrors: []
    });

    indexingState.set({
        isIndexing: false,
        progress: 0,
        message: 'Ready to start indexing...',
        filesProcessed: 0,
        totalFiles: 0,
        currentFile: '',
        stats: {
            totalChunks: 0,
            processedChunks: 0,
            errors: 0,
            startTime: null,
            estimatedTimeRemaining: ''
        }
    });

    searchState.set({
        query: '',
        isSearching: false,
        results: [],
        history: [],
        stats: {
            totalResults: 0,
            searchTime: 0,
            query: ''
        }
    });
};
</file>

<file path="webview/src/lib/stores/persistence.ts">
/**
 * State Persistence Utility
 * 
 * Handles saving and loading application state using VS Code's webview state API.
 * This ensures that the application state persists across webview reloads.
 */

import { getState, setState } from '$lib/vscodeApi';
import { 
    appState, 
    setupState, 
    indexingState, 
    searchState,
    type AppState,
    type SetupState,
    type IndexingState,
    type SearchState
} from './appStore';

// State keys for persistence
const STATE_KEYS = {
    APP: 'app',
    SETUP: 'setup',
    INDEXING: 'indexing',
    SEARCH: 'search'
} as const;

// Interface for persisted state
interface PersistedState {
    app?: Partial<AppState>;
    setup?: Partial<SetupState>;
    indexing?: Partial<IndexingState>;
    search?: Partial<SearchState>;
    version?: string;
    timestamp?: number;
}

// Current state version for migration purposes
const STATE_VERSION = '1.0.0';

/**
 * Save current application state to VS Code's webview state
 */
export function saveState(): void {
    try {
        // Get current state values
        let currentAppState: AppState;
        let currentSetupState: SetupState;
        let currentIndexingState: IndexingState;
        let currentSearchState: SearchState;

        // Subscribe to get current values
        const unsubscribeApp = appState.subscribe(state => currentAppState = state);
        const unsubscribeSetup = setupState.subscribe(state => currentSetupState = state);
        const unsubscribeIndexing = indexingState.subscribe(state => currentIndexingState = state);
        const unsubscribeSearch = searchState.subscribe(state => currentSearchState = state);

        // Clean up subscriptions immediately
        unsubscribeApp();
        unsubscribeSetup();
        unsubscribeIndexing();
        unsubscribeSearch();

        // Create persisted state object
        const persistedState: PersistedState = {
            app: {
                isInitialized: currentAppState!.isInitialized,
                error: null, // Don't persist errors
                lastActivity: currentAppState!.lastActivity
            },
            setup: {
                databaseStatus: currentSetupState!.databaseStatus,
                providerStatus: currentSetupState!.providerStatus,
                selectedDatabase: currentSetupState!.selectedDatabase,
                selectedProvider: currentSetupState!.selectedProvider,
                isSetupComplete: currentSetupState!.isSetupComplete,
                setupErrors: [] // Don't persist errors
            },
            indexing: {
                isIndexing: false, // Don't persist active indexing state
                progress: currentIndexingState!.progress,
                message: currentIndexingState!.message,
                filesProcessed: currentIndexingState!.filesProcessed,
                totalFiles: currentIndexingState!.totalFiles,
                currentFile: '', // Don't persist current file
                stats: {
                    ...currentIndexingState!.stats,
                    startTime: null // Don't persist start time
                }
            },
            search: {
                query: currentSearchState!.query,
                isSearching: false, // Don't persist active search state
                results: [], // Don't persist results (they may be stale)
                history: currentSearchState!.history,
                stats: currentSearchState!.stats
            },
            version: STATE_VERSION,
            timestamp: Date.now()
        };

        // Save to VS Code state
        setState(persistedState);
        
        console.log('State saved successfully');
    } catch (error) {
        console.error('Failed to save state:', error);
    }
}

/**
 * Load application state from VS Code's webview state
 */
export function loadState(): void {
    try {
        const persistedState = getState() as PersistedState | null;
        
        if (!persistedState) {
            console.log('No persisted state found, using defaults');
            return;
        }

        // Check version compatibility
        if (persistedState.version !== STATE_VERSION) {
            console.warn(`State version mismatch. Expected ${STATE_VERSION}, got ${persistedState.version}. Using defaults.`);
            return;
        }

        // Check if state is too old (older than 24 hours)
        const maxAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
        if (persistedState.timestamp && (Date.now() - persistedState.timestamp) > maxAge) {
            console.log('Persisted state is too old, using defaults');
            return;
        }

        // Restore app state
        if (persistedState.app) {
            appState.update(current => ({
                ...current,
                ...persistedState.app,
                isLoading: false, // Always start with loading false
                error: null // Never restore errors
            }));
        }

        // Restore setup state
        if (persistedState.setup) {
            setupState.update(current => ({
                ...current,
                ...persistedState.setup,
                setupErrors: [] // Never restore errors
            }));
        }

        // Restore indexing state
        if (persistedState.indexing) {
            indexingState.update(current => ({
                ...current,
                ...persistedState.indexing,
                isIndexing: false, // Never restore active indexing
                currentFile: '', // Don't restore current file
                stats: {
                    ...current.stats,
                    ...persistedState.indexing.stats,
                    startTime: null // Don't restore start time
                }
            }));
        }

        // Restore search state
        if (persistedState.search) {
            searchState.update(current => ({
                ...current,
                ...persistedState.search,
                isSearching: false, // Never restore active search
                results: [] // Don't restore stale results
            }));
        }

        console.log('State loaded successfully');
    } catch (error) {
        console.error('Failed to load state:', error);
    }
}

/**
 * Clear all persisted state
 */
export function clearPersistedState(): void {
    try {
        setState(null);
        console.log('Persisted state cleared');
    } catch (error) {
        console.error('Failed to clear persisted state:', error);
    }
}

/**
 * Set up automatic state saving
 * This will save state whenever any store changes
 */
export function setupAutoSave(): () => void {
    const unsubscribeFunctions: (() => void)[] = [];
    
    // Debounce save operations to avoid excessive saves
    let saveTimeout: NodeJS.Timeout | null = null;
    
    const debouncedSave = () => {
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        saveTimeout = setTimeout(() => {
            saveState();
            saveTimeout = null;
        }, 1000); // Save 1 second after last change
    };

    // Subscribe to all stores
    unsubscribeFunctions.push(
        appState.subscribe(debouncedSave),
        setupState.subscribe(debouncedSave),
        indexingState.subscribe(debouncedSave),
        searchState.subscribe(debouncedSave)
    );

    // Return cleanup function
    return () => {
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
    };
}

/**
 * Initialize persistence system
 * Call this once when the application starts
 */
export function initializePersistence(): () => void {
    // Load existing state
    loadState();
    
    // Set up auto-save
    const cleanupAutoSave = setupAutoSave();
    
    // Save state when the page is about to unload
    const handleBeforeUnload = () => {
        saveState();
    };
    
    if (typeof window !== 'undefined') {
        window.addEventListener('beforeunload', handleBeforeUnload);
    }
    
    // Return cleanup function
    return () => {
        cleanupAutoSave();
        if (typeof window !== 'undefined') {
            window.removeEventListener('beforeunload', handleBeforeUnload);
        }
    };
}
</file>

<file path="webview/src/lib/stores/viewStore.ts">
import { writable } from 'svelte/store';

/**
 * Type definition for the different views available in the application
 */
export type ViewType = 'setup' | 'indexing' | 'query' | 'diagnostics';

/**
 * Writable store to manage the currently active view
 * Default value is 'setup' as users typically start with setup
 */
export const currentView = writable<ViewType>('setup');

/**
 * Helper function to set the current view
 * @param view - The view to switch to
 */
export function setCurrentView(view: ViewType) {
    currentView.set(view);
}

/**
 * Helper function to get the current view value
 * @returns Promise that resolves to the current view
 */
export function getCurrentView(): Promise<ViewType> {
    return new Promise((resolve) => {
        const unsubscribe = currentView.subscribe((view) => {
            unsubscribe();
            resolve(view);
        });
    });
}
</file>

<file path="webview/src/lib/utils/animations.ts">
/**
 * Animation Utilities
 * 
 * Provides smooth, performant animations and transitions for the application.
 * Uses CSS transforms and will-change properties for optimal performance.
 */

// Animation configuration
export interface AnimationConfig {
    duration?: number;
    easing?: string;
    delay?: number;
    fill?: 'none' | 'forwards' | 'backwards' | 'both';
}

// Default animation settings
export const DEFAULT_ANIMATION: AnimationConfig = {
    duration: 300,
    easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    delay: 0,
    fill: 'both'
};

// Easing functions
export const EASINGS = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'cubic-bezier(0.4, 0.0, 1, 1)',
    easeOut: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
    easeInOut: 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    bounceIn: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
    bounceOut: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
    spring: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)'
} as const;

/**
 * Fade in animation
 */
export function fadeIn(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    // Optimize for performance
    element.style.willChange = 'opacity';
    
    const animation = element.animate([
        { opacity: 0 },
        { opacity: 1 }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    // Clean up will-change after animation
    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Fade out animation
 */
export function fadeOut(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    element.style.willChange = 'opacity';
    
    const animation = element.animate([
        { opacity: 1 },
        { opacity: 0 }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Slide in from top animation
 */
export function slideInFromTop(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    element.style.willChange = 'transform, opacity';
    
    const animation = element.animate([
        { 
            transform: 'translateY(-20px)',
            opacity: 0
        },
        { 
            transform: 'translateY(0)',
            opacity: 1
        }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Slide in from bottom animation
 */
export function slideInFromBottom(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    element.style.willChange = 'transform, opacity';
    
    const animation = element.animate([
        { 
            transform: 'translateY(20px)',
            opacity: 0
        },
        { 
            transform: 'translateY(0)',
            opacity: 1
        }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Scale in animation
 */
export function scaleIn(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    element.style.willChange = 'transform, opacity';
    
    const animation = element.animate([
        { 
            transform: 'scale(0.9)',
            opacity: 0
        },
        { 
            transform: 'scale(1)',
            opacity: 1
        }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Pulse animation for loading states
 */
export function pulse(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration = 1000, easing = EASINGS.easeInOut } = config;
    
    element.style.willChange = 'opacity';
    
    const animation = element.animate([
        { opacity: 1 },
        { opacity: 0.5 },
        { opacity: 1 }
    ], {
        duration,
        easing,
        iterations: Infinity
    });

    return animation;
}

/**
 * Shake animation for errors
 */
export function shake(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration = 500, easing = EASINGS.easeInOut } = config;
    
    element.style.willChange = 'transform';
    
    const animation = element.animate([
        { transform: 'translateX(0)' },
        { transform: 'translateX(-10px)' },
        { transform: 'translateX(10px)' },
        { transform: 'translateX(-10px)' },
        { transform: 'translateX(10px)' },
        { transform: 'translateX(0)' }
    ], {
        duration,
        easing
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Bounce animation for success states
 */
export function bounce(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration = 600, easing = EASINGS.bounceOut } = config;
    
    element.style.willChange = 'transform';
    
    const animation = element.animate([
        { transform: 'scale(1)' },
        { transform: 'scale(1.1)' },
        { transform: 'scale(0.95)' },
        { transform: 'scale(1.05)' },
        { transform: 'scale(1)' }
    ], {
        duration,
        easing
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Progress bar animation
 */
export function animateProgress(element: HTMLElement, fromPercent: number, toPercent: number, config: AnimationConfig = {}): Animation {
    const { duration = 500, easing = EASINGS.easeOut } = config;
    
    element.style.willChange = 'width';
    
    const animation = element.animate([
        { width: `${fromPercent}%` },
        { width: `${toPercent}%` }
    ], {
        duration,
        easing,
        fill: 'forwards'
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Stagger animations for lists
 */
export function staggerIn(elements: HTMLElement[], config: AnimationConfig = {}): Animation[] {
    const { delay = 0 } = config;
    const staggerDelay = 100; // 100ms between each element
    
    return elements.map((element, index) => {
        return slideInFromBottom(element, {
            ...config,
            delay: delay + (index * staggerDelay)
        });
    });
}

/**
 * Create a smooth transition between two states
 */
export function transition(
    element: HTMLElement,
    fromStyles: Partial<CSSStyleDeclaration>,
    toStyles: Partial<CSSStyleDeclaration>,
    config: AnimationConfig = {}
): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    // Set will-change for all properties that will be animated
    const properties = Object.keys(toStyles);
    element.style.willChange = properties.join(', ');
    
    const keyframes = [fromStyles, toStyles];
    
    const animation = element.animate(keyframes, {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Create a loading spinner animation
 */
export function spin(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration = 1000, easing = EASINGS.linear } = config;
    
    element.style.willChange = 'transform';
    
    const animation = element.animate([
        { transform: 'rotate(0deg)' },
        { transform: 'rotate(360deg)' }
    ], {
        duration,
        easing,
        iterations: Infinity
    });

    return animation;
}

/**
 * Animate element entrance based on intersection observer
 */
export function animateOnIntersection(
    element: HTMLElement,
    animationFunction: (el: HTMLElement) => Animation,
    options: IntersectionObserverInit = {}
): IntersectionObserver {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                animationFunction(entry.target as HTMLElement);
                observer.unobserve(entry.target);
            }
        });
    }, {
        threshold: 0.1,
        ...options
    });

    observer.observe(element);
    return observer;
}

/**
 * Prefers reduced motion check
 */
export function prefersReducedMotion(): boolean {
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
}

/**
 * Animate with respect to user preferences
 */
export function respectfulAnimate(
    element: HTMLElement,
    animationFunction: (el: HTMLElement, config?: AnimationConfig) => Animation,
    config: AnimationConfig = {}
): Animation | null {
    if (prefersReducedMotion()) {
        // Skip animation or use a very fast one
        return animationFunction(element, { ...config, duration: 0 });
    }
    
    return animationFunction(element, config);
}
</file>

<file path="webview/src/lib/utils/connectionTesting.ts">
/**
 * Connection Testing Utilities
 * 
 * Provides functionality to test database and provider connections
 * with real-time feedback and validation.
 */

import { postMessage } from '$lib/vscodeApi';
import type { ValidationResult } from './validation';

// Connection test result interface
export interface ConnectionTestResult {
    success: boolean;
    message: string;
    details?: string;
    latency?: number;
    version?: string;
    capabilities?: string[];
}

// Connection test status
export type ConnectionTestStatus = 'idle' | 'testing' | 'success' | 'error';

// Database configuration for testing
export interface DatabaseTestConfig {
    type: 'qdrant' | 'chromadb' | 'pinecone';
    host?: string;
    port?: number;
    apiKey?: string;
    environment?: string;
    collection?: string;
}

// Provider configuration for testing
export interface ProviderTestConfig {
    type: 'ollama' | 'openai' | 'azure';
    apiKey?: string;
    endpoint?: string;
    model?: string;
}

/**
 * Test database connection
 */
export async function testDatabaseConnection(config: DatabaseTestConfig): Promise<ConnectionTestResult> {
    const startTime = Date.now();
    
    try {
        // Send test request to extension
        const response = await sendConnectionTestRequest('testDatabase', config);
        const latency = Date.now() - startTime;
        
        if (response.success) {
            return {
                success: true,
                message: `Successfully connected to ${config.type}`,
                details: response.details || `Connection established in ${latency}ms`,
                latency,
                version: response.version,
                capabilities: response.capabilities
            };
        } else {
            return {
                success: false,
                message: response.message || `Failed to connect to ${config.type}`,
                details: response.details
            };
        }
    } catch (error) {
        return {
            success: false,
            message: `Connection test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            details: 'Please check your configuration and try again'
        };
    }
}

/**
 * Test provider connection
 */
export async function testProviderConnection(config: ProviderTestConfig): Promise<ConnectionTestResult> {
    const startTime = Date.now();
    
    try {
        // Send test request to extension
        const response = await sendConnectionTestRequest('testProvider', config);
        const latency = Date.now() - startTime;
        
        if (response.success) {
            return {
                success: true,
                message: `Successfully connected to ${config.type}`,
                details: response.details || `Connection established in ${latency}ms`,
                latency,
                version: response.version,
                capabilities: response.capabilities
            };
        } else {
            return {
                success: false,
                message: response.message || `Failed to connect to ${config.type}`,
                details: response.details
            };
        }
    } catch (error) {
        return {
            success: false,
            message: `Connection test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            details: 'Please check your configuration and try again'
        };
    }
}

/**
 * Send connection test request to extension
 */
async function sendConnectionTestRequest(command: string, config: any): Promise<any> {
    return new Promise((resolve, reject) => {
        const requestId = generateRequestId();
        const timeout = setTimeout(() => {
            reject(new Error('Connection test timed out'));
        }, 30000); // 30 second timeout

        // Listen for response
        const handleMessage = (event: MessageEvent) => {
            const message = event.data;
            if (message.command === `${command}Response` && message.requestId === requestId) {
                clearTimeout(timeout);
                window.removeEventListener('message', handleMessage);
                resolve(message);
            }
        };

        window.addEventListener('message', handleMessage);

        // Send request
        postMessage(command, {
            requestId,
            config
        });
    });
}

/**
 * Generate unique request ID
 */
function generateRequestId(): string {
    return `test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Convert connection test result to validation result
 */
export function connectionTestToValidation(testResult: ConnectionTestResult): ValidationResult {
    if (testResult.success) {
        const suggestions: string[] = [];
        
        if (testResult.latency && testResult.latency > 1000) {
            suggestions.push('Connection latency is high. Consider using a closer server.');
        }
        
        if (testResult.capabilities && testResult.capabilities.length > 0) {
            suggestions.push(`Available features: ${testResult.capabilities.join(', ')}`);
        }

        return {
            isValid: true,
            errors: [],
            warnings: [],
            suggestions: [
                testResult.message,
                ...(testResult.details ? [testResult.details] : []),
                ...suggestions
            ]
        };
    } else {
        return {
            isValid: false,
            errors: [testResult.message],
            warnings: [],
            suggestions: testResult.details ? [testResult.details] : []
        };
    }
}

/**
 * Create a validator that includes connection testing
 */
export function createConnectionValidator<T extends DatabaseTestConfig | ProviderTestConfig>(
    testFunction: (config: T) => Promise<ConnectionTestResult>,
    baseValidator?: (config: T) => ValidationResult
): (config: T) => Promise<ValidationResult> {
    return async (config: T): Promise<ValidationResult> => {
        // First run base validation if provided
        if (baseValidator) {
            const baseResult = baseValidator(config);
            if (!baseResult.isValid) {
                return baseResult;
            }
        }

        // Then run connection test
        try {
            const testResult = await testFunction(config);
            return connectionTestToValidation(testResult);
        } catch (error) {
            return {
                isValid: false,
                errors: [`Connection test failed: ${error instanceof Error ? error.message : 'Unknown error'}`],
                warnings: [],
                suggestions: ['Please check your configuration and network connection']
            };
        }
    };
}

/**
 * Debounced connection tester
 */
export function createDebouncedConnectionTester<T>(
    testFunction: (config: T) => Promise<ConnectionTestResult>,
    delay: number = 2000
): (config: T) => Promise<ConnectionTestResult> {
    let timeoutId: NodeJS.Timeout;
    let currentPromise: Promise<ConnectionTestResult> | null = null;
    
    return (config: T): Promise<ConnectionTestResult> => {
        // Cancel previous test
        if (timeoutId) {
            clearTimeout(timeoutId);
        }

        // Return existing promise if still running
        if (currentPromise) {
            return currentPromise;
        }

        return new Promise((resolve, reject) => {
            timeoutId = setTimeout(async () => {
                try {
                    currentPromise = testFunction(config);
                    const result = await currentPromise;
                    currentPromise = null;
                    resolve(result);
                } catch (error) {
                    currentPromise = null;
                    reject(error);
                }
            }, delay);
        });
    };
}

/**
 * Quick connection health check
 */
export async function quickHealthCheck(type: 'database' | 'provider', config: any): Promise<boolean> {
    try {
        const command = type === 'database' ? 'quickDatabaseCheck' : 'quickProviderCheck';
        const response = await sendConnectionTestRequest(command, config);
        return response.success === true;
    } catch {
        return false;
    }
}

/**
 * Batch connection test for multiple configurations
 */
export async function batchConnectionTest(
    tests: Array<{
        name: string;
        type: 'database' | 'provider';
        config: DatabaseTestConfig | ProviderTestConfig;
    }>
): Promise<Array<{ name: string; result: ConnectionTestResult }>> {
    const results = await Promise.allSettled(
        tests.map(async (test) => {
            const result = test.type === 'database' 
                ? await testDatabaseConnection(test.config as DatabaseTestConfig)
                : await testProviderConnection(test.config as ProviderTestConfig);
            
            return { name: test.name, result };
        })
    );

    return results.map((result, index) => {
        if (result.status === 'fulfilled') {
            return result.value;
        } else {
            return {
                name: tests[index].name,
                result: {
                    success: false,
                    message: 'Test failed to execute',
                    details: result.reason?.message || 'Unknown error'
                }
            };
        }
    });
}
</file>

<file path="webview/src/lib/utils/fluentUI.ts">
/**
 * Centralized Fluent UI Configuration
 * 
 * This file centralizes all Fluent UI component imports and registration
 * to optimize bundle size through tree-shaking and avoid duplicate registrations.
 */

import { 
    provideFluentDesignSystem,
    fluentButton,
    fluentTextField,
    fluentSelect,
    fluentOption,
    fluentProgressRing,
    fluentCard,
    fluentBadge,
    fluentAccordion,
    fluentAccordionItem
} from '@fluentui/web-components';

// Track which components have been registered to avoid duplicates
const registeredComponents = new Set<string>();

/**
 * Register core Fluent UI components that are used across the application
 */
export function registerCoreComponents(): void {
    if (registeredComponents.has('core')) return;

    const designSystem = provideFluentDesignSystem();
    
    designSystem.register(
        fluentButton(),
        fluentTextField(),
        fluentCard(),
        fluentProgressRing()
    );

    registeredComponents.add('core');
}

/**
 * Register form-related Fluent UI components
 */
export function registerFormComponents(): void {
    if (registeredComponents.has('form')) return;

    const designSystem = provideFluentDesignSystem();
    
    designSystem.register(
        fluentSelect(),
        fluentOption()
    );

    registeredComponents.add('form');
}

/**
 * Register display-related Fluent UI components
 */
export function registerDisplayComponents(): void {
    if (registeredComponents.has('display')) return;

    const designSystem = provideFluentDesignSystem();
    
    designSystem.register(
        fluentBadge(),
        fluentAccordion(),
        fluentAccordionItem()
    );

    registeredComponents.add('display');
}

/**
 * Register all Fluent UI components at once
 * Use this for components that need all features
 */
export function registerAllComponents(): void {
    registerCoreComponents();
    registerFormComponents();
    registerDisplayComponents();
}

/**
 * Get the design system instance
 */
export function getDesignSystem() {
    return provideFluentDesignSystem();
}

/**
 * Check if a component group has been registered
 */
export function isRegistered(componentGroup: 'core' | 'form' | 'display'): boolean {
    return registeredComponents.has(componentGroup);
}

/**
 * Reset registration tracking (useful for testing)
 */
export function resetRegistrations(): void {
    registeredComponents.clear();
}
</file>

<file path="webview/src/lib/utils/performance.ts">
/**
 * Performance Monitoring Utilities
 * 
 * Provides tools for monitoring and optimizing application performance,
 * including component loading times, render performance, and user interactions.
 */

// Performance metrics interface
export interface PerformanceMetric {
    name: string;
    startTime: number;
    endTime?: number;
    duration?: number;
    metadata?: Record<string, any>;
}

// Performance tracker class
class PerformanceTracker {
    private metrics: Map<string, PerformanceMetric> = new Map();
    private observers: PerformanceObserver[] = [];
    private isEnabled: boolean = true;

    constructor() {
        this.setupObservers();
    }

    /**
     * Start tracking a performance metric
     */
    start(name: string, metadata?: Record<string, any>): void {
        if (!this.isEnabled) return;

        const metric: PerformanceMetric = {
            name,
            startTime: performance.now(),
            metadata
        };

        this.metrics.set(name, metric);
        
        // Mark the start in the browser's performance timeline
        if (performance.mark) {
            performance.mark(`${name}-start`);
        }
    }

    /**
     * End tracking a performance metric
     */
    end(name: string): PerformanceMetric | null {
        if (!this.isEnabled) return null;

        const metric = this.metrics.get(name);
        if (!metric) {
            console.warn(`Performance metric '${name}' was not started`);
            return null;
        }

        metric.endTime = performance.now();
        metric.duration = metric.endTime - metric.startTime;

        // Mark the end and measure in the browser's performance timeline
        if (performance.mark && performance.measure) {
            performance.mark(`${name}-end`);
            performance.measure(name, `${name}-start`, `${name}-end`);
        }

        // Log slow operations
        if (metric.duration > 1000) {
            console.warn(`Slow operation detected: ${name} took ${metric.duration.toFixed(2)}ms`);
        }

        return metric;
    }

    /**
     * Get a performance metric
     */
    get(name: string): PerformanceMetric | undefined {
        return this.metrics.get(name);
    }

    /**
     * Get all performance metrics
     */
    getAll(): PerformanceMetric[] {
        return Array.from(this.metrics.values());
    }

    /**
     * Clear all metrics
     */
    clear(): void {
        this.metrics.clear();
        
        if (performance.clearMarks) {
            performance.clearMarks();
        }
        if (performance.clearMeasures) {
            performance.clearMeasures();
        }
    }

    /**
     * Get performance summary
     */
    getSummary(): {
        totalMetrics: number;
        averageDuration: number;
        slowestOperation: PerformanceMetric | null;
        fastestOperation: PerformanceMetric | null;
    } {
        const completedMetrics = Array.from(this.metrics.values()).filter(m => m.duration !== undefined);
        
        if (completedMetrics.length === 0) {
            return {
                totalMetrics: 0,
                averageDuration: 0,
                slowestOperation: null,
                fastestOperation: null
            };
        }

        const durations = completedMetrics.map(m => m.duration!);
        const averageDuration = durations.reduce((sum, duration) => sum + duration, 0) / durations.length;
        
        const slowestOperation = completedMetrics.reduce((slowest, current) => 
            (current.duration! > slowest.duration!) ? current : slowest
        );
        
        const fastestOperation = completedMetrics.reduce((fastest, current) => 
            (current.duration! < fastest.duration!) ? current : fastest
        );

        return {
            totalMetrics: completedMetrics.length,
            averageDuration,
            slowestOperation,
            fastestOperation
        };
    }

    /**
     * Setup performance observers
     */
    private setupObservers(): void {
        if (typeof PerformanceObserver === 'undefined') return;

        try {
            // Observe navigation timing
            const navigationObserver = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'navigation') {
                        this.logNavigationTiming(entry as PerformanceNavigationTiming);
                    }
                }
            });
            navigationObserver.observe({ entryTypes: ['navigation'] });
            this.observers.push(navigationObserver);

            // Observe resource loading
            const resourceObserver = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'resource') {
                        this.logResourceTiming(entry as PerformanceResourceTiming);
                    }
                }
            });
            resourceObserver.observe({ entryTypes: ['resource'] });
            this.observers.push(resourceObserver);

            // Observe long tasks
            if ('longtask' in PerformanceObserver.supportedEntryTypes) {
                const longTaskObserver = new PerformanceObserver((list) => {
                    for (const entry of list.getEntries()) {
                        console.warn(`Long task detected: ${entry.duration.toFixed(2)}ms`);
                    }
                });
                longTaskObserver.observe({ entryTypes: ['longtask'] });
                this.observers.push(longTaskObserver);
            }
        } catch (error) {
            console.warn('Failed to setup performance observers:', error);
        }
    }

    /**
     * Log navigation timing
     */
    private logNavigationTiming(entry: PerformanceNavigationTiming): void {
        const metrics = {
            domContentLoaded: entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart,
            loadComplete: entry.loadEventEnd - entry.loadEventStart,
            domInteractive: entry.domInteractive - entry.navigationStart,
            firstPaint: 0,
            firstContentfulPaint: 0
        };

        // Get paint timings if available
        const paintEntries = performance.getEntriesByType('paint');
        for (const paintEntry of paintEntries) {
            if (paintEntry.name === 'first-paint') {
                metrics.firstPaint = paintEntry.startTime;
            } else if (paintEntry.name === 'first-contentful-paint') {
                metrics.firstContentfulPaint = paintEntry.startTime;
            }
        }

        console.log('Navigation Performance:', metrics);
    }

    /**
     * Log resource timing
     */
    private logResourceTiming(entry: PerformanceResourceTiming): void {
        // Only log slow resources
        if (entry.duration > 500) {
            console.warn(`Slow resource: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
        }
    }

    /**
     * Enable or disable performance tracking
     */
    setEnabled(enabled: boolean): void {
        this.isEnabled = enabled;
    }

    /**
     * Cleanup observers
     */
    destroy(): void {
        this.observers.forEach(observer => observer.disconnect());
        this.observers = [];
        this.clear();
    }
}

// Global performance tracker instance
export const performanceTracker = new PerformanceTracker();

/**
 * Decorator for measuring function performance
 */
export function measurePerformance(name?: string) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        const metricName = name || `${target.constructor.name}.${propertyKey}`;

        descriptor.value = function (...args: any[]) {
            performanceTracker.start(metricName);
            
            try {
                const result = originalMethod.apply(this, args);
                
                // Handle async functions
                if (result && typeof result.then === 'function') {
                    return result.finally(() => {
                        performanceTracker.end(metricName);
                    });
                } else {
                    performanceTracker.end(metricName);
                    return result;
                }
            } catch (error) {
                performanceTracker.end(metricName);
                throw error;
            }
        };

        return descriptor;
    };
}

/**
 * Measure component loading time
 */
export function measureComponentLoad(componentName: string): {
    start: () => void;
    end: () => void;
} {
    const metricName = `component-load-${componentName}`;
    
    return {
        start: () => performanceTracker.start(metricName, { type: 'component-load', component: componentName }),
        end: () => performanceTracker.end(metricName)
    };
}

/**
 * Measure user interaction performance
 */
export function measureInteraction(interactionName: string, callback: () => void | Promise<void>): void {
    const metricName = `interaction-${interactionName}`;
    
    performanceTracker.start(metricName, { type: 'user-interaction', interaction: interactionName });
    
    try {
        const result = callback();
        
        if (result && typeof result.then === 'function') {
            result.finally(() => {
                performanceTracker.end(metricName);
            });
        } else {
            performanceTracker.end(metricName);
        }
    } catch (error) {
        performanceTracker.end(metricName);
        throw error;
    }
}

/**
 * Get performance insights
 */
export function getPerformanceInsights(): {
    summary: ReturnType<PerformanceTracker['getSummary']>;
    recommendations: string[];
} {
    const summary = performanceTracker.getSummary();
    const recommendations: string[] = [];

    // Analyze performance and provide recommendations
    if (summary.averageDuration > 100) {
        recommendations.push('Consider optimizing slow operations or implementing lazy loading');
    }

    if (summary.slowestOperation && summary.slowestOperation.duration! > 1000) {
        recommendations.push(`Optimize ${summary.slowestOperation.name} - it's taking ${summary.slowestOperation.duration!.toFixed(2)}ms`);
    }

    // Check for memory usage
    if (performance.memory) {
        const memoryUsage = (performance.memory as any).usedJSHeapSize / 1024 / 1024;
        if (memoryUsage > 50) {
            recommendations.push(`High memory usage detected: ${memoryUsage.toFixed(2)}MB`);
        }
    }

    return {
        summary,
        recommendations
    };
}

/**
 * Export performance data for analysis
 */
export function exportPerformanceData(): string {
    const data = {
        timestamp: new Date().toISOString(),
        metrics: performanceTracker.getAll(),
        summary: performanceTracker.getSummary(),
        insights: getPerformanceInsights(),
        userAgent: navigator.userAgent,
        url: window.location.href
    };

    return JSON.stringify(data, null, 2);
}
</file>

<file path="webview/src/lib/utils/validation.test.ts">
/**
 * Validation Utilities Unit Tests
 * 
 * Tests for the comprehensive validation system.
 */

import { describe, it, expect, vi } from 'vitest';
import {
	validators,
	validateDatabaseConfig,
	validateProviderConfig,
	createValidResult,
	createInvalidResult,
	combineValidationResults,
	createDebouncedValidator
} from './validation';

describe('Validation Utilities', () => {
	describe('Helper Functions', () => {
		it('should create valid result', () => {
			const result = createValidResult(['warning'], ['suggestion']);
			expect(result).toEqual({
				isValid: true,
				errors: [],
				warnings: ['warning'],
				suggestions: ['suggestion']
			});
		});

		it('should create invalid result', () => {
			const result = createInvalidResult(['error'], ['warning'], ['suggestion']);
			expect(result).toEqual({
				isValid: false,
				errors: ['error'],
				warnings: ['warning'],
				suggestions: ['suggestion']
			});
		});

		it('should combine validation results', () => {
			const result1 = createValidResult(['warning1']);
			const result2 = createInvalidResult(['error1']);
			const result3 = createValidResult([], ['suggestion1']);

			const combined = combineValidationResults(result1, result2, result3);
			expect(combined).toEqual({
				isValid: false,
				errors: ['error1'],
				warnings: ['warning1'],
				suggestions: ['suggestion1']
			});
		});
	});

	describe('Basic Validators', () => {
		describe('required', () => {
			it('should pass for non-empty values', () => {
				expect(validators.required('test')).toEqual(createValidResult());
				expect(validators.required(0)).toEqual(createValidResult());
				expect(validators.required(false)).toEqual(createValidResult());
			});

			it('should fail for empty values', () => {
				expect(validators.required('')).toEqual(createInvalidResult(['Field is required']));
				expect(validators.required(null)).toEqual(createInvalidResult(['Field is required']));
				expect(validators.required(undefined)).toEqual(createInvalidResult(['Field is required']));
			});

			it('should use custom field name', () => {
				const result = validators.required('', 'Username');
				expect(result.errors[0]).toBe('Username is required');
			});
		});

		describe('stringLength', () => {
			it('should pass for valid length strings', () => {
				expect(validators.stringLength('test', 1, 10)).toEqual(createValidResult());
				expect(validators.stringLength('hello', 5, 5)).toEqual(createValidResult());
			});

			it('should fail for strings that are too short', () => {
				const result = validators.stringLength('hi', 5, 10);
				expect(result.isValid).toBe(false);
				expect(result.errors[0]).toContain('at least 5 characters');
			});

			it('should fail for strings that are too long', () => {
				const result = validators.stringLength('this is a very long string', 1, 10);
				expect(result.isValid).toBe(false);
				expect(result.errors[0]).toContain('no more than 10 characters');
			});

			it('should fail for non-string values', () => {
				const result = validators.stringLength(123 as any, 1, 10);
				expect(result.isValid).toBe(false);
				expect(result.errors[0]).toContain('must be a string');
			});
		});

		describe('url', () => {
			it('should pass for valid URLs', () => {
				expect(validators.url('https://example.com')).toEqual(createValidResult());
				expect(validators.url('http://localhost:3000')).toEqual(createValidResult());
				expect(validators.url('ftp://files.example.com')).toEqual(createValidResult());
			});

			it('should pass for empty values (optional)', () => {
				expect(validators.url('')).toEqual(createValidResult());
			});

			it('should fail for invalid URLs', () => {
				expect(validators.url('not-a-url').isValid).toBe(false);
				expect(validators.url('http://').isValid).toBe(false);
				expect(validators.url('just-text').isValid).toBe(false);
			});
		});

		describe('port', () => {
			it('should pass for valid port numbers', () => {
				expect(validators.port(80)).toEqual(createValidResult());
				expect(validators.port('3000')).toEqual(createValidResult());
				expect(validators.port(65535)).toEqual(createValidResult());
			});

			it('should fail for invalid port numbers', () => {
				expect(validators.port(0).isValid).toBe(false);
				expect(validators.port(65536).isValid).toBe(false);
				expect(validators.port(-1).isValid).toBe(false);
				expect(validators.port('not-a-number').isValid).toBe(false);
			});
		});

		describe('apiKey', () => {
			it('should pass for valid API keys', () => {
				expect(validators.apiKey('sk-1234567890abcdef')).toEqual(
					expect.objectContaining({ isValid: true })
				);
				expect(validators.apiKey('valid-api-key-123')).toEqual(
					expect.objectContaining({ isValid: true })
				);
			});

			it('should fail for invalid API keys', () => {
				expect(validators.apiKey('').isValid).toBe(false);
				expect(validators.apiKey('key with spaces').isValid).toBe(false);
				expect(validators.apiKey('your-api-key').isValid).toBe(false);
				expect(validators.apiKey('placeholder').isValid).toBe(false);
			});

			it('should provide warnings for short keys', () => {
				const result = validators.apiKey('short');
				expect(result.warnings).toContain('API Key seems unusually short');
			});

			it('should provide security suggestions', () => {
				const result = validators.apiKey('my-secret-key');
				expect(result.suggestions).toContain('Ensure this API key is kept secure and not shared');
			});
		});

		describe('searchQuery', () => {
			it('should pass for valid search queries', () => {
				expect(validators.searchQuery('function test')).toEqual(
					expect.objectContaining({ isValid: true })
				);
				expect(validators.searchQuery('class Component')).toEqual(
					expect.objectContaining({ isValid: true })
				);
			});

			it('should fail for empty queries', () => {
				expect(validators.searchQuery('').isValid).toBe(false);
				expect(validators.searchQuery('   ').isValid).toBe(false);
			});

			it('should provide warnings for short queries', () => {
				const result = validators.searchQuery('ab');
				expect(result.warnings).toContain('Very short queries may not return meaningful results');
			});

			it('should provide warnings for very long queries', () => {
				const longQuery = 'a'.repeat(600);
				const result = validators.searchQuery(longQuery);
				expect(result.warnings).toContain('Very long queries may be truncated');
			});

			it('should provide suggestions for single word queries', () => {
				const result = validators.searchQuery('function');
				expect(result.suggestions).toContain('Try using multiple words or phrases for better results');
			});
		});
	});

	describe('Database Configuration Validation', () => {
		describe('Qdrant', () => {
			it('should pass for valid Qdrant config', () => {
				const config = {
					type: 'qdrant' as const,
					host: 'localhost',
					port: 6333
				};
				const result = validateDatabaseConfig(config);
				expect(result.isValid).toBe(true);
			});

			it('should provide default port suggestion', () => {
				const config = {
					type: 'qdrant' as const,
					host: 'localhost'
				};
				const result = validateDatabaseConfig(config);
				expect(result.suggestions).toContain('Default port 6333 will be used');
			});
		});

		describe('ChromaDB', () => {
			it('should pass for valid ChromaDB config', () => {
				const config = {
					type: 'chromadb' as const,
					host: 'localhost',
					port: 8000
				};
				const result = validateDatabaseConfig(config);
				expect(result.isValid).toBe(true);
			});
		});

		describe('Pinecone', () => {
			it('should require API key and environment', () => {
				const config = {
					type: 'pinecone' as const
				};
				const result = validateDatabaseConfig(config);
				expect(result.isValid).toBe(false);
				expect(result.errors).toContain('API Key is required');
				expect(result.errors).toContain('Environment is required');
			});

			it('should pass for valid Pinecone config', () => {
				const config = {
					type: 'pinecone' as const,
					apiKey: 'valid-api-key-123',
					environment: 'us-west1-gcp'
				};
				const result = validateDatabaseConfig(config);
				expect(result.isValid).toBe(true);
			});
		});

		it('should fail for missing database type', () => {
			const config = {};
			const result = validateDatabaseConfig(config as any);
			expect(result.isValid).toBe(false);
			expect(result.errors).toContain('Database type is required');
		});

		it('should fail for invalid database type', () => {
			const config = { type: 'invalid' };
			const result = validateDatabaseConfig(config as any);
			expect(result.isValid).toBe(false);
			expect(result.errors).toContain('Invalid database type');
		});
	});

	describe('Provider Configuration Validation', () => {
		describe('Ollama', () => {
			it('should pass for valid Ollama config', () => {
				const config = {
					type: 'ollama' as const,
					endpoint: 'http://localhost:11434',
					model: 'nomic-embed-text'
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(true);
			});

			it('should provide default endpoint suggestion', () => {
				const config = {
					type: 'ollama' as const
				};
				const result = validateProviderConfig(config);
				expect(result.suggestions).toContain('Default endpoint http://localhost:11434 will be used');
			});
		});

		describe('OpenAI', () => {
			it('should require API key', () => {
				const config = {
					type: 'openai' as const
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(false);
				expect(result.errors).toContain('OpenAI API Key is required');
			});

			it('should validate API key format', () => {
				const config = {
					type: 'openai' as const,
					apiKey: 'invalid-key'
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(false);
				expect(result.errors).toContain('OpenAI API keys should start with "sk-"');
			});

			it('should pass for valid OpenAI config', () => {
				const config = {
					type: 'openai' as const,
					apiKey: 'sk-1234567890abcdef',
					model: 'text-embedding-ada-002'
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(true);
			});
		});

		describe('Azure', () => {
			it('should require API key and endpoint', () => {
				const config = {
					type: 'azure' as const
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(false);
				expect(result.errors).toContain('Azure API Key is required');
				expect(result.errors).toContain('Azure Endpoint is required');
			});

			it('should validate Azure endpoint format', () => {
				const config = {
					type: 'azure' as const,
					apiKey: 'valid-key',
					endpoint: 'https://example.com'
				};
				const result = validateProviderConfig(config);
				expect(result.warnings).toContain('Endpoint doesn\'t appear to be an Azure OpenAI endpoint');
			});

			it('should pass for valid Azure config', () => {
				const config = {
					type: 'azure' as const,
					apiKey: 'valid-key',
					endpoint: 'https://my-resource.openai.azure.com/'
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(true);
			});
		});
	});

	describe('Debounced Validator', () => {
		it('should debounce validation calls', async () => {
			const mockValidator = vi.fn(() => createValidResult());
			const debouncedValidator = createDebouncedValidator(mockValidator, 50);

			// Call multiple times quickly
			debouncedValidator('test1');
			debouncedValidator('test2');
			const finalResult = debouncedValidator('test3');

			// Wait for the final result
			await finalResult;

			// Wait a bit more to ensure debouncing worked
			await new Promise(resolve => setTimeout(resolve, 100));

			// Should only call the validator once with the last value
			expect(mockValidator).toHaveBeenCalledTimes(1);
			expect(mockValidator).toHaveBeenCalledWith('test3');
		});

		it('should handle validation errors', async () => {
			const mockValidator = vi.fn(() => {
				throw new Error('Validation failed');
			});
			const debouncedValidator = createDebouncedValidator(mockValidator, 10);

			// The debounced validator should catch errors and return invalid result
			const result = await debouncedValidator('test');
			expect(result.isValid).toBe(false);
			expect(result.errors[0]).toContain('Validation failed');
		});
	});
});
</file>

<file path="webview/src/lib/utils/validation.ts">
/**
 * Comprehensive Validation Utilities
 * 
 * Provides validation functions for all user inputs in the Code Context Engine.
 * Includes database connections, provider configurations, search queries, and more.
 */

// Validation result interface
export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings: string[];
    suggestions: string[];
}

// Validation rule interface
export interface ValidationRule<T = any> {
    name: string;
    validate: (value: T) => ValidationResult;
    required?: boolean;
    async?: boolean;
}

// Database configuration interfaces
export interface DatabaseConfig {
    type: 'qdrant' | 'chromadb' | 'pinecone';
    host?: string;
    port?: number;
    apiKey?: string;
    environment?: string;
    collection?: string;
}

export interface ProviderConfig {
    type: 'ollama' | 'openai' | 'azure';
    apiKey?: string;
    endpoint?: string;
    model?: string;
    temperature?: number;
    maxTokens?: number;
}

/**
 * Create a successful validation result
 */
export function createValidResult(warnings: string[] = [], suggestions: string[] = []): ValidationResult {
    return {
        isValid: true,
        errors: [],
        warnings,
        suggestions
    };
}

/**
 * Create a failed validation result
 */
export function createInvalidResult(errors: string[], warnings: string[] = [], suggestions: string[] = []): ValidationResult {
    return {
        isValid: false,
        errors,
        warnings,
        suggestions
    };
}

/**
 * Combine multiple validation results
 */
export function combineValidationResults(...results: ValidationResult[]): ValidationResult {
    const combined: ValidationResult = {
        isValid: true,
        errors: [],
        warnings: [],
        suggestions: []
    };

    for (const result of results) {
        if (!result.isValid) {
            combined.isValid = false;
        }
        combined.errors.push(...result.errors);
        combined.warnings.push(...result.warnings);
        combined.suggestions.push(...result.suggestions);
    }

    return combined;
}

// Basic validation functions
export const validators = {
    /**
     * Validate that a value is not empty
     */
    required: (value: any, fieldName: string = 'Field'): ValidationResult => {
        if (value === null || value === undefined || value === '') {
            return createInvalidResult([`${fieldName} is required`]);
        }
        return createValidResult();
    },

    /**
     * Validate string length
     */
    stringLength: (value: string, min: number = 0, max: number = Infinity, fieldName: string = 'Field'): ValidationResult => {
        if (typeof value !== 'string') {
            return createInvalidResult([`${fieldName} must be a string`]);
        }

        const length = value.length;
        const errors: string[] = [];

        if (length < min) {
            errors.push(`${fieldName} must be at least ${min} characters long`);
        }
        if (length > max) {
            errors.push(`${fieldName} must be no more than ${max} characters long`);
        }

        return errors.length > 0 ? createInvalidResult(errors) : createValidResult();
    },

    /**
     * Validate URL format
     */
    url: (value: string, fieldName: string = 'URL'): ValidationResult => {
        if (!value) {
            return createValidResult();
        }

        try {
            new URL(value);
            return createValidResult();
        } catch {
            return createInvalidResult([`${fieldName} must be a valid URL`]);
        }
    },

    /**
     * Validate port number
     */
    port: (value: number | string, fieldName: string = 'Port'): ValidationResult => {
        const port = typeof value === 'string' ? parseInt(value, 10) : value;
        
        if (isNaN(port)) {
            return createInvalidResult([`${fieldName} must be a valid number`]);
        }

        if (port < 1 || port > 65535) {
            return createInvalidResult([`${fieldName} must be between 1 and 65535`]);
        }

        return createValidResult();
    },

    /**
     * Validate API key format
     */
    apiKey: (value: string, fieldName: string = 'API Key'): ValidationResult => {
        if (!value) {
            return createInvalidResult([`${fieldName} is required`]);
        }

        const warnings: string[] = [];
        const suggestions: string[] = [];

        // Check for common API key patterns
        if (value.length < 10) {
            warnings.push(`${fieldName} seems unusually short`);
        }

        if (value.includes(' ')) {
            return createInvalidResult([`${fieldName} should not contain spaces`]);
        }

        if (value === 'your-api-key' || value === 'placeholder' || value === 'test') {
            return createInvalidResult([`Please enter a valid ${fieldName}`]);
        }

        // Check for potential security issues
        if (value.toLowerCase().includes('key') || value.toLowerCase().includes('secret')) {
            suggestions.push('Ensure this API key is kept secure and not shared');
        }

        return createValidResult(warnings, suggestions);
    },

    /**
     * Validate search query
     */
    searchQuery: (value: string, fieldName: string = 'Search query'): ValidationResult => {
        if (!value || !value.trim()) {
            return createInvalidResult([`${fieldName} cannot be empty`]);
        }

        const trimmed = value.trim();
        const warnings: string[] = [];
        const suggestions: string[] = [];

        if (trimmed.length < 3) {
            warnings.push('Very short queries may not return meaningful results');
        }

        if (trimmed.length > 500) {
            warnings.push('Very long queries may be truncated');
        }

        // Check for potentially problematic characters
        if (/[<>{}[\]\\]/.test(trimmed)) {
            warnings.push('Special characters in queries may affect search results');
        }

        // Provide helpful suggestions
        if (trimmed.split(' ').length === 1) {
            suggestions.push('Try using multiple words or phrases for better results');
        }

        return createValidResult(warnings, suggestions);
    }
};

// Database-specific validation
export const databaseValidators = {
    /**
     * Validate Qdrant configuration
     */
    qdrant: (config: Partial<DatabaseConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // Host validation
        if (config.host) {
            results.push(validators.url(`http://${config.host}`, 'Host'));
        }

        // Port validation
        if (config.port) {
            results.push(validators.port(config.port, 'Port'));
        } else {
            results.push(createValidResult([], ['Default port 6333 will be used']));
        }

        return combineValidationResults(...results);
    },

    /**
     * Validate ChromaDB configuration
     */
    chromadb: (config: Partial<DatabaseConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // Host validation
        if (config.host) {
            results.push(validators.url(`http://${config.host}`, 'Host'));
        }

        // Port validation
        if (config.port) {
            results.push(validators.port(config.port, 'Port'));
        } else {
            results.push(createValidResult([], ['Default port 8000 will be used']));
        }

        return combineValidationResults(...results);
    },

    /**
     * Validate Pinecone configuration
     */
    pinecone: (config: Partial<DatabaseConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // API key is required for Pinecone
        results.push(validators.required(config.apiKey, 'API Key'));
        if (config.apiKey) {
            results.push(validators.apiKey(config.apiKey, 'Pinecone API Key'));
        }

        // Environment validation
        results.push(validators.required(config.environment, 'Environment'));
        if (config.environment) {
            results.push(validators.stringLength(config.environment, 1, 50, 'Environment'));
        }

        return combineValidationResults(...results);
    }
};

// Provider-specific validation
export const providerValidators = {
    /**
     * Validate Ollama configuration
     */
    ollama: (config: Partial<ProviderConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // Endpoint validation (optional, defaults to localhost)
        if (config.endpoint) {
            results.push(validators.url(config.endpoint, 'Endpoint'));
        } else {
            results.push(createValidResult([], ['Default endpoint http://localhost:11434 will be used']));
        }

        // Model validation
        if (config.model) {
            results.push(validators.stringLength(config.model, 1, 100, 'Model'));
        } else {
            results.push(createValidResult([], ['Default model will be used']));
        }

        return combineValidationResults(...results);
    },

    /**
     * Validate OpenAI configuration
     */
    openai: (config: Partial<ProviderConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // API key is required
        results.push(validators.required(config.apiKey, 'OpenAI API Key'));
        if (config.apiKey) {
            results.push(validators.apiKey(config.apiKey, 'OpenAI API Key'));
            
            // OpenAI API keys have a specific format
            if (!config.apiKey.startsWith('sk-')) {
                results.push(createInvalidResult(['OpenAI API keys should start with "sk-"']));
            }
        }

        // Model validation
        if (config.model) {
            const validModels = ['text-embedding-ada-002', 'text-embedding-3-small', 'text-embedding-3-large'];
            if (!validModels.includes(config.model)) {
                results.push(createValidResult(['Unknown model specified'], [`Consider using one of: ${validModels.join(', ')}`]));
            }
        }

        return combineValidationResults(...results);
    },

    /**
     * Validate Azure OpenAI configuration
     */
    azure: (config: Partial<ProviderConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // API key is required
        results.push(validators.required(config.apiKey, 'Azure API Key'));
        if (config.apiKey) {
            results.push(validators.apiKey(config.apiKey, 'Azure API Key'));
        }

        // Endpoint is required for Azure
        results.push(validators.required(config.endpoint, 'Azure Endpoint'));
        if (config.endpoint) {
            results.push(validators.url(config.endpoint, 'Azure Endpoint'));
            
            // Azure endpoints should contain 'openai.azure.com'
            if (!config.endpoint.includes('openai.azure.com')) {
                results.push(createValidResult(['Endpoint doesn\'t appear to be an Azure OpenAI endpoint'], ['Azure endpoints typically contain "openai.azure.com"']));
            }
        }

        return combineValidationResults(...results);
    }
};

/**
 * Validate complete database configuration
 */
export function validateDatabaseConfig(config: Partial<DatabaseConfig>): ValidationResult {
    if (!config.type) {
        return createInvalidResult(['Database type is required']);
    }

    switch (config.type) {
        case 'qdrant':
            return databaseValidators.qdrant(config);
        case 'chromadb':
            return databaseValidators.chromadb(config);
        case 'pinecone':
            return databaseValidators.pinecone(config);
        default:
            return createInvalidResult(['Invalid database type']);
    }
}

/**
 * Validate complete provider configuration
 */
export function validateProviderConfig(config: Partial<ProviderConfig>): ValidationResult {
    if (!config.type) {
        return createInvalidResult(['Provider type is required']);
    }

    switch (config.type) {
        case 'ollama':
            return providerValidators.ollama(config);
        case 'openai':
            return providerValidators.openai(config);
        case 'azure':
            return providerValidators.azure(config);
        default:
            return createInvalidResult(['Invalid provider type']);
    }
}

/**
 * Debounced validation function
 */
export function createDebouncedValidator<T>(
    validator: (value: T) => ValidationResult,
    delay: number = 300
): (value: T) => Promise<ValidationResult> {
    let timeoutId: NodeJS.Timeout;

    return (value: T): Promise<ValidationResult> => {
        return new Promise((resolve) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                try {
                    resolve(validator(value));
                } catch (error) {
                    resolve(createInvalidResult([
                        `Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
                    ]));
                }
            }, delay);
        });
    };
}
</file>

<file path="webview/src/lib/index.ts">
// place files you want to import through the `$lib` alias in this folder.
</file>

<file path="webview/src/routes/+layout.svelte">
<script lang="ts">
	import '../app.css';
	import favicon from '$lib/assets/favicon.svg';

	let { children } = $props();
</script>

<svelte:head>
	<link rel="icon" href={favicon} />
</svelte:head>

{@render children?.()}
</file>

<file path="webview/src/routes/page.svelte.spec.ts">
import { page } from '@vitest/browser/context';
import { describe, expect, it } from 'vitest';
import { render } from 'vitest-browser-svelte';
import Page from './+page.svelte';

describe('/+page.svelte', () => {
	it('should render h1', async () => {
		render(Page);

		const heading = page.getByRole('heading', { level: 1 });
		await expect.element(heading).toBeInTheDocument();
	});
});
</file>

<file path="webview/src/test/setup.ts">
/**
 * Test Setup Configuration
 * 
 * Global test setup for Vitest, including DOM environment setup,
 * mock configurations, and test utilities.
 */

import '@testing-library/jest-dom';
import { vi } from 'vitest';

// Mock VS Code API
const mockVSCodeApi = {
	postMessage: vi.fn(),
	setState: vi.fn(),
	getState: vi.fn(() => null)
};

// Mock window.acquireVsCodeApi
Object.defineProperty(window, 'acquireVsCodeApi', {
	value: () => mockVSCodeApi,
	writable: true
});

// Mock performance API if not available
if (!global.performance) {
	global.performance = {
		now: vi.fn(() => Date.now()),
		mark: vi.fn(),
		measure: vi.fn(),
		clearMarks: vi.fn(),
		clearMeasures: vi.fn(),
		getEntriesByType: vi.fn(() => []),
		getEntriesByName: vi.fn(() => [])
	} as any;
}

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation((callback) => ({
	observe: vi.fn(),
	unobserve: vi.fn(),
	disconnect: vi.fn()
}));

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation((callback) => ({
	observe: vi.fn(),
	unobserve: vi.fn(),
	disconnect: vi.fn()
}));

// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
	writable: true,
	value: vi.fn().mockImplementation(query => ({
		matches: false,
		media: query,
		onchange: null,
		addListener: vi.fn(),
		removeListener: vi.fn(),
		addEventListener: vi.fn(),
		removeEventListener: vi.fn(),
		dispatchEvent: vi.fn(),
	})),
});

// Mock CSS custom properties
Object.defineProperty(document.documentElement.style, 'setProperty', {
	value: vi.fn(),
	writable: true
});

// Mock Fluent UI web components
vi.mock('@fluentui/web-components', () => ({
	provideFluentDesignSystem: vi.fn(() => ({
		register: vi.fn()
	})),
	fluentButton: vi.fn(),
	fluentTextField: vi.fn(),
	fluentSelect: vi.fn(),
	fluentOption: vi.fn(),
	fluentProgressRing: vi.fn(),
	fluentCard: vi.fn(),
	fluentBadge: vi.fn(),
	fluentAccordion: vi.fn(),
	fluentAccordionItem: vi.fn()
}));

// Global test utilities
export const testUtils = {
	mockVSCodeApi,
	
	// Helper to wait for next tick
	nextTick: () => new Promise(resolve => setTimeout(resolve, 0)),
	
	// Helper to wait for component updates
	waitForUpdate: () => new Promise(resolve => setTimeout(resolve, 10)),
	
	// Helper to create mock events
	createMockEvent: (type: string, properties: Record<string, any> = {}) => {
		const event = new Event(type, { bubbles: true, cancelable: true });
		Object.assign(event, properties);
		return event;
	},
	
	// Helper to create mock input events
	createMockInputEvent: (value: string) => {
		const event = new Event('input', { bubbles: true });
		Object.defineProperty(event, 'target', {
			value: { value },
			enumerable: true
		});
		return event;
	},
	
	// Helper to create mock change events
	createMockChangeEvent: (value: string) => {
		const event = new Event('change', { bubbles: true });
		Object.defineProperty(event, 'target', {
			value: { value },
			enumerable: true
		});
		return event;
	}
};

// Make test utilities globally available
(global as any).testUtils = testUtils;
</file>

<file path="webview/src/app.d.ts">
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};
</file>

<file path="webview/src/app.html">
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
</file>

<file path="webview/src/demo.spec.ts">
import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});
</file>

<file path="webview/static/robots.txt">
# allow crawling everything by default
User-agent: *
Disallow:
</file>

<file path="webview/.gitignore">
test-results
node_modules

# Output
.output
.vercel
.netlify
.wrangler
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
</file>

<file path="webview/.npmrc">
engine-strict=true
</file>

<file path="webview/.prettierignore">
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
bun.lock
bun.lockb

# Miscellaneous
/static/
</file>

<file path="webview/.prettierrc">
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte"],
	"overrides": [
		{
			"files": "*.svelte",
			"options": {
				"parser": "svelte"
			}
		}
	]
}
</file>

<file path="webview/playwright.config.ts">
import { defineConfig } from '@playwright/test';

export default defineConfig({
	webServer: {
		command: 'npm run build && npm run preview',
		port: 4173
	},
	testDir: 'e2e'
});
</file>

<file path="webview/README.md">
# sv

Everything you need to build a Svelte project, powered by [`sv`](https://github.com/sveltejs/cli).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```sh
# create a new project in the current directory
npx sv create

# create a new project in my-app
npx sv create my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```sh
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```sh
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://svelte.dev/docs/kit/adapters) for your target environment.
</file>

<file path="webview/svelte.config.js">
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		// Use static adapter for VS Code webview
		adapter: adapter({
			pages: 'build',
			assets: 'build',
			fallback: 'index.html',
			precompress: false,
			strict: true
		})
	}
};

export default config;
</file>

<file path="webview/vitest-setup-client.ts">
/// <reference types="@vitest/browser/matchers" />
/// <reference types="@vitest/browser/providers/playwright" />
</file>

<file path="webview/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import { sveltekit } from '@sveltejs/kit/vite';

export default defineConfig({
	plugins: [sveltekit()],
	test: {
		include: ['src/**/*.{test,spec}.{js,ts}'],
		environment: 'jsdom',
		setupFiles: ['./src/test/setup.ts'],
		globals: true,
		coverage: {
			reporter: ['text', 'json', 'html'],
			exclude: [
				'node_modules/',
				'src/test/',
				'**/*.d.ts',
				'**/*.config.*',
				'**/build/**',
				'**/.svelte-kit/**'
			],
			thresholds: {
				global: {
					branches: 80,
					functions: 80,
					lines: 80,
					statements: 80
				}
			}
		}
	}
});
</file>

<file path="webview-backup-20250826-101914/src/lib/components/ChromaDBConfig.js">
"use strict";
/**
 * ChromaDBConfig Component
 *
 * Handles ChromaDB-specific configuration including connection settings,
 * authentication, and health checking.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.chromaDBConfigStyles = exports.ChromaDBConfigComponent = void 0;
const setupStore_1 = require("../stores/setupStore");
class ChromaDBConfigComponent {
    constructor(container) {
        this.hostInput = null;
        this.portInput = null;
        this.sslCheckbox = null;
        this.authTokenInput = null;
        this.testButton = null;
        this.statusElement = null;
        this.container = container;
        this.render();
        this.setupEventListeners();
    }
    /**
     * Render the ChromaDB configuration UI
     */
    render() {
        this.container.innerHTML = `
            <div class="chromadb-config">
                <h4>ChromaDB Configuration</h4>
                <p class="config-description">
                    Configure your ChromaDB connection settings. ChromaDB is an open-source vector database 
                    that can run locally or in the cloud.
                </p>

                <div class="config-grid">
                    <div class="config-item">
                        <label for="chromadb-host">Host:</label>
                        <input type="text" id="chromadb-host" value="localhost" placeholder="localhost">
                        <small>ChromaDB server hostname or IP address</small>
                    </div>

                    <div class="config-item">
                        <label for="chromadb-port">Port:</label>
                        <input type="number" id="chromadb-port" value="8000" placeholder="8000" min="1" max="65535">
                        <small>ChromaDB server port (default: 8000)</small>
                    </div>

                    <div class="config-item checkbox-item">
                        <label class="checkbox-label">
                            <input type="checkbox" id="chromadb-ssl">
                            <span class="checkmark"></span>
                            Use SSL/HTTPS
                        </label>
                        <small>Enable secure connection (recommended for production)</small>
                    </div>

                    <div class="config-item">
                        <label for="chromadb-auth-token">Authentication Token (Optional):</label>
                        <input type="password" id="chromadb-auth-token" placeholder="Enter auth token if required">
                        <small>Leave empty if authentication is not configured</small>
                    </div>
                </div>

                <div class="config-actions">
                    <button id="test-chromadb-connection" class="test-button">Test Connection</button>
                    <div id="chromadb-status" class="connection-status">
                        <span class="status-dot unknown"></span>
                        <span class="status-text">Not tested</span>
                    </div>
                </div>

                <div class="config-info">
                    <div class="info-section">
                        <h5> Docker Setup</h5>
                        <p>To run ChromaDB locally with Docker:</p>
                        <code>docker run -p 8000:8000 chromadb/chroma</code>
                    </div>
                    
                    <div class="info-section">
                        <h5> Manual Installation</h5>
                        <p>Install and run ChromaDB manually:</p>
                        <code>pip install chromadb && chroma run --host 0.0.0.0 --port 8000</code>
                    </div>
                </div>
            </div>
        `;
        // Get references to elements
        this.hostInput = this.container.querySelector('#chromadb-host');
        this.portInput = this.container.querySelector('#chromadb-port');
        this.sslCheckbox = this.container.querySelector('#chromadb-ssl');
        this.authTokenInput = this.container.querySelector('#chromadb-auth-token');
        this.testButton = this.container.querySelector('#test-chromadb-connection');
        this.statusElement = this.container.querySelector('#chromadb-status');
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Update configuration when inputs change
        [this.hostInput, this.portInput, this.sslCheckbox, this.authTokenInput].forEach(input => {
            if (input) {
                input.addEventListener('input', () => this.updateConfiguration());
                input.addEventListener('change', () => this.updateConfiguration());
            }
        });
        // Test connection button
        if (this.testButton) {
            this.testButton.addEventListener('click', () => this.testConnection());
        }
    }
    /**
     * Update configuration in store
     */
    updateConfiguration() {
        if (!this.hostInput || !this.portInput || !this.sslCheckbox || !this.authTokenInput)
            return;
        const config = {
            host: this.hostInput.value || 'localhost',
            port: parseInt(this.portInput.value) || 8000,
            ssl: this.sslCheckbox.checked,
            authToken: this.authTokenInput.value || undefined
        };
        setupStore_1.setupActions.setDatabaseConfig(config);
    }
    /**
     * Test ChromaDB connection
     */
    async testConnection() {
        if (!this.testButton || !this.statusElement)
            return;
        // Update UI to show testing state
        this.testButton.disabled = true;
        this.testButton.textContent = 'Testing...';
        this.updateStatus('testing', 'Testing connection...');
        try {
            const config = this.getConfiguration();
            const protocol = config.ssl ? 'https' : 'http';
            const url = `${protocol}://${config.host}:${config.port}/api/v1/heartbeat`;
            // Add auth header if token is provided
            const headers = {
                'Content-Type': 'application/json'
            };
            if (config.authToken) {
                headers['Authorization'] = `Bearer ${config.authToken}`;
            }
            const response = await fetch(url, {
                method: 'GET',
                headers,
                signal: AbortSignal.timeout(5000) // 5 second timeout
            });
            if (response.ok) {
                const data = await response.json();
                if (data && typeof data === 'object') {
                    this.updateStatus('success', 'Connection successful!');
                    setupStore_1.setupActions.updateDatabaseStatus('running');
                }
                else {
                    this.updateStatus('error', 'Invalid response from ChromaDB');
                }
            }
            else {
                this.updateStatus('error', `Connection failed: ${response.status} ${response.statusText}`);
            }
        }
        catch (error) {
            console.error('ChromaDB connection test failed:', error);
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    this.updateStatus('error', 'Connection timeout - check host and port');
                }
                else if (error.message.includes('Failed to fetch')) {
                    this.updateStatus('error', 'Cannot reach ChromaDB - check if it\'s running');
                }
                else {
                    this.updateStatus('error', `Connection error: ${error.message}`);
                }
            }
            else {
                this.updateStatus('error', 'Unknown connection error');
            }
        }
        finally {
            // Reset button state
            this.testButton.disabled = false;
            this.testButton.textContent = 'Test Connection';
        }
    }
    /**
     * Update connection status display
     */
    updateStatus(type, message) {
        if (!this.statusElement)
            return;
        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');
        if (statusDot && statusText) {
            // Remove all status classes
            statusDot.className = 'status-dot';
            statusDot.classList.add(type);
            statusText.textContent = message;
        }
    }
    /**
     * Get current configuration
     */
    getConfiguration() {
        return {
            host: this.hostInput?.value || 'localhost',
            port: parseInt(this.portInput?.value || '8000'),
            ssl: this.sslCheckbox?.checked || false,
            authToken: this.authTokenInput?.value || undefined
        };
    }
    /**
     * Load configuration from external source
     */
    loadConfiguration(config) {
        if (this.hostInput)
            this.hostInput.value = config.host;
        if (this.portInput)
            this.portInput.value = config.port.toString();
        if (this.sslCheckbox)
            this.sslCheckbox.checked = config.ssl;
        if (this.authTokenInput)
            this.authTokenInput.value = config.authToken || '';
        this.updateConfiguration();
    }
    /**
     * Validate configuration
     */
    validateConfiguration() {
        const errors = [];
        const config = this.getConfiguration();
        if (!config.host || config.host.trim() === '') {
            errors.push('Host is required');
        }
        if (!config.port || config.port < 1 || config.port > 65535) {
            errors.push('Port must be between 1 and 65535');
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    /**
     * Cleanup component
     */
    dispose() {
        // Remove event listeners if needed
    }
}
exports.ChromaDBConfigComponent = ChromaDBConfigComponent;
// CSS styles for ChromaDB configuration
exports.chromaDBConfigStyles = `
.chromadb-config {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.chromadb-config h4 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.config-description {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
    line-height: 1.4;
}

.config-grid {
    display: grid;
    gap: 15px;
    margin-bottom: 15px;
}

.config-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.config-item label {
    font-weight: 500;
    color: var(--vscode-foreground);
    font-size: 13px;
}

.config-item input[type="text"],
.config-item input[type="number"],
.config-item input[type="password"] {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item input:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.checkbox-item {
    flex-direction: row;
    align-items: center;
    gap: 8px;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    font-size: 13px;
}

.config-item small {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.config-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.test-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.unknown {
    background-color: var(--vscode-charts-gray);
}

.status-dot.testing {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.success {
    background-color: var(--vscode-charts-green);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 12px;
    color: var(--vscode-foreground);
}

.config-info {
    border-top: 1px solid var(--vscode-panel-border);
    padding-top: 15px;
    margin-top: 15px;
}

.info-section {
    margin-bottom: 12px;
}

.info-section h5 {
    margin: 0 0 6px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.info-section p {
    margin: 0 0 4px 0;
    color: var(--vscode-foreground);
    font-size: 12px;
}

.info-section code {
    display: block;
    padding: 6px 8px;
    background-color: var(--vscode-textCodeBlock-background);
    border: 1px solid var(--vscode-panel-border);
    border-radius: 3px;
    font-family: var(--vscode-editor-font-family);
    font-size: 11px;
    color: var(--vscode-textPreformat-foreground);
    overflow-x: auto;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
//# sourceMappingURL=ChromaDBConfig.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/components/ChromaDBConfig.js.map">
{"version":3,"file":"ChromaDBConfig.js","sourceRoot":"","sources":["ChromaDBConfig.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/components/ChromaDBConfig.ts">
/**
 * ChromaDBConfig Component
 * 
 * Handles ChromaDB-specific configuration including connection settings,
 * authentication, and health checking.
 */

import { setupActions, ChromaDBConfig } from '../stores/setupStore';

export class ChromaDBConfigComponent {
    private container: HTMLElement;
    private hostInput: HTMLInputElement | null = null;
    private portInput: HTMLInputElement | null = null;
    private sslCheckbox: HTMLInputElement | null = null;
    private authTokenInput: HTMLInputElement | null = null;
    private testButton: HTMLButtonElement | null = null;
    private statusElement: HTMLElement | null = null;

    constructor(container: HTMLElement) {
        this.container = container;
        this.render();
        this.setupEventListeners();
    }

    /**
     * Render the ChromaDB configuration UI
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="chromadb-config">
                <h4>ChromaDB Configuration</h4>
                <p class="config-description">
                    Configure your ChromaDB connection settings. ChromaDB is an open-source vector database 
                    that can run locally or in the cloud.
                </p>

                <div class="config-grid">
                    <div class="config-item">
                        <label for="chromadb-host">Host:</label>
                        <input type="text" id="chromadb-host" value="localhost" placeholder="localhost">
                        <small>ChromaDB server hostname or IP address</small>
                    </div>

                    <div class="config-item">
                        <label for="chromadb-port">Port:</label>
                        <input type="number" id="chromadb-port" value="8000" placeholder="8000" min="1" max="65535">
                        <small>ChromaDB server port (default: 8000)</small>
                    </div>

                    <div class="config-item checkbox-item">
                        <label class="checkbox-label">
                            <input type="checkbox" id="chromadb-ssl">
                            <span class="checkmark"></span>
                            Use SSL/HTTPS
                        </label>
                        <small>Enable secure connection (recommended for production)</small>
                    </div>

                    <div class="config-item">
                        <label for="chromadb-auth-token">Authentication Token (Optional):</label>
                        <input type="password" id="chromadb-auth-token" placeholder="Enter auth token if required">
                        <small>Leave empty if authentication is not configured</small>
                    </div>
                </div>

                <div class="config-actions">
                    <button id="test-chromadb-connection" class="test-button">Test Connection</button>
                    <div id="chromadb-status" class="connection-status">
                        <span class="status-dot unknown"></span>
                        <span class="status-text">Not tested</span>
                    </div>
                </div>

                <div class="config-info">
                    <div class="info-section">
                        <h5> Docker Setup</h5>
                        <p>To run ChromaDB locally with Docker:</p>
                        <code>docker run -p 8000:8000 chromadb/chroma</code>
                    </div>
                    
                    <div class="info-section">
                        <h5> Manual Installation</h5>
                        <p>Install and run ChromaDB manually:</p>
                        <code>pip install chromadb && chroma run --host 0.0.0.0 --port 8000</code>
                    </div>
                </div>
            </div>
        `;

        // Get references to elements
        this.hostInput = this.container.querySelector('#chromadb-host') as HTMLInputElement;
        this.portInput = this.container.querySelector('#chromadb-port') as HTMLInputElement;
        this.sslCheckbox = this.container.querySelector('#chromadb-ssl') as HTMLInputElement;
        this.authTokenInput = this.container.querySelector('#chromadb-auth-token') as HTMLInputElement;
        this.testButton = this.container.querySelector('#test-chromadb-connection') as HTMLButtonElement;
        this.statusElement = this.container.querySelector('#chromadb-status') as HTMLElement;
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        // Update configuration when inputs change
        [this.hostInput, this.portInput, this.sslCheckbox, this.authTokenInput].forEach(input => {
            if (input) {
                input.addEventListener('input', () => this.updateConfiguration());
                input.addEventListener('change', () => this.updateConfiguration());
            }
        });

        // Test connection button
        if (this.testButton) {
            this.testButton.addEventListener('click', () => this.testConnection());
        }
    }

    /**
     * Update configuration in store
     */
    private updateConfiguration(): void {
        if (!this.hostInput || !this.portInput || !this.sslCheckbox || !this.authTokenInput) return;

        const config: ChromaDBConfig = {
            host: this.hostInput.value || 'localhost',
            port: parseInt(this.portInput.value) || 8000,
            ssl: this.sslCheckbox.checked,
            authToken: this.authTokenInput.value || undefined
        };

        setupActions.setDatabaseConfig(config);
    }

    /**
     * Test ChromaDB connection
     */
    private async testConnection(): Promise<void> {
        if (!this.testButton || !this.statusElement) return;

        // Update UI to show testing state
        this.testButton.disabled = true;
        this.testButton.textContent = 'Testing...';
        this.updateStatus('testing', 'Testing connection...');

        try {
            const config = this.getConfiguration();
            const protocol = config.ssl ? 'https' : 'http';
            const url = `${protocol}://${config.host}:${config.port}/api/v1/heartbeat`;

            // Add auth header if token is provided
            const headers: Record<string, string> = {
                'Content-Type': 'application/json'
            };
            
            if (config.authToken) {
                headers['Authorization'] = `Bearer ${config.authToken}`;
            }

            const response = await fetch(url, {
                method: 'GET',
                headers,
                signal: AbortSignal.timeout(5000) // 5 second timeout
            });

            if (response.ok) {
                const data = await response.json();
                if (data && typeof data === 'object') {
                    this.updateStatus('success', 'Connection successful!');
                    setupActions.updateDatabaseStatus('running');
                } else {
                    this.updateStatus('error', 'Invalid response from ChromaDB');
                }
            } else {
                this.updateStatus('error', `Connection failed: ${response.status} ${response.statusText}`);
            }

        } catch (error) {
            console.error('ChromaDB connection test failed:', error);
            
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    this.updateStatus('error', 'Connection timeout - check host and port');
                } else if (error.message.includes('Failed to fetch')) {
                    this.updateStatus('error', 'Cannot reach ChromaDB - check if it\'s running');
                } else {
                    this.updateStatus('error', `Connection error: ${error.message}`);
                }
            } else {
                this.updateStatus('error', 'Unknown connection error');
            }
        } finally {
            // Reset button state
            this.testButton.disabled = false;
            this.testButton.textContent = 'Test Connection';
        }
    }

    /**
     * Update connection status display
     */
    private updateStatus(type: 'testing' | 'success' | 'error' | 'unknown', message: string): void {
        if (!this.statusElement) return;

        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');

        if (statusDot && statusText) {
            // Remove all status classes
            statusDot.className = 'status-dot';
            statusDot.classList.add(type);
            statusText.textContent = message;
        }
    }

    /**
     * Get current configuration
     */
    private getConfiguration(): ChromaDBConfig {
        return {
            host: this.hostInput?.value || 'localhost',
            port: parseInt(this.portInput?.value || '8000'),
            ssl: this.sslCheckbox?.checked || false,
            authToken: this.authTokenInput?.value || undefined
        };
    }

    /**
     * Load configuration from external source
     */
    public loadConfiguration(config: ChromaDBConfig): void {
        if (this.hostInput) this.hostInput.value = config.host;
        if (this.portInput) this.portInput.value = config.port.toString();
        if (this.sslCheckbox) this.sslCheckbox.checked = config.ssl;
        if (this.authTokenInput) this.authTokenInput.value = config.authToken || '';
        
        this.updateConfiguration();
    }

    /**
     * Validate configuration
     */
    public validateConfiguration(): { isValid: boolean; errors: string[] } {
        const errors: string[] = [];
        const config = this.getConfiguration();

        if (!config.host || config.host.trim() === '') {
            errors.push('Host is required');
        }

        if (!config.port || config.port < 1 || config.port > 65535) {
            errors.push('Port must be between 1 and 65535');
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        // Remove event listeners if needed
    }
}

// CSS styles for ChromaDB configuration
export const chromaDBConfigStyles = `
.chromadb-config {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.chromadb-config h4 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.config-description {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
    line-height: 1.4;
}

.config-grid {
    display: grid;
    gap: 15px;
    margin-bottom: 15px;
}

.config-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.config-item label {
    font-weight: 500;
    color: var(--vscode-foreground);
    font-size: 13px;
}

.config-item input[type="text"],
.config-item input[type="number"],
.config-item input[type="password"] {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item input:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.checkbox-item {
    flex-direction: row;
    align-items: center;
    gap: 8px;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    font-size: 13px;
}

.config-item small {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.config-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.test-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.unknown {
    background-color: var(--vscode-charts-gray);
}

.status-dot.testing {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.success {
    background-color: var(--vscode-charts-green);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 12px;
    color: var(--vscode-foreground);
}

.config-info {
    border-top: 1px solid var(--vscode-panel-border);
    padding-top: 15px;
    margin-top: 15px;
}

.info-section {
    margin-bottom: 12px;
}

.info-section h5 {
    margin: 0 0 6px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.info-section p {
    margin: 0 0 4px 0;
    color: var(--vscode-foreground);
    font-size: 12px;
}

.info-section code {
    display: block;
    padding: 6px 8px;
    background-color: var(--vscode-textCodeBlock-background);
    border: 1px solid var(--vscode-panel-border);
    border-radius: 3px;
    font-family: var(--vscode-editor-font-family);
    font-size: 11px;
    color: var(--vscode-textPreformat-foreground);
    overflow-x: auto;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/components/ConfigurationManagement.js">
"use strict";
/**
 * Configuration Management Component
 *
 * Provides UI for configuration import/export, template management,
 * backup/restore functionality, and configuration validation.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.configurationManagementStyles = exports.ConfigurationManagementComponent = void 0;
const vscodeApi_1 = require("../vscodeApi");
class ConfigurationManagementComponent {
    constructor(container) {
        this.currentTab = 'import-export';
        this.templates = [];
        this.backups = [];
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.setupMessageHandlers();
        this.loadInitialData();
    }
    /**
     * Render the configuration management UI
     */
    render() {
        this.container.innerHTML = `
            <div class="config-management">
                <div class="config-header">
                    <h3>Configuration Management</h3>
                    <p>Manage, import, export, and backup your configurations.</p>
                </div>

                <div class="config-tabs">
                    <button class="tab-button active" data-tab="import-export">
                         Import/Export
                    </button>
                    <button class="tab-button" data-tab="templates">
                         Templates
                    </button>
                    <button class="tab-button" data-tab="backups">
                         Backups
                    </button>
                    <button class="tab-button" data-tab="validation">
                         Validation
                    </button>
                </div>

                <div class="config-content">
                    <div id="import-export-tab" class="tab-content active">
                        ${this.renderImportExportTab()}
                    </div>
                    <div id="templates-tab" class="tab-content">
                        ${this.renderTemplatesTab()}
                    </div>
                    <div id="backups-tab" class="tab-content">
                        ${this.renderBackupsTab()}
                    </div>
                    <div id="validation-tab" class="tab-content">
                        ${this.renderValidationTab()}
                    </div>
                </div>
            </div>
        `;
    }
    /**
     * Render import/export tab
     */
    renderImportExportTab() {
        return `
            <div class="import-export-section">
                <div class="section-group">
                    <h4> Export Configuration</h4>
                    <p>Export your current configuration to share with team members or backup.</p>
                    <div class="export-options">
                        <label class="checkbox-label">
                            <input type="checkbox" id="include-secrets" />
                            Include API keys and secrets (not recommended for sharing)
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="minify-json" />
                            Minify JSON output
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="validate-export" checked />
                            Validate before export
                        </label>
                    </div>
                    <div class="export-actions">
                        <button id="export-config" class="primary-button">
                             Export Configuration
                        </button>
                        <button id="export-template" class="secondary-button">
                             Save as Template
                        </button>
                    </div>
                </div>

                <div class="section-group">
                    <h4> Import Configuration</h4>
                    <p>Import a configuration file to replace or merge with your current setup.</p>
                    <div class="import-options">
                        <label class="checkbox-label">
                            <input type="checkbox" id="validate-import" checked />
                            Validate configuration before import
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="backup-before-import" checked />
                            Create backup before import
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="merge-config" />
                            Merge with current configuration
                        </label>
                    </div>
                    <div class="import-actions">
                        <input type="file" id="config-file-input" accept=".json" style="display: none;" />
                        <button id="import-config" class="primary-button">
                             Import Configuration
                        </button>
                        <button id="import-preset" class="secondary-button">
                             Apply Preset
                        </button>
                    </div>
                </div>

                <div id="import-export-status" class="status-section hidden">
                    <!-- Status messages will appear here -->
                </div>
            </div>
        `;
    }
    /**
     * Render templates tab
     */
    renderTemplatesTab() {
        return `
            <div class="templates-section">
                <div class="section-header">
                    <h4> Configuration Templates</h4>
                    <button id="refresh-templates" class="icon-button"></button>
                </div>
                <p>Use pre-built templates or create your own for quick configuration setup.</p>
                
                <div class="templates-grid" id="templates-grid">
                    ${this.renderTemplatesList()}
                </div>

                <div class="template-actions">
                    <button id="create-template" class="primary-button">
                         Create Template
                    </button>
                </div>
            </div>
        `;
    }
    /**
     * Render backups tab
     */
    renderBackupsTab() {
        return `
            <div class="backups-section">
                <div class="section-header">
                    <h4> Configuration Backups</h4>
                    <button id="refresh-backups" class="icon-button"></button>
                </div>
                <p>Manage automatic and manual configuration backups.</p>
                
                <div class="backup-actions">
                    <button id="create-backup" class="primary-button">
                         Create Backup
                    </button>
                    <button id="cleanup-backups" class="secondary-button">
                         Cleanup Old Backups
                    </button>
                </div>

                <div class="backups-list" id="backups-list">
                    ${this.renderBackupsList()}
                </div>
            </div>
        `;
    }
    /**
     * Render validation tab
     */
    renderValidationTab() {
        return `
            <div class="validation-section">
                <div class="section-header">
                    <h4> Configuration Validation</h4>
                    <button id="validate-current" class="primary-button">
                         Validate Current Configuration
                    </button>
                </div>
                <p>Validate your configuration for errors and get improvement suggestions.</p>
                
                <div id="validation-results" class="validation-results hidden">
                    <!-- Validation results will appear here -->
                </div>

                <div class="validation-info">
                    <h5>What We Validate</h5>
                    <ul>
                        <li>Configuration schema compliance</li>
                        <li>Required fields and data types</li>
                        <li>Provider-specific settings</li>
                        <li>Performance and security recommendations</li>
                        <li>Cross-section compatibility</li>
                    </ul>
                </div>
            </div>
        `;
    }
    /**
     * Render templates list
     */
    renderTemplatesList() {
        if (this.templates.length === 0) {
            return `
                <div class="empty-state">
                    <p>No templates available. Create your first template or load presets.</p>
                    <button id="load-presets" class="secondary-button">Load Default Presets</button>
                </div>
            `;
        }
        return this.templates.map(template => `
            <div class="template-card ${template.category}">
                <div class="template-header">
                    <h6>${template.name}</h6>
                    <span class="template-category">${template.category.toUpperCase()}</span>
                </div>
                <div class="template-description">${template.description}</div>
                <div class="template-tags">
                    ${template.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                </div>
                <div class="template-actions">
                    <button class="apply-template" data-template-id="${template.id}">
                        Apply
                    </button>
                    <button class="view-template" data-template-id="${template.id}">
                        View
                    </button>
                    ${template.category === 'custom' ? `
                        <button class="delete-template" data-template-id="${template.id}">
                            Delete
                        </button>
                    ` : ''}
                </div>
            </div>
        `).join('');
    }
    /**
     * Render backups list
     */
    renderBackupsList() {
        if (this.backups.length === 0) {
            return `
                <div class="empty-state">
                    <p>No backups available. Create your first backup to get started.</p>
                </div>
            `;
        }
        return this.backups.map(backup => `
            <div class="backup-item">
                <div class="backup-info">
                    <div class="backup-name">${backup.name}</div>
                    <div class="backup-meta">
                        <span class="backup-date">${new Date(backup.timestamp).toLocaleString()}</span>
                        <span class="backup-reason ${backup.metadata.reason}">${backup.metadata.reason.toUpperCase()}</span>
                    </div>
                    ${backup.metadata.description ? `
                        <div class="backup-description">${backup.metadata.description}</div>
                    ` : ''}
                </div>
                <div class="backup-actions">
                    <button class="restore-backup" data-backup-id="${backup.id}">
                         Restore
                    </button>
                    <button class="delete-backup" data-backup-id="${backup.id}">
                         Delete
                    </button>
                </div>
            </div>
        `).join('');
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Tab switching
        this.container.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('tab-button')) {
                const tab = target.dataset.tab;
                this.switchTab(tab);
            }
        });
        // Import/Export actions
        this.setupImportExportListeners();
        // Template actions
        this.setupTemplateListeners();
        // Backup actions
        this.setupBackupListeners();
        // Validation actions
        this.setupValidationListeners();
    }
    /**
     * Set up import/export event listeners
     */
    setupImportExportListeners() {
        const exportButton = this.container.querySelector('#export-config');
        const importButton = this.container.querySelector('#import-config');
        const fileInput = this.container.querySelector('#config-file-input');
        const exportTemplateButton = this.container.querySelector('#export-template');
        const importPresetButton = this.container.querySelector('#import-preset');
        exportButton?.addEventListener('click', () => this.exportConfiguration());
        importButton?.addEventListener('click', () => fileInput?.click());
        exportTemplateButton?.addEventListener('click', () => this.saveAsTemplate());
        importPresetButton?.addEventListener('click', () => this.showPresetDialog());
        fileInput?.addEventListener('change', (e) => {
            const file = e.target.files?.[0];
            if (file) {
                this.importConfiguration(file);
            }
        });
    }
    /**
     * Set up template event listeners
     */
    setupTemplateListeners() {
        this.container.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('apply-template')) {
                const templateId = target.dataset.templateId;
                if (templateId)
                    this.applyTemplate(templateId);
            }
            if (target.classList.contains('view-template')) {
                const templateId = target.dataset.templateId;
                if (templateId)
                    this.viewTemplate(templateId);
            }
            if (target.classList.contains('delete-template')) {
                const templateId = target.dataset.templateId;
                if (templateId)
                    this.deleteTemplate(templateId);
            }
        });
        const refreshButton = this.container.querySelector('#refresh-templates');
        const createButton = this.container.querySelector('#create-template');
        const loadPresetsButton = this.container.querySelector('#load-presets');
        refreshButton?.addEventListener('click', () => this.loadTemplates());
        createButton?.addEventListener('click', () => this.createTemplate());
        loadPresetsButton?.addEventListener('click', () => this.loadPresets());
    }
    /**
     * Set up backup event listeners
     */
    setupBackupListeners() {
        this.container.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('restore-backup')) {
                const backupId = target.dataset.backupId;
                if (backupId)
                    this.restoreBackup(backupId);
            }
            if (target.classList.contains('delete-backup')) {
                const backupId = target.dataset.backupId;
                if (backupId)
                    this.deleteBackup(backupId);
            }
        });
        const createButton = this.container.querySelector('#create-backup');
        const cleanupButton = this.container.querySelector('#cleanup-backups');
        const refreshButton = this.container.querySelector('#refresh-backups');
        createButton?.addEventListener('click', () => this.createBackup());
        cleanupButton?.addEventListener('click', () => this.cleanupBackups());
        refreshButton?.addEventListener('click', () => this.loadBackups());
    }
    /**
     * Set up validation event listeners
     */
    setupValidationListeners() {
        const validateButton = this.container.querySelector('#validate-current');
        validateButton?.addEventListener('click', () => this.validateConfiguration());
    }
    /**
     * Set up message handlers for extension communication
     */
    setupMessageHandlers() {
        vscodeApi_1.vscodeApi.onMessage('configurationTemplates', (event) => {
            this.templates = event.data;
            this.updateTemplatesDisplay();
        });
        vscodeApi_1.vscodeApi.onMessage('configurationBackups', (event) => {
            this.backups = event.data;
            this.updateBackupsDisplay();
        });
        vscodeApi_1.vscodeApi.onMessage('validationResult', (event) => {
            this.displayValidationResults(event.data);
        });
        vscodeApi_1.vscodeApi.onMessage('configurationOperationResult', (event) => {
            this.handleOperationResult(event.data);
        });
    }
    /**
     * Load initial data
     */
    async loadInitialData() {
        this.loadTemplates();
        this.loadBackups();
    }
    /**
     * Switch between tabs
     */
    switchTab(tab) {
        // Update tab buttons
        this.container.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
        });
        this.container.querySelector(`[data-tab="${tab}"]`)?.classList.add('active');
        // Update tab content
        this.container.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        this.container.querySelector(`#${tab}-tab`)?.classList.add('active');
        this.currentTab = tab;
    }
    /**
     * Export configuration
     */
    exportConfiguration() {
        const includeSecrets = this.container.querySelector('#include-secrets')?.checked || false;
        const minify = this.container.querySelector('#minify-json')?.checked || false;
        const validate = this.container.querySelector('#validate-export')?.checked || true;
        vscodeApi_1.vscodeApi.postMessage({
            command: 'exportConfiguration',
            options: {
                includeSecrets,
                minify,
                validate
            }
        });
    }
    /**
     * Import configuration
     */
    importConfiguration(file) {
        const validate = this.container.querySelector('#validate-import')?.checked || true;
        const backup = this.container.querySelector('#backup-before-import')?.checked || true;
        const merge = this.container.querySelector('#merge-config')?.checked || false;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const configData = JSON.parse(e.target?.result);
                vscodeApi_1.vscodeApi.postMessage({
                    command: 'importConfiguration',
                    configData,
                    options: {
                        validate,
                        backup,
                        merge
                    }
                });
            }
            catch (error) {
                this.showStatus('error', 'Invalid JSON file');
            }
        };
        reader.readAsText(file);
    }
    /**
     * Load templates
     */
    loadTemplates() {
        vscodeApi_1.vscodeApi.postMessage({
            command: 'getConfigurationTemplates'
        });
    }
    /**
     * Load backups
     */
    loadBackups() {
        vscodeApi_1.vscodeApi.postMessage({
            command: 'getConfigurationBackups'
        });
    }
    /**
     * Validate configuration
     */
    validateConfiguration() {
        vscodeApi_1.vscodeApi.postMessage({
            command: 'validateConfiguration'
        });
    }
    /**
     * Apply template
     */
    applyTemplate(templateId) {
        vscodeApi_1.vscodeApi.postMessage({
            command: 'applyConfigurationTemplate',
            templateId
        });
    }
    /**
     * Create backup
     */
    createBackup() {
        vscodeApi_1.vscodeApi.postMessage({
            command: 'createConfigurationBackup',
            reason: 'manual',
            description: 'Manual backup created by user'
        });
    }
    /**
     * Restore backup
     */
    restoreBackup(backupId) {
        if (confirm('Are you sure you want to restore this backup? This will replace your current configuration.')) {
            vscodeApi_1.vscodeApi.postMessage({
                command: 'restoreConfigurationBackup',
                backupId
            });
        }
    }
    /**
     * Helper methods for UI updates
     */
    updateTemplatesDisplay() {
        const templatesGrid = this.container.querySelector('#templates-grid');
        if (templatesGrid) {
            templatesGrid.innerHTML = this.renderTemplatesList();
        }
    }
    updateBackupsDisplay() {
        const backupsList = this.container.querySelector('#backups-list');
        if (backupsList) {
            backupsList.innerHTML = this.renderBackupsList();
        }
    }
    displayValidationResults(result) {
        const resultsContainer = this.container.querySelector('#validation-results');
        if (!resultsContainer)
            return;
        resultsContainer.innerHTML = `
            <div class="validation-summary ${result.isValid ? 'valid' : 'invalid'}">
                <h5>${result.isValid ? ' Configuration Valid' : ' Configuration Invalid'}</h5>
                <p>${result.errors.length} errors, ${result.warnings.length} warnings</p>
            </div>
            
            ${result.errors.length > 0 ? `
                <div class="validation-errors">
                    <h6>Errors</h6>
                    ${result.errors.map(error => `
                        <div class="validation-item error">
                            <strong>${error.path}</strong>: ${error.message}
                        </div>
                    `).join('')}
                </div>
            ` : ''}
            
            ${result.warnings.length > 0 ? `
                <div class="validation-warnings">
                    <h6>Warnings</h6>
                    ${result.warnings.map(warning => `
                        <div class="validation-item warning">
                            <strong>${warning.path}</strong>: ${warning.message}
                            ${warning.suggestion ? `<br><em>Suggestion: ${warning.suggestion}</em>` : ''}
                        </div>
                    `).join('')}
                </div>
            ` : ''}
        `;
        resultsContainer.classList.remove('hidden');
    }
    handleOperationResult(result) {
        this.showStatus(result.success ? 'success' : 'error', result.message);
        // Refresh data if needed
        if (result.success && result.type === 'template') {
            this.loadTemplates();
        }
        else if (result.success && result.type === 'backup') {
            this.loadBackups();
        }
    }
    showStatus(type, message) {
        const statusSection = this.container.querySelector('#import-export-status');
        if (statusSection) {
            statusSection.innerHTML = `
                <div class="status-message ${type}">
                    ${type === 'success' ? '' : type === 'error' ? '' : ''} ${message}
                </div>
            `;
            statusSection.classList.remove('hidden');
            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusSection.classList.add('hidden');
            }, 5000);
        }
    }
    // Placeholder methods for additional functionality
    saveAsTemplate() {
        // Implementation for saving current config as template
        vscodeApi_1.vscodeApi.postMessage({ command: 'saveConfigurationAsTemplate' });
    }
    showPresetDialog() {
        // Implementation for showing preset selection dialog
        vscodeApi_1.vscodeApi.postMessage({ command: 'showConfigurationPresets' });
    }
    viewTemplate(templateId) {
        // Implementation for viewing template details
        vscodeApi_1.vscodeApi.postMessage({ command: 'viewConfigurationTemplate', templateId });
    }
    deleteTemplate(templateId) {
        if (confirm('Are you sure you want to delete this template?')) {
            vscodeApi_1.vscodeApi.postMessage({ command: 'deleteConfigurationTemplate', templateId });
        }
    }
    deleteBackup(backupId) {
        if (confirm('Are you sure you want to delete this backup?')) {
            vscodeApi_1.vscodeApi.postMessage({ command: 'deleteConfigurationBackup', backupId });
        }
    }
    createTemplate() {
        // Implementation for creating new template
        vscodeApi_1.vscodeApi.postMessage({ command: 'createConfigurationTemplate' });
    }
    loadPresets() {
        // Implementation for loading default presets
        vscodeApi_1.vscodeApi.postMessage({ command: 'loadConfigurationPresets' });
    }
    cleanupBackups() {
        if (confirm('This will remove old backups (keeping the 10 most recent). Continue?')) {
            vscodeApi_1.vscodeApi.postMessage({ command: 'cleanupConfigurationBackups' });
        }
    }
    /**
     * Cleanup component
     */
    dispose() {
        // Remove event listeners if needed
    }
}
exports.ConfigurationManagementComponent = ConfigurationManagementComponent;
// CSS styles for ConfigurationManagement component
exports.configurationManagementStyles = `
.config-management {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    margin-bottom: 20px;
    background-color: var(--vscode-sideBar-background);
}

.config-header {
    text-align: center;
    margin-bottom: 20px;
}

.config-header h3 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.config-header p {
    margin: 0;
    color: var(--vscode-descriptionForeground);
    font-size: 14px;
}

.config-tabs {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
    margin-bottom: 20px;
}

.tab-button {
    padding: 10px 16px;
    border: none;
    background: none;
    color: var(--vscode-foreground);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    font-family: inherit;
    font-size: 14px;
    transition: all 0.2s ease;
}

.tab-button:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}

.tab-button.active {
    color: var(--vscode-textLink-foreground);
    border-bottom-color: var(--vscode-textLink-foreground);
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.section-group {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.section-group h4 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 16px;
}

.section-group p {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.section-header h4 {
    margin: 0;
    color: var(--vscode-textLink-foreground);
}

.icon-button {
    padding: 6px;
    border: none;
    background: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    border-radius: 3px;
    cursor: pointer;
    font-size: 14px;
}

.icon-button:hover {
    background: var(--vscode-button-secondaryHoverBackground);
}

.checkbox-label {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    font-size: 13px;
    color: var(--vscode-foreground);
    cursor: pointer;
}

.checkbox-label input[type="checkbox"] {
    margin-right: 8px;
}

.export-actions,
.import-actions,
.template-actions,
.backup-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.primary-button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.primary-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.secondary-button {
    padding: 8px 16px;
    border: 1px solid var(--vscode-button-border);
    border-radius: 4px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.secondary-button:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.status-section {
    margin-top: 20px;
    padding: 15px;
    border-radius: 4px;
}

.status-section.hidden {
    display: none;
}

.status-message {
    padding: 10px;
    border-radius: 4px;
    font-size: 13px;
}

.status-message.success {
    background-color: var(--vscode-charts-green);
    color: white;
}

.status-message.error {
    background-color: var(--vscode-charts-red);
    color: white;
}

.status-message.warning {
    background-color: var(--vscode-charts-orange);
    color: white;
}

.templates-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.template-card {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.template-card.development {
    border-left: 3px solid var(--vscode-charts-blue);
}

.template-card.production {
    border-left: 3px solid var(--vscode-charts-red);
}

.template-card.team {
    border-left: 3px solid var(--vscode-charts-green);
}

.template-card.custom {
    border-left: 3px solid var(--vscode-charts-purple);
}

.template-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
}

.template-header h6 {
    margin: 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.template-category {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 2px;
    background-color: var(--vscode-badge-background);
    color: var(--vscode-badge-foreground);
}

.template-description {
    color: var(--vscode-foreground);
    font-size: 12px;
    margin-bottom: 10px;
    line-height: 1.4;
}

.template-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-bottom: 10px;
}

.tag {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 2px;
    background-color: var(--vscode-textCodeBlock-background);
    color: var(--vscode-foreground);
}

.template-actions {
    display: flex;
    gap: 6px;
}

.template-actions button {
    padding: 4px 8px;
    border: none;
    border-radius: 3px;
    font-size: 11px;
    cursor: pointer;
}

.apply-template {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
}

.view-template {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}

.delete-template {
    background-color: var(--vscode-charts-red);
    color: white;
}

.backups-list {
    margin-top: 20px;
}

.backup-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    margin-bottom: 10px;
    background-color: var(--vscode-editor-background);
}

.backup-info {
    flex: 1;
}

.backup-name {
    font-weight: 500;
    color: var(--vscode-foreground);
    margin-bottom: 4px;
}

.backup-meta {
    display: flex;
    gap: 10px;
    align-items: center;
    margin-bottom: 4px;
}

.backup-date {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
}

.backup-reason {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 2px;
    font-weight: bold;
}

.backup-reason.manual {
    background-color: var(--vscode-charts-blue);
    color: white;
}

.backup-reason.auto {
    background-color: var(--vscode-charts-green);
    color: white;
}

.backup-reason.migration {
    background-color: var(--vscode-charts-orange);
    color: white;
}

.backup-description {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
    font-style: italic;
}

.backup-actions {
    display: flex;
    gap: 6px;
}

.backup-actions button {
    padding: 4px 8px;
    border: none;
    border-radius: 3px;
    font-size: 11px;
    cursor: pointer;
}

.restore-backup {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
}

.delete-backup {
    background-color: var(--vscode-charts-red);
    color: white;
}

.validation-results {
    margin-top: 20px;
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.validation-results.hidden {
    display: none;
}

.validation-summary {
    padding: 10px;
    border-radius: 4px;
    margin-bottom: 15px;
}

.validation-summary.valid {
    background-color: var(--vscode-charts-green);
    color: white;
}

.validation-summary.invalid {
    background-color: var(--vscode-charts-red);
    color: white;
}

.validation-summary h5 {
    margin: 0 0 5px 0;
}

.validation-summary p {
    margin: 0;
    font-size: 13px;
}

.validation-errors,
.validation-warnings {
    margin-bottom: 15px;
}

.validation-errors h6,
.validation-warnings h6 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.validation-item {
    padding: 8px;
    border-radius: 3px;
    margin-bottom: 6px;
    font-size: 12px;
}

.validation-item.error {
    background-color: var(--vscode-inputValidation-errorBackground);
    border-left: 3px solid var(--vscode-charts-red);
}

.validation-item.warning {
    background-color: var(--vscode-inputValidation-warningBackground);
    border-left: 3px solid var(--vscode-charts-orange);
}

.validation-info {
    margin-top: 20px;
    padding: 15px;
    background-color: var(--vscode-textCodeBlock-background);
    border-radius: 4px;
}

.validation-info h5 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.validation-info ul {
    margin: 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
}

.validation-info li {
    margin-bottom: 4px;
    font-size: 13px;
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--vscode-descriptionForeground);
}

.empty-state p {
    margin-bottom: 15px;
}
`;
//# sourceMappingURL=ConfigurationManagement.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/components/ConfigurationManagement.js.map">
{"version":3,"file":"ConfigurationManagement.js","sourceRoot":"","sources":["ConfigurationManagement.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/components/ConfigurationManagement.ts">
/**
 * Configuration Management Component
 * 
 * Provides UI for configuration import/export, template management,
 * backup/restore functionality, and configuration validation.
 */

import { vscodeApi } from '../vscodeApi';

export interface ConfigurationTemplate {
    id: string;
    name: string;
    description: string;
    category: 'development' | 'production' | 'team' | 'custom';
    tags: string[];
    version: string;
}

export interface ConfigurationBackup {
    id: string;
    name: string;
    timestamp: string;
    metadata: {
        reason: 'manual' | 'auto' | 'migration';
        description?: string;
    };
}

export interface ValidationResult {
    isValid: boolean;
    errors: Array<{ path: string; message: string; severity: string }>;
    warnings: Array<{ path: string; message: string; suggestion?: string }>;
}

export class ConfigurationManagementComponent {
    private container: HTMLElement;
    private currentTab: 'import-export' | 'templates' | 'backups' | 'validation' = 'import-export';
    private templates: ConfigurationTemplate[] = [];
    private backups: ConfigurationBackup[] = [];

    constructor(container: HTMLElement) {
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.setupMessageHandlers();
        this.loadInitialData();
    }

    /**
     * Render the configuration management UI
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="config-management">
                <div class="config-header">
                    <h3>Configuration Management</h3>
                    <p>Manage, import, export, and backup your configurations.</p>
                </div>

                <div class="config-tabs">
                    <button class="tab-button active" data-tab="import-export">
                         Import/Export
                    </button>
                    <button class="tab-button" data-tab="templates">
                         Templates
                    </button>
                    <button class="tab-button" data-tab="backups">
                         Backups
                    </button>
                    <button class="tab-button" data-tab="validation">
                         Validation
                    </button>
                </div>

                <div class="config-content">
                    <div id="import-export-tab" class="tab-content active">
                        ${this.renderImportExportTab()}
                    </div>
                    <div id="templates-tab" class="tab-content">
                        ${this.renderTemplatesTab()}
                    </div>
                    <div id="backups-tab" class="tab-content">
                        ${this.renderBackupsTab()}
                    </div>
                    <div id="validation-tab" class="tab-content">
                        ${this.renderValidationTab()}
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Render import/export tab
     */
    private renderImportExportTab(): string {
        return `
            <div class="import-export-section">
                <div class="section-group">
                    <h4> Export Configuration</h4>
                    <p>Export your current configuration to share with team members or backup.</p>
                    <div class="export-options">
                        <label class="checkbox-label">
                            <input type="checkbox" id="include-secrets" />
                            Include API keys and secrets (not recommended for sharing)
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="minify-json" />
                            Minify JSON output
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="validate-export" checked />
                            Validate before export
                        </label>
                    </div>
                    <div class="export-actions">
                        <button id="export-config" class="primary-button">
                             Export Configuration
                        </button>
                        <button id="export-template" class="secondary-button">
                             Save as Template
                        </button>
                    </div>
                </div>

                <div class="section-group">
                    <h4> Import Configuration</h4>
                    <p>Import a configuration file to replace or merge with your current setup.</p>
                    <div class="import-options">
                        <label class="checkbox-label">
                            <input type="checkbox" id="validate-import" checked />
                            Validate configuration before import
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="backup-before-import" checked />
                            Create backup before import
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="merge-config" />
                            Merge with current configuration
                        </label>
                    </div>
                    <div class="import-actions">
                        <input type="file" id="config-file-input" accept=".json" style="display: none;" />
                        <button id="import-config" class="primary-button">
                             Import Configuration
                        </button>
                        <button id="import-preset" class="secondary-button">
                             Apply Preset
                        </button>
                    </div>
                </div>

                <div id="import-export-status" class="status-section hidden">
                    <!-- Status messages will appear here -->
                </div>
            </div>
        `;
    }

    /**
     * Render templates tab
     */
    private renderTemplatesTab(): string {
        return `
            <div class="templates-section">
                <div class="section-header">
                    <h4> Configuration Templates</h4>
                    <button id="refresh-templates" class="icon-button"></button>
                </div>
                <p>Use pre-built templates or create your own for quick configuration setup.</p>
                
                <div class="templates-grid" id="templates-grid">
                    ${this.renderTemplatesList()}
                </div>

                <div class="template-actions">
                    <button id="create-template" class="primary-button">
                         Create Template
                    </button>
                </div>
            </div>
        `;
    }

    /**
     * Render backups tab
     */
    private renderBackupsTab(): string {
        return `
            <div class="backups-section">
                <div class="section-header">
                    <h4> Configuration Backups</h4>
                    <button id="refresh-backups" class="icon-button"></button>
                </div>
                <p>Manage automatic and manual configuration backups.</p>
                
                <div class="backup-actions">
                    <button id="create-backup" class="primary-button">
                         Create Backup
                    </button>
                    <button id="cleanup-backups" class="secondary-button">
                         Cleanup Old Backups
                    </button>
                </div>

                <div class="backups-list" id="backups-list">
                    ${this.renderBackupsList()}
                </div>
            </div>
        `;
    }

    /**
     * Render validation tab
     */
    private renderValidationTab(): string {
        return `
            <div class="validation-section">
                <div class="section-header">
                    <h4> Configuration Validation</h4>
                    <button id="validate-current" class="primary-button">
                         Validate Current Configuration
                    </button>
                </div>
                <p>Validate your configuration for errors and get improvement suggestions.</p>
                
                <div id="validation-results" class="validation-results hidden">
                    <!-- Validation results will appear here -->
                </div>

                <div class="validation-info">
                    <h5>What We Validate</h5>
                    <ul>
                        <li>Configuration schema compliance</li>
                        <li>Required fields and data types</li>
                        <li>Provider-specific settings</li>
                        <li>Performance and security recommendations</li>
                        <li>Cross-section compatibility</li>
                    </ul>
                </div>
            </div>
        `;
    }

    /**
     * Render templates list
     */
    private renderTemplatesList(): string {
        if (this.templates.length === 0) {
            return `
                <div class="empty-state">
                    <p>No templates available. Create your first template or load presets.</p>
                    <button id="load-presets" class="secondary-button">Load Default Presets</button>
                </div>
            `;
        }

        return this.templates.map(template => `
            <div class="template-card ${template.category}">
                <div class="template-header">
                    <h6>${template.name}</h6>
                    <span class="template-category">${template.category.toUpperCase()}</span>
                </div>
                <div class="template-description">${template.description}</div>
                <div class="template-tags">
                    ${template.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                </div>
                <div class="template-actions">
                    <button class="apply-template" data-template-id="${template.id}">
                        Apply
                    </button>
                    <button class="view-template" data-template-id="${template.id}">
                        View
                    </button>
                    ${template.category === 'custom' ? `
                        <button class="delete-template" data-template-id="${template.id}">
                            Delete
                        </button>
                    ` : ''}
                </div>
            </div>
        `).join('');
    }

    /**
     * Render backups list
     */
    private renderBackupsList(): string {
        if (this.backups.length === 0) {
            return `
                <div class="empty-state">
                    <p>No backups available. Create your first backup to get started.</p>
                </div>
            `;
        }

        return this.backups.map(backup => `
            <div class="backup-item">
                <div class="backup-info">
                    <div class="backup-name">${backup.name}</div>
                    <div class="backup-meta">
                        <span class="backup-date">${new Date(backup.timestamp).toLocaleString()}</span>
                        <span class="backup-reason ${backup.metadata.reason}">${backup.metadata.reason.toUpperCase()}</span>
                    </div>
                    ${backup.metadata.description ? `
                        <div class="backup-description">${backup.metadata.description}</div>
                    ` : ''}
                </div>
                <div class="backup-actions">
                    <button class="restore-backup" data-backup-id="${backup.id}">
                         Restore
                    </button>
                    <button class="delete-backup" data-backup-id="${backup.id}">
                         Delete
                    </button>
                </div>
            </div>
        `).join('');
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        // Tab switching
        this.container.addEventListener('click', (e) => {
            const target = e.target as HTMLElement;
            
            if (target.classList.contains('tab-button')) {
                const tab = target.dataset.tab as typeof this.currentTab;
                this.switchTab(tab);
            }
        });

        // Import/Export actions
        this.setupImportExportListeners();
        
        // Template actions
        this.setupTemplateListeners();
        
        // Backup actions
        this.setupBackupListeners();
        
        // Validation actions
        this.setupValidationListeners();
    }

    /**
     * Set up import/export event listeners
     */
    private setupImportExportListeners(): void {
        const exportButton = this.container.querySelector('#export-config');
        const importButton = this.container.querySelector('#import-config');
        const fileInput = this.container.querySelector('#config-file-input') as HTMLInputElement;
        const exportTemplateButton = this.container.querySelector('#export-template');
        const importPresetButton = this.container.querySelector('#import-preset');

        exportButton?.addEventListener('click', () => this.exportConfiguration());
        importButton?.addEventListener('click', () => fileInput?.click());
        exportTemplateButton?.addEventListener('click', () => this.saveAsTemplate());
        importPresetButton?.addEventListener('click', () => this.showPresetDialog());

        fileInput?.addEventListener('change', (e) => {
            const file = (e.target as HTMLInputElement).files?.[0];
            if (file) {
                this.importConfiguration(file);
            }
        });
    }

    /**
     * Set up template event listeners
     */
    private setupTemplateListeners(): void {
        this.container.addEventListener('click', (e) => {
            const target = e.target as HTMLElement;
            
            if (target.classList.contains('apply-template')) {
                const templateId = target.dataset.templateId;
                if (templateId) this.applyTemplate(templateId);
            }
            
            if (target.classList.contains('view-template')) {
                const templateId = target.dataset.templateId;
                if (templateId) this.viewTemplate(templateId);
            }
            
            if (target.classList.contains('delete-template')) {
                const templateId = target.dataset.templateId;
                if (templateId) this.deleteTemplate(templateId);
            }
        });

        const refreshButton = this.container.querySelector('#refresh-templates');
        const createButton = this.container.querySelector('#create-template');
        const loadPresetsButton = this.container.querySelector('#load-presets');

        refreshButton?.addEventListener('click', () => this.loadTemplates());
        createButton?.addEventListener('click', () => this.createTemplate());
        loadPresetsButton?.addEventListener('click', () => this.loadPresets());
    }

    /**
     * Set up backup event listeners
     */
    private setupBackupListeners(): void {
        this.container.addEventListener('click', (e) => {
            const target = e.target as HTMLElement;
            
            if (target.classList.contains('restore-backup')) {
                const backupId = target.dataset.backupId;
                if (backupId) this.restoreBackup(backupId);
            }
            
            if (target.classList.contains('delete-backup')) {
                const backupId = target.dataset.backupId;
                if (backupId) this.deleteBackup(backupId);
            }
        });

        const createButton = this.container.querySelector('#create-backup');
        const cleanupButton = this.container.querySelector('#cleanup-backups');
        const refreshButton = this.container.querySelector('#refresh-backups');

        createButton?.addEventListener('click', () => this.createBackup());
        cleanupButton?.addEventListener('click', () => this.cleanupBackups());
        refreshButton?.addEventListener('click', () => this.loadBackups());
    }

    /**
     * Set up validation event listeners
     */
    private setupValidationListeners(): void {
        const validateButton = this.container.querySelector('#validate-current');
        validateButton?.addEventListener('click', () => this.validateConfiguration());
    }

    /**
     * Set up message handlers for extension communication
     */
    private setupMessageHandlers(): void {
        vscodeApi.onMessage('configurationTemplates', (event) => {
            this.templates = event.data;
            this.updateTemplatesDisplay();
        });

        vscodeApi.onMessage('configurationBackups', (event) => {
            this.backups = event.data;
            this.updateBackupsDisplay();
        });

        vscodeApi.onMessage('validationResult', (event) => {
            this.displayValidationResults(event.data);
        });

        vscodeApi.onMessage('configurationOperationResult', (event) => {
            this.handleOperationResult(event.data);
        });
    }

    /**
     * Load initial data
     */
    private async loadInitialData(): Promise<void> {
        this.loadTemplates();
        this.loadBackups();
    }

    /**
     * Switch between tabs
     */
    private switchTab(tab: typeof this.currentTab): void {
        // Update tab buttons
        this.container.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
        });
        this.container.querySelector(`[data-tab="${tab}"]`)?.classList.add('active');

        // Update tab content
        this.container.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        this.container.querySelector(`#${tab}-tab`)?.classList.add('active');

        this.currentTab = tab;
    }

    /**
     * Export configuration
     */
    private exportConfiguration(): void {
        const includeSecrets = (this.container.querySelector('#include-secrets') as HTMLInputElement)?.checked || false;
        const minify = (this.container.querySelector('#minify-json') as HTMLInputElement)?.checked || false;
        const validate = (this.container.querySelector('#validate-export') as HTMLInputElement)?.checked || true;

        vscodeApi.postMessage({
            command: 'exportConfiguration',
            options: {
                includeSecrets,
                minify,
                validate
            }
        });
    }

    /**
     * Import configuration
     */
    private importConfiguration(file: File): void {
        const validate = (this.container.querySelector('#validate-import') as HTMLInputElement)?.checked || true;
        const backup = (this.container.querySelector('#backup-before-import') as HTMLInputElement)?.checked || true;
        const merge = (this.container.querySelector('#merge-config') as HTMLInputElement)?.checked || false;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const configData = JSON.parse(e.target?.result as string);
                
                vscodeApi.postMessage({
                    command: 'importConfiguration',
                    configData,
                    options: {
                        validate,
                        backup,
                        merge
                    }
                });
            } catch (error) {
                this.showStatus('error', 'Invalid JSON file');
            }
        };
        reader.readAsText(file);
    }

    /**
     * Load templates
     */
    private loadTemplates(): void {
        vscodeApi.postMessage({
            command: 'getConfigurationTemplates'
        });
    }

    /**
     * Load backups
     */
    private loadBackups(): void {
        vscodeApi.postMessage({
            command: 'getConfigurationBackups'
        });
    }

    /**
     * Validate configuration
     */
    private validateConfiguration(): void {
        vscodeApi.postMessage({
            command: 'validateConfiguration'
        });
    }

    /**
     * Apply template
     */
    private applyTemplate(templateId: string): void {
        vscodeApi.postMessage({
            command: 'applyConfigurationTemplate',
            templateId
        });
    }

    /**
     * Create backup
     */
    private createBackup(): void {
        vscodeApi.postMessage({
            command: 'createConfigurationBackup',
            reason: 'manual',
            description: 'Manual backup created by user'
        });
    }

    /**
     * Restore backup
     */
    private restoreBackup(backupId: string): void {
        if (confirm('Are you sure you want to restore this backup? This will replace your current configuration.')) {
            vscodeApi.postMessage({
                command: 'restoreConfigurationBackup',
                backupId
            });
        }
    }

    /**
     * Helper methods for UI updates
     */
    private updateTemplatesDisplay(): void {
        const templatesGrid = this.container.querySelector('#templates-grid');
        if (templatesGrid) {
            templatesGrid.innerHTML = this.renderTemplatesList();
        }
    }

    private updateBackupsDisplay(): void {
        const backupsList = this.container.querySelector('#backups-list');
        if (backupsList) {
            backupsList.innerHTML = this.renderBackupsList();
        }
    }

    private displayValidationResults(result: ValidationResult): void {
        const resultsContainer = this.container.querySelector('#validation-results');
        if (!resultsContainer) return;

        resultsContainer.innerHTML = `
            <div class="validation-summary ${result.isValid ? 'valid' : 'invalid'}">
                <h5>${result.isValid ? ' Configuration Valid' : ' Configuration Invalid'}</h5>
                <p>${result.errors.length} errors, ${result.warnings.length} warnings</p>
            </div>
            
            ${result.errors.length > 0 ? `
                <div class="validation-errors">
                    <h6>Errors</h6>
                    ${result.errors.map(error => `
                        <div class="validation-item error">
                            <strong>${error.path}</strong>: ${error.message}
                        </div>
                    `).join('')}
                </div>
            ` : ''}
            
            ${result.warnings.length > 0 ? `
                <div class="validation-warnings">
                    <h6>Warnings</h6>
                    ${result.warnings.map(warning => `
                        <div class="validation-item warning">
                            <strong>${warning.path}</strong>: ${warning.message}
                            ${warning.suggestion ? `<br><em>Suggestion: ${warning.suggestion}</em>` : ''}
                        </div>
                    `).join('')}
                </div>
            ` : ''}
        `;
        
        resultsContainer.classList.remove('hidden');
    }

    private handleOperationResult(result: { success: boolean; message: string; type: string }): void {
        this.showStatus(result.success ? 'success' : 'error', result.message);
        
        // Refresh data if needed
        if (result.success && result.type === 'template') {
            this.loadTemplates();
        } else if (result.success && result.type === 'backup') {
            this.loadBackups();
        }
    }

    private showStatus(type: 'success' | 'error' | 'warning', message: string): void {
        const statusSection = this.container.querySelector('#import-export-status');
        if (statusSection) {
            statusSection.innerHTML = `
                <div class="status-message ${type}">
                    ${type === 'success' ? '' : type === 'error' ? '' : ''} ${message}
                </div>
            `;
            statusSection.classList.remove('hidden');
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusSection.classList.add('hidden');
            }, 5000);
        }
    }

    // Placeholder methods for additional functionality
    private saveAsTemplate(): void {
        // Implementation for saving current config as template
        vscodeApi.postMessage({ command: 'saveConfigurationAsTemplate' });
    }

    private showPresetDialog(): void {
        // Implementation for showing preset selection dialog
        vscodeApi.postMessage({ command: 'showConfigurationPresets' });
    }

    private viewTemplate(templateId: string): void {
        // Implementation for viewing template details
        vscodeApi.postMessage({ command: 'viewConfigurationTemplate', templateId });
    }

    private deleteTemplate(templateId: string): void {
        if (confirm('Are you sure you want to delete this template?')) {
            vscodeApi.postMessage({ command: 'deleteConfigurationTemplate', templateId });
        }
    }

    private deleteBackup(backupId: string): void {
        if (confirm('Are you sure you want to delete this backup?')) {
            vscodeApi.postMessage({ command: 'deleteConfigurationBackup', backupId });
        }
    }

    private createTemplate(): void {
        // Implementation for creating new template
        vscodeApi.postMessage({ command: 'createConfigurationTemplate' });
    }

    private loadPresets(): void {
        // Implementation for loading default presets
        vscodeApi.postMessage({ command: 'loadConfigurationPresets' });
    }

    private cleanupBackups(): void {
        if (confirm('This will remove old backups (keeping the 10 most recent). Continue?')) {
            vscodeApi.postMessage({ command: 'cleanupConfigurationBackups' });
        }
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        // Remove event listeners if needed
    }
}

// CSS styles for ConfigurationManagement component
export const configurationManagementStyles = `
.config-management {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    margin-bottom: 20px;
    background-color: var(--vscode-sideBar-background);
}

.config-header {
    text-align: center;
    margin-bottom: 20px;
}

.config-header h3 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.config-header p {
    margin: 0;
    color: var(--vscode-descriptionForeground);
    font-size: 14px;
}

.config-tabs {
    display: flex;
    border-bottom: 1px solid var(--vscode-panel-border);
    margin-bottom: 20px;
}

.tab-button {
    padding: 10px 16px;
    border: none;
    background: none;
    color: var(--vscode-foreground);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    font-family: inherit;
    font-size: 14px;
    transition: all 0.2s ease;
}

.tab-button:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}

.tab-button.active {
    color: var(--vscode-textLink-foreground);
    border-bottom-color: var(--vscode-textLink-foreground);
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.section-group {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.section-group h4 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 16px;
}

.section-group p {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.section-header h4 {
    margin: 0;
    color: var(--vscode-textLink-foreground);
}

.icon-button {
    padding: 6px;
    border: none;
    background: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    border-radius: 3px;
    cursor: pointer;
    font-size: 14px;
}

.icon-button:hover {
    background: var(--vscode-button-secondaryHoverBackground);
}

.checkbox-label {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    font-size: 13px;
    color: var(--vscode-foreground);
    cursor: pointer;
}

.checkbox-label input[type="checkbox"] {
    margin-right: 8px;
}

.export-actions,
.import-actions,
.template-actions,
.backup-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.primary-button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.primary-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.secondary-button {
    padding: 8px 16px;
    border: 1px solid var(--vscode-button-border);
    border-radius: 4px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.secondary-button:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.status-section {
    margin-top: 20px;
    padding: 15px;
    border-radius: 4px;
}

.status-section.hidden {
    display: none;
}

.status-message {
    padding: 10px;
    border-radius: 4px;
    font-size: 13px;
}

.status-message.success {
    background-color: var(--vscode-charts-green);
    color: white;
}

.status-message.error {
    background-color: var(--vscode-charts-red);
    color: white;
}

.status-message.warning {
    background-color: var(--vscode-charts-orange);
    color: white;
}

.templates-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.template-card {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.template-card.development {
    border-left: 3px solid var(--vscode-charts-blue);
}

.template-card.production {
    border-left: 3px solid var(--vscode-charts-red);
}

.template-card.team {
    border-left: 3px solid var(--vscode-charts-green);
}

.template-card.custom {
    border-left: 3px solid var(--vscode-charts-purple);
}

.template-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
}

.template-header h6 {
    margin: 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.template-category {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 2px;
    background-color: var(--vscode-badge-background);
    color: var(--vscode-badge-foreground);
}

.template-description {
    color: var(--vscode-foreground);
    font-size: 12px;
    margin-bottom: 10px;
    line-height: 1.4;
}

.template-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-bottom: 10px;
}

.tag {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 2px;
    background-color: var(--vscode-textCodeBlock-background);
    color: var(--vscode-foreground);
}

.template-actions {
    display: flex;
    gap: 6px;
}

.template-actions button {
    padding: 4px 8px;
    border: none;
    border-radius: 3px;
    font-size: 11px;
    cursor: pointer;
}

.apply-template {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
}

.view-template {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}

.delete-template {
    background-color: var(--vscode-charts-red);
    color: white;
}

.backups-list {
    margin-top: 20px;
}

.backup-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    margin-bottom: 10px;
    background-color: var(--vscode-editor-background);
}

.backup-info {
    flex: 1;
}

.backup-name {
    font-weight: 500;
    color: var(--vscode-foreground);
    margin-bottom: 4px;
}

.backup-meta {
    display: flex;
    gap: 10px;
    align-items: center;
    margin-bottom: 4px;
}

.backup-date {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
}

.backup-reason {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 2px;
    font-weight: bold;
}

.backup-reason.manual {
    background-color: var(--vscode-charts-blue);
    color: white;
}

.backup-reason.auto {
    background-color: var(--vscode-charts-green);
    color: white;
}

.backup-reason.migration {
    background-color: var(--vscode-charts-orange);
    color: white;
}

.backup-description {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
    font-style: italic;
}

.backup-actions {
    display: flex;
    gap: 6px;
}

.backup-actions button {
    padding: 4px 8px;
    border: none;
    border-radius: 3px;
    font-size: 11px;
    cursor: pointer;
}

.restore-backup {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
}

.delete-backup {
    background-color: var(--vscode-charts-red);
    color: white;
}

.validation-results {
    margin-top: 20px;
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.validation-results.hidden {
    display: none;
}

.validation-summary {
    padding: 10px;
    border-radius: 4px;
    margin-bottom: 15px;
}

.validation-summary.valid {
    background-color: var(--vscode-charts-green);
    color: white;
}

.validation-summary.invalid {
    background-color: var(--vscode-charts-red);
    color: white;
}

.validation-summary h5 {
    margin: 0 0 5px 0;
}

.validation-summary p {
    margin: 0;
    font-size: 13px;
}

.validation-errors,
.validation-warnings {
    margin-bottom: 15px;
}

.validation-errors h6,
.validation-warnings h6 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.validation-item {
    padding: 8px;
    border-radius: 3px;
    margin-bottom: 6px;
    font-size: 12px;
}

.validation-item.error {
    background-color: var(--vscode-inputValidation-errorBackground);
    border-left: 3px solid var(--vscode-charts-red);
}

.validation-item.warning {
    background-color: var(--vscode-inputValidation-warningBackground);
    border-left: 3px solid var(--vscode-charts-orange);
}

.validation-info {
    margin-top: 20px;
    padding: 15px;
    background-color: var(--vscode-textCodeBlock-background);
    border-radius: 4px;
}

.validation-info h5 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.validation-info ul {
    margin: 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
}

.validation-info li {
    margin-bottom: 4px;
    font-size: 13px;
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--vscode-descriptionForeground);
}

.empty-state p {
    margin-bottom: 15px;
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/components/DatabaseSetup.js">
"use strict";
/**
 * DatabaseSetup Component
 *
 * Handles database selection and management for the onboarding process.
 * Provides UI for selecting database type, starting services, and monitoring status.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.databaseSetupStyles = exports.DatabaseSetup = void 0;
const setupStore_1 = require("../stores/setupStore");
const vscodeApi_1 = require("../vscodeApi");
const ChromaDBConfig_1 = require("./ChromaDBConfig");
const PineconeConfig_1 = require("./PineconeConfig");
class DatabaseSetup {
    constructor(container) {
        this.selectElement = null;
        this.startButton = null;
        this.statusElement = null;
        this.configContainer = null;
        this.unsubscribe = null;
        // Database-specific configuration components
        this.chromaDBConfig = null;
        this.pineconeConfig = null;
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.subscribeToStore();
    }
    /**
     * Render the database setup UI
     */
    render() {
        this.container.innerHTML = `
            <div class="database-setup">
                <h3>Database Configuration</h3>
                <p>Select and configure your vector database for code indexing.</p>
                
                <div class="form-group">
                    <label for="database-select">Vector Database:</label>
                    <select id="database-select" class="database-select">
                        <option value="">Select a database...</option>
                        <option value="qdrant">Qdrant (Local/Docker)</option>
                        <option value="chromadb">ChromaDB (Local/Docker)</option>
                        <option value="pinecone">Pinecone (Cloud)</option>
                    </select>
                </div>

                <div id="database-config-container" class="database-config-container">
                    <!-- Database-specific configuration will be inserted here -->
                </div>

                <div class="database-actions">
                    <button id="start-database-btn" class="start-button" disabled>
                        Start Local Qdrant
                    </button>
                    <div id="database-status" class="status-indicator">
                        <span class="status-dot not-running"></span>
                        <span class="status-text">Not Configured</span>
                    </div>
                </div>

                <div class="database-info">
                    <p class="info-text">
                        <strong>Note:</strong> This will start a local Qdrant instance using Docker. 
                        Make sure Docker is installed and running on your system.
                    </p>
                </div>
            </div>
        `;
        // Get references to elements
        this.selectElement = this.container.querySelector('#database-select');
        this.startButton = this.container.querySelector('#start-database-btn');
        this.statusElement = this.container.querySelector('#database-status');
        this.configContainer = this.container.querySelector('#database-config-container');
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        if (this.selectElement) {
            this.selectElement.addEventListener('change', (e) => {
                const target = e.target;
                this.handleDatabaseSelection(target.value);
            });
        }
        if (this.startButton) {
            this.startButton.addEventListener('click', () => {
                this.handleStartDatabase();
            });
        }
    }
    /**
     * Subscribe to store updates
     */
    subscribeToStore() {
        this.unsubscribe = setupStore_1.setupStore.subscribe((state) => {
            this.updateUI(state);
        });
    }
    /**
     * Handle database selection
     */
    handleDatabaseSelection(database) {
        const dbProvider = database;
        setupStore_1.setupActions.selectDatabase(dbProvider);
        // Update configuration UI based on selected database
        this.updateDatabaseConfiguration(dbProvider);
        // Enable start button if database is selected (except for Pinecone which doesn't need starting)
        if (this.startButton) {
            this.startButton.disabled = !database;
            // Update button text based on database type
            if (database === 'pinecone') {
                this.startButton.textContent = 'Validate Configuration';
                this.startButton.style.display = 'inline-block';
            }
            else if (database === 'chromadb') {
                this.startButton.textContent = 'Start Local ChromaDB';
                this.startButton.style.display = 'inline-block';
            }
            else if (database === 'qdrant') {
                this.startButton.textContent = 'Start Local Qdrant';
                this.startButton.style.display = 'inline-block';
            }
            else {
                this.startButton.style.display = 'none';
            }
        }
    }
    /**
     * Update database configuration UI based on selected provider
     */
    updateDatabaseConfiguration(database) {
        if (!this.configContainer)
            return;
        // Clean up existing configuration components
        this.cleanupConfigComponents();
        this.configContainer.innerHTML = '';
        if (!database)
            return;
        // Inject styles for the configuration components
        this.injectConfigStyles();
        switch (database) {
            case 'chromadb':
                this.chromaDBConfig = new ChromaDBConfig_1.ChromaDBConfigComponent(this.configContainer);
                break;
            case 'pinecone':
                this.pineconeConfig = new PineconeConfig_1.PineconeConfigComponent(this.configContainer);
                break;
            case 'qdrant':
                // Qdrant uses simple connection string, no complex config needed
                this.configContainer.innerHTML = `
                    <div class="simple-config">
                        <h4>Qdrant Configuration</h4>
                        <p>Qdrant will run locally on <code>http://localhost:6333</code></p>
                        <p>Click "Start Local Qdrant" to launch it with Docker.</p>
                    </div>
                `;
                break;
        }
    }
    /**
     * Inject CSS styles for configuration components
     */
    injectConfigStyles() {
        const styleId = 'database-config-styles';
        if (document.getElementById(styleId))
            return;
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            ${ChromaDBConfig_1.chromaDBConfigStyles}
            ${PineconeConfig_1.pineconeConfigStyles}
            .simple-config {
                padding: 15px;
                border: 1px solid var(--vscode-panel-border);
                border-radius: 4px;
                background-color: var(--vscode-editor-background);
            }
            .simple-config h4 {
                margin: 0 0 8px 0;
                color: var(--vscode-textLink-foreground);
                font-size: 14px;
            }
            .simple-config p {
                margin: 0 0 8px 0;
                color: var(--vscode-foreground);
                font-size: 13px;
            }
            .simple-config code {
                padding: 2px 4px;
                background-color: var(--vscode-textCodeBlock-background);
                border-radius: 2px;
                font-family: var(--vscode-editor-font-family);
                font-size: 12px;
            }
        `;
        document.head.appendChild(style);
    }
    /**
     * Clean up configuration components
     */
    cleanupConfigComponents() {
        if (this.chromaDBConfig) {
            this.chromaDBConfig.dispose();
            this.chromaDBConfig = null;
        }
        if (this.pineconeConfig) {
            this.pineconeConfig.dispose();
            this.pineconeConfig = null;
        }
    }
    /**
     * Handle start database button click
     */
    async handleStartDatabase() {
        const state = setupStore_1.setupStore.getState();
        if (!state.selectedDatabase) {
            setupStore_1.setupActions.setError('Please select a database first');
            return;
        }
        try {
            setupStore_1.setupActions.clearError();
            switch (state.selectedDatabase) {
                case 'qdrant':
                    await this.startQdrant();
                    break;
                case 'chromadb':
                    await this.startChromaDB();
                    break;
                case 'pinecone':
                    await this.validatePinecone();
                    break;
                default:
                    setupStore_1.setupActions.setError(`Unsupported database: ${state.selectedDatabase}`);
            }
        }
        catch (error) {
            console.error('Failed to handle database operation:', error);
            setupStore_1.setupActions.setError(`Failed to handle database: ${error}`);
            setupStore_1.setupActions.updateDatabaseStatus('error');
        }
    }
    /**
     * Start Qdrant database
     */
    async startQdrant() {
        setupStore_1.setupActions.updateDatabaseStatus('starting');
        vscodeApi_1.vscodeApi.postMessage({
            command: 'startDatabase',
            database: 'qdrant'
        });
        console.log('Qdrant start command sent to extension');
    }
    /**
     * Start ChromaDB database
     */
    async startChromaDB() {
        // Validate ChromaDB configuration first
        if (this.chromaDBConfig) {
            const validation = this.chromaDBConfig.validateConfiguration();
            if (!validation.isValid) {
                setupStore_1.setupActions.setError(`ChromaDB configuration errors: ${validation.errors.join(', ')}`);
                return;
            }
        }
        setupStore_1.setupActions.updateDatabaseStatus('starting');
        vscodeApi_1.vscodeApi.postMessage({
            command: 'startDatabase',
            database: 'chromadb',
            config: setupStore_1.setupStore.getState().databaseConfig
        });
        console.log('ChromaDB start command sent to extension');
    }
    /**
     * Validate Pinecone configuration
     */
    async validatePinecone() {
        if (!this.pineconeConfig) {
            setupStore_1.setupActions.setError('Pinecone configuration not available');
            return;
        }
        const validation = this.pineconeConfig.validateConfiguration();
        if (!validation.isValid) {
            setupStore_1.setupActions.setError(`Pinecone configuration errors: ${validation.errors.join(', ')}`);
            return;
        }
        setupStore_1.setupActions.updateDatabaseStatus('starting');
        // For Pinecone, we just validate the connection since it's cloud-based
        vscodeApi_1.vscodeApi.postMessage({
            command: 'validateDatabase',
            database: 'pinecone',
            config: setupStore_1.setupStore.getState().databaseConfig
        });
        console.log('Pinecone validation command sent to extension');
    }
    /**
     * Update UI based on store state
     */
    updateUI(state) {
        // Update select value
        if (this.selectElement && this.selectElement.value !== state.selectedDatabase) {
            this.selectElement.value = state.selectedDatabase;
        }
        // Update start button
        if (this.startButton) {
            this.startButton.disabled = !state.selectedDatabase || state.databaseStatus === 'starting';
            this.startButton.textContent = state.databaseStatus === 'starting' ? 'Starting...' : 'Start Local Qdrant';
        }
        // Update status indicator
        if (this.statusElement) {
            this.updateStatusIndicator(state.databaseStatus);
        }
    }
    /**
     * Update status indicator based on database status
     */
    updateStatusIndicator(status) {
        if (!this.statusElement)
            return;
        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');
        if (!statusDot || !statusText)
            return;
        // Remove all status classes
        statusDot.className = 'status-dot';
        switch (status) {
            case 'not-configured':
                statusDot.classList.add('not-running');
                statusText.textContent = 'Not Configured';
                break;
            case 'starting':
                statusDot.classList.add('starting');
                statusText.textContent = 'Starting...';
                break;
            case 'running':
                statusDot.classList.add('running');
                statusText.textContent = 'Running';
                break;
            case 'error':
                statusDot.classList.add('error');
                statusText.textContent = 'Error';
                break;
        }
    }
    /**
     * Handle database status updates from extension
     */
    handleDatabaseStatusUpdate(status) {
        setupStore_1.setupActions.updateDatabaseStatus(status);
    }
    /**
     * Cleanup component
     */
    dispose() {
        if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
        }
        this.cleanupConfigComponents();
    }
}
exports.DatabaseSetup = DatabaseSetup;
// CSS styles for the component
exports.databaseSetupStyles = `
.database-setup {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    margin-bottom: 20px;
    background-color: var(--vscode-sideBar-background);
}

.database-setup h3 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.database-setup p {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 14px;
}

.form-group {
    margin-bottom: 15px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
    color: var(--vscode-foreground);
}

.database-select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 4px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 14px;
}

.database-select:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.database-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.start-button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.start-button:hover:not(:disabled) {
    background-color: var(--vscode-button-hoverBackground);
}

.start-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
}

.status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.not-running {
    background-color: var(--vscode-charts-gray);
}

.status-dot.starting {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.running {
    background-color: var(--vscode-charts-green);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 13px;
    color: var(--vscode-foreground);
}

.database-config-container {
    margin-top: 15px;
    margin-bottom: 15px;
}

.database-info {
    padding: 10px;
    background-color: var(--vscode-textCodeBlock-background);
    border-radius: 4px;
    border-left: 3px solid var(--vscode-textLink-foreground);
}

.info-text {
    margin: 0;
    font-size: 13px;
    color: var(--vscode-foreground);
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
//# sourceMappingURL=DatabaseSetup.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/components/DatabaseSetup.js.map">
{"version":3,"file":"DatabaseSetup.js","sourceRoot":"","sources":["DatabaseSetup.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/components/DatabaseSetup.ts">
/**
 * DatabaseSetup Component
 * 
 * Handles database selection and management for the onboarding process.
 * Provides UI for selecting database type, starting services, and monitoring status.
 */

import { setupStore, setupActions, SetupState, DatabaseProvider } from '../stores/setupStore';
import { vscodeApi } from '../vscodeApi';
import { ChromaDBConfigComponent, chromaDBConfigStyles } from './ChromaDBConfig';
import { PineconeConfigComponent, pineconeConfigStyles } from './PineconeConfig';

export class DatabaseSetup {
    private container: HTMLElement;
    private selectElement: HTMLSelectElement | null = null;
    private startButton: HTMLButtonElement | null = null;
    private statusElement: HTMLElement | null = null;
    private configContainer: HTMLElement | null = null;
    private unsubscribe: (() => void) | null = null;

    // Database-specific configuration components
    private chromaDBConfig: ChromaDBConfigComponent | null = null;
    private pineconeConfig: PineconeConfigComponent | null = null;

    constructor(container: HTMLElement) {
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.subscribeToStore();
    }

    /**
     * Render the database setup UI
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="database-setup">
                <h3>Database Configuration</h3>
                <p>Select and configure your vector database for code indexing.</p>
                
                <div class="form-group">
                    <label for="database-select">Vector Database:</label>
                    <select id="database-select" class="database-select">
                        <option value="">Select a database...</option>
                        <option value="qdrant">Qdrant (Local/Docker)</option>
                        <option value="chromadb">ChromaDB (Local/Docker)</option>
                        <option value="pinecone">Pinecone (Cloud)</option>
                    </select>
                </div>

                <div id="database-config-container" class="database-config-container">
                    <!-- Database-specific configuration will be inserted here -->
                </div>

                <div class="database-actions">
                    <button id="start-database-btn" class="start-button" disabled>
                        Start Local Qdrant
                    </button>
                    <div id="database-status" class="status-indicator">
                        <span class="status-dot not-running"></span>
                        <span class="status-text">Not Configured</span>
                    </div>
                </div>

                <div class="database-info">
                    <p class="info-text">
                        <strong>Note:</strong> This will start a local Qdrant instance using Docker. 
                        Make sure Docker is installed and running on your system.
                    </p>
                </div>
            </div>
        `;

        // Get references to elements
        this.selectElement = this.container.querySelector('#database-select') as HTMLSelectElement;
        this.startButton = this.container.querySelector('#start-database-btn') as HTMLButtonElement;
        this.statusElement = this.container.querySelector('#database-status') as HTMLElement;
        this.configContainer = this.container.querySelector('#database-config-container') as HTMLElement;
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        if (this.selectElement) {
            this.selectElement.addEventListener('change', (e) => {
                const target = e.target as HTMLSelectElement;
                this.handleDatabaseSelection(target.value);
            });
        }

        if (this.startButton) {
            this.startButton.addEventListener('click', () => {
                this.handleStartDatabase();
            });
        }
    }

    /**
     * Subscribe to store updates
     */
    private subscribeToStore(): void {
        this.unsubscribe = setupStore.subscribe((state) => {
            this.updateUI(state);
        });
    }

    /**
     * Handle database selection
     */
    private handleDatabaseSelection(database: string): void {
        const dbProvider = database as DatabaseProvider | '';
        setupActions.selectDatabase(dbProvider);

        // Update configuration UI based on selected database
        this.updateDatabaseConfiguration(dbProvider);

        // Enable start button if database is selected (except for Pinecone which doesn't need starting)
        if (this.startButton) {
            this.startButton.disabled = !database;

            // Update button text based on database type
            if (database === 'pinecone') {
                this.startButton.textContent = 'Validate Configuration';
                this.startButton.style.display = 'inline-block';
            } else if (database === 'chromadb') {
                this.startButton.textContent = 'Start Local ChromaDB';
                this.startButton.style.display = 'inline-block';
            } else if (database === 'qdrant') {
                this.startButton.textContent = 'Start Local Qdrant';
                this.startButton.style.display = 'inline-block';
            } else {
                this.startButton.style.display = 'none';
            }
        }
    }

    /**
     * Update database configuration UI based on selected provider
     */
    private updateDatabaseConfiguration(database: DatabaseProvider | ''): void {
        if (!this.configContainer) return;

        // Clean up existing configuration components
        this.cleanupConfigComponents();
        this.configContainer.innerHTML = '';

        if (!database) return;

        // Inject styles for the configuration components
        this.injectConfigStyles();

        switch (database) {
            case 'chromadb':
                this.chromaDBConfig = new ChromaDBConfigComponent(this.configContainer);
                break;
            case 'pinecone':
                this.pineconeConfig = new PineconeConfigComponent(this.configContainer);
                break;
            case 'qdrant':
                // Qdrant uses simple connection string, no complex config needed
                this.configContainer.innerHTML = `
                    <div class="simple-config">
                        <h4>Qdrant Configuration</h4>
                        <p>Qdrant will run locally on <code>http://localhost:6333</code></p>
                        <p>Click "Start Local Qdrant" to launch it with Docker.</p>
                    </div>
                `;
                break;
        }
    }

    /**
     * Inject CSS styles for configuration components
     */
    private injectConfigStyles(): void {
        const styleId = 'database-config-styles';
        if (document.getElementById(styleId)) return;

        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            ${chromaDBConfigStyles}
            ${pineconeConfigStyles}
            .simple-config {
                padding: 15px;
                border: 1px solid var(--vscode-panel-border);
                border-radius: 4px;
                background-color: var(--vscode-editor-background);
            }
            .simple-config h4 {
                margin: 0 0 8px 0;
                color: var(--vscode-textLink-foreground);
                font-size: 14px;
            }
            .simple-config p {
                margin: 0 0 8px 0;
                color: var(--vscode-foreground);
                font-size: 13px;
            }
            .simple-config code {
                padding: 2px 4px;
                background-color: var(--vscode-textCodeBlock-background);
                border-radius: 2px;
                font-family: var(--vscode-editor-font-family);
                font-size: 12px;
            }
        `;
        document.head.appendChild(style);
    }

    /**
     * Clean up configuration components
     */
    private cleanupConfigComponents(): void {
        if (this.chromaDBConfig) {
            this.chromaDBConfig.dispose();
            this.chromaDBConfig = null;
        }
        if (this.pineconeConfig) {
            this.pineconeConfig.dispose();
            this.pineconeConfig = null;
        }
    }

    /**
     * Handle start database button click
     */
    private async handleStartDatabase(): Promise<void> {
        const state = setupStore.getState();

        if (!state.selectedDatabase) {
            setupActions.setError('Please select a database first');
            return;
        }

        try {
            setupActions.clearError();

            switch (state.selectedDatabase) {
                case 'qdrant':
                    await this.startQdrant();
                    break;
                case 'chromadb':
                    await this.startChromaDB();
                    break;
                case 'pinecone':
                    await this.validatePinecone();
                    break;
                default:
                    setupActions.setError(`Unsupported database: ${state.selectedDatabase}`);
            }

        } catch (error) {
            console.error('Failed to handle database operation:', error);
            setupActions.setError(`Failed to handle database: ${error}`);
            setupActions.updateDatabaseStatus('error');
        }
    }

    /**
     * Start Qdrant database
     */
    private async startQdrant(): Promise<void> {
        setupActions.updateDatabaseStatus('starting');

        vscodeApi.postMessage({
            command: 'startDatabase',
            database: 'qdrant'
        });

        console.log('Qdrant start command sent to extension');
    }

    /**
     * Start ChromaDB database
     */
    private async startChromaDB(): Promise<void> {
        // Validate ChromaDB configuration first
        if (this.chromaDBConfig) {
            const validation = this.chromaDBConfig.validateConfiguration();
            if (!validation.isValid) {
                setupActions.setError(`ChromaDB configuration errors: ${validation.errors.join(', ')}`);
                return;
            }
        }

        setupActions.updateDatabaseStatus('starting');

        vscodeApi.postMessage({
            command: 'startDatabase',
            database: 'chromadb',
            config: setupStore.getState().databaseConfig
        });

        console.log('ChromaDB start command sent to extension');
    }

    /**
     * Validate Pinecone configuration
     */
    private async validatePinecone(): Promise<void> {
        if (!this.pineconeConfig) {
            setupActions.setError('Pinecone configuration not available');
            return;
        }

        const validation = this.pineconeConfig.validateConfiguration();
        if (!validation.isValid) {
            setupActions.setError(`Pinecone configuration errors: ${validation.errors.join(', ')}`);
            return;
        }

        setupActions.updateDatabaseStatus('starting');

        // For Pinecone, we just validate the connection since it's cloud-based
        vscodeApi.postMessage({
            command: 'validateDatabase',
            database: 'pinecone',
            config: setupStore.getState().databaseConfig
        });

        console.log('Pinecone validation command sent to extension');
    }

    /**
     * Update UI based on store state
     */
    private updateUI(state: SetupState): void {
        // Update select value
        if (this.selectElement && this.selectElement.value !== state.selectedDatabase) {
            this.selectElement.value = state.selectedDatabase;
        }

        // Update start button
        if (this.startButton) {
            this.startButton.disabled = !state.selectedDatabase || state.databaseStatus === 'starting';
            this.startButton.textContent = state.databaseStatus === 'starting' ? 'Starting...' : 'Start Local Qdrant';
        }

        // Update status indicator
        if (this.statusElement) {
            this.updateStatusIndicator(state.databaseStatus);
        }
    }

    /**
     * Update status indicator based on database status
     */
    private updateStatusIndicator(status: SetupState['databaseStatus']): void {
        if (!this.statusElement) return;

        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');

        if (!statusDot || !statusText) return;

        // Remove all status classes
        statusDot.className = 'status-dot';
        
        switch (status) {
            case 'not-configured':
                statusDot.classList.add('not-running');
                statusText.textContent = 'Not Configured';
                break;
            case 'starting':
                statusDot.classList.add('starting');
                statusText.textContent = 'Starting...';
                break;
            case 'running':
                statusDot.classList.add('running');
                statusText.textContent = 'Running';
                break;
            case 'error':
                statusDot.classList.add('error');
                statusText.textContent = 'Error';
                break;
        }
    }

    /**
     * Handle database status updates from extension
     */
    public handleDatabaseStatusUpdate(status: SetupState['databaseStatus']): void {
        setupActions.updateDatabaseStatus(status);
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
        }

        this.cleanupConfigComponents();
    }
}

// CSS styles for the component
export const databaseSetupStyles = `
.database-setup {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    margin-bottom: 20px;
    background-color: var(--vscode-sideBar-background);
}

.database-setup h3 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.database-setup p {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 14px;
}

.form-group {
    margin-bottom: 15px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
    color: var(--vscode-foreground);
}

.database-select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 4px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 14px;
}

.database-select:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.database-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.start-button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.start-button:hover:not(:disabled) {
    background-color: var(--vscode-button-hoverBackground);
}

.start-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
}

.status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.not-running {
    background-color: var(--vscode-charts-gray);
}

.status-dot.starting {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.running {
    background-color: var(--vscode-charts-green);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 13px;
    color: var(--vscode-foreground);
}

.database-config-container {
    margin-top: 15px;
    margin-bottom: 15px;
}

.database-info {
    padding: 10px;
    background-color: var(--vscode-textCodeBlock-background);
    border-radius: 4px;
    border-left: 3px solid var(--vscode-textLink-foreground);
}

.info-text {
    margin: 0;
    font-size: 13px;
    color: var(--vscode-foreground);
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/components/EmbeddingSetup.js">
"use strict";
/**
 * EmbeddingSetup Component
 *
 * Handles embedding provider selection for the onboarding process.
 * Provides UI for selecting between different embedding providers (Ollama, OpenAI).
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.embeddingSetupStyles = exports.EmbeddingSetup = void 0;
const setupStore_1 = require("../stores/setupStore");
const OllamaConfig_1 = require("./OllamaConfig");
const OpenAIConfig_1 = require("./OpenAIConfig");
class EmbeddingSetup {
    constructor(container) {
        this.selectElement = null;
        this.configSection = null;
        this.unsubscribe = null;
        // Provider-specific configuration components
        this.ollamaConfig = null;
        this.openaiConfig = null;
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.subscribeToStore();
    }
    /**
     * Render the embedding setup UI
     */
    render() {
        this.container.innerHTML = `
            <div class="embedding-setup">
                <h3>Embedding Provider</h3>
                <p>Choose the AI model provider for generating code embeddings.</p>
                
                <div class="form-group">
                    <label for="provider-select">Embedding Provider:</label>
                    <select id="provider-select" class="provider-select">
                        <option value="">Select a provider...</option>
                        <option value="ollama">Ollama (Local, Free)</option>
                        <option value="openai">OpenAI (Cloud, API Key Required)</option>
                    </select>
                </div>

                <div id="provider-config" class="provider-config hidden">
                    <!-- Dynamic configuration content will be inserted here -->
                </div>

                <div class="provider-info">
                    <div class="info-card">
                        <h4> Ollama (Recommended for Local Development)</h4>
                        <ul>
                            <li>Runs locally on your machine</li>
                            <li>No API keys required</li>
                            <li>Privacy-focused - data stays local</li>
                            <li>Free to use</li>
                        </ul>
                    </div>
                    
                    <div class="info-card">
                        <h4> OpenAI (Cloud-based)</h4>
                        <ul>
                            <li>High-quality embeddings</li>
                            <li>Requires API key and internet connection</li>
                            <li>Usage-based pricing</li>
                            <li>Faster processing for large codebases</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;
        // Get references to elements
        this.selectElement = this.container.querySelector('#provider-select');
        this.configSection = this.container.querySelector('#provider-config');
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        if (this.selectElement) {
            this.selectElement.addEventListener('change', (e) => {
                const target = e.target;
                this.handleProviderSelection(target.value);
            });
        }
    }
    /**
     * Subscribe to store updates
     */
    subscribeToStore() {
        this.unsubscribe = setupStore_1.setupStore.subscribe((state) => {
            this.updateUI(state);
        });
    }
    /**
     * Handle provider selection
     */
    handleProviderSelection(provider) {
        const embeddingProvider = provider;
        setupStore_1.setupActions.selectProvider(embeddingProvider);
        this.updateProviderConfig(embeddingProvider);
    }
    /**
     * Update provider-specific configuration UI
     */
    updateProviderConfig(provider) {
        if (!this.configSection)
            return;
        // Clean up existing configuration components
        this.cleanupConfigComponents();
        this.configSection.innerHTML = '';
        if (!provider) {
            this.configSection.classList.add('hidden');
            return;
        }
        this.configSection.classList.remove('hidden');
        // Inject styles for the configuration components
        this.injectConfigStyles();
        switch (provider) {
            case 'ollama':
                this.ollamaConfig = new OllamaConfig_1.OllamaConfigComponent(this.configSection);
                break;
            case 'openai':
                this.openaiConfig = new OpenAIConfig_1.OpenAIConfigComponent(this.configSection);
                break;
        }
    }
    /**
     * Inject CSS styles for configuration components
     */
    injectConfigStyles() {
        const styleId = 'embedding-config-styles';
        if (document.getElementById(styleId))
            return;
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            ${OllamaConfig_1.ollamaConfigStyles}
            ${OpenAIConfig_1.openAIConfigStyles}
        `;
        document.head.appendChild(style);
    }
    /**
     * Clean up configuration components
     */
    cleanupConfigComponents() {
        if (this.ollamaConfig) {
            this.ollamaConfig.dispose();
            this.ollamaConfig = null;
        }
        if (this.openaiConfig) {
            this.openaiConfig.dispose();
            this.openaiConfig = null;
        }
    }
    /**
     * Update UI based on store state
     */
    updateUI(state) {
        // Update select value
        if (this.selectElement && this.selectElement.value !== state.selectedProvider) {
            this.selectElement.value = state.selectedProvider;
            this.updateProviderConfig(state.selectedProvider);
        }
    }
    /**
     * Cleanup component
     */
    dispose() {
        if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
        }
        this.cleanupConfigComponents();
    }
}
exports.EmbeddingSetup = EmbeddingSetup;
// CSS styles for the component
exports.embeddingSetupStyles = `
.embedding-setup {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    margin-bottom: 20px;
    background-color: var(--vscode-sideBar-background);
}

.embedding-setup h3 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.embedding-setup p {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 14px;
}

.provider-select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 4px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 14px;
}

.provider-config {
    margin-top: 15px;
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.provider-config.hidden {
    display: none;
}

.config-content h4 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.config-item {
    margin-bottom: 15px;
}

.config-item label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
    color: var(--vscode-foreground);
}

.config-item input,
.config-item select {
    width: 100%;
    padding: 6px 10px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item small {
    display: block;
    margin-top: 3px;
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.config-message {
    margin-top: 10px;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 13px;
}

.config-message.success {
    background-color: var(--vscode-charts-green);
    color: white;
}

.config-message.error {
    background-color: var(--vscode-charts-red);
    color: white;
}

.provider-info {
    margin-top: 20px;
    display: grid;
    gap: 15px;
}

.info-card {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-textCodeBlock-background);
}

.info-card h4 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.info-card ul {
    margin: 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
}

.info-card li {
    margin-bottom: 5px;
    font-size: 13px;
}

@media (min-width: 600px) {
    .provider-info {
        grid-template-columns: 1fr 1fr;
    }
}
`;
//# sourceMappingURL=EmbeddingSetup.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/components/EmbeddingSetup.js.map">
{"version":3,"file":"EmbeddingSetup.js","sourceRoot":"","sources":["EmbeddingSetup.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/components/EmbeddingSetup.ts">
/**
 * EmbeddingSetup Component
 * 
 * Handles embedding provider selection for the onboarding process.
 * Provides UI for selecting between different embedding providers (Ollama, OpenAI).
 */

import { setupStore, setupActions, SetupState, EmbeddingProvider } from '../stores/setupStore';
import { OllamaConfigComponent, ollamaConfigStyles } from './OllamaConfig';
import { OpenAIConfigComponent, openAIConfigStyles } from './OpenAIConfig';

export class EmbeddingSetup {
    private container: HTMLElement;
    private selectElement: HTMLSelectElement | null = null;
    private configSection: HTMLElement | null = null;
    private unsubscribe: (() => void) | null = null;

    // Provider-specific configuration components
    private ollamaConfig: OllamaConfigComponent | null = null;
    private openaiConfig: OpenAIConfigComponent | null = null;

    constructor(container: HTMLElement) {
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.subscribeToStore();
    }

    /**
     * Render the embedding setup UI
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="embedding-setup">
                <h3>Embedding Provider</h3>
                <p>Choose the AI model provider for generating code embeddings.</p>
                
                <div class="form-group">
                    <label for="provider-select">Embedding Provider:</label>
                    <select id="provider-select" class="provider-select">
                        <option value="">Select a provider...</option>
                        <option value="ollama">Ollama (Local, Free)</option>
                        <option value="openai">OpenAI (Cloud, API Key Required)</option>
                    </select>
                </div>

                <div id="provider-config" class="provider-config hidden">
                    <!-- Dynamic configuration content will be inserted here -->
                </div>

                <div class="provider-info">
                    <div class="info-card">
                        <h4> Ollama (Recommended for Local Development)</h4>
                        <ul>
                            <li>Runs locally on your machine</li>
                            <li>No API keys required</li>
                            <li>Privacy-focused - data stays local</li>
                            <li>Free to use</li>
                        </ul>
                    </div>
                    
                    <div class="info-card">
                        <h4> OpenAI (Cloud-based)</h4>
                        <ul>
                            <li>High-quality embeddings</li>
                            <li>Requires API key and internet connection</li>
                            <li>Usage-based pricing</li>
                            <li>Faster processing for large codebases</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;

        // Get references to elements
        this.selectElement = this.container.querySelector('#provider-select') as HTMLSelectElement;
        this.configSection = this.container.querySelector('#provider-config') as HTMLElement;
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        if (this.selectElement) {
            this.selectElement.addEventListener('change', (e) => {
                const target = e.target as HTMLSelectElement;
                this.handleProviderSelection(target.value);
            });
        }
    }

    /**
     * Subscribe to store updates
     */
    private subscribeToStore(): void {
        this.unsubscribe = setupStore.subscribe((state) => {
            this.updateUI(state);
        });
    }

    /**
     * Handle provider selection
     */
    private handleProviderSelection(provider: string): void {
        const embeddingProvider = provider as EmbeddingProvider | '';
        setupActions.selectProvider(embeddingProvider);
        this.updateProviderConfig(embeddingProvider);
    }

    /**
     * Update provider-specific configuration UI
     */
    private updateProviderConfig(provider: EmbeddingProvider | ''): void {
        if (!this.configSection) return;

        // Clean up existing configuration components
        this.cleanupConfigComponents();
        this.configSection.innerHTML = '';

        if (!provider) {
            this.configSection.classList.add('hidden');
            return;
        }

        this.configSection.classList.remove('hidden');

        // Inject styles for the configuration components
        this.injectConfigStyles();

        switch (provider) {
            case 'ollama':
                this.ollamaConfig = new OllamaConfigComponent(this.configSection);
                break;
            case 'openai':
                this.openaiConfig = new OpenAIConfigComponent(this.configSection);
                break;
        }
    }

    /**
     * Inject CSS styles for configuration components
     */
    private injectConfigStyles(): void {
        const styleId = 'embedding-config-styles';
        if (document.getElementById(styleId)) return;

        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            ${ollamaConfigStyles}
            ${openAIConfigStyles}
        `;
        document.head.appendChild(style);
    }

    /**
     * Clean up configuration components
     */
    private cleanupConfigComponents(): void {
        if (this.ollamaConfig) {
            this.ollamaConfig.dispose();
            this.ollamaConfig = null;
        }
        if (this.openaiConfig) {
            this.openaiConfig.dispose();
            this.openaiConfig = null;
        }
    }



    /**
     * Update UI based on store state
     */
    private updateUI(state: SetupState): void {
        // Update select value
        if (this.selectElement && this.selectElement.value !== state.selectedProvider) {
            this.selectElement.value = state.selectedProvider;
            this.updateProviderConfig(state.selectedProvider);
        }
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
        }

        this.cleanupConfigComponents();
    }
}

// CSS styles for the component
export const embeddingSetupStyles = `
.embedding-setup {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    margin-bottom: 20px;
    background-color: var(--vscode-sideBar-background);
}

.embedding-setup h3 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.embedding-setup p {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 14px;
}

.provider-select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 4px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 14px;
}

.provider-config {
    margin-top: 15px;
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.provider-config.hidden {
    display: none;
}

.config-content h4 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.config-item {
    margin-bottom: 15px;
}

.config-item label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
    color: var(--vscode-foreground);
}

.config-item input,
.config-item select {
    width: 100%;
    padding: 6px 10px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item small {
    display: block;
    margin-top: 3px;
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.config-message {
    margin-top: 10px;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 13px;
}

.config-message.success {
    background-color: var(--vscode-charts-green);
    color: white;
}

.config-message.error {
    background-color: var(--vscode-charts-red);
    color: white;
}

.provider-info {
    margin-top: 20px;
    display: grid;
    gap: 15px;
}

.info-card {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-textCodeBlock-background);
}

.info-card h4 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.info-card ul {
    margin: 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
}

.info-card li {
    margin-bottom: 5px;
    font-size: 13px;
}

@media (min-width: 600px) {
    .provider-info {
        grid-template-columns: 1fr 1fr;
    }
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/components/OllamaConfig.js">
"use strict";
/**
 * OllamaConfig Component
 *
 * Enhanced Ollama configuration with support for custom endpoints,
 * model validation, and connection testing.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ollamaConfigStyles = exports.OllamaConfigComponent = void 0;
const setupStore_1 = require("../stores/setupStore");
class OllamaConfigComponent {
    constructor(container) {
        this.endpointInput = null;
        this.modelSelect = null;
        this.apiKeyInput = null;
        this.timeoutInput = null;
        this.testButton = null;
        this.refreshModelsButton = null;
        this.statusElement = null;
        this.availableModels = [];
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.loadAvailableModels();
    }
    /**
     * Render the Ollama configuration UI
     */
    render() {
        this.container.innerHTML = `
            <div class="ollama-config">
                <h4>Ollama Configuration</h4>
                <p class="config-description">
                    Configure your Ollama instance. Ollama can run locally or on a remote server.
                    <a href="https://ollama.ai/" target="_blank" rel="noopener">Learn more about Ollama</a>
                </p>

                <div class="config-grid">
                    <div class="config-item">
                        <label for="ollama-endpoint">Endpoint URL:</label>
                        <input type="text" id="ollama-endpoint" value="http://localhost:11434" placeholder="http://localhost:11434">
                        <small>Ollama server endpoint (local or remote)</small>
                    </div>

                    <div class="config-item">
                        <label for="ollama-model">Embedding Model:</label>
                        <div class="model-selection">
                            <select id="ollama-model" class="model-select">
                                <option value="">Loading models...</option>
                            </select>
                            <button id="refresh-models" class="refresh-button" title="Refresh available models">
                                
                            </button>
                        </div>
                        <small>Choose an embedding model (will be downloaded if not available)</small>
                    </div>

                    <div class="config-item">
                        <label for="ollama-api-key">API Key (Optional):</label>
                        <input type="password" id="ollama-api-key" placeholder="Enter API key if required">
                        <small>Leave empty for local instances without authentication</small>
                    </div>

                    <div class="config-item">
                        <label for="ollama-timeout">Request Timeout (seconds):</label>
                        <input type="number" id="ollama-timeout" value="30" min="5" max="300">
                        <small>Timeout for model requests (5-300 seconds)</small>
                    </div>
                </div>

                <div class="config-actions">
                    <button id="test-ollama-connection" class="test-button">Test Connection</button>
                    <div id="ollama-status" class="connection-status">
                        <span class="status-dot unknown"></span>
                        <span class="status-text">Not tested</span>
                    </div>
                </div>

                <div class="config-info">
                    <div class="info-section">
                        <h5> Local Installation</h5>
                        <p>Install Ollama locally:</p>
                        <ol>
                            <li>Download from <a href="https://ollama.ai/" target="_blank">ollama.ai</a></li>
                            <li>Install and start the service</li>
                            <li>Pull an embedding model: <code>ollama pull nomic-embed-text</code></li>
                        </ol>
                    </div>
                    
                    <div class="info-section">
                        <h5> Remote Setup</h5>
                        <p>Connect to a remote Ollama instance:</p>
                        <ul>
                            <li>Update the endpoint URL to your server</li>
                            <li>Add API key if authentication is enabled</li>
                            <li>Ensure the server is accessible from your network</li>
                        </ul>
                    </div>

                    <div class="info-section">
                        <h5> Recommended Models</h5>
                        <ul>
                            <li><strong>nomic-embed-text</strong> - High quality, 768 dimensions</li>
                            <li><strong>all-minilm</strong> - Fast and efficient, 384 dimensions</li>
                            <li><strong>mxbai-embed-large</strong> - Large model, 1024 dimensions</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;
        // Get references to elements
        this.endpointInput = this.container.querySelector('#ollama-endpoint');
        this.modelSelect = this.container.querySelector('#ollama-model');
        this.apiKeyInput = this.container.querySelector('#ollama-api-key');
        this.timeoutInput = this.container.querySelector('#ollama-timeout');
        this.testButton = this.container.querySelector('#test-ollama-connection');
        this.refreshModelsButton = this.container.querySelector('#refresh-models');
        this.statusElement = this.container.querySelector('#ollama-status');
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Update configuration when inputs change
        [this.endpointInput, this.modelSelect, this.apiKeyInput, this.timeoutInput].forEach(input => {
            if (input) {
                input.addEventListener('input', () => this.updateConfiguration());
                input.addEventListener('change', () => this.updateConfiguration());
            }
        });
        // Test connection button
        if (this.testButton) {
            this.testButton.addEventListener('click', () => this.testConnection());
        }
        // Refresh models button
        if (this.refreshModelsButton) {
            this.refreshModelsButton.addEventListener('click', () => this.loadAvailableModels());
        }
        // Endpoint change should reload models
        if (this.endpointInput) {
            this.endpointInput.addEventListener('blur', () => {
                setTimeout(() => this.loadAvailableModels(), 500);
            });
        }
    }
    /**
     * Load available models from Ollama
     */
    async loadAvailableModels() {
        if (!this.modelSelect || !this.endpointInput || !this.refreshModelsButton)
            return;
        const endpoint = this.endpointInput.value || 'http://localhost:11434';
        // Update UI to show loading
        this.refreshModelsButton.disabled = true;
        this.refreshModelsButton.textContent = '';
        this.modelSelect.innerHTML = '<option value="">Loading models...</option>';
        try {
            const headers = {
                'Content-Type': 'application/json'
            };
            // Add API key if provided
            if (this.apiKeyInput?.value) {
                headers['Authorization'] = `Bearer ${this.apiKeyInput.value}`;
            }
            const response = await fetch(`${endpoint}/api/tags`, {
                method: 'GET',
                headers,
                signal: AbortSignal.timeout(10000)
            });
            if (response.ok) {
                const data = await response.json();
                this.availableModels = data.models?.map((model) => model.name) || [];
                this.updateModelOptions();
                this.updateStatus('success', 'Models loaded successfully');
            }
            else {
                throw new Error(`Failed to load models: ${response.status}`);
            }
        }
        catch (error) {
            console.error('Failed to load Ollama models:', error);
            this.availableModels = [];
            this.updateModelOptions(true);
            if (error instanceof Error && error.name === 'AbortError') {
                this.updateStatus('error', 'Connection timeout - check endpoint');
            }
            else {
                this.updateStatus('error', 'Could not load models - using defaults');
            }
        }
        finally {
            // Reset button state
            this.refreshModelsButton.disabled = false;
            this.refreshModelsButton.textContent = '';
        }
    }
    /**
     * Update model selection options
     */
    updateModelOptions(useDefaults = false) {
        if (!this.modelSelect)
            return;
        const currentValue = this.modelSelect.value;
        this.modelSelect.innerHTML = '';
        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Select a model...';
        this.modelSelect.appendChild(defaultOption);
        // Add available models or defaults
        const models = useDefaults ? [
            'nomic-embed-text',
            'all-minilm',
            'mxbai-embed-large'
        ] : this.availableModels;
        models.forEach(model => {
            const option = document.createElement('option');
            option.value = model;
            option.textContent = model;
            this.modelSelect.appendChild(option);
        });
        // Restore previous selection if still available
        if (currentValue && models.includes(currentValue)) {
            this.modelSelect.value = currentValue;
        }
        // Add note about default models if using fallback
        if (useDefaults) {
            const noteOption = document.createElement('option');
            noteOption.disabled = true;
            noteOption.textContent = '--- Default models (will be downloaded) ---';
            this.modelSelect.insertBefore(noteOption, this.modelSelect.children[1]);
        }
    }
    /**
     * Update configuration in store
     */
    updateConfiguration() {
        if (!this.endpointInput || !this.modelSelect || !this.timeoutInput)
            return;
        const config = {
            endpoint: this.endpointInput.value || 'http://localhost:11434',
            model: this.modelSelect.value,
            apiKey: this.apiKeyInput?.value || undefined,
            timeout: parseInt(this.timeoutInput.value) || 30
        };
        setupStore_1.setupActions.setEmbeddingConfig(config);
    }
    /**
     * Test Ollama connection and model availability
     */
    async testConnection() {
        if (!this.testButton || !this.statusElement)
            return;
        const config = this.getConfiguration();
        // Validate required fields
        if (!config.endpoint || !config.model) {
            this.updateStatus('error', 'Endpoint and model are required');
            return;
        }
        // Update UI to show testing state
        this.testButton.disabled = true;
        this.testButton.textContent = 'Testing...';
        this.updateStatus('testing', 'Testing connection...');
        try {
            // Test basic connection
            const headers = {
                'Content-Type': 'application/json'
            };
            if (config.apiKey) {
                headers['Authorization'] = `Bearer ${config.apiKey}`;
            }
            // First test: Check if Ollama is running
            const healthResponse = await fetch(`${config.endpoint}/api/tags`, {
                method: 'GET',
                headers,
                signal: AbortSignal.timeout(config.timeout * 1000)
            });
            if (!healthResponse.ok) {
                throw new Error(`Ollama not responding: ${healthResponse.status}`);
            }
            // Second test: Check if model is available
            const modelsData = await healthResponse.json();
            const availableModels = modelsData.models?.map((m) => m.name) || [];
            if (!availableModels.includes(config.model)) {
                this.updateStatus('warning', `Model '${config.model}' not found - will be downloaded when needed`);
            }
            else {
                this.updateStatus('success', 'Connection successful! Model is available.');
            }
        }
        catch (error) {
            console.error('Ollama connection test failed:', error);
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    this.updateStatus('error', 'Connection timeout - check endpoint and timeout settings');
                }
                else if (error.message.includes('Failed to fetch')) {
                    this.updateStatus('error', 'Cannot reach Ollama - check if it\'s running and endpoint is correct');
                }
                else {
                    this.updateStatus('error', `Connection error: ${error.message}`);
                }
            }
            else {
                this.updateStatus('error', 'Unknown connection error');
            }
        }
        finally {
            // Reset button state
            this.testButton.disabled = false;
            this.testButton.textContent = 'Test Connection';
        }
    }
    /**
     * Update connection status display
     */
    updateStatus(type, message) {
        if (!this.statusElement)
            return;
        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');
        if (statusDot && statusText) {
            // Remove all status classes
            statusDot.className = 'status-dot';
            statusDot.classList.add(type);
            statusText.textContent = message;
        }
    }
    /**
     * Get current configuration
     */
    getConfiguration() {
        return {
            endpoint: this.endpointInput?.value || 'http://localhost:11434',
            model: this.modelSelect?.value || '',
            apiKey: this.apiKeyInput?.value || undefined,
            timeout: parseInt(this.timeoutInput?.value || '30')
        };
    }
    /**
     * Load configuration from external source
     */
    loadConfiguration(config) {
        if (this.endpointInput)
            this.endpointInput.value = config.endpoint;
        if (this.modelSelect)
            this.modelSelect.value = config.model;
        if (this.apiKeyInput)
            this.apiKeyInput.value = config.apiKey || '';
        if (this.timeoutInput)
            this.timeoutInput.value = (config.timeout || 30).toString();
        this.updateConfiguration();
    }
    /**
     * Validate configuration
     */
    validateConfiguration() {
        const errors = [];
        const config = this.getConfiguration();
        if (!config.endpoint || config.endpoint.trim() === '') {
            errors.push('Endpoint URL is required');
        }
        else {
            try {
                new URL(config.endpoint);
            }
            catch {
                errors.push('Endpoint URL is not valid');
            }
        }
        if (!config.model || config.model.trim() === '') {
            errors.push('Model selection is required');
        }
        if (config.timeout < 5 || config.timeout > 300) {
            errors.push('Timeout must be between 5 and 300 seconds');
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    /**
     * Cleanup component
     */
    dispose() {
        // Remove event listeners if needed
    }
}
exports.OllamaConfigComponent = OllamaConfigComponent;
// CSS styles for Ollama configuration
exports.ollamaConfigStyles = `
.ollama-config {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.ollama-config h4 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.config-description {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
    line-height: 1.4;
}

.config-description a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.config-description a:hover {
    text-decoration: underline;
}

.config-grid {
    display: grid;
    gap: 15px;
    margin-bottom: 15px;
}

.config-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.config-item label {
    font-weight: 500;
    color: var(--vscode-foreground);
    font-size: 13px;
}

.config-item input,
.config-item select {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item input:focus,
.config-item select:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.model-selection {
    display: flex;
    gap: 6px;
    align-items: center;
}

.model-select {
    flex: 1;
}

.refresh-button {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    cursor: pointer;
    font-size: 12px;
    min-width: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.refresh-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.refresh-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.config-item small {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.config-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.test-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.unknown {
    background-color: var(--vscode-charts-gray);
}

.status-dot.testing {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.success {
    background-color: var(--vscode-charts-green);
}

.status-dot.warning {
    background-color: var(--vscode-charts-orange);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 12px;
    color: var(--vscode-foreground);
}

.config-info {
    border-top: 1px solid var(--vscode-panel-border);
    padding-top: 15px;
    margin-top: 15px;
}

.info-section {
    margin-bottom: 15px;
}

.info-section h5 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.info-section p {
    margin: 0 0 6px 0;
    color: var(--vscode-foreground);
    font-size: 12px;
    line-height: 1.4;
}

.info-section ol,
.info-section ul {
    margin: 6px 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
    font-size: 12px;
}

.info-section li {
    margin-bottom: 3px;
    line-height: 1.3;
}

.info-section code {
    padding: 2px 4px;
    background-color: var(--vscode-textCodeBlock-background);
    border: 1px solid var(--vscode-panel-border);
    border-radius: 2px;
    font-family: var(--vscode-editor-font-family);
    font-size: 11px;
    color: var(--vscode-textPreformat-foreground);
}

.info-section a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.info-section a:hover {
    text-decoration: underline;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
//# sourceMappingURL=OllamaConfig.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/components/OllamaConfig.js.map">
{"version":3,"file":"OllamaConfig.js","sourceRoot":"","sources":["OllamaConfig.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/components/OllamaConfig.ts">
/**
 * OllamaConfig Component
 * 
 * Enhanced Ollama configuration with support for custom endpoints,
 * model validation, and connection testing.
 */

import { setupActions, OllamaConfig } from '../stores/setupStore';

export class OllamaConfigComponent {
    private container: HTMLElement;
    private endpointInput: HTMLInputElement | null = null;
    private modelSelect: HTMLSelectElement | null = null;
    private apiKeyInput: HTMLInputElement | null = null;
    private timeoutInput: HTMLInputElement | null = null;
    private testButton: HTMLButtonElement | null = null;
    private refreshModelsButton: HTMLButtonElement | null = null;
    private statusElement: HTMLElement | null = null;
    private availableModels: string[] = [];

    constructor(container: HTMLElement) {
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.loadAvailableModels();
    }

    /**
     * Render the Ollama configuration UI
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="ollama-config">
                <h4>Ollama Configuration</h4>
                <p class="config-description">
                    Configure your Ollama instance. Ollama can run locally or on a remote server.
                    <a href="https://ollama.ai/" target="_blank" rel="noopener">Learn more about Ollama</a>
                </p>

                <div class="config-grid">
                    <div class="config-item">
                        <label for="ollama-endpoint">Endpoint URL:</label>
                        <input type="text" id="ollama-endpoint" value="http://localhost:11434" placeholder="http://localhost:11434">
                        <small>Ollama server endpoint (local or remote)</small>
                    </div>

                    <div class="config-item">
                        <label for="ollama-model">Embedding Model:</label>
                        <div class="model-selection">
                            <select id="ollama-model" class="model-select">
                                <option value="">Loading models...</option>
                            </select>
                            <button id="refresh-models" class="refresh-button" title="Refresh available models">
                                
                            </button>
                        </div>
                        <small>Choose an embedding model (will be downloaded if not available)</small>
                    </div>

                    <div class="config-item">
                        <label for="ollama-api-key">API Key (Optional):</label>
                        <input type="password" id="ollama-api-key" placeholder="Enter API key if required">
                        <small>Leave empty for local instances without authentication</small>
                    </div>

                    <div class="config-item">
                        <label for="ollama-timeout">Request Timeout (seconds):</label>
                        <input type="number" id="ollama-timeout" value="30" min="5" max="300">
                        <small>Timeout for model requests (5-300 seconds)</small>
                    </div>
                </div>

                <div class="config-actions">
                    <button id="test-ollama-connection" class="test-button">Test Connection</button>
                    <div id="ollama-status" class="connection-status">
                        <span class="status-dot unknown"></span>
                        <span class="status-text">Not tested</span>
                    </div>
                </div>

                <div class="config-info">
                    <div class="info-section">
                        <h5> Local Installation</h5>
                        <p>Install Ollama locally:</p>
                        <ol>
                            <li>Download from <a href="https://ollama.ai/" target="_blank">ollama.ai</a></li>
                            <li>Install and start the service</li>
                            <li>Pull an embedding model: <code>ollama pull nomic-embed-text</code></li>
                        </ol>
                    </div>
                    
                    <div class="info-section">
                        <h5> Remote Setup</h5>
                        <p>Connect to a remote Ollama instance:</p>
                        <ul>
                            <li>Update the endpoint URL to your server</li>
                            <li>Add API key if authentication is enabled</li>
                            <li>Ensure the server is accessible from your network</li>
                        </ul>
                    </div>

                    <div class="info-section">
                        <h5> Recommended Models</h5>
                        <ul>
                            <li><strong>nomic-embed-text</strong> - High quality, 768 dimensions</li>
                            <li><strong>all-minilm</strong> - Fast and efficient, 384 dimensions</li>
                            <li><strong>mxbai-embed-large</strong> - Large model, 1024 dimensions</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;

        // Get references to elements
        this.endpointInput = this.container.querySelector('#ollama-endpoint') as HTMLInputElement;
        this.modelSelect = this.container.querySelector('#ollama-model') as HTMLSelectElement;
        this.apiKeyInput = this.container.querySelector('#ollama-api-key') as HTMLInputElement;
        this.timeoutInput = this.container.querySelector('#ollama-timeout') as HTMLInputElement;
        this.testButton = this.container.querySelector('#test-ollama-connection') as HTMLButtonElement;
        this.refreshModelsButton = this.container.querySelector('#refresh-models') as HTMLButtonElement;
        this.statusElement = this.container.querySelector('#ollama-status') as HTMLElement;
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        // Update configuration when inputs change
        [this.endpointInput, this.modelSelect, this.apiKeyInput, this.timeoutInput].forEach(input => {
            if (input) {
                input.addEventListener('input', () => this.updateConfiguration());
                input.addEventListener('change', () => this.updateConfiguration());
            }
        });

        // Test connection button
        if (this.testButton) {
            this.testButton.addEventListener('click', () => this.testConnection());
        }

        // Refresh models button
        if (this.refreshModelsButton) {
            this.refreshModelsButton.addEventListener('click', () => this.loadAvailableModels());
        }

        // Endpoint change should reload models
        if (this.endpointInput) {
            this.endpointInput.addEventListener('blur', () => {
                setTimeout(() => this.loadAvailableModels(), 500);
            });
        }
    }

    /**
     * Load available models from Ollama
     */
    private async loadAvailableModels(): Promise<void> {
        if (!this.modelSelect || !this.endpointInput || !this.refreshModelsButton) return;

        const endpoint = this.endpointInput.value || 'http://localhost:11434';
        
        // Update UI to show loading
        this.refreshModelsButton.disabled = true;
        this.refreshModelsButton.textContent = '';
        this.modelSelect.innerHTML = '<option value="">Loading models...</option>';

        try {
            const headers: Record<string, string> = {
                'Content-Type': 'application/json'
            };

            // Add API key if provided
            if (this.apiKeyInput?.value) {
                headers['Authorization'] = `Bearer ${this.apiKeyInput.value}`;
            }

            const response = await fetch(`${endpoint}/api/tags`, {
                method: 'GET',
                headers,
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                const data = await response.json();
                this.availableModels = data.models?.map((model: any) => model.name) || [];
                this.updateModelOptions();
                this.updateStatus('success', 'Models loaded successfully');
            } else {
                throw new Error(`Failed to load models: ${response.status}`);
            }

        } catch (error) {
            console.error('Failed to load Ollama models:', error);
            this.availableModels = [];
            this.updateModelOptions(true);
            
            if (error instanceof Error && error.name === 'AbortError') {
                this.updateStatus('error', 'Connection timeout - check endpoint');
            } else {
                this.updateStatus('error', 'Could not load models - using defaults');
            }
        } finally {
            // Reset button state
            this.refreshModelsButton.disabled = false;
            this.refreshModelsButton.textContent = '';
        }
    }

    /**
     * Update model selection options
     */
    private updateModelOptions(useDefaults: boolean = false): void {
        if (!this.modelSelect) return;

        const currentValue = this.modelSelect.value;
        this.modelSelect.innerHTML = '';

        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Select a model...';
        this.modelSelect.appendChild(defaultOption);

        // Add available models or defaults
        const models = useDefaults ? [
            'nomic-embed-text',
            'all-minilm',
            'mxbai-embed-large'
        ] : this.availableModels;

        models.forEach(model => {
            const option = document.createElement('option');
            option.value = model;
            option.textContent = model;
            this.modelSelect.appendChild(option);
        });

        // Restore previous selection if still available
        if (currentValue && models.includes(currentValue)) {
            this.modelSelect.value = currentValue;
        }

        // Add note about default models if using fallback
        if (useDefaults) {
            const noteOption = document.createElement('option');
            noteOption.disabled = true;
            noteOption.textContent = '--- Default models (will be downloaded) ---';
            this.modelSelect.insertBefore(noteOption, this.modelSelect.children[1]);
        }
    }

    /**
     * Update configuration in store
     */
    private updateConfiguration(): void {
        if (!this.endpointInput || !this.modelSelect || !this.timeoutInput) return;

        const config: OllamaConfig = {
            endpoint: this.endpointInput.value || 'http://localhost:11434',
            model: this.modelSelect.value,
            apiKey: this.apiKeyInput?.value || undefined,
            timeout: parseInt(this.timeoutInput.value) || 30
        };

        setupActions.setEmbeddingConfig(config);
    }

    /**
     * Test Ollama connection and model availability
     */
    private async testConnection(): Promise<void> {
        if (!this.testButton || !this.statusElement) return;

        const config = this.getConfiguration();
        
        // Validate required fields
        if (!config.endpoint || !config.model) {
            this.updateStatus('error', 'Endpoint and model are required');
            return;
        }

        // Update UI to show testing state
        this.testButton.disabled = true;
        this.testButton.textContent = 'Testing...';
        this.updateStatus('testing', 'Testing connection...');

        try {
            // Test basic connection
            const headers: Record<string, string> = {
                'Content-Type': 'application/json'
            };

            if (config.apiKey) {
                headers['Authorization'] = `Bearer ${config.apiKey}`;
            }

            // First test: Check if Ollama is running
            const healthResponse = await fetch(`${config.endpoint}/api/tags`, {
                method: 'GET',
                headers,
                signal: AbortSignal.timeout(config.timeout * 1000)
            });

            if (!healthResponse.ok) {
                throw new Error(`Ollama not responding: ${healthResponse.status}`);
            }

            // Second test: Check if model is available
            const modelsData = await healthResponse.json();
            const availableModels = modelsData.models?.map((m: any) => m.name) || [];
            
            if (!availableModels.includes(config.model)) {
                this.updateStatus('warning', `Model '${config.model}' not found - will be downloaded when needed`);
            } else {
                this.updateStatus('success', 'Connection successful! Model is available.');
            }

        } catch (error) {
            console.error('Ollama connection test failed:', error);
            
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    this.updateStatus('error', 'Connection timeout - check endpoint and timeout settings');
                } else if (error.message.includes('Failed to fetch')) {
                    this.updateStatus('error', 'Cannot reach Ollama - check if it\'s running and endpoint is correct');
                } else {
                    this.updateStatus('error', `Connection error: ${error.message}`);
                }
            } else {
                this.updateStatus('error', 'Unknown connection error');
            }
        } finally {
            // Reset button state
            this.testButton.disabled = false;
            this.testButton.textContent = 'Test Connection';
        }
    }

    /**
     * Update connection status display
     */
    private updateStatus(type: 'testing' | 'success' | 'warning' | 'error' | 'unknown', message: string): void {
        if (!this.statusElement) return;

        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');

        if (statusDot && statusText) {
            // Remove all status classes
            statusDot.className = 'status-dot';
            statusDot.classList.add(type);
            statusText.textContent = message;
        }
    }

    /**
     * Get current configuration
     */
    private getConfiguration(): OllamaConfig {
        return {
            endpoint: this.endpointInput?.value || 'http://localhost:11434',
            model: this.modelSelect?.value || '',
            apiKey: this.apiKeyInput?.value || undefined,
            timeout: parseInt(this.timeoutInput?.value || '30')
        };
    }

    /**
     * Load configuration from external source
     */
    public loadConfiguration(config: OllamaConfig): void {
        if (this.endpointInput) this.endpointInput.value = config.endpoint;
        if (this.modelSelect) this.modelSelect.value = config.model;
        if (this.apiKeyInput) this.apiKeyInput.value = config.apiKey || '';
        if (this.timeoutInput) this.timeoutInput.value = (config.timeout || 30).toString();
        
        this.updateConfiguration();
    }

    /**
     * Validate configuration
     */
    public validateConfiguration(): { isValid: boolean; errors: string[] } {
        const errors: string[] = [];
        const config = this.getConfiguration();

        if (!config.endpoint || config.endpoint.trim() === '') {
            errors.push('Endpoint URL is required');
        } else {
            try {
                new URL(config.endpoint);
            } catch {
                errors.push('Endpoint URL is not valid');
            }
        }

        if (!config.model || config.model.trim() === '') {
            errors.push('Model selection is required');
        }

        if (config.timeout < 5 || config.timeout > 300) {
            errors.push('Timeout must be between 5 and 300 seconds');
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        // Remove event listeners if needed
    }
}

// CSS styles for Ollama configuration
export const ollamaConfigStyles = `
.ollama-config {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.ollama-config h4 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.config-description {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
    line-height: 1.4;
}

.config-description a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.config-description a:hover {
    text-decoration: underline;
}

.config-grid {
    display: grid;
    gap: 15px;
    margin-bottom: 15px;
}

.config-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.config-item label {
    font-weight: 500;
    color: var(--vscode-foreground);
    font-size: 13px;
}

.config-item input,
.config-item select {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item input:focus,
.config-item select:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.model-selection {
    display: flex;
    gap: 6px;
    align-items: center;
}

.model-select {
    flex: 1;
}

.refresh-button {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    cursor: pointer;
    font-size: 12px;
    min-width: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.refresh-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.refresh-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.config-item small {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.config-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.test-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.unknown {
    background-color: var(--vscode-charts-gray);
}

.status-dot.testing {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.success {
    background-color: var(--vscode-charts-green);
}

.status-dot.warning {
    background-color: var(--vscode-charts-orange);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 12px;
    color: var(--vscode-foreground);
}

.config-info {
    border-top: 1px solid var(--vscode-panel-border);
    padding-top: 15px;
    margin-top: 15px;
}

.info-section {
    margin-bottom: 15px;
}

.info-section h5 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.info-section p {
    margin: 0 0 6px 0;
    color: var(--vscode-foreground);
    font-size: 12px;
    line-height: 1.4;
}

.info-section ol,
.info-section ul {
    margin: 6px 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
    font-size: 12px;
}

.info-section li {
    margin-bottom: 3px;
    line-height: 1.3;
}

.info-section code {
    padding: 2px 4px;
    background-color: var(--vscode-textCodeBlock-background);
    border: 1px solid var(--vscode-panel-border);
    border-radius: 2px;
    font-family: var(--vscode-editor-font-family);
    font-size: 11px;
    color: var(--vscode-textPreformat-foreground);
}

.info-section a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.info-section a:hover {
    text-decoration: underline;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/components/OpenAIConfig.js">
"use strict";
/**
 * OpenAIConfig Component
 *
 * Enhanced OpenAI configuration with secure API key storage,
 * model validation, and custom endpoint support.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.openAIConfigStyles = exports.OpenAIConfigComponent = void 0;
const setupStore_1 = require("../stores/setupStore");
const vscodeApi_1 = require("../vscodeApi");
class OpenAIConfigComponent {
    constructor(container) {
        this.apiKeyInput = null;
        this.modelSelect = null;
        this.organizationInput = null;
        this.baseURLInput = null;
        this.testButton = null;
        this.saveKeyButton = null;
        this.loadKeyButton = null;
        this.statusElement = null;
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.loadSavedApiKey();
    }
    /**
     * Render the OpenAI configuration UI
     */
    render() {
        this.container.innerHTML = `
            <div class="openai-config">
                <h4>OpenAI Configuration</h4>
                <p class="config-description">
                    Configure your OpenAI API settings for cloud-based embeddings.
                    <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener">Get your API key</a>
                </p>

                <div class="config-grid">
                    <div class="config-item">
                        <label for="openai-api-key">API Key:</label>
                        <div class="api-key-section">
                            <input type="password" id="openai-api-key" placeholder="sk-...">
                            <div class="key-actions">
                                <button id="save-api-key" class="key-button" title="Save API key securely"></button>
                                <button id="load-api-key" class="key-button" title="Load saved API key"></button>
                            </div>
                        </div>
                        <small>Your API key is stored securely in VS Code's secret storage</small>
                    </div>

                    <div class="config-item">
                        <label for="openai-model">Embedding Model:</label>
                        <select id="openai-model" class="model-select">
                            <option value="text-embedding-ada-002">text-embedding-ada-002 (Legacy)</option>
                            <option value="text-embedding-3-small" selected>text-embedding-3-small (Recommended)</option>
                            <option value="text-embedding-3-large">text-embedding-3-large (High Performance)</option>
                        </select>
                        <small>Choose the embedding model for your use case</small>
                    </div>

                    <div class="config-item">
                        <label for="openai-organization">Organization ID (Optional):</label>
                        <input type="text" id="openai-organization" placeholder="org-...">
                        <small>Your OpenAI organization ID (if applicable)</small>
                    </div>

                    <div class="config-item">
                        <label for="openai-base-url">Custom Base URL (Optional):</label>
                        <input type="text" id="openai-base-url" placeholder="https://api.openai.com/v1">
                        <small>Custom endpoint for OpenAI-compatible APIs (Azure OpenAI, etc.)</small>
                    </div>
                </div>

                <div class="config-actions">
                    <button id="test-openai-connection" class="test-button">Test API Key</button>
                    <div id="openai-status" class="connection-status">
                        <span class="status-dot unknown"></span>
                        <span class="status-text">Not tested</span>
                    </div>
                </div>

                <div class="config-info">
                    <div class="info-section">
                        <h5> API Key Management</h5>
                        <ul>
                            <li>API keys are stored securely using VS Code's secret storage</li>
                            <li>Keys are encrypted and never stored in plain text</li>
                            <li>Use the save/load buttons to manage your API key</li>
                        </ul>
                    </div>
                    
                    <div class="info-section">
                        <h5> Model Comparison</h5>
                        <ul>
                            <li><strong>text-embedding-3-small</strong> - Best balance of performance and cost</li>
                            <li><strong>text-embedding-3-large</strong> - Highest quality embeddings</li>
                            <li><strong>text-embedding-ada-002</strong> - Legacy model (deprecated)</li>
                        </ul>
                    </div>

                    <div class="info-section">
                        <h5> Custom Endpoints</h5>
                        <p>Supported OpenAI-compatible services:</p>
                        <ul>
                            <li>Azure OpenAI Service</li>
                            <li>OpenAI-compatible local models</li>
                            <li>Third-party OpenAI proxies</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;
        // Get references to elements
        this.apiKeyInput = this.container.querySelector('#openai-api-key');
        this.modelSelect = this.container.querySelector('#openai-model');
        this.organizationInput = this.container.querySelector('#openai-organization');
        this.baseURLInput = this.container.querySelector('#openai-base-url');
        this.testButton = this.container.querySelector('#test-openai-connection');
        this.saveKeyButton = this.container.querySelector('#save-api-key');
        this.loadKeyButton = this.container.querySelector('#load-api-key');
        this.statusElement = this.container.querySelector('#openai-status');
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Update configuration when inputs change
        [this.apiKeyInput, this.modelSelect, this.organizationInput, this.baseURLInput].forEach(input => {
            if (input) {
                input.addEventListener('input', () => this.updateConfiguration());
                input.addEventListener('change', () => this.updateConfiguration());
            }
        });
        // Test connection button
        if (this.testButton) {
            this.testButton.addEventListener('click', () => this.testConnection());
        }
        // Save API key button
        if (this.saveKeyButton) {
            this.saveKeyButton.addEventListener('click', () => this.saveApiKey());
        }
        // Load API key button
        if (this.loadKeyButton) {
            this.loadKeyButton.addEventListener('click', () => this.loadSavedApiKey());
        }
        // API key validation
        if (this.apiKeyInput) {
            this.apiKeyInput.addEventListener('input', () => this.validateApiKey());
        }
    }
    /**
     * Validate API key format
     */
    validateApiKey() {
        if (!this.apiKeyInput)
            return;
        const apiKey = this.apiKeyInput.value;
        const isValid = apiKey.startsWith('sk-') && apiKey.length > 20;
        if (apiKey && !isValid) {
            this.apiKeyInput.style.borderColor = 'var(--vscode-inputValidation-errorBorder)';
        }
        else {
            this.apiKeyInput.style.borderColor = '';
        }
    }
    /**
     * Save API key securely
     */
    async saveApiKey() {
        if (!this.apiKeyInput || !this.saveKeyButton)
            return;
        const apiKey = this.apiKeyInput.value;
        if (!apiKey) {
            this.updateStatus('error', 'No API key to save');
            return;
        }
        this.saveKeyButton.disabled = true;
        this.saveKeyButton.textContent = '...';
        try {
            vscodeApi_1.vscodeApi.postMessage({
                command: 'saveSecretValue',
                key: 'openai-api-key',
                value: apiKey
            });
            this.updateStatus('success', 'API key saved securely');
        }
        catch (error) {
            console.error('Failed to save API key:', error);
            this.updateStatus('error', 'Failed to save API key');
        }
        finally {
            this.saveKeyButton.disabled = false;
            this.saveKeyButton.textContent = '';
        }
    }
    /**
     * Load saved API key
     */
    async loadSavedApiKey() {
        if (!this.loadKeyButton)
            return;
        this.loadKeyButton.disabled = true;
        this.loadKeyButton.textContent = '...';
        try {
            // Send message to get secret value
            vscodeApi_1.vscodeApi.postMessage({
                command: 'getSecretValue',
                key: 'openai-api-key'
            });
            // Listen for response (this is a simplified approach - in a real implementation,
            // you'd want to set up proper response handling)
            this.updateStatus('success', 'Attempting to load saved API key...');
        }
        catch (error) {
            console.error('Failed to load API key:', error);
            this.updateStatus('error', 'Failed to load API key');
        }
        finally {
            this.loadKeyButton.disabled = false;
            this.loadKeyButton.textContent = '';
        }
    }
    /**
     * Update configuration in store
     */
    updateConfiguration() {
        if (!this.apiKeyInput || !this.modelSelect)
            return;
        const config = {
            apiKey: this.apiKeyInput.value,
            model: this.modelSelect.value,
            organization: this.organizationInput?.value || undefined,
            baseURL: this.baseURLInput?.value || undefined
        };
        setupStore_1.setupActions.setEmbeddingConfig(config);
    }
    /**
     * Test OpenAI connection and API key
     */
    async testConnection() {
        if (!this.testButton || !this.statusElement)
            return;
        const config = this.getConfiguration();
        // Validate required fields
        if (!config.apiKey) {
            this.updateStatus('error', 'API key is required');
            return;
        }
        // Update UI to show testing state
        this.testButton.disabled = true;
        this.testButton.textContent = 'Testing...';
        this.updateStatus('testing', 'Testing API key...');
        try {
            const baseURL = config.baseURL || 'https://api.openai.com/v1';
            const headers = {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            };
            if (config.organization) {
                headers['OpenAI-Organization'] = config.organization;
            }
            // Test API key by listing models
            const response = await fetch(`${baseURL}/models`, {
                method: 'GET',
                headers,
                signal: AbortSignal.timeout(10000)
            });
            if (response.ok) {
                const data = await response.json();
                const hasEmbeddingModels = data.data?.some((model) => model.id.includes('embedding') || model.id === config.model);
                if (hasEmbeddingModels) {
                    this.updateStatus('success', 'API key valid! Embedding models available.');
                }
                else {
                    this.updateStatus('warning', 'API key valid, but embedding models may not be available.');
                }
            }
            else if (response.status === 401) {
                this.updateStatus('error', 'Invalid API key');
            }
            else if (response.status === 403) {
                this.updateStatus('error', 'Access denied - check your API key permissions');
            }
            else {
                this.updateStatus('error', `API test failed: ${response.status} ${response.statusText}`);
            }
        }
        catch (error) {
            console.error('OpenAI connection test failed:', error);
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    this.updateStatus('error', 'Connection timeout - check your base URL');
                }
                else if (error.message.includes('Failed to fetch')) {
                    this.updateStatus('error', 'Network error - check your internet connection');
                }
                else {
                    this.updateStatus('error', `Connection error: ${error.message}`);
                }
            }
            else {
                this.updateStatus('error', 'Unknown connection error');
            }
        }
        finally {
            // Reset button state
            this.testButton.disabled = false;
            this.testButton.textContent = 'Test API Key';
        }
    }
    /**
     * Update connection status display
     */
    updateStatus(type, message) {
        if (!this.statusElement)
            return;
        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');
        if (statusDot && statusText) {
            // Remove all status classes
            statusDot.className = 'status-dot';
            statusDot.classList.add(type);
            statusText.textContent = message;
        }
    }
    /**
     * Get current configuration
     */
    getConfiguration() {
        return {
            apiKey: this.apiKeyInput?.value || '',
            model: this.modelSelect?.value || 'text-embedding-3-small',
            organization: this.organizationInput?.value || undefined,
            baseURL: this.baseURLInput?.value || undefined
        };
    }
    /**
     * Load configuration from external source
     */
    loadConfiguration(config) {
        if (this.apiKeyInput)
            this.apiKeyInput.value = config.apiKey;
        if (this.modelSelect)
            this.modelSelect.value = config.model;
        if (this.organizationInput)
            this.organizationInput.value = config.organization || '';
        if (this.baseURLInput)
            this.baseURLInput.value = config.baseURL || '';
        this.updateConfiguration();
    }
    /**
     * Validate configuration
     */
    validateConfiguration() {
        const errors = [];
        const config = this.getConfiguration();
        if (!config.apiKey || config.apiKey.trim() === '') {
            errors.push('API key is required');
        }
        else if (!config.apiKey.startsWith('sk-') || config.apiKey.length < 20) {
            errors.push('API key format appears to be invalid');
        }
        if (!config.model || config.model.trim() === '') {
            errors.push('Model selection is required');
        }
        if (config.baseURL) {
            try {
                new URL(config.baseURL);
            }
            catch {
                errors.push('Base URL is not a valid URL');
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    /**
     * Cleanup component
     */
    dispose() {
        // Remove event listeners if needed
    }
}
exports.OpenAIConfigComponent = OpenAIConfigComponent;
// CSS styles for OpenAI configuration
exports.openAIConfigStyles = `
.openai-config {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.openai-config h4 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.config-description {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
    line-height: 1.4;
}

.config-description a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.config-description a:hover {
    text-decoration: underline;
}

.config-grid {
    display: grid;
    gap: 15px;
    margin-bottom: 15px;
}

.config-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.config-item label {
    font-weight: 500;
    color: var(--vscode-foreground);
    font-size: 13px;
}

.api-key-section {
    display: flex;
    gap: 6px;
    align-items: center;
}

.api-key-section input {
    flex: 1;
}

.key-actions {
    display: flex;
    gap: 4px;
}

.key-button {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    cursor: pointer;
    font-size: 12px;
    min-width: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.key-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.key-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.config-item input,
.config-item select {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item input:focus,
.config-item select:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.config-item small {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.config-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.test-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.unknown {
    background-color: var(--vscode-charts-gray);
}

.status-dot.testing {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.success {
    background-color: var(--vscode-charts-green);
}

.status-dot.warning {
    background-color: var(--vscode-charts-orange);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 12px;
    color: var(--vscode-foreground);
}

.config-info {
    border-top: 1px solid var(--vscode-panel-border);
    padding-top: 15px;
    margin-top: 15px;
}

.info-section {
    margin-bottom: 15px;
}

.info-section h5 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.info-section p {
    margin: 0 0 6px 0;
    color: var(--vscode-foreground);
    font-size: 12px;
    line-height: 1.4;
}

.info-section ul {
    margin: 6px 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
    font-size: 12px;
}

.info-section li {
    margin-bottom: 3px;
    line-height: 1.3;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
//# sourceMappingURL=OpenAIConfig.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/components/OpenAIConfig.js.map">
{"version":3,"file":"OpenAIConfig.js","sourceRoot":"","sources":["OpenAIConfig.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/components/OpenAIConfig.ts">
/**
 * OpenAIConfig Component
 * 
 * Enhanced OpenAI configuration with secure API key storage,
 * model validation, and custom endpoint support.
 */

import { setupActions, OpenAIConfig } from '../stores/setupStore';
import { vscodeApi } from '../vscodeApi';

export class OpenAIConfigComponent {
    private container: HTMLElement;
    private apiKeyInput: HTMLInputElement | null = null;
    private modelSelect: HTMLSelectElement | null = null;
    private organizationInput: HTMLInputElement | null = null;
    private baseURLInput: HTMLInputElement | null = null;
    private testButton: HTMLButtonElement | null = null;
    private saveKeyButton: HTMLButtonElement | null = null;
    private loadKeyButton: HTMLButtonElement | null = null;
    private statusElement: HTMLElement | null = null;

    constructor(container: HTMLElement) {
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.loadSavedApiKey();
    }

    /**
     * Render the OpenAI configuration UI
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="openai-config">
                <h4>OpenAI Configuration</h4>
                <p class="config-description">
                    Configure your OpenAI API settings for cloud-based embeddings.
                    <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener">Get your API key</a>
                </p>

                <div class="config-grid">
                    <div class="config-item">
                        <label for="openai-api-key">API Key:</label>
                        <div class="api-key-section">
                            <input type="password" id="openai-api-key" placeholder="sk-...">
                            <div class="key-actions">
                                <button id="save-api-key" class="key-button" title="Save API key securely"></button>
                                <button id="load-api-key" class="key-button" title="Load saved API key"></button>
                            </div>
                        </div>
                        <small>Your API key is stored securely in VS Code's secret storage</small>
                    </div>

                    <div class="config-item">
                        <label for="openai-model">Embedding Model:</label>
                        <select id="openai-model" class="model-select">
                            <option value="text-embedding-ada-002">text-embedding-ada-002 (Legacy)</option>
                            <option value="text-embedding-3-small" selected>text-embedding-3-small (Recommended)</option>
                            <option value="text-embedding-3-large">text-embedding-3-large (High Performance)</option>
                        </select>
                        <small>Choose the embedding model for your use case</small>
                    </div>

                    <div class="config-item">
                        <label for="openai-organization">Organization ID (Optional):</label>
                        <input type="text" id="openai-organization" placeholder="org-...">
                        <small>Your OpenAI organization ID (if applicable)</small>
                    </div>

                    <div class="config-item">
                        <label for="openai-base-url">Custom Base URL (Optional):</label>
                        <input type="text" id="openai-base-url" placeholder="https://api.openai.com/v1">
                        <small>Custom endpoint for OpenAI-compatible APIs (Azure OpenAI, etc.)</small>
                    </div>
                </div>

                <div class="config-actions">
                    <button id="test-openai-connection" class="test-button">Test API Key</button>
                    <div id="openai-status" class="connection-status">
                        <span class="status-dot unknown"></span>
                        <span class="status-text">Not tested</span>
                    </div>
                </div>

                <div class="config-info">
                    <div class="info-section">
                        <h5> API Key Management</h5>
                        <ul>
                            <li>API keys are stored securely using VS Code's secret storage</li>
                            <li>Keys are encrypted and never stored in plain text</li>
                            <li>Use the save/load buttons to manage your API key</li>
                        </ul>
                    </div>
                    
                    <div class="info-section">
                        <h5> Model Comparison</h5>
                        <ul>
                            <li><strong>text-embedding-3-small</strong> - Best balance of performance and cost</li>
                            <li><strong>text-embedding-3-large</strong> - Highest quality embeddings</li>
                            <li><strong>text-embedding-ada-002</strong> - Legacy model (deprecated)</li>
                        </ul>
                    </div>

                    <div class="info-section">
                        <h5> Custom Endpoints</h5>
                        <p>Supported OpenAI-compatible services:</p>
                        <ul>
                            <li>Azure OpenAI Service</li>
                            <li>OpenAI-compatible local models</li>
                            <li>Third-party OpenAI proxies</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;

        // Get references to elements
        this.apiKeyInput = this.container.querySelector('#openai-api-key') as HTMLInputElement;
        this.modelSelect = this.container.querySelector('#openai-model') as HTMLSelectElement;
        this.organizationInput = this.container.querySelector('#openai-organization') as HTMLInputElement;
        this.baseURLInput = this.container.querySelector('#openai-base-url') as HTMLInputElement;
        this.testButton = this.container.querySelector('#test-openai-connection') as HTMLButtonElement;
        this.saveKeyButton = this.container.querySelector('#save-api-key') as HTMLButtonElement;
        this.loadKeyButton = this.container.querySelector('#load-api-key') as HTMLButtonElement;
        this.statusElement = this.container.querySelector('#openai-status') as HTMLElement;
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        // Update configuration when inputs change
        [this.apiKeyInput, this.modelSelect, this.organizationInput, this.baseURLInput].forEach(input => {
            if (input) {
                input.addEventListener('input', () => this.updateConfiguration());
                input.addEventListener('change', () => this.updateConfiguration());
            }
        });

        // Test connection button
        if (this.testButton) {
            this.testButton.addEventListener('click', () => this.testConnection());
        }

        // Save API key button
        if (this.saveKeyButton) {
            this.saveKeyButton.addEventListener('click', () => this.saveApiKey());
        }

        // Load API key button
        if (this.loadKeyButton) {
            this.loadKeyButton.addEventListener('click', () => this.loadSavedApiKey());
        }

        // API key validation
        if (this.apiKeyInput) {
            this.apiKeyInput.addEventListener('input', () => this.validateApiKey());
        }
    }

    /**
     * Validate API key format
     */
    private validateApiKey(): void {
        if (!this.apiKeyInput) return;

        const apiKey = this.apiKeyInput.value;
        const isValid = apiKey.startsWith('sk-') && apiKey.length > 20;
        
        if (apiKey && !isValid) {
            this.apiKeyInput.style.borderColor = 'var(--vscode-inputValidation-errorBorder)';
        } else {
            this.apiKeyInput.style.borderColor = '';
        }
    }

    /**
     * Save API key securely
     */
    private async saveApiKey(): Promise<void> {
        if (!this.apiKeyInput || !this.saveKeyButton) return;

        const apiKey = this.apiKeyInput.value;
        if (!apiKey) {
            this.updateStatus('error', 'No API key to save');
            return;
        }

        this.saveKeyButton.disabled = true;
        this.saveKeyButton.textContent = '...';

        try {
            vscodeApi.postMessage({
                command: 'saveSecretValue',
                key: 'openai-api-key',
                value: apiKey
            });

            this.updateStatus('success', 'API key saved securely');
        } catch (error) {
            console.error('Failed to save API key:', error);
            this.updateStatus('error', 'Failed to save API key');
        } finally {
            this.saveKeyButton.disabled = false;
            this.saveKeyButton.textContent = '';
        }
    }

    /**
     * Load saved API key
     */
    private async loadSavedApiKey(): Promise<void> {
        if (!this.loadKeyButton) return;

        this.loadKeyButton.disabled = true;
        this.loadKeyButton.textContent = '...';

        try {
            // Send message to get secret value
            vscodeApi.postMessage({
                command: 'getSecretValue',
                key: 'openai-api-key'
            });

            // Listen for response (this is a simplified approach - in a real implementation,
            // you'd want to set up proper response handling)
            this.updateStatus('success', 'Attempting to load saved API key...');
        } catch (error) {
            console.error('Failed to load API key:', error);
            this.updateStatus('error', 'Failed to load API key');
        } finally {
            this.loadKeyButton.disabled = false;
            this.loadKeyButton.textContent = '';
        }
    }

    /**
     * Update configuration in store
     */
    private updateConfiguration(): void {
        if (!this.apiKeyInput || !this.modelSelect) return;

        const config: OpenAIConfig = {
            apiKey: this.apiKeyInput.value,
            model: this.modelSelect.value,
            organization: this.organizationInput?.value || undefined,
            baseURL: this.baseURLInput?.value || undefined
        };

        setupActions.setEmbeddingConfig(config);
    }

    /**
     * Test OpenAI connection and API key
     */
    private async testConnection(): Promise<void> {
        if (!this.testButton || !this.statusElement) return;

        const config = this.getConfiguration();
        
        // Validate required fields
        if (!config.apiKey) {
            this.updateStatus('error', 'API key is required');
            return;
        }

        // Update UI to show testing state
        this.testButton.disabled = true;
        this.testButton.textContent = 'Testing...';
        this.updateStatus('testing', 'Testing API key...');

        try {
            const baseURL = config.baseURL || 'https://api.openai.com/v1';
            const headers: Record<string, string> = {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            };

            if (config.organization) {
                headers['OpenAI-Organization'] = config.organization;
            }

            // Test API key by listing models
            const response = await fetch(`${baseURL}/models`, {
                method: 'GET',
                headers,
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                const data = await response.json();
                const hasEmbeddingModels = data.data?.some((model: any) => 
                    model.id.includes('embedding') || model.id === config.model
                );

                if (hasEmbeddingModels) {
                    this.updateStatus('success', 'API key valid! Embedding models available.');
                } else {
                    this.updateStatus('warning', 'API key valid, but embedding models may not be available.');
                }
            } else if (response.status === 401) {
                this.updateStatus('error', 'Invalid API key');
            } else if (response.status === 403) {
                this.updateStatus('error', 'Access denied - check your API key permissions');
            } else {
                this.updateStatus('error', `API test failed: ${response.status} ${response.statusText}`);
            }

        } catch (error) {
            console.error('OpenAI connection test failed:', error);
            
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    this.updateStatus('error', 'Connection timeout - check your base URL');
                } else if (error.message.includes('Failed to fetch')) {
                    this.updateStatus('error', 'Network error - check your internet connection');
                } else {
                    this.updateStatus('error', `Connection error: ${error.message}`);
                }
            } else {
                this.updateStatus('error', 'Unknown connection error');
            }
        } finally {
            // Reset button state
            this.testButton.disabled = false;
            this.testButton.textContent = 'Test API Key';
        }
    }

    /**
     * Update connection status display
     */
    private updateStatus(type: 'testing' | 'success' | 'warning' | 'error' | 'unknown', message: string): void {
        if (!this.statusElement) return;

        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');

        if (statusDot && statusText) {
            // Remove all status classes
            statusDot.className = 'status-dot';
            statusDot.classList.add(type);
            statusText.textContent = message;
        }
    }

    /**
     * Get current configuration
     */
    private getConfiguration(): OpenAIConfig {
        return {
            apiKey: this.apiKeyInput?.value || '',
            model: this.modelSelect?.value || 'text-embedding-3-small',
            organization: this.organizationInput?.value || undefined,
            baseURL: this.baseURLInput?.value || undefined
        };
    }

    /**
     * Load configuration from external source
     */
    public loadConfiguration(config: OpenAIConfig): void {
        if (this.apiKeyInput) this.apiKeyInput.value = config.apiKey;
        if (this.modelSelect) this.modelSelect.value = config.model;
        if (this.organizationInput) this.organizationInput.value = config.organization || '';
        if (this.baseURLInput) this.baseURLInput.value = config.baseURL || '';
        
        this.updateConfiguration();
    }

    /**
     * Validate configuration
     */
    public validateConfiguration(): { isValid: boolean; errors: string[] } {
        const errors: string[] = [];
        const config = this.getConfiguration();

        if (!config.apiKey || config.apiKey.trim() === '') {
            errors.push('API key is required');
        } else if (!config.apiKey.startsWith('sk-') || config.apiKey.length < 20) {
            errors.push('API key format appears to be invalid');
        }

        if (!config.model || config.model.trim() === '') {
            errors.push('Model selection is required');
        }

        if (config.baseURL) {
            try {
                new URL(config.baseURL);
            } catch {
                errors.push('Base URL is not a valid URL');
            }
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        // Remove event listeners if needed
    }
}

// CSS styles for OpenAI configuration
export const openAIConfigStyles = `
.openai-config {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.openai-config h4 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.config-description {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
    line-height: 1.4;
}

.config-description a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.config-description a:hover {
    text-decoration: underline;
}

.config-grid {
    display: grid;
    gap: 15px;
    margin-bottom: 15px;
}

.config-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.config-item label {
    font-weight: 500;
    color: var(--vscode-foreground);
    font-size: 13px;
}

.api-key-section {
    display: flex;
    gap: 6px;
    align-items: center;
}

.api-key-section input {
    flex: 1;
}

.key-actions {
    display: flex;
    gap: 4px;
}

.key-button {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    cursor: pointer;
    font-size: 12px;
    min-width: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.key-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.key-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.config-item input,
.config-item select {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item input:focus,
.config-item select:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.config-item small {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.config-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.test-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.unknown {
    background-color: var(--vscode-charts-gray);
}

.status-dot.testing {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.success {
    background-color: var(--vscode-charts-green);
}

.status-dot.warning {
    background-color: var(--vscode-charts-orange);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 12px;
    color: var(--vscode-foreground);
}

.config-info {
    border-top: 1px solid var(--vscode-panel-border);
    padding-top: 15px;
    margin-top: 15px;
}

.info-section {
    margin-bottom: 15px;
}

.info-section h5 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.info-section p {
    margin: 0 0 6px 0;
    color: var(--vscode-foreground);
    font-size: 12px;
    line-height: 1.4;
}

.info-section ul {
    margin: 6px 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
    font-size: 12px;
}

.info-section li {
    margin-bottom: 3px;
    line-height: 1.3;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/components/PineconeConfig.js">
"use strict";
/**
 * PineconeConfig Component
 *
 * Handles Pinecone-specific configuration including API key, environment,
 * and index management for cloud-based vector database.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pineconeConfigStyles = exports.PineconeConfigComponent = void 0;
const setupStore_1 = require("../stores/setupStore");
class PineconeConfigComponent {
    constructor(container) {
        this.apiKeyInput = null;
        this.environmentInput = null;
        this.indexNameInput = null;
        this.testButton = null;
        this.statusElement = null;
        this.container = container;
        this.render();
        this.setupEventListeners();
    }
    /**
     * Render the Pinecone configuration UI
     */
    render() {
        this.container.innerHTML = `
            <div class="pinecone-config">
                <h4>Pinecone Configuration</h4>
                <p class="config-description">
                    Configure your Pinecone cloud vector database. You'll need a Pinecone account and API key.
                    <a href="https://www.pinecone.io/" target="_blank" rel="noopener">Sign up for Pinecone</a>
                </p>

                <div class="config-grid">
                    <div class="config-item">
                        <label for="pinecone-api-key">API Key:</label>
                        <input type="password" id="pinecone-api-key" placeholder="Enter your Pinecone API key">
                        <small>Your Pinecone API key (stored securely in VS Code)</small>
                    </div>

                    <div class="config-item">
                        <label for="pinecone-environment">Environment:</label>
                        <input type="text" id="pinecone-environment" placeholder="e.g., us-east-1-aws">
                        <small>Your Pinecone environment (found in Pinecone console)</small>
                    </div>

                    <div class="config-item">
                        <label for="pinecone-index-name">Index Name:</label>
                        <input type="text" id="pinecone-index-name" placeholder="e.g., code-context-index">
                        <small>Name for your vector index (will be created if it doesn't exist)</small>
                    </div>
                </div>

                <div class="config-actions">
                    <button id="test-pinecone-connection" class="test-button">Test Connection</button>
                    <div id="pinecone-status" class="connection-status">
                        <span class="status-dot unknown"></span>
                        <span class="status-text">Not tested</span>
                    </div>
                </div>

                <div class="config-info">
                    <div class="info-section">
                        <h5> Getting Your API Key</h5>
                        <ol>
                            <li>Sign up at <a href="https://www.pinecone.io/" target="_blank">pinecone.io</a></li>
                            <li>Go to your Pinecone console</li>
                            <li>Navigate to "API Keys" section</li>
                            <li>Copy your API key</li>
                        </ol>
                    </div>
                    
                    <div class="info-section">
                        <h5> Finding Your Environment</h5>
                        <p>Your environment is shown in the Pinecone console URL or dashboard. Common environments:</p>
                        <ul>
                            <li><code>us-east-1-aws</code> (US East)</li>
                            <li><code>us-west-2-aws</code> (US West)</li>
                            <li><code>eu-west-1-aws</code> (Europe)</li>
                        </ul>
                    </div>

                    <div class="info-section">
                        <h5> Index Configuration</h5>
                        <p>The index will be created automatically with these settings:</p>
                        <ul>
                            <li><strong>Dimension:</strong> Based on your embedding model</li>
                            <li><strong>Metric:</strong> Cosine similarity</li>
                            <li><strong>Pod Type:</strong> Starter (free tier)</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;
        // Get references to elements
        this.apiKeyInput = this.container.querySelector('#pinecone-api-key');
        this.environmentInput = this.container.querySelector('#pinecone-environment');
        this.indexNameInput = this.container.querySelector('#pinecone-index-name');
        this.testButton = this.container.querySelector('#test-pinecone-connection');
        this.statusElement = this.container.querySelector('#pinecone-status');
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Update configuration when inputs change
        [this.apiKeyInput, this.environmentInput, this.indexNameInput].forEach(input => {
            if (input) {
                input.addEventListener('input', () => this.updateConfiguration());
                input.addEventListener('change', () => this.updateConfiguration());
            }
        });
        // Test connection button
        if (this.testButton) {
            this.testButton.addEventListener('click', () => this.testConnection());
        }
        // API key validation
        if (this.apiKeyInput) {
            this.apiKeyInput.addEventListener('input', () => this.validateApiKey());
        }
    }
    /**
     * Validate API key format
     */
    validateApiKey() {
        if (!this.apiKeyInput)
            return;
        const apiKey = this.apiKeyInput.value;
        const isValid = apiKey.length > 20 && /^[a-f0-9-]+$/i.test(apiKey);
        if (apiKey && !isValid) {
            this.apiKeyInput.style.borderColor = 'var(--vscode-inputValidation-errorBorder)';
        }
        else {
            this.apiKeyInput.style.borderColor = '';
        }
    }
    /**
     * Update configuration in store
     */
    updateConfiguration() {
        if (!this.apiKeyInput || !this.environmentInput || !this.indexNameInput)
            return;
        const config = {
            apiKey: this.apiKeyInput.value,
            environment: this.environmentInput.value,
            indexName: this.indexNameInput.value
        };
        setupStore_1.setupActions.setDatabaseConfig(config);
    }
    /**
     * Test Pinecone connection
     */
    async testConnection() {
        if (!this.testButton || !this.statusElement)
            return;
        const config = this.getConfiguration();
        // Validate required fields
        if (!config.apiKey || !config.environment) {
            this.updateStatus('error', 'API key and environment are required');
            return;
        }
        // Update UI to show testing state
        this.testButton.disabled = true;
        this.testButton.textContent = 'Testing...';
        this.updateStatus('testing', 'Testing connection...');
        try {
            // Test connection by listing indexes
            const response = await fetch(`https://controller.${config.environment}.pinecone.io/databases`, {
                method: 'GET',
                headers: {
                    'Api-Key': config.apiKey,
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(10000) // 10 second timeout
            });
            if (response.ok) {
                const data = await response.json();
                this.updateStatus('success', 'Connection successful!');
                setupStore_1.setupActions.updateDatabaseStatus('running');
                // Check if index exists
                if (config.indexName && Array.isArray(data)) {
                    const indexExists = data.some((index) => index.name === config.indexName);
                    if (indexExists) {
                        this.updateStatus('success', 'Connection successful! Index found.');
                    }
                    else {
                        this.updateStatus('success', 'Connection successful! Index will be created.');
                    }
                }
            }
            else if (response.status === 401) {
                this.updateStatus('error', 'Invalid API key');
            }
            else if (response.status === 403) {
                this.updateStatus('error', 'Access denied - check your API key permissions');
            }
            else {
                this.updateStatus('error', `Connection failed: ${response.status} ${response.statusText}`);
            }
        }
        catch (error) {
            console.error('Pinecone connection test failed:', error);
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    this.updateStatus('error', 'Connection timeout - check your environment');
                }
                else if (error.message.includes('Failed to fetch')) {
                    this.updateStatus('error', 'Network error - check your internet connection');
                }
                else {
                    this.updateStatus('error', `Connection error: ${error.message}`);
                }
            }
            else {
                this.updateStatus('error', 'Unknown connection error');
            }
        }
        finally {
            // Reset button state
            this.testButton.disabled = false;
            this.testButton.textContent = 'Test Connection';
        }
    }
    /**
     * Update connection status display
     */
    updateStatus(type, message) {
        if (!this.statusElement)
            return;
        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');
        if (statusDot && statusText) {
            // Remove all status classes
            statusDot.className = 'status-dot';
            statusDot.classList.add(type);
            statusText.textContent = message;
        }
    }
    /**
     * Get current configuration
     */
    getConfiguration() {
        return {
            apiKey: this.apiKeyInput?.value || '',
            environment: this.environmentInput?.value || '',
            indexName: this.indexNameInput?.value || ''
        };
    }
    /**
     * Load configuration from external source
     */
    loadConfiguration(config) {
        if (this.apiKeyInput)
            this.apiKeyInput.value = config.apiKey;
        if (this.environmentInput)
            this.environmentInput.value = config.environment;
        if (this.indexNameInput)
            this.indexNameInput.value = config.indexName;
        this.updateConfiguration();
    }
    /**
     * Validate configuration
     */
    validateConfiguration() {
        const errors = [];
        const config = this.getConfiguration();
        if (!config.apiKey || config.apiKey.trim() === '') {
            errors.push('API key is required');
        }
        else if (config.apiKey.length < 20) {
            errors.push('API key appears to be invalid (too short)');
        }
        if (!config.environment || config.environment.trim() === '') {
            errors.push('Environment is required');
        }
        if (!config.indexName || config.indexName.trim() === '') {
            errors.push('Index name is required');
        }
        else if (!/^[a-z0-9-]+$/.test(config.indexName)) {
            errors.push('Index name must contain only lowercase letters, numbers, and hyphens');
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    /**
     * Cleanup component
     */
    dispose() {
        // Remove event listeners if needed
    }
}
exports.PineconeConfigComponent = PineconeConfigComponent;
// CSS styles for Pinecone configuration
exports.pineconeConfigStyles = `
.pinecone-config {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.pinecone-config h4 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.config-description {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
    line-height: 1.4;
}

.config-description a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.config-description a:hover {
    text-decoration: underline;
}

.config-grid {
    display: grid;
    gap: 15px;
    margin-bottom: 15px;
}

.config-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.config-item label {
    font-weight: 500;
    color: var(--vscode-foreground);
    font-size: 13px;
}

.config-item input {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item input:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.config-item small {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.config-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.test-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.unknown {
    background-color: var(--vscode-charts-gray);
}

.status-dot.testing {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.success {
    background-color: var(--vscode-charts-green);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 12px;
    color: var(--vscode-foreground);
}

.config-info {
    border-top: 1px solid var(--vscode-panel-border);
    padding-top: 15px;
    margin-top: 15px;
}

.info-section {
    margin-bottom: 15px;
}

.info-section h5 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.info-section p {
    margin: 0 0 6px 0;
    color: var(--vscode-foreground);
    font-size: 12px;
    line-height: 1.4;
}

.info-section ol,
.info-section ul {
    margin: 6px 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
    font-size: 12px;
}

.info-section li {
    margin-bottom: 3px;
    line-height: 1.3;
}

.info-section code {
    padding: 2px 4px;
    background-color: var(--vscode-textCodeBlock-background);
    border: 1px solid var(--vscode-panel-border);
    border-radius: 2px;
    font-family: var(--vscode-editor-font-family);
    font-size: 11px;
    color: var(--vscode-textPreformat-foreground);
}

.info-section a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.info-section a:hover {
    text-decoration: underline;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
//# sourceMappingURL=PineconeConfig.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/components/PineconeConfig.js.map">
{"version":3,"file":"PineconeConfig.js","sourceRoot":"","sources":["PineconeConfig.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/components/PineconeConfig.ts">
/**
 * PineconeConfig Component
 * 
 * Handles Pinecone-specific configuration including API key, environment,
 * and index management for cloud-based vector database.
 */

import { setupActions, PineconeConfig } from '../stores/setupStore';

export class PineconeConfigComponent {
    private container: HTMLElement;
    private apiKeyInput: HTMLInputElement | null = null;
    private environmentInput: HTMLInputElement | null = null;
    private indexNameInput: HTMLInputElement | null = null;
    private testButton: HTMLButtonElement | null = null;
    private statusElement: HTMLElement | null = null;

    constructor(container: HTMLElement) {
        this.container = container;
        this.render();
        this.setupEventListeners();
    }

    /**
     * Render the Pinecone configuration UI
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="pinecone-config">
                <h4>Pinecone Configuration</h4>
                <p class="config-description">
                    Configure your Pinecone cloud vector database. You'll need a Pinecone account and API key.
                    <a href="https://www.pinecone.io/" target="_blank" rel="noopener">Sign up for Pinecone</a>
                </p>

                <div class="config-grid">
                    <div class="config-item">
                        <label for="pinecone-api-key">API Key:</label>
                        <input type="password" id="pinecone-api-key" placeholder="Enter your Pinecone API key">
                        <small>Your Pinecone API key (stored securely in VS Code)</small>
                    </div>

                    <div class="config-item">
                        <label for="pinecone-environment">Environment:</label>
                        <input type="text" id="pinecone-environment" placeholder="e.g., us-east-1-aws">
                        <small>Your Pinecone environment (found in Pinecone console)</small>
                    </div>

                    <div class="config-item">
                        <label for="pinecone-index-name">Index Name:</label>
                        <input type="text" id="pinecone-index-name" placeholder="e.g., code-context-index">
                        <small>Name for your vector index (will be created if it doesn't exist)</small>
                    </div>
                </div>

                <div class="config-actions">
                    <button id="test-pinecone-connection" class="test-button">Test Connection</button>
                    <div id="pinecone-status" class="connection-status">
                        <span class="status-dot unknown"></span>
                        <span class="status-text">Not tested</span>
                    </div>
                </div>

                <div class="config-info">
                    <div class="info-section">
                        <h5> Getting Your API Key</h5>
                        <ol>
                            <li>Sign up at <a href="https://www.pinecone.io/" target="_blank">pinecone.io</a></li>
                            <li>Go to your Pinecone console</li>
                            <li>Navigate to "API Keys" section</li>
                            <li>Copy your API key</li>
                        </ol>
                    </div>
                    
                    <div class="info-section">
                        <h5> Finding Your Environment</h5>
                        <p>Your environment is shown in the Pinecone console URL or dashboard. Common environments:</p>
                        <ul>
                            <li><code>us-east-1-aws</code> (US East)</li>
                            <li><code>us-west-2-aws</code> (US West)</li>
                            <li><code>eu-west-1-aws</code> (Europe)</li>
                        </ul>
                    </div>

                    <div class="info-section">
                        <h5> Index Configuration</h5>
                        <p>The index will be created automatically with these settings:</p>
                        <ul>
                            <li><strong>Dimension:</strong> Based on your embedding model</li>
                            <li><strong>Metric:</strong> Cosine similarity</li>
                            <li><strong>Pod Type:</strong> Starter (free tier)</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;

        // Get references to elements
        this.apiKeyInput = this.container.querySelector('#pinecone-api-key') as HTMLInputElement;
        this.environmentInput = this.container.querySelector('#pinecone-environment') as HTMLInputElement;
        this.indexNameInput = this.container.querySelector('#pinecone-index-name') as HTMLInputElement;
        this.testButton = this.container.querySelector('#test-pinecone-connection') as HTMLButtonElement;
        this.statusElement = this.container.querySelector('#pinecone-status') as HTMLElement;
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        // Update configuration when inputs change
        [this.apiKeyInput, this.environmentInput, this.indexNameInput].forEach(input => {
            if (input) {
                input.addEventListener('input', () => this.updateConfiguration());
                input.addEventListener('change', () => this.updateConfiguration());
            }
        });

        // Test connection button
        if (this.testButton) {
            this.testButton.addEventListener('click', () => this.testConnection());
        }

        // API key validation
        if (this.apiKeyInput) {
            this.apiKeyInput.addEventListener('input', () => this.validateApiKey());
        }
    }

    /**
     * Validate API key format
     */
    private validateApiKey(): void {
        if (!this.apiKeyInput) return;

        const apiKey = this.apiKeyInput.value;
        const isValid = apiKey.length > 20 && /^[a-f0-9-]+$/i.test(apiKey);
        
        if (apiKey && !isValid) {
            this.apiKeyInput.style.borderColor = 'var(--vscode-inputValidation-errorBorder)';
        } else {
            this.apiKeyInput.style.borderColor = '';
        }
    }

    /**
     * Update configuration in store
     */
    private updateConfiguration(): void {
        if (!this.apiKeyInput || !this.environmentInput || !this.indexNameInput) return;

        const config: PineconeConfig = {
            apiKey: this.apiKeyInput.value,
            environment: this.environmentInput.value,
            indexName: this.indexNameInput.value
        };

        setupActions.setDatabaseConfig(config);
    }

    /**
     * Test Pinecone connection
     */
    private async testConnection(): Promise<void> {
        if (!this.testButton || !this.statusElement) return;

        const config = this.getConfiguration();
        
        // Validate required fields
        if (!config.apiKey || !config.environment) {
            this.updateStatus('error', 'API key and environment are required');
            return;
        }

        // Update UI to show testing state
        this.testButton.disabled = true;
        this.testButton.textContent = 'Testing...';
        this.updateStatus('testing', 'Testing connection...');

        try {
            // Test connection by listing indexes
            const response = await fetch(`https://controller.${config.environment}.pinecone.io/databases`, {
                method: 'GET',
                headers: {
                    'Api-Key': config.apiKey,
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(10000) // 10 second timeout
            });

            if (response.ok) {
                const data = await response.json();
                this.updateStatus('success', 'Connection successful!');
                setupActions.updateDatabaseStatus('running');
                
                // Check if index exists
                if (config.indexName && Array.isArray(data)) {
                    const indexExists = data.some((index: any) => index.name === config.indexName);
                    if (indexExists) {
                        this.updateStatus('success', 'Connection successful! Index found.');
                    } else {
                        this.updateStatus('success', 'Connection successful! Index will be created.');
                    }
                }
            } else if (response.status === 401) {
                this.updateStatus('error', 'Invalid API key');
            } else if (response.status === 403) {
                this.updateStatus('error', 'Access denied - check your API key permissions');
            } else {
                this.updateStatus('error', `Connection failed: ${response.status} ${response.statusText}`);
            }

        } catch (error) {
            console.error('Pinecone connection test failed:', error);
            
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    this.updateStatus('error', 'Connection timeout - check your environment');
                } else if (error.message.includes('Failed to fetch')) {
                    this.updateStatus('error', 'Network error - check your internet connection');
                } else {
                    this.updateStatus('error', `Connection error: ${error.message}`);
                }
            } else {
                this.updateStatus('error', 'Unknown connection error');
            }
        } finally {
            // Reset button state
            this.testButton.disabled = false;
            this.testButton.textContent = 'Test Connection';
        }
    }

    /**
     * Update connection status display
     */
    private updateStatus(type: 'testing' | 'success' | 'error' | 'unknown', message: string): void {
        if (!this.statusElement) return;

        const statusDot = this.statusElement.querySelector('.status-dot');
        const statusText = this.statusElement.querySelector('.status-text');

        if (statusDot && statusText) {
            // Remove all status classes
            statusDot.className = 'status-dot';
            statusDot.classList.add(type);
            statusText.textContent = message;
        }
    }

    /**
     * Get current configuration
     */
    private getConfiguration(): PineconeConfig {
        return {
            apiKey: this.apiKeyInput?.value || '',
            environment: this.environmentInput?.value || '',
            indexName: this.indexNameInput?.value || ''
        };
    }

    /**
     * Load configuration from external source
     */
    public loadConfiguration(config: PineconeConfig): void {
        if (this.apiKeyInput) this.apiKeyInput.value = config.apiKey;
        if (this.environmentInput) this.environmentInput.value = config.environment;
        if (this.indexNameInput) this.indexNameInput.value = config.indexName;
        
        this.updateConfiguration();
    }

    /**
     * Validate configuration
     */
    public validateConfiguration(): { isValid: boolean; errors: string[] } {
        const errors: string[] = [];
        const config = this.getConfiguration();

        if (!config.apiKey || config.apiKey.trim() === '') {
            errors.push('API key is required');
        } else if (config.apiKey.length < 20) {
            errors.push('API key appears to be invalid (too short)');
        }

        if (!config.environment || config.environment.trim() === '') {
            errors.push('Environment is required');
        }

        if (!config.indexName || config.indexName.trim() === '') {
            errors.push('Index name is required');
        } else if (!/^[a-z0-9-]+$/.test(config.indexName)) {
            errors.push('Index name must contain only lowercase letters, numbers, and hyphens');
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        // Remove event listeners if needed
    }
}

// CSS styles for Pinecone configuration
export const pineconeConfigStyles = `
.pinecone-config {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    background-color: var(--vscode-editor-background);
}

.pinecone-config h4 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.config-description {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 13px;
    line-height: 1.4;
}

.config-description a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.config-description a:hover {
    text-decoration: underline;
}

.config-grid {
    display: grid;
    gap: 15px;
    margin-bottom: 15px;
}

.config-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.config-item label {
    font-weight: 500;
    color: var(--vscode-foreground);
    font-size: 13px;
}

.config-item input {
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    border-radius: 3px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    font-family: inherit;
    font-size: 13px;
}

.config-item input:focus {
    outline: none;
    border-color: var(--vscode-focusBorder);
}

.config-item small {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
}

.config-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.test-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
}

.test-button:hover:not(:disabled) {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.test-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.status-dot.unknown {
    background-color: var(--vscode-charts-gray);
}

.status-dot.testing {
    background-color: var(--vscode-charts-yellow);
    animation: pulse 1.5s infinite;
}

.status-dot.success {
    background-color: var(--vscode-charts-green);
}

.status-dot.error {
    background-color: var(--vscode-charts-red);
}

.status-text {
    font-size: 12px;
    color: var(--vscode-foreground);
}

.config-info {
    border-top: 1px solid var(--vscode-panel-border);
    padding-top: 15px;
    margin-top: 15px;
}

.info-section {
    margin-bottom: 15px;
}

.info-section h5 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.info-section p {
    margin: 0 0 6px 0;
    color: var(--vscode-foreground);
    font-size: 12px;
    line-height: 1.4;
}

.info-section ol,
.info-section ul {
    margin: 6px 0;
    padding-left: 20px;
    color: var(--vscode-foreground);
    font-size: 12px;
}

.info-section li {
    margin-bottom: 3px;
    line-height: 1.3;
}

.info-section code {
    padding: 2px 4px;
    background-color: var(--vscode-textCodeBlock-background);
    border: 1px solid var(--vscode-panel-border);
    border-radius: 2px;
    font-family: var(--vscode-editor-font-family);
    font-size: 11px;
    color: var(--vscode-textPreformat-foreground);
}

.info-section a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

.info-section a:hover {
    text-decoration: underline;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/components/SystemValidation.js">
"use strict";
/**
 * SystemValidation Component
 *
 * Displays system validation results and provides access to troubleshooting guides.
 * Shows pre-flight checks, system requirements, and interactive problem resolution.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.systemValidationStyles = exports.SystemValidationComponent = void 0;
const vscodeApi_1 = require("../vscodeApi");
class SystemValidationComponent {
    constructor(container) {
        this.runValidationButton = null;
        this.validationResults = null;
        this.troubleshootingSection = null;
        this.currentReport = null;
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.setupMessageHandlers();
    }
    /**
     * Render the system validation UI
     */
    render() {
        this.container.innerHTML = `
            <div class="system-validation">
                <div class="validation-header">
                    <h3>System Validation</h3>
                    <p>Check your system for compatibility and resolve any issues before setup.</p>
                    <button id="run-validation" class="validation-button">
                        <span class="button-icon"></span>
                        Run System Check
                    </button>
                </div>

                <div id="validation-results" class="validation-results hidden">
                    <!-- Validation results will be inserted here -->
                </div>

                <div id="troubleshooting-section" class="troubleshooting-section hidden">
                    <h4>Recommended Troubleshooting Guides</h4>
                    <div id="troubleshooting-guides" class="troubleshooting-guides">
                        <!-- Troubleshooting guides will be inserted here -->
                    </div>
                </div>

                <div class="validation-info">
                    <h4>What We Check</h4>
                    <div class="check-categories">
                        <div class="check-category">
                            <h5> Docker</h5>
                            <ul>
                                <li>Docker installation and version</li>
                                <li>Docker daemon status</li>
                                <li>Container runtime availability</li>
                            </ul>
                        </div>
                        <div class="check-category">
                            <h5> Network</h5>
                            <ul>
                                <li>Internet connectivity</li>
                                <li>API endpoint accessibility</li>
                                <li>Proxy and firewall settings</li>
                            </ul>
                        </div>
                        <div class="check-category">
                            <h5> System</h5>
                            <ul>
                                <li>Available memory and disk space</li>
                                <li>Node.js version compatibility</li>
                                <li>Operating system requirements</li>
                            </ul>
                        </div>
                        <div class="check-category">
                            <h5> Ports</h5>
                            <ul>
                                <li>Port availability for services</li>
                                <li>Conflict detection and resolution</li>
                                <li>Service binding capabilities</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        `;
        // Get references to elements
        this.runValidationButton = this.container.querySelector('#run-validation');
        this.validationResults = this.container.querySelector('#validation-results');
        this.troubleshootingSection = this.container.querySelector('#troubleshooting-section');
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        if (this.runValidationButton) {
            this.runValidationButton.addEventListener('click', () => {
                this.runSystemValidation();
            });
        }
    }
    /**
     * Set up message handlers for extension communication
     */
    setupMessageHandlers() {
        vscodeApi_1.vscodeApi.onMessage('validationResults', (event) => {
            this.displayValidationResults(event.data);
        });
        vscodeApi_1.vscodeApi.onMessage('troubleshootingGuides', (event) => {
            this.displayTroubleshootingGuides(event.data);
        });
    }
    /**
     * Run system validation
     */
    async runSystemValidation() {
        if (!this.runValidationButton)
            return;
        // Update button state
        this.runValidationButton.disabled = true;
        this.runValidationButton.innerHTML = '<span class="button-icon"></span> Running Checks...';
        // Hide previous results
        if (this.validationResults) {
            this.validationResults.classList.add('hidden');
        }
        if (this.troubleshootingSection) {
            this.troubleshootingSection.classList.add('hidden');
        }
        try {
            // Send validation request to extension
            vscodeApi_1.vscodeApi.postMessage({
                command: 'runSystemValidation'
            });
        }
        catch (error) {
            console.error('Failed to run system validation:', error);
            this.showError('Failed to run system validation. Please try again.');
        }
        finally {
            // Reset button state
            this.runValidationButton.disabled = false;
            this.runValidationButton.innerHTML = '<span class="button-icon"></span> Run System Check';
        }
    }
    /**
     * Display validation results
     */
    displayValidationResults(report) {
        if (!this.validationResults)
            return;
        this.currentReport = report;
        // Create results HTML
        const resultsHTML = `
            <div class="validation-summary">
                <div class="summary-header">
                    <h4>Validation Results</h4>
                    <div class="overall-status ${report.overallStatus}">
                        ${this.getStatusIcon(report.overallStatus)} ${this.getStatusText(report.overallStatus)}
                    </div>
                </div>
                <div class="summary-stats">
                    <div class="stat passed">
                        <span class="stat-number">${report.summary.passed}</span>
                        <span class="stat-label">Passed</span>
                    </div>
                    <div class="stat warnings">
                        <span class="stat-number">${report.summary.warnings}</span>
                        <span class="stat-label">Warnings</span>
                    </div>
                    <div class="stat failed">
                        <span class="stat-number">${report.summary.failed}</span>
                        <span class="stat-label">Failed</span>
                    </div>
                </div>
            </div>

            <div class="validation-details">
                ${this.renderValidationDetails(report.results)}
            </div>
        `;
        this.validationResults.innerHTML = resultsHTML;
        this.validationResults.classList.remove('hidden');
        // Set up event listeners for auto-fix buttons
        this.setupAutoFixListeners();
        // Request troubleshooting guides if there are issues
        if (report.summary.warnings > 0 || report.summary.failed > 0) {
            vscodeApi_1.vscodeApi.postMessage({
                command: 'getTroubleshootingGuides',
                validationResults: report.results
            });
        }
    }
    /**
     * Render validation details
     */
    renderValidationDetails(results) {
        const categories = this.groupResultsByCategory(results);
        return Object.entries(categories).map(([category, categoryResults]) => `
            <div class="category-section">
                <h5>${this.getCategoryIcon(category)} ${this.getCategoryTitle(category)}</h5>
                <div class="category-results">
                    ${categoryResults.map(result => this.renderValidationResult(result)).join('')}
                </div>
            </div>
        `).join('');
    }
    /**
     * Render individual validation result
     */
    renderValidationResult(result) {
        return `
            <div class="validation-result ${result.status}">
                <div class="result-header">
                    <span class="result-icon">${this.getStatusIcon(result.status)}</span>
                    <span class="result-check">${result.check}</span>
                    <span class="result-status">${result.status.toUpperCase()}</span>
                </div>
                <div class="result-message">${result.message}</div>
                ${result.details ? `<div class="result-details">${result.details}</div>` : ''}
                ${result.fixSuggestion ? `
                    <div class="result-fix">
                        <span class="fix-label"> Suggestion:</span>
                        <span class="fix-text">${result.fixSuggestion}</span>
                        ${result.autoFixAvailable ? `
                            <button class="auto-fix-button" data-check="${result.check}">
                                Auto Fix
                            </button>
                        ` : ''}
                    </div>
                ` : ''}
            </div>
        `;
    }
    /**
     * Display troubleshooting guides
     */
    displayTroubleshootingGuides(guides) {
        if (!this.troubleshootingSection || guides.length === 0)
            return;
        const guidesContainer = this.troubleshootingSection.querySelector('#troubleshooting-guides');
        if (!guidesContainer)
            return;
        const guidesHTML = guides.map(guide => `
            <div class="troubleshooting-guide ${guide.severity}">
                <div class="guide-header">
                    <h6>${guide.title}</h6>
                    <div class="guide-meta">
                        <span class="guide-severity ${guide.severity}">${guide.severity.toUpperCase()}</span>
                        <span class="guide-time"> ${guide.estimatedTime}</span>
                    </div>
                </div>
                <div class="guide-description">${guide.description}</div>
                <button class="guide-button" data-guide-id="${guide.id}">
                    Start Guide
                </button>
            </div>
        `).join('');
        guidesContainer.innerHTML = guidesHTML;
        this.troubleshootingSection.classList.remove('hidden');
        // Set up event listeners for guide buttons
        this.setupGuideListeners();
    }
    /**
     * Set up auto-fix button listeners
     */
    setupAutoFixListeners() {
        const autoFixButtons = this.validationResults?.querySelectorAll('.auto-fix-button');
        autoFixButtons?.forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.target;
                const check = target.dataset.check;
                if (check) {
                    this.runAutoFix(check);
                }
            });
        });
    }
    /**
     * Set up troubleshooting guide button listeners
     */
    setupGuideListeners() {
        const guideButtons = this.troubleshootingSection?.querySelectorAll('.guide-button');
        guideButtons?.forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.target;
                const guideId = target.dataset.guideId;
                if (guideId) {
                    this.openTroubleshootingGuide(guideId);
                }
            });
        });
    }
    /**
     * Run auto-fix for a specific check
     */
    async runAutoFix(check) {
        vscodeApi_1.vscodeApi.postMessage({
            command: 'runAutoFix',
            check: check
        });
    }
    /**
     * Open troubleshooting guide
     */
    openTroubleshootingGuide(guideId) {
        vscodeApi_1.vscodeApi.postMessage({
            command: 'openTroubleshootingGuide',
            guideId: guideId
        });
    }
    /**
     * Helper methods
     */
    groupResultsByCategory(results) {
        return results.reduce((groups, result) => {
            if (!groups[result.category]) {
                groups[result.category] = [];
            }
            groups[result.category].push(result);
            return groups;
        }, {});
    }
    getStatusIcon(status) {
        switch (status) {
            case 'pass': return '';
            case 'warning': return '';
            case 'fail': return '';
            default: return '';
        }
    }
    getStatusText(status) {
        switch (status) {
            case 'pass': return 'All Checks Passed';
            case 'warning': return 'Issues Found';
            case 'fail': return 'Critical Issues';
            default: return 'Unknown Status';
        }
    }
    getCategoryIcon(category) {
        switch (category) {
            case 'docker': return '';
            case 'network': return '';
            case 'system': return '';
            case 'ports': return '';
            default: return '';
        }
    }
    getCategoryTitle(category) {
        switch (category) {
            case 'docker': return 'Docker';
            case 'network': return 'Network';
            case 'system': return 'System';
            case 'ports': return 'Ports';
            default: return category.charAt(0).toUpperCase() + category.slice(1);
        }
    }
    showError(message) {
        if (this.validationResults) {
            this.validationResults.innerHTML = `
                <div class="validation-error">
                    <span class="error-icon"></span>
                    <span class="error-message">${message}</span>
                </div>
            `;
            this.validationResults.classList.remove('hidden');
        }
    }
    /**
     * Cleanup component
     */
    dispose() {
        // Remove event listeners if needed
    }
}
exports.SystemValidationComponent = SystemValidationComponent;
// CSS styles for SystemValidation component
exports.systemValidationStyles = `
.system-validation {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    margin-bottom: 20px;
    background-color: var(--vscode-sideBar-background);
}

.validation-header {
    text-align: center;
    margin-bottom: 20px;
}

.validation-header h3 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.validation-header p {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 14px;
}

.validation-button {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.validation-button:hover:not(:disabled) {
    background-color: var(--vscode-button-hoverBackground);
}

.validation-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.validation-results {
    margin-bottom: 20px;
}

.validation-results.hidden,
.troubleshooting-section.hidden {
    display: none;
}

.validation-summary {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    margin-bottom: 15px;
    background-color: var(--vscode-editor-background);
}

.summary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.summary-header h4 {
    margin: 0;
    color: var(--vscode-textLink-foreground);
}

.overall-status {
    padding: 6px 12px;
    border-radius: 4px;
    font-weight: 500;
    font-size: 13px;
}

.overall-status.pass {
    background-color: var(--vscode-charts-green);
    color: white;
}

.overall-status.warning {
    background-color: var(--vscode-charts-orange);
    color: white;
}

.overall-status.fail {
    background-color: var(--vscode-charts-red);
    color: white;
}

.summary-stats {
    display: flex;
    gap: 20px;
    justify-content: center;
}

.stat {
    text-align: center;
}

.stat-number {
    display: block;
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 4px;
}

.stat.passed .stat-number {
    color: var(--vscode-charts-green);
}

.stat.warnings .stat-number {
    color: var(--vscode-charts-orange);
}

.stat.failed .stat-number {
    color: var(--vscode-charts-red);
}

.stat-label {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
}

.category-section {
    margin-bottom: 20px;
}

.category-section h5 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
    padding-bottom: 5px;
    border-bottom: 1px solid var(--vscode-panel-border);
}

.validation-result {
    padding: 12px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    margin-bottom: 8px;
    background-color: var(--vscode-editor-background);
}

.validation-result.pass {
    border-left: 3px solid var(--vscode-charts-green);
}

.validation-result.warning {
    border-left: 3px solid var(--vscode-charts-orange);
}

.validation-result.fail {
    border-left: 3px solid var(--vscode-charts-red);
}

.result-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
}

.result-check {
    flex: 1;
    font-weight: 500;
    color: var(--vscode-foreground);
}

.result-status {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 2px;
    background-color: var(--vscode-badge-background);
    color: var(--vscode-badge-foreground);
}

.result-message {
    color: var(--vscode-foreground);
    font-size: 13px;
    margin-bottom: 4px;
}

.result-details {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
    font-family: var(--vscode-editor-font-family);
    margin-bottom: 8px;
}

.result-fix {
    padding: 8px;
    background-color: var(--vscode-textCodeBlock-background);
    border-radius: 3px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.fix-label {
    font-weight: 500;
    color: var(--vscode-textLink-foreground);
}

.fix-text {
    flex: 1;
    color: var(--vscode-foreground);
}

.auto-fix-button {
    padding: 4px 8px;
    border: 1px solid var(--vscode-button-border);
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-size: 11px;
    cursor: pointer;
}

.auto-fix-button:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.troubleshooting-section {
    margin-top: 20px;
}

.troubleshooting-section h4 {
    margin: 0 0 15px 0;
    color: var(--vscode-textLink-foreground);
}

.troubleshooting-guide {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    margin-bottom: 10px;
    background-color: var(--vscode-editor-background);
}

.troubleshooting-guide.critical {
    border-left: 3px solid var(--vscode-charts-red);
}

.troubleshooting-guide.high {
    border-left: 3px solid var(--vscode-charts-orange);
}

.troubleshooting-guide.medium {
    border-left: 3px solid var(--vscode-charts-yellow);
}

.troubleshooting-guide.low {
    border-left: 3px solid var(--vscode-charts-blue);
}

.guide-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
}

.guide-header h6 {
    margin: 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.guide-meta {
    display: flex;
    gap: 8px;
    align-items: center;
}

.guide-severity {
    font-size: 10px;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
}

.guide-severity.critical {
    background-color: var(--vscode-charts-red);
    color: white;
}

.guide-severity.high {
    background-color: var(--vscode-charts-orange);
    color: white;
}

.guide-severity.medium {
    background-color: var(--vscode-charts-yellow);
    color: black;
}

.guide-severity.low {
    background-color: var(--vscode-charts-blue);
    color: white;
}

.guide-time {
    font-size: 11px;
    color: var(--vscode-descriptionForeground);
}

.guide-description {
    color: var(--vscode-foreground);
    font-size: 13px;
    margin-bottom: 10px;
}

.guide-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-size: 12px;
    cursor: pointer;
}

.guide-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.validation-info {
    margin-top: 20px;
    padding: 15px;
    background-color: var(--vscode-textCodeBlock-background);
    border-radius: 4px;
}

.validation-info h4 {
    margin: 0 0 15px 0;
    color: var(--vscode-textLink-foreground);
}

.check-categories {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.check-category h5 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.check-category ul {
    margin: 0;
    padding-left: 16px;
    color: var(--vscode-foreground);
}

.check-category li {
    font-size: 12px;
    margin-bottom: 3px;
}

.validation-error {
    padding: 15px;
    border: 1px solid var(--vscode-inputValidation-errorBorder);
    border-radius: 4px;
    background-color: var(--vscode-inputValidation-errorBackground);
    color: var(--vscode-inputValidation-errorForeground);
    display: flex;
    align-items: center;
    gap: 8px;
}
`;
//# sourceMappingURL=SystemValidation.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/components/SystemValidation.js.map">
{"version":3,"file":"SystemValidation.js","sourceRoot":"","sources":["SystemValidation.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/components/SystemValidation.ts">
/**
 * SystemValidation Component
 * 
 * Displays system validation results and provides access to troubleshooting guides.
 * Shows pre-flight checks, system requirements, and interactive problem resolution.
 */

import { vscodeApi } from '../vscodeApi';

export interface ValidationResult {
    isValid: boolean;
    category: 'docker' | 'network' | 'system' | 'ports';
    check: string;
    status: 'pass' | 'fail' | 'warning';
    message: string;
    details?: string;
    fixSuggestion?: string;
    autoFixAvailable?: boolean;
}

export interface SystemValidationReport {
    overallStatus: 'pass' | 'warning' | 'fail';
    results: ValidationResult[];
    summary: {
        passed: number;
        warnings: number;
        failed: number;
    };
}

export interface TroubleshootingGuide {
    id: string;
    title: string;
    description: string;
    category: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    estimatedTime: string;
}

export class SystemValidationComponent {
    private container: HTMLElement;
    private runValidationButton: HTMLButtonElement | null = null;
    private validationResults: HTMLElement | null = null;
    private troubleshootingSection: HTMLElement | null = null;
    private currentReport: SystemValidationReport | null = null;

    constructor(container: HTMLElement) {
        this.container = container;
        this.render();
        this.setupEventListeners();
        this.setupMessageHandlers();
    }

    /**
     * Render the system validation UI
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="system-validation">
                <div class="validation-header">
                    <h3>System Validation</h3>
                    <p>Check your system for compatibility and resolve any issues before setup.</p>
                    <button id="run-validation" class="validation-button">
                        <span class="button-icon"></span>
                        Run System Check
                    </button>
                </div>

                <div id="validation-results" class="validation-results hidden">
                    <!-- Validation results will be inserted here -->
                </div>

                <div id="troubleshooting-section" class="troubleshooting-section hidden">
                    <h4>Recommended Troubleshooting Guides</h4>
                    <div id="troubleshooting-guides" class="troubleshooting-guides">
                        <!-- Troubleshooting guides will be inserted here -->
                    </div>
                </div>

                <div class="validation-info">
                    <h4>What We Check</h4>
                    <div class="check-categories">
                        <div class="check-category">
                            <h5> Docker</h5>
                            <ul>
                                <li>Docker installation and version</li>
                                <li>Docker daemon status</li>
                                <li>Container runtime availability</li>
                            </ul>
                        </div>
                        <div class="check-category">
                            <h5> Network</h5>
                            <ul>
                                <li>Internet connectivity</li>
                                <li>API endpoint accessibility</li>
                                <li>Proxy and firewall settings</li>
                            </ul>
                        </div>
                        <div class="check-category">
                            <h5> System</h5>
                            <ul>
                                <li>Available memory and disk space</li>
                                <li>Node.js version compatibility</li>
                                <li>Operating system requirements</li>
                            </ul>
                        </div>
                        <div class="check-category">
                            <h5> Ports</h5>
                            <ul>
                                <li>Port availability for services</li>
                                <li>Conflict detection and resolution</li>
                                <li>Service binding capabilities</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Get references to elements
        this.runValidationButton = this.container.querySelector('#run-validation') as HTMLButtonElement;
        this.validationResults = this.container.querySelector('#validation-results') as HTMLElement;
        this.troubleshootingSection = this.container.querySelector('#troubleshooting-section') as HTMLElement;
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        if (this.runValidationButton) {
            this.runValidationButton.addEventListener('click', () => {
                this.runSystemValidation();
            });
        }
    }

    /**
     * Set up message handlers for extension communication
     */
    private setupMessageHandlers(): void {
        vscodeApi.onMessage('validationResults', (event) => {
            this.displayValidationResults(event.data);
        });

        vscodeApi.onMessage('troubleshootingGuides', (event) => {
            this.displayTroubleshootingGuides(event.data);
        });
    }

    /**
     * Run system validation
     */
    private async runSystemValidation(): Promise<void> {
        if (!this.runValidationButton) return;

        // Update button state
        this.runValidationButton.disabled = true;
        this.runValidationButton.innerHTML = '<span class="button-icon"></span> Running Checks...';

        // Hide previous results
        if (this.validationResults) {
            this.validationResults.classList.add('hidden');
        }
        if (this.troubleshootingSection) {
            this.troubleshootingSection.classList.add('hidden');
        }

        try {
            // Send validation request to extension
            vscodeApi.postMessage({
                command: 'runSystemValidation'
            });

        } catch (error) {
            console.error('Failed to run system validation:', error);
            this.showError('Failed to run system validation. Please try again.');
        } finally {
            // Reset button state
            this.runValidationButton.disabled = false;
            this.runValidationButton.innerHTML = '<span class="button-icon"></span> Run System Check';
        }
    }

    /**
     * Display validation results
     */
    private displayValidationResults(report: SystemValidationReport): void {
        if (!this.validationResults) return;

        this.currentReport = report;

        // Create results HTML
        const resultsHTML = `
            <div class="validation-summary">
                <div class="summary-header">
                    <h4>Validation Results</h4>
                    <div class="overall-status ${report.overallStatus}">
                        ${this.getStatusIcon(report.overallStatus)} ${this.getStatusText(report.overallStatus)}
                    </div>
                </div>
                <div class="summary-stats">
                    <div class="stat passed">
                        <span class="stat-number">${report.summary.passed}</span>
                        <span class="stat-label">Passed</span>
                    </div>
                    <div class="stat warnings">
                        <span class="stat-number">${report.summary.warnings}</span>
                        <span class="stat-label">Warnings</span>
                    </div>
                    <div class="stat failed">
                        <span class="stat-number">${report.summary.failed}</span>
                        <span class="stat-label">Failed</span>
                    </div>
                </div>
            </div>

            <div class="validation-details">
                ${this.renderValidationDetails(report.results)}
            </div>
        `;

        this.validationResults.innerHTML = resultsHTML;
        this.validationResults.classList.remove('hidden');

        // Set up event listeners for auto-fix buttons
        this.setupAutoFixListeners();

        // Request troubleshooting guides if there are issues
        if (report.summary.warnings > 0 || report.summary.failed > 0) {
            vscodeApi.postMessage({
                command: 'getTroubleshootingGuides',
                validationResults: report.results
            });
        }
    }

    /**
     * Render validation details
     */
    private renderValidationDetails(results: ValidationResult[]): string {
        const categories = this.groupResultsByCategory(results);
        
        return Object.entries(categories).map(([category, categoryResults]) => `
            <div class="category-section">
                <h5>${this.getCategoryIcon(category)} ${this.getCategoryTitle(category)}</h5>
                <div class="category-results">
                    ${categoryResults.map(result => this.renderValidationResult(result)).join('')}
                </div>
            </div>
        `).join('');
    }

    /**
     * Render individual validation result
     */
    private renderValidationResult(result: ValidationResult): string {
        return `
            <div class="validation-result ${result.status}">
                <div class="result-header">
                    <span class="result-icon">${this.getStatusIcon(result.status)}</span>
                    <span class="result-check">${result.check}</span>
                    <span class="result-status">${result.status.toUpperCase()}</span>
                </div>
                <div class="result-message">${result.message}</div>
                ${result.details ? `<div class="result-details">${result.details}</div>` : ''}
                ${result.fixSuggestion ? `
                    <div class="result-fix">
                        <span class="fix-label"> Suggestion:</span>
                        <span class="fix-text">${result.fixSuggestion}</span>
                        ${result.autoFixAvailable ? `
                            <button class="auto-fix-button" data-check="${result.check}">
                                Auto Fix
                            </button>
                        ` : ''}
                    </div>
                ` : ''}
            </div>
        `;
    }

    /**
     * Display troubleshooting guides
     */
    private displayTroubleshootingGuides(guides: TroubleshootingGuide[]): void {
        if (!this.troubleshootingSection || guides.length === 0) return;

        const guidesContainer = this.troubleshootingSection.querySelector('#troubleshooting-guides');
        if (!guidesContainer) return;

        const guidesHTML = guides.map(guide => `
            <div class="troubleshooting-guide ${guide.severity}">
                <div class="guide-header">
                    <h6>${guide.title}</h6>
                    <div class="guide-meta">
                        <span class="guide-severity ${guide.severity}">${guide.severity.toUpperCase()}</span>
                        <span class="guide-time"> ${guide.estimatedTime}</span>
                    </div>
                </div>
                <div class="guide-description">${guide.description}</div>
                <button class="guide-button" data-guide-id="${guide.id}">
                    Start Guide
                </button>
            </div>
        `).join('');

        guidesContainer.innerHTML = guidesHTML;
        this.troubleshootingSection.classList.remove('hidden');

        // Set up event listeners for guide buttons
        this.setupGuideListeners();
    }

    /**
     * Set up auto-fix button listeners
     */
    private setupAutoFixListeners(): void {
        const autoFixButtons = this.validationResults?.querySelectorAll('.auto-fix-button');
        autoFixButtons?.forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                const check = target.dataset.check;
                if (check) {
                    this.runAutoFix(check);
                }
            });
        });
    }

    /**
     * Set up troubleshooting guide button listeners
     */
    private setupGuideListeners(): void {
        const guideButtons = this.troubleshootingSection?.querySelectorAll('.guide-button');
        guideButtons?.forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                const guideId = target.dataset.guideId;
                if (guideId) {
                    this.openTroubleshootingGuide(guideId);
                }
            });
        });
    }

    /**
     * Run auto-fix for a specific check
     */
    private async runAutoFix(check: string): Promise<void> {
        vscodeApi.postMessage({
            command: 'runAutoFix',
            check: check
        });
    }

    /**
     * Open troubleshooting guide
     */
    private openTroubleshootingGuide(guideId: string): void {
        vscodeApi.postMessage({
            command: 'openTroubleshootingGuide',
            guideId: guideId
        });
    }

    /**
     * Helper methods
     */
    private groupResultsByCategory(results: ValidationResult[]): Record<string, ValidationResult[]> {
        return results.reduce((groups, result) => {
            if (!groups[result.category]) {
                groups[result.category] = [];
            }
            groups[result.category].push(result);
            return groups;
        }, {} as Record<string, ValidationResult[]>);
    }

    private getStatusIcon(status: string): string {
        switch (status) {
            case 'pass': return '';
            case 'warning': return '';
            case 'fail': return '';
            default: return '';
        }
    }

    private getStatusText(status: string): string {
        switch (status) {
            case 'pass': return 'All Checks Passed';
            case 'warning': return 'Issues Found';
            case 'fail': return 'Critical Issues';
            default: return 'Unknown Status';
        }
    }

    private getCategoryIcon(category: string): string {
        switch (category) {
            case 'docker': return '';
            case 'network': return '';
            case 'system': return '';
            case 'ports': return '';
            default: return '';
        }
    }

    private getCategoryTitle(category: string): string {
        switch (category) {
            case 'docker': return 'Docker';
            case 'network': return 'Network';
            case 'system': return 'System';
            case 'ports': return 'Ports';
            default: return category.charAt(0).toUpperCase() + category.slice(1);
        }
    }

    private showError(message: string): void {
        if (this.validationResults) {
            this.validationResults.innerHTML = `
                <div class="validation-error">
                    <span class="error-icon"></span>
                    <span class="error-message">${message}</span>
                </div>
            `;
            this.validationResults.classList.remove('hidden');
        }
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        // Remove event listeners if needed
    }
}

// CSS styles for SystemValidation component
export const systemValidationStyles = `
.system-validation {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    margin-bottom: 20px;
    background-color: var(--vscode-sideBar-background);
}

.validation-header {
    text-align: center;
    margin-bottom: 20px;
}

.validation-header h3 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
}

.validation-header p {
    margin: 0 0 15px 0;
    color: var(--vscode-descriptionForeground);
    font-size: 14px;
}

.validation-button {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.validation-button:hover:not(:disabled) {
    background-color: var(--vscode-button-hoverBackground);
}

.validation-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.validation-results {
    margin-bottom: 20px;
}

.validation-results.hidden,
.troubleshooting-section.hidden {
    display: none;
}

.validation-summary {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    margin-bottom: 15px;
    background-color: var(--vscode-editor-background);
}

.summary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.summary-header h4 {
    margin: 0;
    color: var(--vscode-textLink-foreground);
}

.overall-status {
    padding: 6px 12px;
    border-radius: 4px;
    font-weight: 500;
    font-size: 13px;
}

.overall-status.pass {
    background-color: var(--vscode-charts-green);
    color: white;
}

.overall-status.warning {
    background-color: var(--vscode-charts-orange);
    color: white;
}

.overall-status.fail {
    background-color: var(--vscode-charts-red);
    color: white;
}

.summary-stats {
    display: flex;
    gap: 20px;
    justify-content: center;
}

.stat {
    text-align: center;
}

.stat-number {
    display: block;
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 4px;
}

.stat.passed .stat-number {
    color: var(--vscode-charts-green);
}

.stat.warnings .stat-number {
    color: var(--vscode-charts-orange);
}

.stat.failed .stat-number {
    color: var(--vscode-charts-red);
}

.stat-label {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
}

.category-section {
    margin-bottom: 20px;
}

.category-section h5 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
    padding-bottom: 5px;
    border-bottom: 1px solid var(--vscode-panel-border);
}

.validation-result {
    padding: 12px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    margin-bottom: 8px;
    background-color: var(--vscode-editor-background);
}

.validation-result.pass {
    border-left: 3px solid var(--vscode-charts-green);
}

.validation-result.warning {
    border-left: 3px solid var(--vscode-charts-orange);
}

.validation-result.fail {
    border-left: 3px solid var(--vscode-charts-red);
}

.result-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
}

.result-check {
    flex: 1;
    font-weight: 500;
    color: var(--vscode-foreground);
}

.result-status {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 2px;
    background-color: var(--vscode-badge-background);
    color: var(--vscode-badge-foreground);
}

.result-message {
    color: var(--vscode-foreground);
    font-size: 13px;
    margin-bottom: 4px;
}

.result-details {
    color: var(--vscode-descriptionForeground);
    font-size: 12px;
    font-family: var(--vscode-editor-font-family);
    margin-bottom: 8px;
}

.result-fix {
    padding: 8px;
    background-color: var(--vscode-textCodeBlock-background);
    border-radius: 3px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.fix-label {
    font-weight: 500;
    color: var(--vscode-textLink-foreground);
}

.fix-text {
    flex: 1;
    color: var(--vscode-foreground);
}

.auto-fix-button {
    padding: 4px 8px;
    border: 1px solid var(--vscode-button-border);
    border-radius: 3px;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    font-size: 11px;
    cursor: pointer;
}

.auto-fix-button:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.troubleshooting-section {
    margin-top: 20px;
}

.troubleshooting-section h4 {
    margin: 0 0 15px 0;
    color: var(--vscode-textLink-foreground);
}

.troubleshooting-guide {
    padding: 15px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
    margin-bottom: 10px;
    background-color: var(--vscode-editor-background);
}

.troubleshooting-guide.critical {
    border-left: 3px solid var(--vscode-charts-red);
}

.troubleshooting-guide.high {
    border-left: 3px solid var(--vscode-charts-orange);
}

.troubleshooting-guide.medium {
    border-left: 3px solid var(--vscode-charts-yellow);
}

.troubleshooting-guide.low {
    border-left: 3px solid var(--vscode-charts-blue);
}

.guide-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
}

.guide-header h6 {
    margin: 0;
    color: var(--vscode-textLink-foreground);
    font-size: 14px;
}

.guide-meta {
    display: flex;
    gap: 8px;
    align-items: center;
}

.guide-severity {
    font-size: 10px;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
}

.guide-severity.critical {
    background-color: var(--vscode-charts-red);
    color: white;
}

.guide-severity.high {
    background-color: var(--vscode-charts-orange);
    color: white;
}

.guide-severity.medium {
    background-color: var(--vscode-charts-yellow);
    color: black;
}

.guide-severity.low {
    background-color: var(--vscode-charts-blue);
    color: white;
}

.guide-time {
    font-size: 11px;
    color: var(--vscode-descriptionForeground);
}

.guide-description {
    color: var(--vscode-foreground);
    font-size: 13px;
    margin-bottom: 10px;
}

.guide-button {
    padding: 6px 12px;
    border: none;
    border-radius: 3px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-size: 12px;
    cursor: pointer;
}

.guide-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.validation-info {
    margin-top: 20px;
    padding: 15px;
    background-color: var(--vscode-textCodeBlock-background);
    border-radius: 4px;
}

.validation-info h4 {
    margin: 0 0 15px 0;
    color: var(--vscode-textLink-foreground);
}

.check-categories {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.check-category h5 {
    margin: 0 0 8px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 13px;
}

.check-category ul {
    margin: 0;
    padding-left: 16px;
    color: var(--vscode-foreground);
}

.check-category li {
    font-size: 12px;
    margin-bottom: 3px;
}

.validation-error {
    padding: 15px;
    border: 1px solid var(--vscode-inputValidation-errorBorder);
    border-radius: 4px;
    background-color: var(--vscode-inputValidation-errorBackground);
    color: var(--vscode-inputValidation-errorForeground);
    display: flex;
    align-items: center;
    gap: 8px;
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/stores/setupStore.js">
"use strict";
/**
 * Setup Store for Onboarding & Configuration Management
 *
 * This store manages the state during the user onboarding process,
 * tracking database status, embedding provider selection, and overall setup progress.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupActions = exports.setupStore = void 0;
class SetupStore {
    constructor() {
        this.state = {
            selectedDatabase: '',
            databaseConfig: null,
            isDatabaseRunning: false,
            databaseStatus: 'not-configured',
            selectedProvider: '',
            embeddingConfig: null,
            providerConfigured: false,
            isSetupComplete: false,
            isIndexing: false,
            setupStep: 'database',
            lastError: null
        };
        this.listeners = [];
    }
    /**
     * Subscribe to state changes
     */
    subscribe(listener) {
        this.listeners.push(listener);
        listener(this.state); // Immediately call with current state
        // Return unsubscribe function
        return () => {
            const index = this.listeners.indexOf(listener);
            if (index > -1) {
                this.listeners.splice(index, 1);
            }
        };
    }
    /**
     * Get current state
     */
    getState() {
        return { ...this.state };
    }
    /**
     * Update database selection
     */
    setSelectedDatabase(database) {
        this.updateState({
            selectedDatabase: database,
            databaseConfig: null,
            databaseStatus: database ? 'not-configured' : 'not-configured'
        });
    }
    /**
     * Update database configuration
     */
    setDatabaseConfig(config) {
        this.updateState({
            databaseConfig: config
        });
    }
    /**
     * Update database status
     */
    setDatabaseStatus(status) {
        this.updateState({
            databaseStatus: status,
            isDatabaseRunning: status === 'running',
            setupStep: status === 'running' ? 'provider' : 'database'
        });
    }
    /**
     * Update embedding provider selection
     */
    setSelectedProvider(provider) {
        this.updateState({
            selectedProvider: provider,
            embeddingConfig: null,
            providerConfigured: !!provider,
            setupStep: provider && this.state.isDatabaseRunning ? 'ready' : this.state.setupStep
        });
        this.checkSetupComplete();
    }
    /**
     * Update embedding provider configuration
     */
    setEmbeddingConfig(config) {
        this.updateState({
            embeddingConfig: config,
            providerConfigured: true
        });
        this.checkSetupComplete();
    }
    /**
     * Set indexing state
     */
    setIndexing(isIndexing) {
        this.updateState({
            isIndexing,
            setupStep: isIndexing ? 'indexing' : 'ready'
        });
    }
    /**
     * Set error state
     */
    setError(error) {
        this.updateState({
            lastError: error
        });
    }
    /**
     * Clear error state
     */
    clearError() {
        this.setError(null);
    }
    /**
     * Reset setup state
     */
    reset() {
        this.state = {
            selectedDatabase: '',
            databaseConfig: null,
            isDatabaseRunning: false,
            databaseStatus: 'not-configured',
            selectedProvider: '',
            embeddingConfig: null,
            providerConfigured: false,
            isSetupComplete: false,
            isIndexing: false,
            setupStep: 'database',
            lastError: null
        };
        this.notifyListeners();
    }
    /**
     * Check if setup is complete and update state accordingly
     */
    checkSetupComplete() {
        const isComplete = this.state.isDatabaseRunning && this.state.providerConfigured;
        if (isComplete !== this.state.isSetupComplete) {
            this.updateState({
                isSetupComplete: isComplete
            });
        }
    }
    /**
     * Update state and notify listeners
     */
    updateState(updates) {
        this.state = { ...this.state, ...updates };
        this.notifyListeners();
    }
    /**
     * Notify all listeners of state changes
     */
    notifyListeners() {
        this.listeners.forEach(listener => listener(this.state));
    }
    /**
     * Derived getters for common state checks
     */
    get canStartIndexing() {
        return this.state.isSetupComplete && !this.state.isIndexing;
    }
    get isConfiguring() {
        return this.state.setupStep === 'database' || this.state.setupStep === 'provider';
    }
    get isReady() {
        return this.state.setupStep === 'ready';
    }
}
// Export singleton instance
exports.setupStore = new SetupStore();
// Export convenience functions for common operations
exports.setupActions = {
    selectDatabase: (database) => exports.setupStore.setSelectedDatabase(database),
    setDatabaseConfig: (config) => exports.setupStore.setDatabaseConfig(config),
    updateDatabaseStatus: (status) => exports.setupStore.setDatabaseStatus(status),
    selectProvider: (provider) => exports.setupStore.setSelectedProvider(provider),
    setEmbeddingConfig: (config) => exports.setupStore.setEmbeddingConfig(config),
    startIndexing: () => exports.setupStore.setIndexing(true),
    stopIndexing: () => exports.setupStore.setIndexing(false),
    setError: (error) => exports.setupStore.setError(error),
    clearError: () => exports.setupStore.clearError(),
    reset: () => exports.setupStore.reset()
};
//# sourceMappingURL=setupStore.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/stores/setupStore.js.map">
{"version":3,"file":"setupStore.js","sourceRoot":"","sources":["setupStore.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/stores/setupStore.ts">
/**
 * Setup Store for Onboarding & Configuration Management
 * 
 * This store manages the state during the user onboarding process,
 * tracking database status, embedding provider selection, and overall setup progress.
 */

// Database provider types
export type DatabaseProvider = 'qdrant' | 'chromadb' | 'pinecone';

// Database configuration interfaces
export interface QdrantConfig {
    host: string;
    port: number;
    apiKey?: string;
}

export interface ChromaDBConfig {
    host: string;
    port: number;
    ssl: boolean;
    authToken?: string;
}

export interface PineconeConfig {
    apiKey: string;
    environment: string;
    indexName: string;
}

export type DatabaseConfig = QdrantConfig | ChromaDBConfig | PineconeConfig;

// Embedding provider types
export type EmbeddingProvider = 'ollama' | 'openai';

// Embedding provider configuration interfaces
export interface OllamaConfig {
    endpoint: string;
    model: string;
    apiKey?: string; // For secured Ollama instances
    timeout?: number;
}

export interface OpenAIConfig {
    apiKey: string;
    model: string;
    organization?: string;
    baseURL?: string; // For custom OpenAI-compatible endpoints
}

export type EmbeddingConfig = OllamaConfig | OpenAIConfig;

export interface SetupState {
    // Database configuration
    selectedDatabase: DatabaseProvider | '';
    databaseConfig: DatabaseConfig | null;
    isDatabaseRunning: boolean;
    databaseStatus: 'not-configured' | 'starting' | 'running' | 'error';

    // Embedding provider configuration
    selectedProvider: EmbeddingProvider | '';
    embeddingConfig: EmbeddingConfig | null;
    providerConfigured: boolean;

    // Overall setup state
    isSetupComplete: boolean;
    isIndexing: boolean;
    setupStep: 'database' | 'provider' | 'ready' | 'indexing';

    // Error handling
    lastError: string | null;
}

class SetupStore {
    private state: SetupState = {
        selectedDatabase: '',
        databaseConfig: null,
        isDatabaseRunning: false,
        databaseStatus: 'not-configured',
        selectedProvider: '',
        embeddingConfig: null,
        providerConfigured: false,
        isSetupComplete: false,
        isIndexing: false,
        setupStep: 'database',
        lastError: null
    };

    private listeners: Array<(state: SetupState) => void> = [];

    /**
     * Subscribe to state changes
     */
    subscribe(listener: (state: SetupState) => void): () => void {
        this.listeners.push(listener);
        listener(this.state); // Immediately call with current state
        
        // Return unsubscribe function
        return () => {
            const index = this.listeners.indexOf(listener);
            if (index > -1) {
                this.listeners.splice(index, 1);
            }
        };
    }

    /**
     * Get current state
     */
    getState(): SetupState {
        return { ...this.state };
    }

    /**
     * Update database selection
     */
    setSelectedDatabase(database: DatabaseProvider | ''): void {
        this.updateState({
            selectedDatabase: database,
            databaseConfig: null, // Reset config when changing database
            databaseStatus: database ? 'not-configured' : 'not-configured'
        });
    }

    /**
     * Update database configuration
     */
    setDatabaseConfig(config: DatabaseConfig): void {
        this.updateState({
            databaseConfig: config
        });
    }

    /**
     * Update database status
     */
    setDatabaseStatus(status: SetupState['databaseStatus']): void {
        this.updateState({
            databaseStatus: status,
            isDatabaseRunning: status === 'running',
            setupStep: status === 'running' ? 'provider' : 'database'
        });
    }

    /**
     * Update embedding provider selection
     */
    setSelectedProvider(provider: EmbeddingProvider | ''): void {
        this.updateState({
            selectedProvider: provider,
            embeddingConfig: null, // Reset config when changing provider
            providerConfigured: !!provider,
            setupStep: provider && this.state.isDatabaseRunning ? 'ready' : this.state.setupStep
        });
        this.checkSetupComplete();
    }

    /**
     * Update embedding provider configuration
     */
    setEmbeddingConfig(config: EmbeddingConfig): void {
        this.updateState({
            embeddingConfig: config,
            providerConfigured: true
        });
        this.checkSetupComplete();
    }

    /**
     * Set indexing state
     */
    setIndexing(isIndexing: boolean): void {
        this.updateState({
            isIndexing,
            setupStep: isIndexing ? 'indexing' : 'ready'
        });
    }

    /**
     * Set error state
     */
    setError(error: string | null): void {
        this.updateState({
            lastError: error
        });
    }

    /**
     * Clear error state
     */
    clearError(): void {
        this.setError(null);
    }

    /**
     * Reset setup state
     */
    reset(): void {
        this.state = {
            selectedDatabase: '',
            databaseConfig: null,
            isDatabaseRunning: false,
            databaseStatus: 'not-configured',
            selectedProvider: '',
            embeddingConfig: null,
            providerConfigured: false,
            isSetupComplete: false,
            isIndexing: false,
            setupStep: 'database',
            lastError: null
        };
        this.notifyListeners();
    }

    /**
     * Check if setup is complete and update state accordingly
     */
    private checkSetupComplete(): void {
        const isComplete = this.state.isDatabaseRunning && this.state.providerConfigured;
        if (isComplete !== this.state.isSetupComplete) {
            this.updateState({
                isSetupComplete: isComplete
            });
        }
    }

    /**
     * Update state and notify listeners
     */
    private updateState(updates: Partial<SetupState>): void {
        this.state = { ...this.state, ...updates };
        this.notifyListeners();
    }

    /**
     * Notify all listeners of state changes
     */
    private notifyListeners(): void {
        this.listeners.forEach(listener => listener(this.state));
    }

    /**
     * Derived getters for common state checks
     */
    get canStartIndexing(): boolean {
        return this.state.isSetupComplete && !this.state.isIndexing;
    }

    get isConfiguring(): boolean {
        return this.state.setupStep === 'database' || this.state.setupStep === 'provider';
    }

    get isReady(): boolean {
        return this.state.setupStep === 'ready';
    }
}

// Export singleton instance
export const setupStore = new SetupStore();

// Export convenience functions for common operations
export const setupActions = {
    selectDatabase: (database: DatabaseProvider | '') => setupStore.setSelectedDatabase(database),
    setDatabaseConfig: (config: DatabaseConfig) => setupStore.setDatabaseConfig(config),
    updateDatabaseStatus: (status: SetupState['databaseStatus']) => setupStore.setDatabaseStatus(status),
    selectProvider: (provider: EmbeddingProvider | '') => setupStore.setSelectedProvider(provider),
    setEmbeddingConfig: (config: EmbeddingConfig) => setupStore.setEmbeddingConfig(config),
    startIndexing: () => setupStore.setIndexing(true),
    stopIndexing: () => setupStore.setIndexing(false),
    setError: (error: string) => setupStore.setError(error),
    clearError: () => setupStore.clearError(),
    reset: () => setupStore.reset()
};
</file>

<file path="webview-backup-20250826-101914/src/lib/views/SetupView.js">
"use strict";
/**
 * SetupView - Main Onboarding Component
 *
 * This is the main view for user onboarding and initial setup.
 * It orchestrates the database and embedding provider configuration process.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SetupView = void 0;
const setupStore_1 = require("../stores/setupStore");
const DatabaseSetup_1 = require("../components/DatabaseSetup");
const EmbeddingSetup_1 = require("../components/EmbeddingSetup");
const SystemValidation_1 = require("../components/SystemValidation");
const ConfigurationManagement_1 = require("../components/ConfigurationManagement");
const vscodeApi_1 = require("../vscodeApi");
class SetupView {
    constructor(container) {
        this.databaseSetup = null;
        this.embeddingSetup = null;
        this.systemValidation = null;
        this.configurationManagement = null;
        this.indexButton = null;
        this.progressSection = null;
        this.unsubscribe = null;
        this.container = container;
        this.injectStyles();
        this.render();
        this.initializeComponents();
        this.setupEventListeners();
        this.subscribeToStore();
        this.setupMessageHandlers();
    }
    /**
     * Inject CSS styles for all components
     */
    injectStyles() {
        const styleId = 'setup-view-styles';
        if (document.getElementById(styleId))
            return;
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            ${setupViewStyles}
            ${SystemValidation_1.systemValidationStyles}
            ${DatabaseSetup_1.databaseSetupStyles}
            ${EmbeddingSetup_1.embeddingSetupStyles}
            ${ConfigurationManagement_1.configurationManagementStyles}
        `;
        document.head.appendChild(style);
    }
    /**
     * Render the main setup view
     */
    render() {
        this.container.innerHTML = `
            <div class="setup-view">
                <div class="setup-header">
                    <h1>Welcome to Code Context Engine</h1>
                    <p>Let's get you set up! Configure your database and embedding provider to start indexing your code.</p>
                </div>

                <div class="setup-progress">
                    <div class="progress-step active" data-step="database">
                        <div class="step-number">1</div>
                        <div class="step-label">Database</div>
                    </div>
                    <div class="progress-line"></div>
                    <div class="progress-step" data-step="provider">
                        <div class="step-number">2</div>
                        <div class="step-label">Provider</div>
                    </div>
                    <div class="progress-line"></div>
                    <div class="progress-step" data-step="ready">
                        <div class="step-number">3</div>
                        <div class="step-label">Ready</div>
                    </div>
                </div>

                <div class="setup-content">
                    <div id="system-validation-container"></div>
                    <div id="database-setup-container"></div>
                    <div id="embedding-setup-container"></div>
                    <div id="configuration-management-container"></div>
                </div>

                <div class="setup-actions">
                    <button id="index-now-btn" class="index-button" disabled>
                        <span class="button-icon"></span>
                        Index Now
                    </button>
                    <p class="action-help">
                        Complete the configuration above to enable indexing.
                    </p>
                </div>

                <div id="indexing-progress" class="indexing-progress hidden">
                    <h3>Indexing in Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <p class="progress-text">Starting indexing process...</p>
                </div>
            </div>
        `;
        // Get references to key elements
        this.indexButton = this.container.querySelector('#index-now-btn');
        this.progressSection = this.container.querySelector('#indexing-progress');
    }
    /**
     * Initialize child components
     */
    initializeComponents() {
        const systemValidationContainer = this.container.querySelector('#system-validation-container');
        const databaseContainer = this.container.querySelector('#database-setup-container');
        const embeddingContainer = this.container.querySelector('#embedding-setup-container');
        const configManagementContainer = this.container.querySelector('#configuration-management-container');
        if (systemValidationContainer) {
            this.systemValidation = new SystemValidation_1.SystemValidationComponent(systemValidationContainer);
        }
        if (databaseContainer) {
            this.databaseSetup = new DatabaseSetup_1.DatabaseSetup(databaseContainer);
        }
        if (embeddingContainer) {
            this.embeddingSetup = new EmbeddingSetup_1.EmbeddingSetup(embeddingContainer);
        }
        if (configManagementContainer) {
            this.configurationManagement = new ConfigurationManagement_1.ConfigurationManagementComponent(configManagementContainer);
        }
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        if (this.indexButton) {
            this.indexButton.addEventListener('click', () => {
                this.handleStartIndexing();
            });
        }
    }
    /**
     * Subscribe to store updates
     */
    subscribeToStore() {
        this.unsubscribe = setupStore_1.setupStore.subscribe((state) => {
            this.updateUI(state);
        });
    }
    /**
     * Set up message handlers for extension communication
     */
    setupMessageHandlers() {
        // Listen for database status updates
        vscodeApi_1.vscodeApi.onMessage('databaseStatus', (event) => {
            if (this.databaseSetup) {
                this.databaseSetup.handleDatabaseStatusUpdate(event.data.status);
            }
        });
        // Listen for indexing progress updates
        vscodeApi_1.vscodeApi.onMessage('indexingProgress', (data) => {
            this.updateIndexingProgress(data);
        });
        // Listen for indexing completion
        vscodeApi_1.vscodeApi.onMessage('indexingCompleted', (data) => {
            this.handleIndexingCompleted(data);
        });
        // Listen for errors
        vscodeApi_1.vscodeApi.onMessage('error', (event) => {
            setupStore_1.setupActions.setError(event.data.message);
        });
    }
    /**
     * Handle start indexing button click
     */
    async handleStartIndexing() {
        const state = setupStore_1.setupStore.getState();
        if (!state.isSetupComplete) {
            setupStore_1.setupActions.setError('Please complete the setup first');
            return;
        }
        try {
            setupStore_1.setupActions.startIndexing();
            setupStore_1.setupActions.clearError();
            // Send indexing command to extension
            vscodeApi_1.vscodeApi.postMessage({
                command: 'startIndexing',
                configuration: {
                    database: state.selectedDatabase,
                    provider: state.selectedProvider
                }
            });
            console.log('Indexing started');
        }
        catch (error) {
            console.error('Failed to start indexing:', error);
            setupStore_1.setupActions.setError(`Failed to start indexing: ${error}`);
            setupStore_1.setupActions.stopIndexing();
        }
    }
    /**
     * Update UI based on store state
     */
    updateUI(state) {
        // Update progress steps
        this.updateProgressSteps(state.setupStep);
        // Update index button
        if (this.indexButton) {
            this.indexButton.disabled = !state.isSetupComplete || state.isIndexing;
            if (state.isIndexing) {
                this.indexButton.innerHTML = '<span class="button-icon"></span> Indexing...';
            }
            else {
                this.indexButton.innerHTML = '<span class="button-icon"></span> Index Now';
            }
        }
        // Update action help text
        const actionHelp = this.container.querySelector('.action-help');
        if (actionHelp) {
            if (state.isSetupComplete) {
                actionHelp.textContent = 'Ready to index your codebase!';
                actionHelp.style.color = 'var(--vscode-charts-green)';
            }
            else {
                actionHelp.textContent = 'Complete the configuration above to enable indexing.';
                actionHelp.style.color = 'var(--vscode-descriptionForeground)';
            }
        }
        // Show/hide indexing progress
        if (this.progressSection) {
            if (state.isIndexing) {
                this.progressSection.classList.remove('hidden');
            }
            else {
                this.progressSection.classList.add('hidden');
            }
        }
        // Show errors
        if (state.lastError) {
            this.showError(state.lastError);
        }
    }
    /**
     * Update progress steps visual state
     */
    updateProgressSteps(currentStep) {
        const steps = this.container.querySelectorAll('.progress-step');
        steps.forEach((step) => {
            const stepElement = step;
            const stepName = stepElement.dataset.step;
            stepElement.classList.remove('active', 'completed');
            if (stepName === currentStep) {
                stepElement.classList.add('active');
            }
            else if (this.isStepCompleted(stepName, currentStep)) {
                stepElement.classList.add('completed');
            }
        });
    }
    /**
     * Check if a step is completed
     */
    isStepCompleted(stepName, currentStep) {
        const stepOrder = ['database', 'provider', 'ready', 'indexing'];
        const currentIndex = stepOrder.indexOf(currentStep);
        const stepIndex = stepOrder.indexOf(stepName || '');
        return stepIndex < currentIndex;
    }
    /**
     * Update indexing progress
     */
    updateIndexingProgress(data) {
        if (!this.progressSection)
            return;
        const progressFill = this.progressSection.querySelector('.progress-fill');
        const progressText = this.progressSection.querySelector('.progress-text');
        if (progressFill && data.percentage !== undefined) {
            progressFill.style.width = `${data.percentage}%`;
        }
        if (progressText && data.message) {
            progressText.textContent = data.message;
        }
    }
    /**
     * Handle indexing completion
     */
    handleIndexingCompleted(data) {
        setupStore_1.setupActions.stopIndexing();
        if (data.success) {
            this.showSuccess('Indexing completed successfully! You can now search your code.');
        }
        else {
            setupStore_1.setupActions.setError('Indexing failed. Please check the logs and try again.');
        }
    }
    /**
     * Show error message
     */
    showError(message) {
        this.showNotification(message, 'error');
    }
    /**
     * Show success message
     */
    showSuccess(message) {
        this.showNotification(message, 'success');
    }
    /**
     * Show notification
     */
    showNotification(message, type) {
        // Remove existing notifications
        const existing = this.container.querySelector('.notification');
        if (existing) {
            existing.remove();
        }
        // Create new notification
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        // Add close button
        const closeBtn = document.createElement('button');
        closeBtn.className = 'notification-close';
        closeBtn.textContent = '';
        closeBtn.onclick = () => notification.remove();
        notification.appendChild(closeBtn);
        // Insert at top of setup view
        this.container.insertBefore(notification, this.container.firstChild);
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 5000);
    }
    /**
     * Cleanup component
     */
    dispose() {
        if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
        }
        if (this.systemValidation) {
            this.systemValidation.dispose();
            this.systemValidation = null;
        }
        if (this.databaseSetup) {
            this.databaseSetup.dispose();
            this.databaseSetup = null;
        }
        if (this.embeddingSetup) {
            this.embeddingSetup.dispose();
            this.embeddingSetup = null;
        }
        if (this.configurationManagement) {
            this.configurationManagement.dispose();
            this.configurationManagement = null;
        }
    }
}
exports.SetupView = SetupView;
// CSS styles for the setup view
const setupViewStyles = `
.setup-view {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

.setup-header {
    text-align: center;
    margin-bottom: 30px;
}

.setup-header h1 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 28px;
}

.setup-header p {
    margin: 0;
    color: var(--vscode-descriptionForeground);
    font-size: 16px;
}

.setup-progress {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 40px;
    padding: 20px;
}

.progress-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.step-number {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
    border: 2px solid var(--vscode-panel-border);
    background-color: var(--vscode-sideBar-background);
    color: var(--vscode-descriptionForeground);
    transition: all 0.3s ease;
}

.progress-step.active .step-number {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border-color: var(--vscode-button-background);
}

.progress-step.completed .step-number {
    background-color: var(--vscode-charts-green);
    color: white;
    border-color: var(--vscode-charts-green);
}

.step-label {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
    font-weight: 500;
}

.progress-step.active .step-label {
    color: var(--vscode-foreground);
}

.progress-line {
    width: 60px;
    height: 2px;
    background-color: var(--vscode-panel-border);
    margin: 0 10px;
}

.setup-content {
    margin-bottom: 30px;
}

.setup-actions {
    text-align: center;
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    background-color: var(--vscode-sideBar-background);
}

.index-button {
    padding: 12px 24px;
    border: none;
    border-radius: 6px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-family: inherit;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.index-button:hover:not(:disabled) {
    background-color: var(--vscode-button-hoverBackground);
}

.index-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.action-help {
    margin: 10px 0 0 0;
    font-size: 14px;
    color: var(--vscode-descriptionForeground);
}

.indexing-progress {
    margin-top: 20px;
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    background-color: var(--vscode-textCodeBlock-background);
}

.indexing-progress.hidden {
    display: none;
}

.indexing-progress h3 {
    margin: 0 0 15px 0;
    color: var(--vscode-textLink-foreground);
}

.progress-bar {
    width: 100%;
    height: 8px;
    background-color: var(--vscode-progressBar-background);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-fill {
    height: 100%;
    background-color: var(--vscode-progressBar-foreground);
    transition: width 0.3s ease;
    width: 0%;
}

.progress-text {
    margin: 0;
    font-size: 14px;
    color: var(--vscode-foreground);
}

.notification {
    padding: 12px 16px;
    border-radius: 4px;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.notification.error {
    background-color: var(--vscode-inputValidation-errorBackground);
    border: 1px solid var(--vscode-inputValidation-errorBorder);
    color: var(--vscode-inputValidation-errorForeground);
}

.notification.success {
    background-color: var(--vscode-charts-green);
    color: white;
}

.notification-close {
    background: none;
    border: none;
    color: inherit;
    font-size: 18px;
    cursor: pointer;
    padding: 0;
    margin-left: 10px;
}
`;
//# sourceMappingURL=SetupView.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/views/SetupView.js.map">
{"version":3,"file":"SetupView.js","sourceRoot":"","sources":["SetupView.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/views/SetupView.ts">
/**
 * SetupView - Main Onboarding Component
 * 
 * This is the main view for user onboarding and initial setup.
 * It orchestrates the database and embedding provider configuration process.
 */

import { setupStore, setupActions, SetupState } from '../stores/setupStore';
import { DatabaseSetup, databaseSetupStyles } from '../components/DatabaseSetup';
import { EmbeddingSetup, embeddingSetupStyles } from '../components/EmbeddingSetup';
import { SystemValidationComponent, systemValidationStyles } from '../components/SystemValidation';
import { ConfigurationManagementComponent, configurationManagementStyles } from '../components/ConfigurationManagement';
import { vscodeApi } from '../vscodeApi';

export class SetupView {
    private container: HTMLElement;
    private databaseSetup: DatabaseSetup | null = null;
    private embeddingSetup: EmbeddingSetup | null = null;
    private systemValidation: SystemValidationComponent | null = null;
    private configurationManagement: ConfigurationManagementComponent | null = null;
    private indexButton: HTMLButtonElement | null = null;
    private progressSection: HTMLElement | null = null;
    private unsubscribe: (() => void) | null = null;

    constructor(container: HTMLElement) {
        this.container = container;
        this.injectStyles();
        this.render();
        this.initializeComponents();
        this.setupEventListeners();
        this.subscribeToStore();
        this.setupMessageHandlers();
    }

    /**
     * Inject CSS styles for all components
     */
    private injectStyles(): void {
        const styleId = 'setup-view-styles';
        if (document.getElementById(styleId)) return;

        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            ${setupViewStyles}
            ${systemValidationStyles}
            ${databaseSetupStyles}
            ${embeddingSetupStyles}
            ${configurationManagementStyles}
        `;
        document.head.appendChild(style);
    }

    /**
     * Render the main setup view
     */
    private render(): void {
        this.container.innerHTML = `
            <div class="setup-view">
                <div class="setup-header">
                    <h1>Welcome to Code Context Engine</h1>
                    <p>Let's get you set up! Configure your database and embedding provider to start indexing your code.</p>
                </div>

                <div class="setup-progress">
                    <div class="progress-step active" data-step="database">
                        <div class="step-number">1</div>
                        <div class="step-label">Database</div>
                    </div>
                    <div class="progress-line"></div>
                    <div class="progress-step" data-step="provider">
                        <div class="step-number">2</div>
                        <div class="step-label">Provider</div>
                    </div>
                    <div class="progress-line"></div>
                    <div class="progress-step" data-step="ready">
                        <div class="step-number">3</div>
                        <div class="step-label">Ready</div>
                    </div>
                </div>

                <div class="setup-content">
                    <div id="system-validation-container"></div>
                    <div id="database-setup-container"></div>
                    <div id="embedding-setup-container"></div>
                    <div id="configuration-management-container"></div>
                </div>

                <div class="setup-actions">
                    <button id="index-now-btn" class="index-button" disabled>
                        <span class="button-icon"></span>
                        Index Now
                    </button>
                    <p class="action-help">
                        Complete the configuration above to enable indexing.
                    </p>
                </div>

                <div id="indexing-progress" class="indexing-progress hidden">
                    <h3>Indexing in Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <p class="progress-text">Starting indexing process...</p>
                </div>
            </div>
        `;

        // Get references to key elements
        this.indexButton = this.container.querySelector('#index-now-btn') as HTMLButtonElement;
        this.progressSection = this.container.querySelector('#indexing-progress') as HTMLElement;
    }

    /**
     * Initialize child components
     */
    private initializeComponents(): void {
        const systemValidationContainer = this.container.querySelector('#system-validation-container') as HTMLElement;
        const databaseContainer = this.container.querySelector('#database-setup-container') as HTMLElement;
        const embeddingContainer = this.container.querySelector('#embedding-setup-container') as HTMLElement;
        const configManagementContainer = this.container.querySelector('#configuration-management-container') as HTMLElement;

        if (systemValidationContainer) {
            this.systemValidation = new SystemValidationComponent(systemValidationContainer);
        }

        if (databaseContainer) {
            this.databaseSetup = new DatabaseSetup(databaseContainer);
        }

        if (embeddingContainer) {
            this.embeddingSetup = new EmbeddingSetup(embeddingContainer);
        }

        if (configManagementContainer) {
            this.configurationManagement = new ConfigurationManagementComponent(configManagementContainer);
        }
    }

    /**
     * Set up event listeners
     */
    private setupEventListeners(): void {
        if (this.indexButton) {
            this.indexButton.addEventListener('click', () => {
                this.handleStartIndexing();
            });
        }
    }

    /**
     * Subscribe to store updates
     */
    private subscribeToStore(): void {
        this.unsubscribe = setupStore.subscribe((state) => {
            this.updateUI(state);
        });
    }

    /**
     * Set up message handlers for extension communication
     */
    private setupMessageHandlers(): void {
        // Listen for database status updates
        vscodeApi.onMessage('databaseStatus', (event) => {
            if (this.databaseSetup) {
                this.databaseSetup.handleDatabaseStatusUpdate(event.data.status);
            }
        });

        // Listen for indexing progress updates
        vscodeApi.onMessage('indexingProgress', (data) => {
            this.updateIndexingProgress(data);
        });

        // Listen for indexing completion
        vscodeApi.onMessage('indexingCompleted', (data) => {
            this.handleIndexingCompleted(data);
        });

        // Listen for errors
        vscodeApi.onMessage('error', (event) => {
            setupActions.setError(event.data.message);
        });
    }

    /**
     * Handle start indexing button click
     */
    private async handleStartIndexing(): Promise<void> {
        const state = setupStore.getState();
        
        if (!state.isSetupComplete) {
            setupActions.setError('Please complete the setup first');
            return;
        }

        try {
            setupActions.startIndexing();
            setupActions.clearError();

            // Send indexing command to extension
            vscodeApi.postMessage({
                command: 'startIndexing',
                configuration: {
                    database: state.selectedDatabase,
                    provider: state.selectedProvider
                }
            });

            console.log('Indexing started');

        } catch (error) {
            console.error('Failed to start indexing:', error);
            setupActions.setError(`Failed to start indexing: ${error}`);
            setupActions.stopIndexing();
        }
    }

    /**
     * Update UI based on store state
     */
    private updateUI(state: SetupState): void {
        // Update progress steps
        this.updateProgressSteps(state.setupStep);

        // Update index button
        if (this.indexButton) {
            this.indexButton.disabled = !state.isSetupComplete || state.isIndexing;
            
            if (state.isIndexing) {
                this.indexButton.innerHTML = '<span class="button-icon"></span> Indexing...';
            } else {
                this.indexButton.innerHTML = '<span class="button-icon"></span> Index Now';
            }
        }

        // Update action help text
        const actionHelp = this.container.querySelector('.action-help') as HTMLElement;
        if (actionHelp) {
            if (state.isSetupComplete) {
                actionHelp.textContent = 'Ready to index your codebase!';
                actionHelp.style.color = 'var(--vscode-charts-green)';
            } else {
                actionHelp.textContent = 'Complete the configuration above to enable indexing.';
                actionHelp.style.color = 'var(--vscode-descriptionForeground)';
            }
        }

        // Show/hide indexing progress
        if (this.progressSection) {
            if (state.isIndexing) {
                this.progressSection.classList.remove('hidden');
            } else {
                this.progressSection.classList.add('hidden');
            }
        }

        // Show errors
        if (state.lastError) {
            this.showError(state.lastError);
        }
    }

    /**
     * Update progress steps visual state
     */
    private updateProgressSteps(currentStep: SetupState['setupStep']): void {
        const steps = this.container.querySelectorAll('.progress-step');
        
        steps.forEach((step) => {
            const stepElement = step as HTMLElement;
            const stepName = stepElement.dataset.step;
            
            stepElement.classList.remove('active', 'completed');
            
            if (stepName === currentStep) {
                stepElement.classList.add('active');
            } else if (this.isStepCompleted(stepName, currentStep)) {
                stepElement.classList.add('completed');
            }
        });
    }

    /**
     * Check if a step is completed
     */
    private isStepCompleted(stepName: string | undefined, currentStep: SetupState['setupStep']): boolean {
        const stepOrder = ['database', 'provider', 'ready', 'indexing'];
        const currentIndex = stepOrder.indexOf(currentStep);
        const stepIndex = stepOrder.indexOf(stepName || '');
        
        return stepIndex < currentIndex;
    }

    /**
     * Update indexing progress
     */
    private updateIndexingProgress(data: any): void {
        if (!this.progressSection) return;

        const progressFill = this.progressSection.querySelector('.progress-fill') as HTMLElement;
        const progressText = this.progressSection.querySelector('.progress-text') as HTMLElement;

        if (progressFill && data.percentage !== undefined) {
            progressFill.style.width = `${data.percentage}%`;
        }

        if (progressText && data.message) {
            progressText.textContent = data.message;
        }
    }

    /**
     * Handle indexing completion
     */
    private handleIndexingCompleted(data: any): void {
        setupActions.stopIndexing();
        
        if (data.success) {
            this.showSuccess('Indexing completed successfully! You can now search your code.');
        } else {
            setupActions.setError('Indexing failed. Please check the logs and try again.');
        }
    }

    /**
     * Show error message
     */
    private showError(message: string): void {
        this.showNotification(message, 'error');
    }

    /**
     * Show success message
     */
    private showSuccess(message: string): void {
        this.showNotification(message, 'success');
    }

    /**
     * Show notification
     */
    private showNotification(message: string, type: 'error' | 'success'): void {
        // Remove existing notifications
        const existing = this.container.querySelector('.notification');
        if (existing) {
            existing.remove();
        }

        // Create new notification
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;

        // Add close button
        const closeBtn = document.createElement('button');
        closeBtn.className = 'notification-close';
        closeBtn.textContent = '';
        closeBtn.onclick = () => notification.remove();
        notification.appendChild(closeBtn);

        // Insert at top of setup view
        this.container.insertBefore(notification, this.container.firstChild);

        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 5000);
    }

    /**
     * Cleanup component
     */
    public dispose(): void {
        if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
        }

        if (this.systemValidation) {
            this.systemValidation.dispose();
            this.systemValidation = null;
        }

        if (this.databaseSetup) {
            this.databaseSetup.dispose();
            this.databaseSetup = null;
        }

        if (this.embeddingSetup) {
            this.embeddingSetup.dispose();
            this.embeddingSetup = null;
        }

        if (this.configurationManagement) {
            this.configurationManagement.dispose();
            this.configurationManagement = null;
        }
    }
}

// CSS styles for the setup view
const setupViewStyles = `
.setup-view {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

.setup-header {
    text-align: center;
    margin-bottom: 30px;
}

.setup-header h1 {
    margin: 0 0 10px 0;
    color: var(--vscode-textLink-foreground);
    font-size: 28px;
}

.setup-header p {
    margin: 0;
    color: var(--vscode-descriptionForeground);
    font-size: 16px;
}

.setup-progress {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 40px;
    padding: 20px;
}

.progress-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.step-number {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
    border: 2px solid var(--vscode-panel-border);
    background-color: var(--vscode-sideBar-background);
    color: var(--vscode-descriptionForeground);
    transition: all 0.3s ease;
}

.progress-step.active .step-number {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border-color: var(--vscode-button-background);
}

.progress-step.completed .step-number {
    background-color: var(--vscode-charts-green);
    color: white;
    border-color: var(--vscode-charts-green);
}

.step-label {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
    font-weight: 500;
}

.progress-step.active .step-label {
    color: var(--vscode-foreground);
}

.progress-line {
    width: 60px;
    height: 2px;
    background-color: var(--vscode-panel-border);
    margin: 0 10px;
}

.setup-content {
    margin-bottom: 30px;
}

.setup-actions {
    text-align: center;
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    background-color: var(--vscode-sideBar-background);
}

.index-button {
    padding: 12px 24px;
    border: none;
    border-radius: 6px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-family: inherit;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.index-button:hover:not(:disabled) {
    background-color: var(--vscode-button-hoverBackground);
}

.index-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.action-help {
    margin: 10px 0 0 0;
    font-size: 14px;
    color: var(--vscode-descriptionForeground);
}

.indexing-progress {
    margin-top: 20px;
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 6px;
    background-color: var(--vscode-textCodeBlock-background);
}

.indexing-progress.hidden {
    display: none;
}

.indexing-progress h3 {
    margin: 0 0 15px 0;
    color: var(--vscode-textLink-foreground);
}

.progress-bar {
    width: 100%;
    height: 8px;
    background-color: var(--vscode-progressBar-background);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-fill {
    height: 100%;
    background-color: var(--vscode-progressBar-foreground);
    transition: width 0.3s ease;
    width: 0%;
}

.progress-text {
    margin: 0;
    font-size: 14px;
    color: var(--vscode-foreground);
}

.notification {
    padding: 12px 16px;
    border-radius: 4px;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.notification.error {
    background-color: var(--vscode-inputValidation-errorBackground);
    border: 1px solid var(--vscode-inputValidation-errorBorder);
    color: var(--vscode-inputValidation-errorForeground);
}

.notification.success {
    background-color: var(--vscode-charts-green);
    color: white;
}

.notification-close {
    background: none;
    border: none;
    color: inherit;
    font-size: 18px;
    cursor: pointer;
    padding: 0;
    margin-left: 10px;
}
`;
</file>

<file path="webview-backup-20250826-101914/src/lib/vscodeApi.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.vscodeApi = exports.VSCodeApiClient = void 0;
/**
 * VS Code API wrapper for webview communication
 */
class VSCodeApiClient {
    constructor() {
        this.messageListeners = new Map();
        this.pendingRequests = new Map();
        this.vscode = acquireVsCodeApi();
        this.setupMessageListener();
    }
    setupMessageListener() {
        window.addEventListener('message', (event) => {
            const message = event.data;
            // Handle responses with request IDs
            if (message.requestId && this.pendingRequests.has(message.requestId)) {
                const request = this.pendingRequests.get(message.requestId);
                clearTimeout(request.timeout);
                this.pendingRequests.delete(message.requestId);
                if (message.error) {
                    request.reject(new Error(message.error));
                }
                else {
                    request.resolve(message.result);
                }
                return;
            }
            // Handle general messages
            const listeners = this.messageListeners.get(message.command) || [];
            listeners.forEach(listener => listener(event));
        });
    }
    generateRequestId() {
        return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    sendRequestWithResponse(message, timeoutMs = 30000) {
        return new Promise((resolve, reject) => {
            const requestId = this.generateRequestId();
            message.requestId = requestId;
            const timeout = setTimeout(() => {
                this.pendingRequests.delete(requestId);
                reject(new Error('Request timeout'));
            }, timeoutMs);
            this.pendingRequests.set(requestId, { resolve, reject, timeout });
            this.vscode.postMessage(message);
        });
    }
    /**
     * Send a message to the extension
     */
    postMessage(message) {
        this.vscode.postMessage(message);
    }
    /**
     * Listen for messages from the extension
     */
    onMessage(command, listener) {
        if (!this.messageListeners.has(command)) {
            this.messageListeners.set(command, []);
        }
        this.messageListeners.get(command).push(listener);
    }
    /**
     * Remove message listener
     */
    offMessage(command, listener) {
        const listeners = this.messageListeners.get(command);
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }
    /**
     * Perform a search
     */
    async search(query) {
        return new Promise((resolve) => {
            const listener = (event) => {
                if (event.data.command === 'searchResults') {
                    this.offMessage('searchResults', listener);
                    resolve(event.data.results || []);
                }
            };
            this.onMessage('searchResults', listener);
            this.postMessage({ command: 'search', query });
        });
    }
    /**
     * Get file content
     */
    async getFileContent(filePath, includeRelatedChunks = false) {
        return this.sendRequestWithResponse({
            command: 'getFileContent',
            filePath,
            includeRelatedChunks
        });
    }
    /**
     * Find related files
     */
    async findRelatedFiles(query, currentFilePath, maxResults = 10, minSimilarity = 0.5) {
        return this.sendRequestWithResponse({
            command: 'findRelatedFiles',
            query,
            currentFilePath,
            maxResults,
            minSimilarity
        });
    }
    /**
     * Perform context query
     */
    async queryContext(contextQuery) {
        return this.sendRequestWithResponse({
            command: 'queryContext',
            contextQuery
        });
    }
    /**
     * Get service status
     */
    async getServiceStatus() {
        return this.sendRequestWithResponse({
            command: 'getServiceStatus'
        });
    }
    /**
     * Check setup status
     */
    async checkSetupStatus() {
        return this.sendRequestWithResponse({
            command: 'checkSetupStatus'
        });
    }
    /**
     * Send ping to test communication
     */
    async ping() {
        return this.sendRequestWithResponse({
            command: 'ping'
        });
    }
    /**
     * Start indexing
     */
    startIndexing() {
        this.postMessage({ command: 'startIndexing' });
    }
    /**
     * Open settings
     */
    openSettings() {
        this.postMessage({ command: 'openSettings' });
    }
    /**
     * Get webview state
     */
    getState() {
        return this.vscode.getState();
    }
    /**
     * Set webview state
     */
    setState(state) {
        this.vscode.setState(state);
    }
}
exports.VSCodeApiClient = VSCodeApiClient;
// Create and export a singleton instance
exports.vscodeApi = new VSCodeApiClient();
//# sourceMappingURL=vscodeApi.js.map
</file>

<file path="webview-backup-20250826-101914/src/lib/vscodeApi.js.map">
{"version":3,"file":"vscodeApi.js","sourceRoot":"","sources":["vscodeApi.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/lib/vscodeApi.ts">
// VS Code API types
interface VSCodeApi {
    postMessage(message: any): void;
    getState(): any;
    setState(state: any): void;
}

// Declare the global vscode API
declare const acquireVsCodeApi: () => VSCodeApi;

// Message types for type safety
export interface SearchRequest {
    command: 'search';
    query: string;
}

export interface FileContentRequest {
    command: 'getFileContent';
    requestId: string;
    filePath: string;
    includeRelatedChunks?: boolean;
}

export interface RelatedFilesRequest {
    command: 'findRelatedFiles';
    requestId: string;
    query: string;
    currentFilePath?: string;
    maxResults?: number;
    minSimilarity?: number;
}

export interface ContextQueryRequest {
    command: 'queryContext';
    requestId: string;
    contextQuery: {
        query: string;
        filePath?: string;
        includeRelated?: boolean;
        maxResults?: number;
        minSimilarity?: number;
        fileTypes?: string[];
    };
}

export interface ServiceStatusRequest {
    command: 'getServiceStatus';
}

// Response types
export interface SearchResult {
    file: string;
    snippet: string;
    line: number;
    score?: number;
    type?: string;
    name?: string;
    language?: string;
}

export interface FileContentResult {
    filePath: string;
    content: string;
    language?: string;
    size: number;
    lastModified: string;
    relatedChunks?: any[];
}

export interface RelatedFile {
    filePath: string;
    similarity: number;
    reason: string;
    chunkCount: number;
    language?: string;
}

export interface ContextResult {
    query: string;
    results: any[];
    relatedFiles: RelatedFile[];
    totalResults: number;
    processingTime: number;
}

export interface ServiceStatus {
    qdrantConnected: boolean;
    embeddingProvider: string | null;
    collectionExists: boolean;
    collectionInfo?: any;
}

export interface SetupStatus {
    isConfigured: boolean;
    hasConfigFile: boolean;
    databaseConfigured?: boolean;
    embeddingConfigured?: boolean;
}

// Event listener type
type MessageListener = (event: MessageEvent) => void;

/**
 * VS Code API wrapper for webview communication
 */
export class VSCodeApiClient {
    private vscode: VSCodeApi;
    private messageListeners: Map<string, MessageListener[]> = new Map();
    private pendingRequests: Map<string, {
        resolve: (value: any) => void;
        reject: (error: any) => void;
        timeout: NodeJS.Timeout;
    }> = new Map();

    constructor() {
        this.vscode = acquireVsCodeApi();
        this.setupMessageListener();
    }

    private setupMessageListener() {
        window.addEventListener('message', (event) => {
            const message = event.data;
            
            // Handle responses with request IDs
            if (message.requestId && this.pendingRequests.has(message.requestId)) {
                const request = this.pendingRequests.get(message.requestId)!;
                clearTimeout(request.timeout);
                this.pendingRequests.delete(message.requestId);
                
                if (message.error) {
                    request.reject(new Error(message.error));
                } else {
                    request.resolve(message.result);
                }
                return;
            }

            // Handle general messages
            const listeners = this.messageListeners.get(message.command) || [];
            listeners.forEach(listener => listener(event));
        });
    }

    private generateRequestId(): string {
        return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    private sendRequestWithResponse<T>(message: any, timeoutMs: number = 30000): Promise<T> {
        return new Promise((resolve, reject) => {
            const requestId = this.generateRequestId();
            message.requestId = requestId;

            const timeout = setTimeout(() => {
                this.pendingRequests.delete(requestId);
                reject(new Error('Request timeout'));
            }, timeoutMs);

            this.pendingRequests.set(requestId, { resolve, reject, timeout });
            this.vscode.postMessage(message);
        });
    }

    /**
     * Send a message to the extension
     */
    postMessage(message: any): void {
        this.vscode.postMessage(message);
    }

    /**
     * Listen for messages from the extension
     */
    onMessage(command: string, listener: MessageListener): void {
        if (!this.messageListeners.has(command)) {
            this.messageListeners.set(command, []);
        }
        this.messageListeners.get(command)!.push(listener);
    }

    /**
     * Remove message listener
     */
    offMessage(command: string, listener: MessageListener): void {
        const listeners = this.messageListeners.get(command);
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }

    /**
     * Perform a search
     */
    async search(query: string): Promise<SearchResult[]> {
        return new Promise((resolve) => {
            const listener = (event: MessageEvent) => {
                if (event.data.command === 'searchResults') {
                    this.offMessage('searchResults', listener);
                    resolve(event.data.results || []);
                }
            };
            
            this.onMessage('searchResults', listener);
            this.postMessage({ command: 'search', query });
        });
    }

    /**
     * Get file content
     */
    async getFileContent(filePath: string, includeRelatedChunks: boolean = false): Promise<FileContentResult> {
        return this.sendRequestWithResponse<FileContentResult>({
            command: 'getFileContent',
            filePath,
            includeRelatedChunks
        });
    }

    /**
     * Find related files
     */
    async findRelatedFiles(
        query: string, 
        currentFilePath?: string, 
        maxResults: number = 10, 
        minSimilarity: number = 0.5
    ): Promise<RelatedFile[]> {
        return this.sendRequestWithResponse<RelatedFile[]>({
            command: 'findRelatedFiles',
            query,
            currentFilePath,
            maxResults,
            minSimilarity
        });
    }

    /**
     * Perform context query
     */
    async queryContext(contextQuery: {
        query: string;
        filePath?: string;
        includeRelated?: boolean;
        maxResults?: number;
        minSimilarity?: number;
        fileTypes?: string[];
    }): Promise<ContextResult> {
        return this.sendRequestWithResponse<ContextResult>({
            command: 'queryContext',
            contextQuery
        });
    }

    /**
     * Get service status
     */
    async getServiceStatus(): Promise<ServiceStatus> {
        return this.sendRequestWithResponse<ServiceStatus>({
            command: 'getServiceStatus'
        });
    }

    /**
     * Check setup status
     */
    async checkSetupStatus(): Promise<{ isConfigured: boolean; status?: any; error?: string }> {
        return this.sendRequestWithResponse<{ isConfigured: boolean; status?: any; error?: string }>({
            command: 'checkSetupStatus'
        });
    }

    /**
     * Send ping to test communication
     */
    async ping(): Promise<any> {
        return this.sendRequestWithResponse<any>({
            command: 'ping'
        });
    }

    /**
     * Start indexing
     */
    startIndexing(): void {
        this.postMessage({ command: 'startIndexing' });
    }

    /**
     * Open settings
     */
    openSettings(): void {
        this.postMessage({ command: 'openSettings' });
    }

    /**
     * Get webview state
     */
    getState(): any {
        return this.vscode.getState();
    }

    /**
     * Set webview state
     */
    setState(state: any): void {
        this.vscode.setState(state);
    }
}

// Create and export a singleton instance
export const vscodeApi = new VSCodeApiClient();
</file>

<file path="webview-backup-20250826-101914/src/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Context Engine</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .header {
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
        }
        .progress-section {
            display: none;
        }
        .progress-section.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Code Context Engine</h1>
            <p>AI-powered code context and search for your workspace</p>
        </div>

        <div class="section">
            <h2>Communication Test</h2>
            <p>Test the communication bridge between webview and extension.</p>
            <fluent-button id="ping-button" appearance="stealth">Send Ping to Extension</fluent-button>
            <div id="ping-result" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;">
                <!-- Ping result will be displayed here -->
            </div>
        </div>

        <div class="section">
            <h2>Repository Indexing</h2>
            <p>Index your repository to enable AI-powered code search and context analysis.</p>
            <fluent-button id="index-button" appearance="accent">Index Repository</fluent-button>
            
            <div id="progress-section" class="progress-section">
                <h3>Indexing Progress</h3>
                <fluent-progress-ring id="progress-ring"></fluent-progress-ring>
                <p id="progress-text">Starting indexing process...</p>
            </div>
        </div>

        <div class="section">
            <h2>Search & Context</h2>
            <p>Search through your indexed code and get AI-powered context.</p>
            <fluent-text-field id="search-input" placeholder="Search your code..." style="width: 100%; margin-bottom: 10px;"></fluent-text-field>
            <fluent-button id="search-button">Search</fluent-button>
            
            <div id="search-results" style="margin-top: 20px;">
                <!-- Search results will be displayed here -->
            </div>
        </div>

        <div class="section">
            <h2>Settings</h2>
            <p>Configure your Code Context Engine preferences.</p>
            <fluent-button id="settings-button" appearance="stealth">Open Settings</fluent-button>
        </div>
    </div>
</body>
</html>
</file>

<file path="webview-backup-20250826-101914/src/index.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./styles.css");
const web_components_1 = require("@fluentui/web-components");
const vscodeApi_1 = require("./lib/vscodeApi");
const SetupView_1 = require("./lib/views/SetupView");
// Register Fluent UI components
(0, web_components_1.provideFluentDesignSystem)()
    .register((0, web_components_1.fluentButton)(), (0, web_components_1.fluentTextField)(), (0, web_components_1.fluentProgressRing)(), (0, web_components_1.fluentCard)(), (0, web_components_1.fluentBadge)(), (0, web_components_1.fluentAccordion)(), (0, web_components_1.fluentAccordionItem)());
class CodeContextWebview {
    constructor() {
        this.currentQuery = '';
        this.isSetupMode = false;
        this.setupView = null;
        this.setupState = {
            databaseReady: false,
            providerSelected: false,
            selectedProvider: '',
            databaseType: 'qdrant'
        };
        this.initializeElements();
        this.setupEventListeners();
        this.setupMessageListener();
        this.checkWorkspaceSetup();
    }
    initializeElements() {
        this.indexButton = document.getElementById('index-button');
        this.progressSection = document.getElementById('progress-section');
        this.progressRing = document.getElementById('progress-ring');
        this.progressText = document.getElementById('progress-text');
        this.searchButton = document.getElementById('search-button');
        this.searchInput = document.getElementById('search-input');
        this.searchResults = document.getElementById('search-results');
        this.settingsButton = document.getElementById('settings-button');
        this.serviceStatus = document.getElementById('service-status');
        this.relatedFilesSection = document.getElementById('related-files');
        this.pingButton = document.getElementById('ping-button');
        this.pingResult = document.getElementById('ping-result');
    }
    setupEventListeners() {
        this.indexButton?.addEventListener('click', () => {
            this.startIndexing();
        });
        this.searchButton?.addEventListener('click', () => {
            this.performSearch();
        });
        this.searchInput?.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                this.performSearch();
            }
        });
        // Add search suggestions
        this.searchInput?.addEventListener('input', () => {
            this.showSearchSuggestions();
        });
        this.settingsButton?.addEventListener('click', () => {
            this.openSettings();
        });
        this.pingButton?.addEventListener('click', () => {
            this.sendPing();
        });
    }
    setupMessageListener() {
        // Listen for indexing progress updates
        vscodeApi_1.vscodeApi.onMessage('indexingProgress', (event) => {
            this.updateIndexingProgress(event.data.progress, event.data.message);
        });
        // Listen for indexing completion
        vscodeApi_1.vscodeApi.onMessage('indexingComplete', (event) => {
            this.indexingComplete(event.data.result);
        });
        // Listen for search results
        vscodeApi_1.vscodeApi.onMessage('searchResults', (event) => {
            this.displaySearchResults(event.data.results, event.data.error);
        });
        // Setup completion listener - switch to main UI when setup is done
        vscodeApi_1.vscodeApi.onMessage('setupComplete', () => {
            this.isSetupMode = false;
            this.showMainUI();
            this.checkServiceStatus();
        });
    }
    handleSetupStatusResponse(message) {
        // This method handles the response from checkSetupStatus
        // It's called by the vscodeApi when a response is received
        if (message.error) {
            console.error('Setup status check failed:', message.error);
            this.showMainUI();
            this.checkServiceStatus();
        }
    }
    startIndexing() {
        vscodeApi_1.vscodeApi.startIndexing();
        // Show progress section
        this.progressSection?.classList.add('visible');
        if (this.indexButton) {
            this.indexButton.disabled = true;
        }
    }
    updateIndexingProgress(progress, message) {
        if (this.progressText) {
            this.progressText.textContent = message;
        }
        // Update progress ring if needed
    }
    indexingComplete(result) {
        if (this.progressText) {
            if (result && result.success) {
                this.progressText.textContent = `Indexing complete! Processed ${result.processedFiles} files, created ${result.chunks.length} chunks.`;
            }
            else {
                this.progressText.textContent = 'Indexing complete!';
            }
        }
        if (this.indexButton) {
            this.indexButton.disabled = false;
        }
        // Hide progress section after a delay
        setTimeout(() => {
            this.progressSection?.classList.remove('visible');
        }, 3000);
        // Refresh service status
        this.checkServiceStatus();
    }
    async performSearch() {
        const searchTerm = this.searchInput?.value;
        if (!searchTerm)
            return;
        this.currentQuery = searchTerm;
        // Add to search history
        this.addToSearchHistory(searchTerm);
        // Show loading state
        if (this.searchResults) {
            this.searchResults.innerHTML = '<p>Searching...</p>';
        }
        try {
            // Perform search using the new API
            const results = await vscodeApi_1.vscodeApi.search(searchTerm);
            this.displaySearchResults(results);
            // Find related files
            const relatedFiles = await vscodeApi_1.vscodeApi.findRelatedFiles(searchTerm, undefined, 5, 0.6);
            this.displayRelatedFiles(relatedFiles);
        }
        catch (error) {
            this.displaySearchResults([], `Search failed: ${error}`);
        }
    }
    displaySearchResults(results, error) {
        if (!this.searchResults)
            return;
        if (error) {
            this.searchResults.innerHTML = `<p style="color: var(--vscode-errorForeground);">${error}</p>`;
            return;
        }
        if (results.length === 0) {
            this.searchResults.innerHTML = '<p>No results found.</p>';
            return;
        }
        const resultsHtml = results.map(result => `
            <fluent-card style="margin-bottom: 15px; padding: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                    <h4 style="margin: 0; color: var(--vscode-textLink-foreground);">${result.file}</h4>
                    ${result.score ? `<fluent-badge appearance="accent">${(result.score * 100).toFixed(1)}%</fluent-badge>` : ''}
                </div>
                ${result.type && result.name ? `<p style="margin: 4px 0; font-size: 0.9em; color: var(--vscode-descriptionForeground);"><strong>${result.type}:</strong> ${result.name}</p>` : ''}
                <p style="margin: 8px 0; font-family: var(--vscode-editor-font-family); background: var(--vscode-textCodeBlock-background); padding: 8px; border-radius: 4px; font-size: 0.9em;">${result.snippet}</p>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <small style="color: var(--vscode-descriptionForeground);">Line ${result.line}${result.language ? `  ${result.language}` : ''}</small>
                    <fluent-button appearance="stealth" onclick="this.openFile('${result.file}', ${result.line})">Open</fluent-button>
                </div>
            </fluent-card>
        `).join('');
        this.searchResults.innerHTML = resultsHtml;
    }
    openSettings() {
        vscodeApi_1.vscodeApi.openSettings();
    }
    async sendPing() {
        if (!this.pingResult)
            return;
        try {
            // Show loading state
            this.pingResult.style.display = 'block';
            this.pingResult.style.backgroundColor = 'var(--vscode-textCodeBlock-background)';
            this.pingResult.style.color = 'var(--vscode-foreground)';
            this.pingResult.textContent = 'Sending ping...';
            // Send ping and wait for response
            const response = await vscodeApi_1.vscodeApi.ping();
            // Show success response
            this.pingResult.style.backgroundColor = 'var(--vscode-testing-iconPassed)';
            this.pingResult.style.color = 'white';
            this.pingResult.textContent = ` Received pong! Response time: ${response.timestamp}`;
            // Hide after 3 seconds
            setTimeout(() => {
                if (this.pingResult) {
                    this.pingResult.style.display = 'none';
                }
            }, 3000);
        }
        catch (error) {
            // Show error response
            this.pingResult.style.backgroundColor = 'var(--vscode-testing-iconFailed)';
            this.pingResult.style.color = 'white';
            this.pingResult.textContent = ` Ping failed: ${error}`;
            // Hide after 5 seconds
            setTimeout(() => {
                if (this.pingResult) {
                    this.pingResult.style.display = 'none';
                }
            }, 5000);
        }
    }
    addToSearchHistory(query) {
        const history = this.getSearchHistory();
        // Remove if already exists to avoid duplicates
        const index = history.indexOf(query);
        if (index > -1) {
            history.splice(index, 1);
        }
        // Add to beginning
        history.unshift(query);
        // Keep only last 10 searches
        if (history.length > 10) {
            history.splice(10);
        }
        localStorage.setItem('searchHistory', JSON.stringify(history));
    }
    getSearchHistory() {
        try {
            const history = localStorage.getItem('searchHistory');
            return history ? JSON.parse(history) : [];
        }
        catch {
            return [];
        }
    }
    showSearchSuggestions() {
        if (!this.searchInput)
            return;
        const query = this.searchInput.value.trim().toLowerCase();
        if (query.length < 2) {
            this.hideSuggestions();
            return;
        }
        const history = this.getSearchHistory();
        const suggestions = history.filter(item => item.toLowerCase().includes(query) && item.toLowerCase() !== query).slice(0, 5);
        if (suggestions.length > 0) {
            this.displaySuggestions(suggestions);
        }
        else {
            this.hideSuggestions();
        }
    }
    displaySuggestions(suggestions) {
        // Remove existing suggestions
        this.hideSuggestions();
        const suggestionsContainer = document.createElement('div');
        suggestionsContainer.id = 'search-suggestions';
        suggestionsContainer.className = 'search-suggestions';
        suggestions.forEach(suggestion => {
            const suggestionItem = document.createElement('div');
            suggestionItem.className = 'suggestion-item';
            suggestionItem.textContent = suggestion;
            suggestionItem.addEventListener('click', () => {
                if (this.searchInput) {
                    this.searchInput.value = suggestion;
                    this.performSearch();
                    this.hideSuggestions();
                }
            });
            suggestionsContainer.appendChild(suggestionItem);
        });
        // Insert after search input
        this.searchInput?.parentNode?.insertBefore(suggestionsContainer, this.searchInput.nextSibling);
    }
    hideSuggestions() {
        const existing = document.getElementById('search-suggestions');
        if (existing) {
            existing.remove();
        }
    }
    displayRelatedFiles(relatedFiles) {
        if (!this.relatedFilesSection)
            return;
        if (relatedFiles.length === 0) {
            this.relatedFilesSection.innerHTML = '<p>No related files found.</p>';
            return;
        }
        const relatedHtml = relatedFiles.map(file => `
            <fluent-card style="margin-bottom: 10px; padding: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h5 style="margin: 0; color: var(--vscode-textLink-foreground);">${file.filePath}</h5>
                        <p style="margin: 4px 0; font-size: 0.85em; color: var(--vscode-descriptionForeground);">${file.reason}</p>
                        <small style="color: var(--vscode-descriptionForeground);">${file.chunkCount} chunks  ${(file.similarity * 100).toFixed(1)}% similarity${file.language ? `  ${file.language}` : ''}</small>
                    </div>
                    <fluent-button appearance="stealth" onclick="this.openFile('${file.filePath}')">Open</fluent-button>
                </div>
            </fluent-card>
        `).join('');
        this.relatedFilesSection.innerHTML = `
            <h3>Related Files</h3>
            ${relatedHtml}
        `;
    }
    async checkWorkspaceSetup() {
        try {
            // Check if workspace is configured
            const setupStatus = await vscodeApi_1.vscodeApi.checkSetupStatus();
            this.isSetupMode = !setupStatus.isConfigured;
            if (this.isSetupMode) {
                this.showSetupUI();
            }
            else {
                this.showMainUI();
                this.checkServiceStatus();
            }
        }
        catch (error) {
            console.error('Failed to check workspace setup:', error);
            // Default to main UI if check fails
            this.showMainUI();
            this.checkServiceStatus();
        }
    }
    async checkServiceStatus() {
        try {
            const status = await vscodeApi_1.vscodeApi.getServiceStatus();
            this.displayServiceStatus(status);
        }
        catch (error) {
            console.error('Failed to get service status:', error);
        }
    }
    displayServiceStatus(status) {
        if (!this.serviceStatus)
            return;
        const qdrantStatus = status.qdrantConnected ?
            '<fluent-badge appearance="accent">Connected</fluent-badge>' :
            '<fluent-badge appearance="important">Disconnected</fluent-badge>';
        const embeddingStatus = status.embeddingProvider ?
            `<fluent-badge appearance="accent">${status.embeddingProvider}</fluent-badge>` :
            '<fluent-badge appearance="neutral">Not configured</fluent-badge>';
        const collectionStatus = status.collectionExists ?
            '<fluent-badge appearance="accent">Ready</fluent-badge>' :
            '<fluent-badge appearance="neutral">Not indexed</fluent-badge>';
        this.serviceStatus.innerHTML = `
            <div style="display: flex; gap: 15px; align-items: center; font-size: 0.9em;">
                <span>Database: ${qdrantStatus}</span>
                <span>Embeddings: ${embeddingStatus}</span>
                <span>Collection: ${collectionStatus}</span>
            </div>
        `;
    }
    async openFile(filePath, line) {
        try {
            // This would need to be implemented in the extension
            // For now, we can show file content in a modal or new section
            const content = await vscodeApi_1.vscodeApi.getFileContent(filePath, true);
            this.showFileContent(content, line);
        }
        catch (error) {
            console.error('Failed to open file:', error);
        }
    }
    showFileContent(content, line) {
        // Create a modal or new section to show file content
        // This is a simplified implementation
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 1000;
            display: flex; align-items: center; justify-content: center;
        `;
        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `
            background: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 8px; padding: 20px; max-width: 80%; max-height: 80%;
            overflow: auto; position: relative;
        `;
        contentDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>${content.filePath}</h3>
                <fluent-button appearance="stealth" onclick="this.parentElement.parentElement.remove()"></fluent-button>
            </div>
            <pre style="background: var(--vscode-textCodeBlock-background); padding: 15px; border-radius: 4px; overflow: auto; font-family: var(--vscode-editor-font-family); font-size: 0.9em;">${content.content}</pre>
            <div style="margin-top: 10px; font-size: 0.85em; color: var(--vscode-descriptionForeground);">
                Size: ${content.size} bytes  Modified: ${new Date(content.lastModified).toLocaleString()}
                ${content.language ? `  Language: ${content.language}` : ''}
            </div>
        `;
        modal.appendChild(contentDiv);
        document.body.appendChild(modal);
        // Close modal on background click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }
    showSetupUI() {
        // Hide main UI elements
        const mainSections = document.querySelectorAll('.section');
        mainSections.forEach(section => {
            section.style.display = 'none';
        });
        // Show or create setup UI
        this.createSetupUI();
    }
    showMainUI() {
        // Show main UI elements
        const mainSections = document.querySelectorAll('.section');
        mainSections.forEach(section => {
            section.style.display = 'block';
        });
        // Hide setup UI if it exists
        const setupContainer = document.getElementById('setup-container');
        if (setupContainer) {
            setupContainer.style.display = 'none';
        }
    }
    createSetupUI() {
        // Check if setup UI already exists
        let setupContainer = document.getElementById('setup-container');
        if (!setupContainer) {
            setupContainer = document.createElement('div');
            setupContainer.id = 'setup-container';
            setupContainer.className = 'setup-container';
            // Insert setup UI at the beginning of the container
            const container = document.querySelector('.container');
            if (container) {
                container.insertBefore(setupContainer, container.firstChild);
            }
            // Create and initialize the SetupView
            this.setupView = new SetupView_1.SetupView(setupContainer);
        }
        else {
            setupContainer.style.display = 'block';
            // Reinitialize SetupView if needed
            if (!this.setupView) {
                this.setupView = new SetupView_1.SetupView(setupContainer);
            }
        }
    }
}
// Initialize the webview when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new CodeContextWebview();
});
//# sourceMappingURL=index.js.map
</file>

<file path="webview-backup-20250826-101914/src/index.js.map">
{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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"}
</file>

<file path="webview-backup-20250826-101914/src/index.ts">
import './styles.css';
import {
    provideFluentDesignSystem,
    fluentButton,
    fluentTextField,
    fluentProgressRing,
    fluentCard,
    fluentBadge,
    fluentAccordion,
    fluentAccordionItem
} from '@fluentui/web-components';
import { vscodeApi, type SearchResult, type RelatedFile, type ServiceStatus } from './lib/vscodeApi';
import { SetupView } from './lib/views/SetupView';

// Setup state interface
interface SetupState {
    databaseReady: boolean;
    providerSelected: boolean;
    selectedProvider: string;
    databaseType: string;
}

// Register Fluent UI components
provideFluentDesignSystem()
    .register(
        fluentButton(),
        fluentTextField(),
        fluentProgressRing(),
        fluentCard(),
        fluentBadge(),
        fluentAccordion(),
        fluentAccordionItem()
    );

class CodeContextWebview {
    private indexButton: HTMLElement | null;
    private progressSection: HTMLElement | null;
    private progressRing: HTMLElement | null;
    private progressText: HTMLElement | null;
    private searchButton: HTMLElement | null;
    private searchInput: HTMLElement | null;
    private searchResults: HTMLElement | null;
    private settingsButton: HTMLElement | null;
    private serviceStatus: HTMLElement | null;
    private relatedFilesSection: HTMLElement | null;
    private pingButton: HTMLElement | null;
    private pingResult: HTMLElement | null;
    private currentQuery: string = '';
    private isSetupMode: boolean = false;
    private setupView: SetupView | null = null;
    private setupState: SetupState = {
        databaseReady: false,
        providerSelected: false,
        selectedProvider: '',
        databaseType: 'qdrant'
    };

    constructor() {
        this.initializeElements();
        this.setupEventListeners();
        this.setupMessageListener();
        this.checkWorkspaceSetup();
    }

    private initializeElements(): void {
        this.indexButton = document.getElementById('index-button');
        this.progressSection = document.getElementById('progress-section');
        this.progressRing = document.getElementById('progress-ring');
        this.progressText = document.getElementById('progress-text');
        this.searchButton = document.getElementById('search-button');
        this.searchInput = document.getElementById('search-input');
        this.searchResults = document.getElementById('search-results');
        this.settingsButton = document.getElementById('settings-button');
        this.serviceStatus = document.getElementById('service-status');
        this.relatedFilesSection = document.getElementById('related-files');
        this.pingButton = document.getElementById('ping-button');
        this.pingResult = document.getElementById('ping-result');
    }

    private setupEventListeners(): void {
        this.indexButton?.addEventListener('click', () => {
            this.startIndexing();
        });

        this.searchButton?.addEventListener('click', () => {
            this.performSearch();
        });

        this.searchInput?.addEventListener('keypress', (event) => {
            if ((event as KeyboardEvent).key === 'Enter') {
                this.performSearch();
            }
        });

        // Add search suggestions
        this.searchInput?.addEventListener('input', () => {
            this.showSearchSuggestions();
        });

        this.settingsButton?.addEventListener('click', () => {
            this.openSettings();
        });

        this.pingButton?.addEventListener('click', () => {
            this.sendPing();
        });
    }

    private setupMessageListener(): void {
        // Listen for indexing progress updates
        vscodeApi.onMessage('indexingProgress', (event) => {
            this.updateIndexingProgress(event.data.progress, event.data.message);
        });

        // Listen for indexing completion
        vscodeApi.onMessage('indexingComplete', (event) => {
            this.indexingComplete(event.data.result);
        });

        // Listen for search results
        vscodeApi.onMessage('searchResults', (event) => {
            this.displaySearchResults(event.data.results, event.data.error);
        });

        // Setup completion listener - switch to main UI when setup is done
        vscodeApi.onMessage('setupComplete', () => {
            this.isSetupMode = false;
            this.showMainUI();
            this.checkServiceStatus();
        });
    }

    private handleSetupStatusResponse(message: any): void {
        // This method handles the response from checkSetupStatus
        // It's called by the vscodeApi when a response is received
        if (message.error) {
            console.error('Setup status check failed:', message.error);
            this.showMainUI();
            this.checkServiceStatus();
        }
    }

    private startIndexing(): void {
        vscodeApi.startIndexing();

        // Show progress section
        this.progressSection?.classList.add('visible');
        if (this.indexButton) {
            (this.indexButton as any).disabled = true;
        }
    }

    private updateIndexingProgress(progress: number, message: string): void {
        if (this.progressText) {
            this.progressText.textContent = message;
        }
        // Update progress ring if needed
    }

    private indexingComplete(result?: any): void {
        if (this.progressText) {
            if (result && result.success) {
                this.progressText.textContent = `Indexing complete! Processed ${result.processedFiles} files, created ${result.chunks.length} chunks.`;
            } else {
                this.progressText.textContent = 'Indexing complete!';
            }
        }
        if (this.indexButton) {
            (this.indexButton as any).disabled = false;
        }

        // Hide progress section after a delay
        setTimeout(() => {
            this.progressSection?.classList.remove('visible');
        }, 3000);

        // Refresh service status
        this.checkServiceStatus();
    }

    private async performSearch(): Promise<void> {
        const searchTerm = (this.searchInput as any)?.value;
        if (!searchTerm) return;

        this.currentQuery = searchTerm;

        // Add to search history
        this.addToSearchHistory(searchTerm);

        // Show loading state
        if (this.searchResults) {
            this.searchResults.innerHTML = '<p>Searching...</p>';
        }

        try {
            // Perform search using the new API
            const results = await vscodeApi.search(searchTerm);
            this.displaySearchResults(results);

            // Find related files
            const relatedFiles = await vscodeApi.findRelatedFiles(searchTerm, undefined, 5, 0.6);
            this.displayRelatedFiles(relatedFiles);

        } catch (error) {
            this.displaySearchResults([], `Search failed: ${error}`);
        }
    }

    private displaySearchResults(results: SearchResult[], error?: string): void {
        if (!this.searchResults) return;

        if (error) {
            this.searchResults.innerHTML = `<p style="color: var(--vscode-errorForeground);">${error}</p>`;
            return;
        }

        if (results.length === 0) {
            this.searchResults.innerHTML = '<p>No results found.</p>';
            return;
        }

        const resultsHtml = results.map(result => `
            <fluent-card style="margin-bottom: 15px; padding: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                    <h4 style="margin: 0; color: var(--vscode-textLink-foreground);">${result.file}</h4>
                    ${result.score ? `<fluent-badge appearance="accent">${(result.score * 100).toFixed(1)}%</fluent-badge>` : ''}
                </div>
                ${result.type && result.name ? `<p style="margin: 4px 0; font-size: 0.9em; color: var(--vscode-descriptionForeground);"><strong>${result.type}:</strong> ${result.name}</p>` : ''}
                <p style="margin: 8px 0; font-family: var(--vscode-editor-font-family); background: var(--vscode-textCodeBlock-background); padding: 8px; border-radius: 4px; font-size: 0.9em;">${result.snippet}</p>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <small style="color: var(--vscode-descriptionForeground);">Line ${result.line}${result.language ? `  ${result.language}` : ''}</small>
                    <fluent-button appearance="stealth" onclick="this.openFile('${result.file}', ${result.line})">Open</fluent-button>
                </div>
            </fluent-card>
        `).join('');

        this.searchResults.innerHTML = resultsHtml;
    }

    private openSettings(): void {
        vscodeApi.openSettings();
    }

    private async sendPing(): Promise<void> {
        if (!this.pingResult) return;

        try {
            // Show loading state
            this.pingResult.style.display = 'block';
            this.pingResult.style.backgroundColor = 'var(--vscode-textCodeBlock-background)';
            this.pingResult.style.color = 'var(--vscode-foreground)';
            this.pingResult.textContent = 'Sending ping...';

            // Send ping and wait for response
            const response = await vscodeApi.ping();

            // Show success response
            this.pingResult.style.backgroundColor = 'var(--vscode-testing-iconPassed)';
            this.pingResult.style.color = 'white';
            this.pingResult.textContent = ` Received pong! Response time: ${response.timestamp}`;

            // Hide after 3 seconds
            setTimeout(() => {
                if (this.pingResult) {
                    this.pingResult.style.display = 'none';
                }
            }, 3000);

        } catch (error) {
            // Show error response
            this.pingResult.style.backgroundColor = 'var(--vscode-testing-iconFailed)';
            this.pingResult.style.color = 'white';
            this.pingResult.textContent = ` Ping failed: ${error}`;

            // Hide after 5 seconds
            setTimeout(() => {
                if (this.pingResult) {
                    this.pingResult.style.display = 'none';
                }
            }, 5000);
        }
    }

    private addToSearchHistory(query: string): void {
        const history = this.getSearchHistory();

        // Remove if already exists to avoid duplicates
        const index = history.indexOf(query);
        if (index > -1) {
            history.splice(index, 1);
        }

        // Add to beginning
        history.unshift(query);

        // Keep only last 10 searches
        if (history.length > 10) {
            history.splice(10);
        }

        localStorage.setItem('searchHistory', JSON.stringify(history));
    }

    private getSearchHistory(): string[] {
        try {
            const history = localStorage.getItem('searchHistory');
            return history ? JSON.parse(history) : [];
        } catch {
            return [];
        }
    }

    private showSearchSuggestions(): void {
        if (!this.searchInput) return;

        const query = (this.searchInput as any).value.trim().toLowerCase();
        if (query.length < 2) {
            this.hideSuggestions();
            return;
        }

        const history = this.getSearchHistory();
        const suggestions = history.filter(item =>
            item.toLowerCase().includes(query) && item.toLowerCase() !== query
        ).slice(0, 5);

        if (suggestions.length > 0) {
            this.displaySuggestions(suggestions);
        } else {
            this.hideSuggestions();
        }
    }

    private displaySuggestions(suggestions: string[]): void {
        // Remove existing suggestions
        this.hideSuggestions();

        const suggestionsContainer = document.createElement('div');
        suggestionsContainer.id = 'search-suggestions';
        suggestionsContainer.className = 'search-suggestions';

        suggestions.forEach(suggestion => {
            const suggestionItem = document.createElement('div');
            suggestionItem.className = 'suggestion-item';
            suggestionItem.textContent = suggestion;
            suggestionItem.addEventListener('click', () => {
                if (this.searchInput) {
                    (this.searchInput as any).value = suggestion;
                    this.performSearch();
                    this.hideSuggestions();
                }
            });
            suggestionsContainer.appendChild(suggestionItem);
        });

        // Insert after search input
        this.searchInput?.parentNode?.insertBefore(suggestionsContainer, this.searchInput.nextSibling);
    }

    private hideSuggestions(): void {
        const existing = document.getElementById('search-suggestions');
        if (existing) {
            existing.remove();
        }
    }

    private displayRelatedFiles(relatedFiles: RelatedFile[]): void {
        if (!this.relatedFilesSection) return;

        if (relatedFiles.length === 0) {
            this.relatedFilesSection.innerHTML = '<p>No related files found.</p>';
            return;
        }

        const relatedHtml = relatedFiles.map(file => `
            <fluent-card style="margin-bottom: 10px; padding: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h5 style="margin: 0; color: var(--vscode-textLink-foreground);">${file.filePath}</h5>
                        <p style="margin: 4px 0; font-size: 0.85em; color: var(--vscode-descriptionForeground);">${file.reason}</p>
                        <small style="color: var(--vscode-descriptionForeground);">${file.chunkCount} chunks  ${(file.similarity * 100).toFixed(1)}% similarity${file.language ? `  ${file.language}` : ''}</small>
                    </div>
                    <fluent-button appearance="stealth" onclick="this.openFile('${file.filePath}')">Open</fluent-button>
                </div>
            </fluent-card>
        `).join('');

        this.relatedFilesSection.innerHTML = `
            <h3>Related Files</h3>
            ${relatedHtml}
        `;
    }

    private async checkWorkspaceSetup(): Promise<void> {
        try {
            // Check if workspace is configured
            const setupStatus = await vscodeApi.checkSetupStatus();
            this.isSetupMode = !setupStatus.isConfigured;

            if (this.isSetupMode) {
                this.showSetupUI();
            } else {
                this.showMainUI();
                this.checkServiceStatus();
            }
        } catch (error) {
            console.error('Failed to check workspace setup:', error);
            // Default to main UI if check fails
            this.showMainUI();
            this.checkServiceStatus();
        }
    }

    private async checkServiceStatus(): Promise<void> {
        try {
            const status = await vscodeApi.getServiceStatus();
            this.displayServiceStatus(status);
        } catch (error) {
            console.error('Failed to get service status:', error);
        }
    }

    private displayServiceStatus(status: ServiceStatus): void {
        if (!this.serviceStatus) return;

        const qdrantStatus = status.qdrantConnected ?
            '<fluent-badge appearance="accent">Connected</fluent-badge>' :
            '<fluent-badge appearance="important">Disconnected</fluent-badge>';

        const embeddingStatus = status.embeddingProvider ?
            `<fluent-badge appearance="accent">${status.embeddingProvider}</fluent-badge>` :
            '<fluent-badge appearance="neutral">Not configured</fluent-badge>';

        const collectionStatus = status.collectionExists ?
            '<fluent-badge appearance="accent">Ready</fluent-badge>' :
            '<fluent-badge appearance="neutral">Not indexed</fluent-badge>';

        this.serviceStatus.innerHTML = `
            <div style="display: flex; gap: 15px; align-items: center; font-size: 0.9em;">
                <span>Database: ${qdrantStatus}</span>
                <span>Embeddings: ${embeddingStatus}</span>
                <span>Collection: ${collectionStatus}</span>
            </div>
        `;
    }

    private async openFile(filePath: string, line?: number): Promise<void> {
        try {
            // This would need to be implemented in the extension
            // For now, we can show file content in a modal or new section
            const content = await vscodeApi.getFileContent(filePath, true);
            this.showFileContent(content, line);
        } catch (error) {
            console.error('Failed to open file:', error);
        }
    }

    private showFileContent(content: any, line?: number): void {
        // Create a modal or new section to show file content
        // This is a simplified implementation
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 1000;
            display: flex; align-items: center; justify-content: center;
        `;

        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `
            background: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 8px; padding: 20px; max-width: 80%; max-height: 80%;
            overflow: auto; position: relative;
        `;

        contentDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>${content.filePath}</h3>
                <fluent-button appearance="stealth" onclick="this.parentElement.parentElement.remove()"></fluent-button>
            </div>
            <pre style="background: var(--vscode-textCodeBlock-background); padding: 15px; border-radius: 4px; overflow: auto; font-family: var(--vscode-editor-font-family); font-size: 0.9em;">${content.content}</pre>
            <div style="margin-top: 10px; font-size: 0.85em; color: var(--vscode-descriptionForeground);">
                Size: ${content.size} bytes  Modified: ${new Date(content.lastModified).toLocaleString()}
                ${content.language ? `  Language: ${content.language}` : ''}
            </div>
        `;

        modal.appendChild(contentDiv);
        document.body.appendChild(modal);

        // Close modal on background click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }

    private showSetupUI(): void {
        // Hide main UI elements
        const mainSections = document.querySelectorAll('.section');
        mainSections.forEach(section => {
            (section as HTMLElement).style.display = 'none';
        });

        // Show or create setup UI
        this.createSetupUI();
    }

    private showMainUI(): void {
        // Show main UI elements
        const mainSections = document.querySelectorAll('.section');
        mainSections.forEach(section => {
            (section as HTMLElement).style.display = 'block';
        });

        // Hide setup UI if it exists
        const setupContainer = document.getElementById('setup-container');
        if (setupContainer) {
            setupContainer.style.display = 'none';
        }
    }

    private createSetupUI(): void {
        // Check if setup UI already exists
        let setupContainer = document.getElementById('setup-container');
        if (!setupContainer) {
            setupContainer = document.createElement('div');
            setupContainer.id = 'setup-container';
            setupContainer.className = 'setup-container';

            // Insert setup UI at the beginning of the container
            const container = document.querySelector('.container');
            if (container) {
                container.insertBefore(setupContainer, container.firstChild);
            }

            // Create and initialize the SetupView
            this.setupView = new SetupView(setupContainer);
        } else {
            setupContainer.style.display = 'block';
            // Reinitialize SetupView if needed
            if (!this.setupView) {
                this.setupView = new SetupView(setupContainer);
            }
        }
    }




}

// Initialize the webview when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new CodeContextWebview();
});
</file>

<file path="webview-backup-20250826-101914/src/styles.css">
/* VS Code theme integration */
:root {
  --vscode-font-family: var(--vscode-font-family, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif);
  --vscode-foreground: var(--vscode-foreground, #cccccc);
  --vscode-editor-background: var(--vscode-editor-background, #1e1e1e);
  --vscode-panel-border: var(--vscode-panel-border, #3c3c3c);
  --vscode-button-background: var(--vscode-button-background, #0e639c);
  --vscode-button-foreground: var(--vscode-button-foreground, #ffffff);
  --vscode-button-hoverBackground: var(--vscode-button-hoverBackground, #1177bb);
}

/* Fluent UI component customization for VS Code theme */
fluent-button {
  --accent-fill-rest: var(--vscode-button-background);
  --accent-fill-hover: var(--vscode-button-hoverBackground);
  --accent-foreground-rest: var(--vscode-button-foreground);
  --neutral-fill-rest: var(--vscode-editor-background);
  --neutral-stroke-rest: var(--vscode-panel-border);
}

fluent-text-field {
  --neutral-fill-rest: var(--vscode-editor-background);
  --neutral-stroke-rest: var(--vscode-panel-border);
  --neutral-foreground-rest: var(--vscode-foreground);
}

fluent-progress-ring {
  --accent-fill-rest: var(--vscode-button-background);
}

/* Custom styles */
.container {
  font-family: var(--vscode-font-family);
  color: var(--vscode-foreground);
  background-color: var(--vscode-editor-background);
}

.section {
  background-color: var(--vscode-editor-background);
  border-color: var(--vscode-panel-border);
}

.section h2 {
  margin-top: 0;
  color: var(--vscode-foreground);
}

.section h3 {
  color: var(--vscode-foreground);
}

.section p {
  color: var(--vscode-foreground);
  opacity: 0.8;
}

/* Progress section animations */
.progress-section {
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
}

.progress-section.visible {
  opacity: 1;
  max-height: 200px;
  margin-top: 20px;
}

/* Search results styling */
#search-results {
  max-height: 400px;
  overflow-y: auto;
}

#search-results h4 {
  margin: 0 0 5px 0;
  color: var(--vscode-button-background);
}

#search-results p {
  margin: 5px 0;
  font-family: 'Courier New', monospace;
  font-size: 0.9em;
  background-color: rgba(255, 255, 255, 0.05);
  padding: 5px;
  border-radius: 3px;
}

#search-results small {
  color: var(--vscode-foreground);
  opacity: 0.6;
}

/* Search suggestions styles */
.search-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background-color: var(--vscode-dropdown-background, var(--vscode-editor-background));
  border: 1px solid var(--vscode-dropdown-border, var(--vscode-panel-border));
  border-top: none;
  border-radius: 0 0 4px 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  z-index: 1000;
  max-height: 200px;
  overflow-y: auto;
}

.suggestion-item {
  padding: 8px 12px;
  cursor: pointer;
  color: var(--vscode-dropdown-foreground, var(--vscode-foreground));
  border-bottom: 1px solid var(--vscode-dropdown-border, var(--vscode-panel-border));
}

.suggestion-item:last-child {
  border-bottom: none;
}

.suggestion-item:hover {
  background-color: var(--vscode-list-hoverBackground, rgba(255, 255, 255, 0.1));
}

.search-input-container {
  position: relative;
  display: inline-block;
  width: 100%;
}

/* Setup UI styles */
.setup-container {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.setup-header {
  text-align: center;
  margin-bottom: 40px;
  padding: 30px;
  background: var(--vscode-textCodeBlock-background);
  border-radius: 8px;
}

.setup-header h1 {
  margin: 0 0 10px 0;
  color: var(--vscode-foreground);
}

.setup-header p {
  margin: 0;
  color: var(--vscode-descriptionForeground);
}

.setup-section {
  margin-bottom: 30px;
  padding: 20px;
  border: 1px solid var(--vscode-panel-border);
  border-radius: 8px;
  background: var(--vscode-editor-background);
}

.setup-section h2 {
  margin-top: 0;
  color: var(--vscode-textLink-foreground);
  border-bottom: 1px solid var(--vscode-panel-border);
  padding-bottom: 10px;
}

.setup-item {
  margin-bottom: 15px;
}

.setup-item label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
  color: var(--vscode-foreground);
}

.setup-select {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--vscode-input-border);
  background-color: var(--vscode-input-background);
  color: var(--vscode-input-foreground);
  border-radius: 4px;
  font-family: inherit;
  font-size: inherit;
}

.setup-description {
  font-size: 0.9em;
  color: var(--vscode-descriptionForeground);
  margin: 5px 0 0 0;
}

.setup-controls {
  display: flex;
  gap: 10px;
  align-items: center;
  margin-top: 15px;
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9em;
}

.status-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.status-unknown { background-color: #ff9800; }
.status-running { background-color: #4CAF50; }
.status-stopped { background-color: #f44336; }

.provider-config {
  margin-top: 15px;
  padding: 15px;
  background: var(--vscode-textCodeBlock-background);
  border-radius: 4px;
}

.setup-actions {
  text-align: center;
  margin-top: 30px;
  padding: 20px;
  background: var(--vscode-textCodeBlock-background);
  border-radius: 8px;
}

.setup-status {
  margin-top: 15px;
  font-size: 0.9em;
}

.setup-status.info {
  color: var(--vscode-foreground);
}

.setup-status.success {
  color: var(--vscode-textLink-foreground);
}

.setup-status.error {
  color: var(--vscode-errorForeground);
}
</file>

<file path="webview-backup-20250826-101914/package.json">
{
  "name": "code-context-engine-webview",
  "version": "1.0.0",
  "description": "Webview for Code Context Engine VS Code Extension",
  "main": "dist/index.js",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack --mode development --watch",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "webpack": "^5.88.0",
    "webpack-cli": "^5.1.0",
    "ts-loader": "^9.4.0",
    "typescript": "^4.9.0",
    "css-loader": "^6.8.0",
    "style-loader": "^3.3.0",
    "html-webpack-plugin": "^5.5.0"
  },
  "dependencies": {
    "@fluentui/web-components": "^2.5.16"
  }
}
</file>

<file path="webview-backup-20250826-101914/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "DOM",
      "DOM.Iterable",
      "ES6"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": false,
    "strictPropertyInitialization": false,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": false,
    "declaration": true,
    "outDir": "./dist"
  },
  "include": [
    "src"
  ]
}
</file>

<file path="webview-backup-20250826-101914/webpack.config.js">
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.ts',
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html',
    }),
  ],
};
</file>

<file path=".eslintrc.json">
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 6,
        "sourceType": "module"
    },
    "plugins": [
        "@typescript-eslint"
    ],
    "rules": {
        "@typescript-eslint/naming-convention": [
            "warn",
            {
                "selector": "import",
                "format": [ "camelCase", "PascalCase" ]
            }
        ],
        "@typescript-eslint/semi": "warn",
        "curly": "warn",
        "eqeqeq": "warn",
        "no-throw-literal": "warn",
        "semi": "off"
    },
    "ignorePatterns": [
        "out",
        "dist",
        "**/*.d.ts"
    ]
}
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
</file>

<file path=".vscodeignore">
# Source files
src/**
webview/src/**
webview/node_modules/**

# Build artifacts
*.vsix
out/test/**

# Development files
.vscode/**
.vscode-test/**
.gitignore
.github/**
.eslintrc.json
tsconfig.json
vsc-extension-quickstart.md

# Documentation
docs/**
*.md
!README.md

# Node modules and dependencies
node_modules/**
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Test files
test/**
**/*.test.ts
**/*.spec.ts

# Configuration files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.idea/**
*.swp
*.swo
*~

# OS files
.DS_Store
Thumbs.db

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Repomix output
repomix-output.xml
repomix.config.json

# Docker files
docker-compose.yml
Dockerfile*

# Development scripts
scripts/**
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  qdrant:
    image: qdrant/qdrant:latest
    container_name: code-context-qdrant
    ports:
      - "6333:6333"  # REST API port
      - "6334:6334"  # gRPC port
    volumes:
      - ./qdrant_storage:/qdrant/storage
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
      - QDRANT__SERVICE__GRPC_PORT=6334
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Optional: Ollama service for local embeddings
  # Uncomment if you want to run Ollama locally
  # ollama:
  #   image: ollama/ollama:latest
  #   container_name: code-context-ollama
  #   ports:
  #     - "11434:11434"
  #   volumes:
  #     - ./ollama_data:/root/.ollama
  #   restart: unless-stopped
  #   environment:
  #     - OLLAMA_HOST=0.0.0.0
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="src/db/qdrantService.ts">
import { QdrantClient } from '@qdrant/js-client-rest';
import { CodeChunk } from '../parsing/chunker';

export interface QdrantPoint {
    id: string | number;
    vector: number[];
    payload: {
        filePath: string;
        content: string;
        startLine: number;
        endLine: number;
        type: string;
        name?: string;
        signature?: string;
        docstring?: string;
        language: string;
        metadata?: Record<string, any>;
    };
}

export interface SearchResult {
    id: string | number;
    score: number;
    payload: QdrantPoint['payload'];
}

export class QdrantService {
    private client: QdrantClient;
    private connectionString: string;

    /**
     * Constructor now accepts connectionString as a required parameter
     * This enables dependency injection and removes direct VS Code configuration access
     */
    constructor(connectionString: string) {
        this.connectionString = connectionString;
        this.client = new QdrantClient({
            host: this.extractHost(connectionString),
            port: this.extractPort(connectionString)
        });
    }

    private extractHost(connectionString: string): string {
        try {
            const url = new URL(connectionString);
            return url.hostname;
        } catch {
            return 'localhost';
        }
    }

    private extractPort(connectionString: string): number {
        try {
            const url = new URL(connectionString);
            return parseInt(url.port) || 6333;
        } catch {
            return 6333;
        }
    }

    /**
     * Check if Qdrant service is accessible
     */
    async healthCheck(): Promise<boolean> {
        try {
            await this.client.getCollections();
            return true;
        } catch (error) {
            console.error('Qdrant health check failed:', error);
            return false;
        }
    }

    /**
     * Create a collection if it doesn't exist
     */
    async createCollectionIfNotExists(
        collectionName: string, 
        vectorSize: number = 768, 
        distance: 'Cosine' | 'Dot' | 'Euclid' = 'Cosine'
    ): Promise<boolean> {
        try {
            // Check if collection exists
            const collections = await this.client.getCollections();
            const existingCollection = collections.collections?.find(
                col => col.name === collectionName
            );

            if (existingCollection) {
                console.log(`Collection '${collectionName}' already exists`);
                return true;
            }

            // Create new collection
            await this.client.createCollection(collectionName, {
                vectors: {
                    size: vectorSize,
                    distance: distance
                }
            });

            console.log(`Collection '${collectionName}' created successfully`);
            return true;
        } catch (error) {
            console.error(`Failed to create collection '${collectionName}':`, error);
            return false;
        }
    }

    /**
     * Convert CodeChunk to QdrantPoint format
     */
    private chunkToPoint(chunk: CodeChunk, vector: number[], index: number): QdrantPoint {
        return {
            id: `${chunk.filePath}:${chunk.startLine}-${chunk.endLine}:${index}`,
            vector: vector,
            payload: {
                filePath: chunk.filePath,
                content: chunk.content,
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                type: chunk.type,
                name: chunk.name,
                signature: chunk.signature,
                docstring: chunk.docstring,
                language: chunk.language,
                metadata: chunk.metadata
            }
        };
    }

    /**
     * Upsert chunks with their vectors into the collection
     */
    async upsertChunks(
        collectionName: string, 
        chunks: CodeChunk[], 
        vectors: number[][]
    ): Promise<boolean> {
        try {
            if (chunks.length !== vectors.length) {
                throw new Error(`Chunks count (${chunks.length}) doesn't match vectors count (${vectors.length})`);
            }

            // Convert chunks to points
            const points = chunks.map((chunk, index) => 
                this.chunkToPoint(chunk, vectors[index], index)
            );

            // Upsert points in batches to avoid memory issues
            const batchSize = 100;
            for (let i = 0; i < points.length; i += batchSize) {
                const batch = points.slice(i, i + batchSize);
                
                await this.client.upsert(collectionName, {
                    wait: true,
                    points: batch
                });

                console.log(`Upserted batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(points.length / batchSize)} (${batch.length} points)`);
            }

            console.log(`Successfully upserted ${points.length} chunks to collection '${collectionName}'`);
            return true;
        } catch (error) {
            console.error(`Failed to upsert chunks to collection '${collectionName}':`, error);
            return false;
        }
    }

    /**
     * Search for similar vectors in the collection
     */
    async search(
        collectionName: string, 
        queryVector: number[], 
        limit: number = 10,
        filter?: any
    ): Promise<SearchResult[]> {
        try {
            const searchResult = await this.client.search(collectionName, {
                vector: queryVector,
                limit: limit,
                with_payload: true,
                filter: filter
            });

            return searchResult.map(point => ({
                id: point.id,
                score: point.score || 0,
                payload: point.payload as QdrantPoint['payload']
            }));
        } catch (error) {
            console.error(`Search failed in collection '${collectionName}':`, error);
            return [];
        }
    }

    /**
     * Get collection info
     */
    async getCollectionInfo(collectionName: string): Promise<any> {
        try {
            return await this.client.getCollection(collectionName);
        } catch (error) {
            console.error(`Failed to get collection info for '${collectionName}':`, error);
            return null;
        }
    }

    /**
     * Delete collection
     */
    async deleteCollection(collectionName: string): Promise<boolean> {
        try {
            await this.client.deleteCollection(collectionName);
            console.log(`Collection '${collectionName}' deleted successfully`);
            return true;
        } catch (error) {
            console.error(`Failed to delete collection '${collectionName}':`, error);
            return false;
        }
    }

    /**
     * Get all collections
     */
    async getCollections(): Promise<string[]> {
        try {
            const collections = await this.client.getCollections();
            return collections.collections?.map(col => col.name) || [];
        } catch (error) {
            console.error('Failed to get collections:', error);
            return [];
        }
    }
}
</file>

<file path="src/embeddings/embeddingProvider.ts">
/**
 * Core interface for embedding providers that can generate vector embeddings from text
 *
 * This interface defines the contract that all embedding providers must implement,
 * ensuring consistent behavior across different embedding services (OpenAI, Ollama, etc.)
 */
export interface IEmbeddingProvider {
    /**
     * Generate vector embeddings for an array of text chunks
     *
     * This is the main method that converts text into numerical vector representations
     * that can be used for semantic search, similarity comparison, and other AI tasks.
     *
     * @param chunks - Array of text strings to convert to embeddings
     * @returns Promise resolving to array of embedding vectors, where each vector
     *          corresponds to the input chunk at the same index
     */
    generateEmbeddings(chunks: string[]): Promise<number[][]>;

    /**
     * Get the dimension size of embeddings produced by this provider
     *
     * Different embedding models produce vectors of different dimensions.
     * This information is crucial for vector database operations and compatibility checks.
     *
     * @returns The vector dimension size (e.g., 768, 1536, 1024)
     */
    getDimensions(): number;

    /**
     * Get the name/identifier of this embedding provider
     *
     * This method returns a unique identifier that includes both the provider type
     * and the specific model being used, useful for logging and debugging.
     *
     * @returns Provider name in format "provider:model" (e.g., "openai:text-embedding-ada-002")
     */
    getProviderName(): string;

    /**
     * Check if the provider is properly configured and available
     *
     * This method validates that the provider service is accessible and properly
     * configured before attempting to use it for embedding generation.
     *
     * @returns Promise resolving to true if provider is ready and available
     */
    isAvailable(): Promise<boolean>;
}

/**
 * Configuration interface for embedding providers
 *
 * This interface defines the configuration options needed to initialize
 * different types of embedding providers. The structure is designed to be
 * flexible enough to work with various embedding services while maintaining
 * a consistent interface.
 */
export interface EmbeddingConfig {
    /** The type of embedding provider to use ('ollama' or 'openai') */
    provider: 'ollama' | 'openai';
    
    /** The specific model name to use for embeddings (optional, uses default if not specified) */
    model?: string;
    
    /** API key for authentication (required for OpenAI, not needed for Ollama) */
    apiKey?: string;
    
    /** Base URL for the embedding service (optional, uses default if not specified) */
    baseUrl?: string;
    
    /** Maximum number of chunks to process in a single batch (optional, uses provider defaults) */
    maxBatchSize?: number;
    
    /** Timeout for API requests in milliseconds (optional, uses provider defaults) */
    timeout?: number;
}

/**
 * Result interface for embedding generation operations
 *
 * This interface provides detailed information about the embedding generation process,
 * including the actual embeddings, performance metrics, and any errors that occurred.
 */
export interface EmbeddingResult {
    /** The generated embedding vectors, one for each input chunk */
    embeddings: number[][];
    
    /** Total number of tokens processed (if available from the provider) */
    totalTokens?: number;
    
    /** Total processing time in milliseconds */
    processingTime: number;
    
    /** Array of error messages for any chunks that failed to process */
    errors: string[];
}

/**
 * Factory class for creating embedding providers
 *
 * This factory class implements the Factory Design Pattern to provide a clean,
 * centralized way to create different types of embedding providers based on
 * configuration. It supports dynamic imports to avoid loading unnecessary dependencies
 * and integrates with the centralized configuration system.
 */
export class EmbeddingProviderFactory {
    /**
     * Create an embedding provider instance based on configuration
     *
     * This method dynamically imports and instantiates the appropriate embedding provider
     * based on the provider type specified in the configuration. This approach ensures
     * that only the necessary provider code is loaded, improving startup performance.
     *
     * @param config - Configuration object specifying the provider type and its settings
     * @returns Promise resolving to a configured embedding provider instance
     * @throws Error if the specified provider type is not supported
     */
    static async createProvider(config: EmbeddingConfig): Promise<IEmbeddingProvider> {
        switch (config.provider) {
            case 'ollama':
                // Dynamically import Ollama provider to avoid loading it when not needed
                const { OllamaProvider } = await import('./ollamaProvider');
                return new OllamaProvider(config);
            case 'openai':
                // Dynamically import OpenAI provider to avoid loading it when not needed
                const { OpenAIProvider } = await import('./openaiProvider');
                return new OpenAIProvider(config);
            default:
                throw new Error(`Unsupported embedding provider: ${config.provider}. Supported providers: ${this.getSupportedProviders().join(', ')}`);
        }
    }

    /**
     * Create an embedding provider using the centralized ConfigService
     *
     * This method integrates with the application's centralized configuration system
     * to automatically retrieve the appropriate configuration for the specified
     * embedding provider type. This ensures consistency across the application
     * and reduces configuration duplication.
     *
     * @param configService - The centralized configuration service instance
     * @returns Promise resolving to a configured embedding provider instance
     * @throws Error if the provider type is not supported or configuration is invalid
     */
    static async createProviderFromConfigService(configService: any): Promise<IEmbeddingProvider> {
        // Get the configured provider type from the central configuration
        const providerType = configService.getEmbeddingProvider();

        let config: EmbeddingConfig;

        // Build configuration based on provider type
        if (providerType === 'ollama') {
            const ollamaConfig = configService.getOllamaConfig();
            config = {
                provider: 'ollama',
                model: ollamaConfig.model,
                baseUrl: ollamaConfig.apiUrl,
                maxBatchSize: ollamaConfig.maxBatchSize,
                timeout: ollamaConfig.timeout
            };
        } else if (providerType === 'openai') {
            const openaiConfig = configService.getOpenAIConfig();
            config = {
                provider: 'openai',
                model: openaiConfig.model,
                apiKey: openaiConfig.apiKey,
                maxBatchSize: openaiConfig.maxBatchSize,
                timeout: openaiConfig.timeout
            };
        } else {
            throw new Error(`Unsupported embedding provider: ${providerType}. Supported providers: ${this.getSupportedProviders().join(', ')}`);
        }

        // Create the provider using the standard factory method
        return this.createProvider(config);
    }

    /**
     * Get list of supported embedding provider types
     *
     * This method returns an array of all supported embedding provider types,
     * which can be useful for UI components, validation, and documentation.
     *
     * @returns Array of supported provider type strings
     */
    static getSupportedProviders(): string[] {
        return ['ollama', 'openai'];
    }
}
</file>

<file path="src/embeddings/ollamaProvider.ts">
import axios, { AxiosInstance } from 'axios';
import { IEmbeddingProvider, EmbeddingConfig } from './embeddingProvider';

/**
 * Ollama embedding provider implementation
 *
 * This class provides an implementation of the IEmbeddingProvider interface for
 * Ollama, a local open-source large language model runner. It allows users to
 * generate embeddings locally without relying on external APIs, providing better
 * privacy and potentially lower latency for local development workflows.
 *
 * Ollama embeddings are particularly useful for:
 * - Local development environments without internet access
 * - Privacy-sensitive applications where data shouldn't leave the local machine
 * - Applications requiring offline capabilities
 * - Cost-sensitive projects where API costs are a concern
 */
export class OllamaProvider implements IEmbeddingProvider {
    /** HTTP client for making API requests to Ollama */
    private client: AxiosInstance;
    
    /** The name of the embedding model to use */
    private model: string;
    
    /** Base URL of the Ollama service (default: localhost:11434) */
    private baseUrl: string;
    
    /** Maximum number of chunks to process in a single batch (default: 10) */
    private maxBatchSize: number;
    
    /** Request timeout in milliseconds (default: 30000) */
    private timeout: number;

    /**
     * Initialize the Ollama embedding provider
     *
     * @param config - Configuration object for the Ollama provider
     *
     * The constructor sets up the HTTP client with appropriate configuration
     * and validates that the necessary parameters are provided. It uses
     * sensible defaults for most parameters while allowing customization
     * through the configuration object.
     */
    constructor(config: EmbeddingConfig) {
        // Set model with fallback to a popular default
        this.model = config.model || 'nomic-embed-text';
        
        // Set base URL with fallback to local Ollama default
        this.baseUrl = config.baseUrl || 'http://localhost:11434';
        
        // Set batch size with conservative default to avoid overwhelming local service
        this.maxBatchSize = config.maxBatchSize || 10;
        
        // Set timeout with reasonable default for local operations
        this.timeout = config.timeout || 30000;

        // Configure HTTP client for Ollama API communication
        this.client = axios.create({
            baseURL: this.baseUrl,
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }

    /**
     * Generate embeddings for an array of text chunks
     *
     * This method processes text chunks in batches to optimize performance
     * and avoid overwhelming the local Ollama service. It implements robust
     * error handling to ensure that partial failures don't break the entire
     * embedding generation process.
     *
     * @param chunks - Array of text strings to convert to embeddings
     * @returns Promise resolving to array of embedding vectors
     *
     * The method maintains array alignment even when some chunks fail to process
     * by substituting zero vectors for failed chunks, ensuring that the output
     * array always matches the input array in length.
     */
    async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        // Early return for empty input to avoid unnecessary processing
        if (chunks.length === 0) {
            return [];
        }

        const embeddings: number[][] = [];
        const errors: string[] = [];

        // Process chunks in batches to avoid overwhelming the local API
        for (let i = 0; i < chunks.length; i += this.maxBatchSize) {
            const batch = chunks.slice(i, i + this.maxBatchSize);
            
            try {
                const batchEmbeddings = await this.processBatch(batch);
                embeddings.push(...batchEmbeddings);
            } catch (error) {
                const errorMessage = `Failed to process batch ${Math.floor(i / this.maxBatchSize) + 1}: ${error instanceof Error ? error.message : String(error)}`;
                errors.push(errorMessage);
                console.error(errorMessage);
                
                // Add zero vectors for failed chunks to maintain array alignment
                // This ensures the output array length matches the input array length
                for (let j = 0; j < batch.length; j++) {
                    embeddings.push(new Array(this.getDimensions()).fill(0));
                }
            }
        }

        // Log warnings if there were any processing errors
        if (errors.length > 0) {
            console.warn(`Ollama embedding generation completed with ${errors.length} errors`);
        }

        return embeddings;
    }

    /**
     * Process a batch of text chunks for embedding generation
     *
     * This private method handles the actual API communication with Ollama.
     * Unlike some other providers, Ollama typically processes one embedding
     * at a time, so this method loops through each chunk in the batch.
     *
     * @param chunks - Array of text chunks to process
     * @returns Promise resolving to array of embedding vectors
     * @throws Error if the API request fails or returns invalid data
     *
     * The method includes comprehensive error handling for common issues
     * like connection problems, missing models, and API errors.
     */
    private async processBatch(chunks: string[]): Promise<number[][]> {
        const embeddings: number[][] = [];

        // Ollama API typically processes one embedding at a time
        // Loop through each chunk and make individual API calls
        for (const chunk of chunks) {
            try {
                const response = await this.client.post('/api/embeddings', {
                    model: this.model,
                    prompt: chunk
                });

                // Validate response format and extract embedding
                if (response.data && response.data.embedding) {
                    embeddings.push(response.data.embedding);
                } else {
                    throw new Error('Invalid response format from Ollama API');
                }
            } catch (error) {
                // Handle specific error cases with helpful messages
                if (axios.isAxiosError(error)) {
                    if (error.response?.status === 404) {
                        throw new Error(`Model '${this.model}' not found. Please pull the model first: ollama pull ${this.model}`);
                    } else if (error.code === 'ECONNREFUSED') {
                        throw new Error('Cannot connect to Ollama. Please ensure Ollama is running on ' + this.baseUrl);
                    } else {
                        throw new Error(`Ollama API error: ${error.response?.data?.error || error.message}`);
                    }
                } else {
                    throw error;
                }
            }
        }

        return embeddings;
    }

    /**
     * Get the dimension size of embeddings for the current model
     *
     * Different embedding models produce vectors of different dimensions.
     * This method uses a lookup table for common Ollama models and falls
     * back to a reasonable default for unknown models.
     *
     * @returns The vector dimension size (e.g., 768 for nomic-embed-text)
     */
    getDimensions(): number {
        // Common dimensions for popular Ollama embedding models
        const modelDimensions: Record<string, number> = {
            'nomic-embed-text': 768,
            'all-minilm': 384,
            'sentence-transformers/all-MiniLM-L6-v2': 384,
            'mxbai-embed-large': 1024
        };

        // Return known dimension or default to 768 for unknown models
        return modelDimensions[this.model] || 768;
    }

    /**
     * Get the provider name identifier
     *
     * This method returns a unique identifier that includes both the
     * provider type and the specific model being used, useful for
     * logging, debugging, and display purposes.
     *
     * @returns Provider name in format "ollama:model-name"
     */
    getProviderName(): string {
        return `ollama:${this.model}`;
    }

    /**
     * Check if the Ollama service and model are available
     *
     * This method performs two checks:
     * 1. Verifies that the Ollama service is running and accessible
     * 2. Confirms that the specified embedding model is available
     *
     * @returns Promise resolving to true if both service and model are available
     */
    async isAvailable(): Promise<boolean> {
        try {
            // First check: Verify Ollama service is running
            const response = await this.client.get('/api/tags');
            
            // Second check: Verify the specific model is available
            if (response.data && response.data.models) {
                const modelExists = response.data.models.some((model: any) =>
                    model.name === this.model || model.name.startsWith(this.model + ':')
                );
                
                if (!modelExists) {
                    console.warn(`Model '${this.model}' not found in Ollama. Available models:`,
                        response.data.models.map((m: any) => m.name));
                    return false;
                }
            }

            return true;
        } catch (error) {
            // Provide specific error messages for common connection issues
            if (axios.isAxiosError(error) && error.code === 'ECONNREFUSED') {
                console.error('Ollama is not running. Please start Ollama service.');
            } else {
                console.error('Failed to check Ollama availability:', error);
            }
            return false;
        }
    }

    /**
     * Get list of available models from the Ollama service
     *
     * This method queries the Ollama service to get a list of all
     * currently available models. This can be useful for UI components
     * that need to show users what models they can use.
     *
     * @returns Promise resolving to array of available model names
     */
    async getAvailableModels(): Promise<string[]> {
        try {
            const response = await this.client.get('/api/tags');
            if (response.data && response.data.models) {
                return response.data.models.map((model: any) => model.name);
            }
            return [];
        } catch (error) {
            console.error('Failed to get available models:', error);
            return [];
        }
    }

    /**
     * Pull a model from the Ollama registry
     *
     * This method allows the application to automatically download and
     * install models from the Ollama registry if they're not already
     * available locally. This provides a better user experience by
     * handling model management automatically.
     *
     * @param modelName - The name of the model to pull
     * @returns Promise resolving to true if the model was successfully pulled
     */
    async pullModel(modelName: string): Promise<boolean> {
        try {
            console.log(`Pulling model '${modelName}' from Ollama...`);
            await this.client.post('/api/pull', {
                name: modelName
            });
            console.log(`Model '${modelName}' pulled successfully`);
            return true;
        } catch (error) {
            console.error(`Failed to pull model '${modelName}':`, error);
            return false;
        }
    }
}
</file>

<file path="src/embeddings/openaiProvider.ts">
import axios, { AxiosInstance } from 'axios';
import { IEmbeddingProvider, EmbeddingConfig } from './embeddingProvider';

/**
 * OpenAI embedding provider implementation
 *
 * This class provides an implementation of the IEmbeddingProvider interface for
 * OpenAI's embedding services. It leverages OpenAI's powerful embedding models
 * like text-embedding-ada-002 and text-embedding-3-series to generate high-quality
 * vector representations of text for semantic search, clustering, and other AI tasks.
 *
 * OpenAI embeddings are particularly useful for:
 * - High-quality semantic understanding
 * - Access to state-of-the-art language models
 * - Integration with other OpenAI services
 * - Applications requiring the latest in AI capabilities
 */
export class OpenAIProvider implements IEmbeddingProvider {
    /** HTTP client for making API requests to OpenAI */
    private client: AxiosInstance;
    
    /** The name of the embedding model to use */
    private model: string;
    
    /** OpenAI API key for authentication */
    private apiKey: string;
    
    /** Maximum number of chunks to process in a single batch (default: 100) */
    private maxBatchSize: number;
    
    /** Request timeout in milliseconds (default: 60000) */
    private timeout: number;

    /**
     * Initialize the OpenAI embedding provider
     *
     * @param config - Configuration object for the OpenAI provider
     *
     * The constructor validates that an API key is provided and sets up the
     * HTTP client with appropriate authentication headers. It uses sensible
     * defaults for most parameters while allowing customization through the
     * configuration object.
     *
     * @throws Error if API key is not provided
     */
    constructor(config: EmbeddingConfig) {
        // Set model with fallback to a popular default
        this.model = config.model || 'text-embedding-ada-002';
        
        // API key is required for OpenAI services
        this.apiKey = config.apiKey || '';
        
        // Set batch size with larger default since OpenAI supports bigger batches
        this.maxBatchSize = config.maxBatchSize || 100;
        
        // Set longer timeout for external API calls
        this.timeout = config.timeout || 60000;

        // Validate that API key is provided
        if (!this.apiKey) {
            throw new Error('OpenAI API key is required. Please set it in VS Code settings.');
        }

        // Configure HTTP client for OpenAI API communication with authentication
        this.client = axios.create({
            baseURL: 'https://api.openai.com/v1',
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.apiKey}`
            }
        });
    }

    /**
     * Generate embeddings for an array of text chunks
     *
     * This method processes text chunks in batches to optimize performance
     * and stay within OpenAI's rate limits. Unlike some other providers,
     * OpenAI's embedding API can process multiple inputs in a single request,
     * making batch processing very efficient.
     *
     * @param chunks - Array of text strings to convert to embeddings
     * @returns Promise resolving to array of embedding vectors
     *
     * The method maintains array alignment even when some chunks fail to process
     * by substituting zero vectors for failed chunks, ensuring that the output
     * array always matches the input array in length.
     */
    async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        // Early return for empty input to avoid unnecessary processing
        if (chunks.length === 0) {
            return [];
        }

        const embeddings: number[][] = [];
        const errors: string[] = [];

        // Process chunks in batches to optimize API usage and avoid rate limits
        for (let i = 0; i < chunks.length; i += this.maxBatchSize) {
            const batch = chunks.slice(i, i + this.maxBatchSize);
            
            try {
                const batchEmbeddings = await this.processBatch(batch);
                embeddings.push(...batchEmbeddings);
            } catch (error) {
                const errorMessage = `Failed to process batch ${Math.floor(i / this.maxBatchSize) + 1}: ${error instanceof Error ? error.message : String(error)}`;
                errors.push(errorMessage);
                console.error(errorMessage);
                
                // Add zero vectors for failed chunks to maintain array alignment
                // This ensures the output array length matches the input array length
                for (let j = 0; j < batch.length; j++) {
                    embeddings.push(new Array(this.getDimensions()).fill(0));
                }
            }
        }

        // Log warnings if there were any processing errors
        if (errors.length > 0) {
            console.warn(`OpenAI embedding generation completed with ${errors.length} errors`);
        }

        return embeddings;
    }

    /**
     * Process a batch of text chunks for embedding generation
     *
     * This private method handles the actual API communication with OpenAI.
     * Unlike Ollama, OpenAI's embedding API can process multiple inputs
     * in a single request, making it more efficient for batch processing.
     *
     * @param chunks - Array of text chunks to process
     * @returns Promise resolving to array of embedding vectors
     * @throws Error if the API request fails or returns invalid data
     *
     * The method includes comprehensive error handling for common issues
     * like authentication problems, rate limits, invalid requests, and
     * model availability.
     */
    private async processBatch(chunks: string[]): Promise<number[][]> {
        try {
            const response = await this.client.post('/embeddings', {
                model: this.model,
                input: chunks,
                encoding_format: 'float'
            });

            // Validate response format and extract embeddings
            if (response.data && response.data.data) {
                // OpenAI returns embeddings in the same order as input
                return response.data.data.map((item: any) => item.embedding);
            } else {
                throw new Error('Invalid response format from OpenAI API');
            }
        } catch (error) {
            // Handle specific error cases with helpful messages
            if (axios.isAxiosError(error)) {
                if (error.response?.status === 401) {
                    throw new Error('Invalid OpenAI API key. Please check your API key in VS Code settings.');
                } else if (error.response?.status === 429) {
                    throw new Error('OpenAI API rate limit exceeded. Please try again later.');
                } else if (error.response?.status === 400) {
                    const errorData = error.response.data;
                    if (errorData?.error?.code === 'invalid_request_error') {
                        throw new Error(`OpenAI API error: ${errorData.error.message}`);
                    }
                    throw new Error('Bad request to OpenAI API. Check your input data.');
                } else if (error.response?.status === 404) {
                    throw new Error(`Model '${this.model}' not found. Please check the model name.`);
                } else {
                    throw new Error(`OpenAI API error (${error.response?.status}): ${error.response?.data?.error?.message || error.message}`);
                }
            } else {
                throw error;
            }
        }
    }

    /**
     * Get the dimension size of embeddings for the current model
     *
     * Different embedding models produce vectors of different dimensions.
     * This method uses a lookup table for common OpenAI embedding models
     * and falls back to a reasonable default for unknown models.
     *
     * @returns The vector dimension size (e.g., 1536 for ada-002)
     */
    getDimensions(): number {
        // Dimensions for popular OpenAI embedding models
        const modelDimensions: Record<string, number> = {
            'text-embedding-ada-002': 1536,
            'text-embedding-3-small': 1536,
            'text-embedding-3-large': 3072
        };

        // Return known dimension or default to ada-002 dimensions for unknown models
        return modelDimensions[this.model] || 1536;
    }

    /**
     * Get the provider name identifier
     *
     * This method returns a unique identifier that includes both the
     * provider type and the specific model being used, useful for
     * logging, debugging, and display purposes.
     *
     * @returns Provider name in format "openai:model-name"
     */
    getProviderName(): string {
        return `openai:${this.model}`;
    }

    /**
     * Check if the OpenAI service and model are available
     *
     * This method performs a test request to verify that:
     * 1. The API key is valid and authentication works
     * 2. The specified embedding model is available
     * 3. The service is responding correctly
     *
     * @returns Promise resolving to true if the service is available
     */
    async isAvailable(): Promise<boolean> {
        try {
            // Test with a simple embedding request to verify connectivity and auth
            const response = await this.client.post('/embeddings', {
                model: this.model,
                input: 'test',
                encoding_format: 'float'
            });

            return response.status === 200 && response.data?.data?.length > 0;
        } catch (error) {
            // Provide specific error messages for different failure scenarios
            if (axios.isAxiosError(error)) {
                if (error.response?.status === 401) {
                    console.error('OpenAI API key is invalid or missing');
                } else if (error.response?.status === 404) {
                    console.error(`OpenAI model '${this.model}' not found`);
                } else if (error.response?.status === 429) {
                    console.warn('OpenAI API rate limit exceeded, but service is available');
                    return true; // Rate limit means the service is available, just busy
                } else {
                    console.error('OpenAI API availability check failed:', error.response?.data || error.message);
                }
            } else {
                console.error('Failed to check OpenAI availability:', error);
            }
            return false;
        }
    }

    /**
     * Get usage statistics for the last request
     *
     * This method would track token usage from the last API response,
     * which is useful for monitoring API costs and usage limits.
     * Currently returns an empty object as this feature needs implementation.
     *
     * @returns Object with usage statistics (currently empty)
     */
    getLastUsage(): { prompt_tokens?: number; total_tokens?: number } {
        // This would need to be implemented to track usage from the last response
        // For now, return empty object
        return {};
    }

    /**
     * Estimate token count for text (rough approximation)
     *
     * This method provides a rough estimate of how many tokens a piece of text
     * would consume when sent to the OpenAI API. This is useful for:
     * - Pre-validating text before sending to API
     * - Estimating API costs
     * - Implementing usage limits
     *
     * @param text - The text to estimate tokens for
     * @returns Estimated token count (rough approximation)
     *
     * Note: This is a rough approximation. For accurate token counting,
     * use OpenAI's tiktoken library or similar.
     */
    estimateTokens(text: string): number {
        // Rough approximation: 1 token  4 characters for English text
        // This is a simplification - actual tokenization varies by language
        return Math.ceil(text.length / 4);
    }

    /**
     * Check if text is within token limits
     *
     * This method uses the token estimation to check if text would exceed
     * OpenAI's maximum token limit for embedding requests.
     *
     * @param text - The text to check
     * @param maxTokens - Maximum allowed tokens (default: 8191)
     * @returns True if text is within token limits
     */
    isWithinTokenLimit(text: string, maxTokens: number = 8191): boolean {
        return this.estimateTokens(text) <= maxTokens;
    }

    /**
     * Truncate text to fit within token limits
     *
     * This method truncates text to ensure it stays within OpenAI's token
     * limits while preserving as much content as possible.
     *
     * @param text - The text to truncate
     * @param maxTokens - Maximum allowed tokens (default: 8191)
     * @returns Truncated text that fits within token limits
     */
    truncateToTokenLimit(text: string, maxTokens: number = 8191): string {
        const estimatedTokens = this.estimateTokens(text);
        if (estimatedTokens <= maxTokens) {
            return text;
        }

        // Rough truncation based on character count
        // This is a simplification - proper truncation would use actual tokenization
        const maxChars = maxTokens * 4;
        return text.substring(0, maxChars - 3) + '...';
    }
}
</file>

<file path="src/parsing/astParser.ts">
/**
 * Abstract Syntax Tree Parser Module
 * 
 * This module provides functionality for parsing source code into Abstract Syntax Trees (ASTs)
 * using the tree-sitter library. It supports multiple programming languages including TypeScript,
 * JavaScript, Python, and C#. The parser enables code analysis, traversal, and querying of
 * syntax nodes within the parsed code.
 * 
 * Key features:
 * - Multi-language support with extensible architecture
 * - Error recovery and reporting during parsing
 * - File extension to language detection
 * - AST traversal and node querying capabilities
 * - Utility functions for working with syntax nodes
 */

import Parser from 'tree-sitter';
import TypeScript from 'tree-sitter-typescript';
import Python from 'tree-sitter-python';
import CSharp from 'tree-sitter-c-sharp';

// TODO: (agent) Setup mono repo for our application to build and setup our ast parser modules

/**
 * Defines the programming languages supported by the AST parser.
 * Currently supports TypeScript, JavaScript, Python, and C#.
 */
export type SupportedLanguage = 'typescript' | 'javascript' | 'python' | 'csharp';

/**
 * AstParser class provides functionality to parse and analyze source code
 * using the tree-sitter library across multiple programming languages.
 */
export class AstParser {
    /** The tree-sitter parser instance used for parsing source code */
    private parser: Parser;
    
    /** Map of supported languages to their corresponding tree-sitter grammar */
    private languages: Map<SupportedLanguage, any>;

    /**
     * Initializes a new instance of the AstParser class.
     * Sets up the parser and registers all supported language grammars.
     */
    constructor() {
        this.parser = new Parser();
        this.languages = new Map();
        
        // Initialize supported languages
        this.languages.set('typescript', TypeScript.typescript);
        this.languages.set('javascript', TypeScript.javascript);
        this.languages.set('python', Python);
        this.languages.set('csharp', CSharp);
    }

    /**
     * Parses source code into an Abstract Syntax Tree (AST).
     * 
     * @param language - The programming language of the source code
     * @param code - The source code string to parse
     * @returns The parsed AST or null if parsing fails
     * @throws Error if the language is not supported or parsing fails
     */
    public parse(language: SupportedLanguage, code: string): Parser.Tree | null {
        try {
            // Get the language grammar for the specified language
            const languageGrammar = this.languages.get(language);
            if (!languageGrammar) {
                throw new Error(`Unsupported language: ${language}`);
            }

            // Configure the parser with the appropriate language grammar
            this.parser.setLanguage(languageGrammar);
            const tree = this.parser.parse(code);
            
            if (!tree) {
                throw new Error(`Failed to parse code for language: ${language}`);
            }

            return tree;
        } catch (error) {
            console.error(`Error parsing code for language ${language}:`, error);
            return null;
        }
    }

    /**
     * Parses source code with error recovery, collecting syntax errors encountered during parsing.
     * This method is useful for partial or incomplete code that may contain syntax errors.
     * 
     * @param language - The programming language of the source code
     * @param code - The source code string to parse
     * @returns An object containing the parsed tree (or null) and an array of error messages
     */
    public parseWithErrorRecovery(language: SupportedLanguage, code: string): { tree: Parser.Tree | null; errors: string[] } {
        const errors: string[] = [];
        
        try {
            const tree = this.parse(language, code);
            
            if (tree && tree.rootNode.hasError()) {
                // Walk the tree to find error nodes
                const cursor = tree.walk();
                
                /**
                 * Recursive helper function to find and collect error nodes in the AST
                 * @param node - The current syntax node being examined
                 */
                const findErrors = (node: Parser.SyntaxNode) => {
                    if (node.hasError()) {
                        if (node.type === 'ERROR') {
                            // Convert to 1-based line and column numbers for human readability
                            errors.push(`Syntax error at line ${node.startPosition.row + 1}, column ${node.startPosition.column + 1}`);
                        }
                        
                        // Recursively check all child nodes for errors
                        for (let i = 0; i < node.childCount; i++) {
                            findErrors(node.child(i)!);
                        }
                    }
                };
                
                // Start error detection from the root node
                findErrors(tree.rootNode);
            }
            
            return { tree, errors };
        } catch (error) {
            // Handle any exceptions during parsing
            errors.push(`Parse error: ${error instanceof Error ? error.message : String(error)}`);
            return { tree: null, errors };
        }
    }

    /**
     * Determines the programming language based on a file's extension.
     * 
     * @param filePath - The path to the file
     * @returns The detected language or null if the extension is not supported
     */
    public getLanguageFromFilePath(filePath: string): SupportedLanguage | null {
        const extension = filePath.toLowerCase().split('.').pop();
        
        switch (extension) {
            case 'ts':
            case 'tsx':
                return 'typescript';
            case 'js':
            case 'jsx':
                return 'javascript';
            case 'py':
                return 'python';
            case 'cs':
                return 'csharp';
            default:
                return null;
        }
    }

    /**
     * Gets a list of all supported programming languages.
     * 
     * @returns An array of supported language identifiers
     */
    public getSupportedLanguages(): SupportedLanguage[] {
        return Array.from(this.languages.keys());
    }

    /**
     * Checks if a given language is supported by the parser.
     * This is a type guard function that narrows the type of the language parameter.
     * 
     * @param language - The language identifier to check
     * @returns True if the language is supported, false otherwise
     */
    public isLanguageSupported(language: string): language is SupportedLanguage {
        return this.languages.has(language as SupportedLanguage);
    }

    /**
     * Extracts the text content of a syntax node from the original source code.
     * 
     * @param node - The syntax node to extract text from
     * @param code - The original source code string
     * @returns The text content of the node
     */
    public getNodeText(node: Parser.SyntaxNode, code: string): string {
        return code.slice(node.startIndex, node.endIndex);
    }

    /**
     * Gets the location information for a syntax node in human-readable format.
     * Converts from tree-sitter's 0-based indices to 1-based line and column numbers.
     * 
     * @param node - The syntax node to get location information for
     * @returns An object containing start/end line and column numbers (1-based)
     */
    public getNodeLocation(node: Parser.SyntaxNode): { startLine: number; endLine: number; startColumn: number; endColumn: number } {
        return {
            startLine: node.startPosition.row + 1, // Convert to 1-based line numbers
            endLine: node.endPosition.row + 1,
            startColumn: node.startPosition.column + 1, // Convert to 1-based column numbers
            endColumn: node.endPosition.column + 1
        };
    }

    /**
     * Finds all syntax nodes of a specific type in the AST.
     * 
     * @param tree - The parsed syntax tree to search
     * @param nodeType - The type of nodes to find (e.g., 'function_declaration')
     * @returns An array of matching syntax nodes
     */
    public findNodesByType(tree: Parser.Tree, nodeType: string): Parser.SyntaxNode[] {
        const nodes: Parser.SyntaxNode[] = [];
        
        /**
         * Recursive helper function to traverse the AST and collect nodes of the specified type
         * @param node - The current node being examined
         */
        const traverse = (node: Parser.SyntaxNode) => {
            if (node.type === nodeType) {
                nodes.push(node);
            }
            
            // Recursively traverse all child nodes
            for (let i = 0; i < node.childCount; i++) {
                traverse(node.child(i)!);
            }
        };
        
        // Start traversal from the root node
        traverse(tree.rootNode);
        return nodes;
    }

    /**
     * Executes a tree-sitter query against the AST to find matching patterns.
     * Queries use tree-sitter's query language to match specific patterns in the syntax tree.
     * 
     * @param tree - The parsed syntax tree to query
     * @param language - The programming language of the source code
     * @param queryString - The tree-sitter query string
     * @returns An array of query matches or an empty array if the query fails
     */
    public queryNodes(tree: Parser.Tree, language: SupportedLanguage, queryString: string): Parser.QueryMatch[] {
        try {
            const languageGrammar = this.languages.get(language);
            if (!languageGrammar) {
                throw new Error(`Unsupported language: ${language}`);
            }

            // Create and execute the query against the root node
            const query = new Parser.Query(languageGrammar, queryString);
            return query.matches(tree.rootNode);
        } catch (error) {
            console.error(`Error executing query for language ${language}:`, error);
            return [];
        }
    }
}
</file>

<file path="src/commandManager.ts">
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';
import { WebviewManager } from './webviewManager';

/**
 * CommandManager class responsible for registering and managing all VS Code commands
 * for the Code Context Engine extension.
 * 
 * This class centralizes command registration and provides a clean separation between
 * command handling logic and the main extension activation. It handles:
 * - Registration of all extension commands
 * - Command callback implementations
 * - Integration with core services
 * - Proper disposal of command registrations
 */
export class CommandManager {
    private indexingService: IndexingService;
    private webviewManager: WebviewManager;

    /**
     * Creates a new CommandManager instance
     * @param indexingService - The IndexingService instance for handling indexing commands
     * @param webviewManager - The WebviewManager instance for handling webview operations
     */
    constructor(indexingService: IndexingService, webviewManager: WebviewManager) {
        this.indexingService = indexingService;
        this.webviewManager = webviewManager;
    }

    /**
     * Registers all extension commands and returns their disposables
     * @returns Array of disposables for the registered commands
     */
    registerCommands(): vscode.Disposable[] {
        const disposables: vscode.Disposable[] = [];

        // Register the main panel command
        const openMainPanelDisposable = vscode.commands.registerCommand(
            'code-context-engine.openMainPanel',
            this.handleOpenMainPanel.bind(this)
        );
        disposables.push(openMainPanelDisposable);

        // Register the start indexing command
        const startIndexingDisposable = vscode.commands.registerCommand(
            'code-context-engine.startIndexing',
            this.handleStartIndexing.bind(this)
        );
        disposables.push(startIndexingDisposable);

        // Register the open settings command
        const openSettingsDisposable = vscode.commands.registerCommand(
            'code-context-engine.openSettings',
            this.handleOpenSettings.bind(this)
        );
        disposables.push(openSettingsDisposable);

        // Register the setup project command
        const setupProjectDisposable = vscode.commands.registerCommand(
            'code-context-engine.setupProject',
            this.handleSetupProject.bind(this)
        );
        disposables.push(setupProjectDisposable);

        // Register the open diagnostics command
        const openDiagnosticsDisposable = vscode.commands.registerCommand(
            'code-context-engine.openDiagnostics',
            this.handleOpenDiagnostics.bind(this)
        );
        disposables.push(openDiagnosticsDisposable);

        console.log('CommandManager: All commands registered successfully');
        return disposables;
    }

    /**
     * Handles the 'code-context-engine.openMainPanel' command
     * Opens the main Code Context Engine panel using WebviewManager
     */
    private async handleOpenMainPanel(): Promise<void> {
        try {
            console.log('CommandManager: Opening main panel...');

            this.webviewManager.showMainPanel();

            console.log('CommandManager: Main panel opened successfully');
        } catch (error) {
            console.error('CommandManager: Failed to open main panel:', error);
            vscode.window.showErrorMessage('Failed to open Code Context Engine panel');
        }
    }

    /**
     * Handles the 'code-context-engine.startIndexing' command
     * Starts the indexing process for the current workspace
     */
    private async handleStartIndexing(): Promise<void> {
        try {
            console.log('CommandManager: Starting indexing...');

            if (!this.indexingService) {
                throw new Error('IndexingService not available');
            }

            // Check if workspace is available
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                vscode.window.showWarningMessage('No workspace folder is open. Please open a folder to index.');
                return;
            }

            // Show progress notification
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Code Context Engine',
                cancellable: false
            }, async (progress) => {
                progress.report({ message: 'Starting indexing process...' });

                // Start the indexing process
                const result = await this.indexingService.startIndexing((progressInfo) => {
                    progress.report({ 
                        message: `${progressInfo.currentPhase}: ${progressInfo.currentFile}`,
                        increment: (progressInfo.processedFiles / progressInfo.totalFiles) * 100
                    });
                });

                if (result.success) {
                    progress.report({ message: 'Indexing completed successfully!' });
                    vscode.window.showInformationMessage(
                        `Indexing completed! Processed ${result.processedFiles} files with ${result.chunks.length} code chunks.`
                    );
                } else {
                    throw new Error(`Indexing failed with ${result.errors.length} errors`);
                }
            });

            console.log('CommandManager: Indexing completed successfully');
        } catch (error) {
            console.error('CommandManager: Failed to start indexing:', error);
            vscode.window.showErrorMessage(`Failed to start indexing: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Handles the 'code-context-engine.openSettings' command
     * Opens the native VS Code settings UI filtered for this extension
     */
    private async handleOpenSettings(): Promise<void> {
        try {
            console.log('CommandManager: Opening native settings...');

            // Open the native VS Code settings UI, filtered for this extension
            await vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');

            console.log('CommandManager: Native settings opened successfully');
        } catch (error) {
            console.error('CommandManager: Failed to open settings:', error);
            vscode.window.showErrorMessage('Failed to open Code Context Engine settings');
        }
    }

    /**
     * Handles the 'code-context-engine.setupProject' command
     * Opens the project setup wizard
     */
    private async handleSetupProject(): Promise<void> {
        try {
            console.log('CommandManager: Starting project setup...');

            // Check if workspace is available
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                vscode.window.showWarningMessage('No workspace folder is open. Please open a folder to setup.');
                return;
            }

            // For now, show a simple setup dialog
            const setupChoice = await vscode.window.showInformationMessage(
                'Welcome to Code Context Engine! Would you like to start indexing your project?',
                'Start Indexing',
                'Configure Settings',
                'Cancel'
            );

            switch (setupChoice) {
                case 'Start Indexing':
                    await this.handleStartIndexing();
                    break;
                case 'Configure Settings':
                    await this.handleOpenSettings();
                    break;
                default:
                    console.log('CommandManager: Project setup cancelled');
                    break;
            }

            console.log('CommandManager: Project setup completed');
        } catch (error) {
            console.error('CommandManager: Failed to setup project:', error);
            vscode.window.showErrorMessage('Failed to setup Code Context Engine project');
        }
    }

    /**
     * Handles the 'code-context-engine.openDiagnostics' command
     * Opens the diagnostics panel for testing connections and viewing system status
     */
    private async handleOpenDiagnostics(): Promise<void> {
        try {
            console.log('CommandManager: Opening diagnostics panel...');

            this.webviewManager.showDiagnosticsPanel();

            console.log('CommandManager: Diagnostics panel opened successfully');
        } catch (error) {
            console.error('CommandManager: Failed to open diagnostics panel:', error);
            vscode.window.showErrorMessage('Failed to open Code Context Engine diagnostics');
        }
    }
}
</file>

<file path="src/configurationManager.ts">
import * as vscode from 'vscode';
import { ConfigService } from './configService';

/**
 * Configuration validation result
 */
export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings: string[];
}

/**
 * Configuration change event
 */
export interface ConfigurationChangeEvent {
    key: string;
    oldValue: any;
    newValue: any;
    timestamp: Date;
}

/**
 * Configuration preset for quick setup
 */
export interface ConfigurationPreset {
    name: string;
    description: string;
    settings: Record<string, any>;
}

/**
 * ConfigurationManager class responsible for advanced configuration management.
 * 
 * This class provides enhanced configuration capabilities including:
 * - Configuration validation and error checking
 * - Configuration presets and templates
 * - Change tracking and history
 * - Import/export functionality
 * - Real-time configuration updates
 */
export class ConfigurationManager {
    private configService: ConfigService;
    private changeListeners: ((event: ConfigurationChangeEvent) => void)[] = [];
    private configurationWatcher: vscode.Disposable | undefined;

    /**
     * Creates a new ConfigurationManager instance
     * @param configService - The ConfigService instance
     */
    constructor(configService: ConfigService) {
        this.configService = configService;
        this.setupConfigurationWatcher();
    }

    /**
     * Validates the current configuration
     * @returns Validation result with errors and warnings
     */
    async validateConfiguration(): Promise<ValidationResult> {
        const result: ValidationResult = {
            isValid: true,
            errors: [],
            warnings: []
        };

        try {
            // Validate database configuration
            const dbConfig = this.configService.getDatabaseConfig();
            if (!dbConfig.connectionString) {
                result.errors.push('Database connection string is required');
                result.isValid = false;
            } else {
                try {
                    new URL(dbConfig.connectionString);
                } catch {
                    result.errors.push('Invalid database connection string format');
                    result.isValid = false;
                }
            }

            // Validate embedding provider configuration
            const embeddingProvider = this.configService.getEmbeddingProvider();
            const isProviderConfigured = this.configService.isProviderConfigured(embeddingProvider);
            
            if (!isProviderConfigured) {
                if (embeddingProvider === 'openai') {
                    const openaiConfig = this.configService.getOpenAIConfig();
                    if (!openaiConfig.apiKey) {
                        result.errors.push('OpenAI API key is required when using OpenAI provider');
                        result.isValid = false;
                    }
                } else if (embeddingProvider === 'ollama') {
                    const ollamaConfig = this.configService.getOllamaConfig();
                    if (!ollamaConfig.apiUrl) {
                        result.errors.push('Ollama API URL is required when using Ollama provider');
                        result.isValid = false;
                    }
                }
            }

            // Validate indexing configuration
            const indexingConfig = this.configService.getIndexingConfig();
            if (indexingConfig.chunkSize !== undefined && indexingConfig.chunkSize <= 0) {
                result.errors.push('Chunk size must be greater than 0');
                result.isValid = false;
            }

            if (indexingConfig.chunkOverlap !== undefined && indexingConfig.chunkOverlap < 0) {
                result.errors.push('Chunk overlap cannot be negative');
                result.isValid = false;
            }

            if (indexingConfig.chunkOverlap !== undefined &&
                indexingConfig.chunkSize !== undefined &&
                indexingConfig.chunkOverlap >= indexingConfig.chunkSize) {
                result.warnings.push('Chunk overlap should be smaller than chunk size');
            }

            // Check for performance warnings
            if (indexingConfig.chunkSize !== undefined && indexingConfig.chunkSize > 2000) {
                result.warnings.push('Large chunk size may impact performance');
            }

            const openaiConfig = this.configService.getOpenAIConfig();
            if (openaiConfig.maxBatchSize !== undefined && openaiConfig.maxBatchSize > 100) {
                result.warnings.push('Large batch size may hit API rate limits');
            }

        } catch (error) {
            result.errors.push(`Configuration validation failed: ${error instanceof Error ? error.message : String(error)}`);
            result.isValid = false;
        }

        return result;
    }

    /**
     * Gets available configuration presets
     * @returns Array of configuration presets
     */
    getConfigurationPresets(): ConfigurationPreset[] {
        return [
            {
                name: 'Local Development',
                description: 'Optimized for local development with Ollama',
                settings: {
                    'code-context-engine.embeddingProvider': 'ollama',
                    'code-context-engine.ollama.apiUrl': 'http://localhost:11434',
                    'code-context-engine.ollama.model': 'nomic-embed-text',
                    'code-context-engine.databaseConnectionString': 'http://localhost:6333',
                    'code-context-engine.indexing.chunkSize': 1000,
                    'code-context-engine.indexing.chunkOverlap': 200
                }
            },
            {
                name: 'Cloud Production',
                description: 'Optimized for production use with OpenAI',
                settings: {
                    'code-context-engine.embeddingProvider': 'openai',
                    'code-context-engine.openai.model': 'text-embedding-ada-002',
                    'code-context-engine.openai.maxBatchSize': 50,
                    'code-context-engine.indexing.chunkSize': 1500,
                    'code-context-engine.indexing.chunkOverlap': 300
                }
            },
            {
                name: 'Performance Optimized',
                description: 'Optimized for large codebases',
                settings: {
                    'code-context-engine.indexing.chunkSize': 800,
                    'code-context-engine.indexing.chunkOverlap': 100,
                    'code-context-engine.indexing.maxFileSize': 2097152, // 2MB
                    'code-context-engine.ollama.maxBatchSize': 5,
                    'code-context-engine.openai.maxBatchSize': 20
                }
            },
            {
                name: 'Minimal Setup',
                description: 'Minimal configuration for quick testing',
                settings: {
                    'code-context-engine.embeddingProvider': 'ollama',
                    'code-context-engine.indexing.chunkSize': 500,
                    'code-context-engine.indexing.chunkOverlap': 50,
                    'code-context-engine.indexing.excludePatterns': [
                        '**/node_modules/**',
                        '**/dist/**',
                        '**/.git/**'
                    ]
                }
            }
        ];
    }

    /**
     * Applies a configuration preset
     * @param presetName - Name of the preset to apply
     * @returns Promise resolving when preset is applied
     */
    async applyPreset(presetName: string): Promise<void> {
        const preset = this.getConfigurationPresets().find(p => p.name === presetName);
        if (!preset) {
            throw new Error(`Configuration preset '${presetName}' not found`);
        }

        const config = vscode.workspace.getConfiguration();
        
        for (const [key, value] of Object.entries(preset.settings)) {
            await config.update(key, value, vscode.ConfigurationTarget.Workspace);
        }

        // Refresh the config service
        this.configService.refresh();

        console.log(`ConfigurationManager: Applied preset '${presetName}'`);
    }

    /**
     * Exports current configuration to a JSON object
     * @returns Configuration export object
     */
    exportConfiguration(): Record<string, any> {
        const fullConfig = this.configService.getFullConfig();
        
        return {
            exportedAt: new Date().toISOString(),
            version: '1.0',
            configuration: {
                database: fullConfig.database,
                embeddingProvider: fullConfig.embeddingProvider,
                ollama: fullConfig.ollama,
                openai: {
                    ...fullConfig.openai,
                    apiKey: fullConfig.openai.apiKey ? '[REDACTED]' : ''
                },
                indexing: fullConfig.indexing
            }
        };
    }

    /**
     * Imports configuration from a JSON object
     * @param configData - Configuration data to import
     * @returns Promise resolving when configuration is imported
     */
    async importConfiguration(configData: any): Promise<void> {
        if (!configData.configuration) {
            throw new Error('Invalid configuration format');
        }

        const config = vscode.workspace.getConfiguration();
        const settings = configData.configuration;

        // Import database settings
        if (settings.database?.connectionString) {
            await config.update(
                'code-context-engine.databaseConnectionString',
                settings.database.connectionString,
                vscode.ConfigurationTarget.Workspace
            );
        }

        // Import embedding provider settings
        if (settings.embeddingProvider) {
            await config.update(
                'code-context-engine.embeddingProvider',
                settings.embeddingProvider,
                vscode.ConfigurationTarget.Workspace
            );
        }

        // Import Ollama settings
        if (settings.ollama) {
            for (const [key, value] of Object.entries(settings.ollama)) {
                await config.update(
                    `code-context-engine.ollama.${key}`,
                    value,
                    vscode.ConfigurationTarget.Workspace
                );
            }
        }

        // Import OpenAI settings (excluding API key for security)
        if (settings.openai) {
            for (const [key, value] of Object.entries(settings.openai)) {
                if (key !== 'apiKey') {
                    await config.update(
                        `code-context-engine.openai.${key}`,
                        value,
                        vscode.ConfigurationTarget.Workspace
                    );
                }
            }
        }

        // Import indexing settings
        if (settings.indexing) {
            for (const [key, value] of Object.entries(settings.indexing)) {
                await config.update(
                    `code-context-engine.indexing.${key}`,
                    value,
                    vscode.ConfigurationTarget.Workspace
                );
            }
        }

        // Refresh the config service
        this.configService.refresh();

        console.log('ConfigurationManager: Configuration imported successfully');
    }

    /**
     * Resets configuration to defaults
     * @returns Promise resolving when configuration is reset
     */
    async resetToDefaults(): Promise<void> {
        const config = vscode.workspace.getConfiguration();
        const configKeys = [
            'code-context-engine.databaseConnectionString',
            'code-context-engine.embeddingProvider',
            'code-context-engine.ollama.apiUrl',
            'code-context-engine.ollama.model',
            'code-context-engine.ollama.timeout',
            'code-context-engine.ollama.maxBatchSize',
            'code-context-engine.openai.apiKey',
            'code-context-engine.openai.model',
            'code-context-engine.openai.timeout',
            'code-context-engine.openai.maxBatchSize',
            'code-context-engine.indexing.excludePatterns',
            'code-context-engine.indexing.supportedLanguages',
            'code-context-engine.indexing.maxFileSize',
            'code-context-engine.indexing.chunkSize',
            'code-context-engine.indexing.chunkOverlap'
        ];

        for (const key of configKeys) {
            await config.update(key, undefined, vscode.ConfigurationTarget.Workspace);
        }

        // Refresh the config service
        this.configService.refresh();

        console.log('ConfigurationManager: Configuration reset to defaults');
    }

    /**
     * Adds a configuration change listener
     * @param listener - Function to call when configuration changes
     */
    onConfigurationChange(listener: (event: ConfigurationChangeEvent) => void): void {
        this.changeListeners.push(listener);
    }

    /**
     * Sets up configuration watcher for real-time updates
     */
    private setupConfigurationWatcher(): void {
        this.configurationWatcher = vscode.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('code-context-engine')) {
                // Refresh the config service
                this.configService.refresh();

                // Notify listeners
                const changeEvent: ConfigurationChangeEvent = {
                    key: 'code-context-engine',
                    oldValue: null, // Would need to track previous values
                    newValue: this.configService.getFullConfig(),
                    timestamp: new Date()
                };

                this.changeListeners.forEach(listener => {
                    try {
                        listener(changeEvent);
                    } catch (error) {
                        console.error('ConfigurationManager: Error in change listener:', error);
                    }
                });

                console.log('ConfigurationManager: Configuration changed');
            }
        });
    }

    /**
     * Disposes of the ConfigurationManager and cleans up resources
     */
    dispose(): void {
        if (this.configurationWatcher) {
            this.configurationWatcher.dispose();
        }
        this.changeListeners = [];
        console.log('ConfigurationManager: Disposed');
    }
}
</file>

<file path="src/searchManager.ts">
import * as vscode from 'vscode';
import { ContextService, ContextQuery } from './context/contextService';

/**
 * Search filters and options for advanced search functionality
 */
export interface SearchFilters {
    fileTypes?: string[];
    languages?: string[];
    dateRange?: {
        from?: Date;
        to?: Date;
    };
    minSimilarity?: number;
    maxResults?: number;
    includeTests?: boolean;
    includeComments?: boolean;
}

/**
 * Enhanced search result with additional metadata
 */
export interface EnhancedSearchResult {
    id: string;
    title: string;
    description: string;
    filePath: string;
    language: string;
    lineNumber: number;
    similarity: number;
    context: string;
    preview: string;
    lastModified: Date;
    fileSize: number;
    chunkType: string;
}

/**
 * Search history entry for tracking user searches
 */
export interface SearchHistoryEntry {
    query: string;
    filters: SearchFilters;
    timestamp: Date;
    resultCount: number;
}

/**
 * SearchManager class responsible for advanced search functionality and result management.
 * 
 * This class provides enhanced search capabilities including:
 * - Advanced filtering and sorting options
 * - Search history and suggestions
 * - Result caching and performance optimization
 * - File preview and context extraction
 * - Search analytics and insights
 */
export class SearchManager {
    private contextService: ContextService;
    private searchHistory: SearchHistoryEntry[] = [];
    private resultCache: Map<string, EnhancedSearchResult[]> = new Map();
    private readonly maxHistoryEntries = 50;
    private readonly cacheTimeout = 5 * 60 * 1000; // 5 minutes

    /**
     * Creates a new SearchManager instance
     * @param contextService - The ContextService instance for performing searches
     */
    constructor(contextService: ContextService) {
        this.contextService = contextService;
        this.loadSearchHistory();
    }

    /**
     * Performs an advanced search with filters and options
     * @param query - The search query string
     * @param filters - Search filters and options
     * @returns Promise resolving to enhanced search results
     */
    async search(query: string, filters: SearchFilters = {}): Promise<EnhancedSearchResult[]> {
        try {
            console.log('SearchManager: Performing advanced search:', { query, filters });

            // Check cache first
            const cacheKey = this.generateCacheKey(query, filters);
            const cachedResults = this.resultCache.get(cacheKey);
            if (cachedResults) {
                console.log('SearchManager: Returning cached results');
                return cachedResults;
            }

            // Build context query from search parameters
            const contextQuery: ContextQuery = {
                query,
                maxResults: filters.maxResults || 20,
                minSimilarity: filters.minSimilarity || 0.5,
                fileTypes: filters.fileTypes
            };

            // Perform the search
            const contextResults = await this.contextService.queryContext(contextQuery);

            // Transform results to enhanced format
            const enhancedResults = await this.transformResults(contextResults.relatedFiles || []);

            // Apply additional filtering
            const filteredResults = this.applyAdvancedFilters(enhancedResults, filters);

            // Sort results by relevance and similarity
            const sortedResults = this.sortResults(filteredResults);

            // Cache the results
            this.cacheResults(cacheKey, sortedResults);

            // Add to search history
            this.addToHistory(query, filters, sortedResults.length);

            console.log(`SearchManager: Found ${sortedResults.length} results`);
            return sortedResults;

        } catch (error) {
            console.error('SearchManager: Search failed:', error);
            throw error;
        }
    }

    /**
     * Gets search suggestions based on query and history
     * @param partialQuery - Partial query string for suggestions
     * @returns Array of suggested search terms
     */
    getSuggestions(partialQuery: string): string[] {
        const suggestions = new Set<string>();

        // Add suggestions from search history
        this.searchHistory
            .filter(entry => entry.query.toLowerCase().includes(partialQuery.toLowerCase()))
            .slice(0, 5)
            .forEach(entry => suggestions.add(entry.query));

        // Add common programming terms if relevant
        const programmingTerms = [
            'function', 'class', 'interface', 'method', 'variable',
            'import', 'export', 'async', 'await', 'promise',
            'error', 'exception', 'test', 'mock', 'config'
        ];

        programmingTerms
            .filter(term => term.toLowerCase().includes(partialQuery.toLowerCase()))
            .slice(0, 3)
            .forEach(term => suggestions.add(term));

        return Array.from(suggestions).slice(0, 8);
    }

    /**
     * Gets recent search history
     * @param limit - Maximum number of history entries to return
     * @returns Array of recent search history entries
     */
    getSearchHistory(limit: number = 10): SearchHistoryEntry[] {
        return this.searchHistory
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }

    /**
     * Clears search history
     */
    clearSearchHistory(): void {
        this.searchHistory = [];
        this.saveSearchHistory();
        console.log('SearchManager: Search history cleared');
    }

    /**
     * Gets file preview for a search result
     * @param filePath - Path to the file
     * @param lineNumber - Line number to center the preview around
     * @param contextLines - Number of lines to include before and after
     * @returns File preview with syntax highlighting
     */
    async getFilePreview(filePath: string, lineNumber: number, contextLines: number = 5): Promise<string> {
        try {
            const fileContent = await this.contextService.getFileContent(filePath);
            if (!fileContent.content) {
                return 'File content not available';
            }

            const lines = fileContent.content.split('\n');
            const startLine = Math.max(0, lineNumber - contextLines - 1);
            const endLine = Math.min(lines.length, lineNumber + contextLines);

            const previewLines = lines.slice(startLine, endLine);
            
            return previewLines
                .map((line, index) => {
                    const actualLineNumber = startLine + index + 1;
                    const isTargetLine = actualLineNumber === lineNumber;
                    const prefix = isTargetLine ? ' ' : '  ';
                    return `${prefix}${actualLineNumber.toString().padStart(4)}: ${line}`;
                })
                .join('\n');

        } catch (error) {
            console.error('SearchManager: Failed to get file preview:', error);
            return 'Preview not available';
        }
    }

    /**
     * Transforms context service results to enhanced search results
     */
    private async transformResults(chunks: any[]): Promise<EnhancedSearchResult[]> {
        const results: EnhancedSearchResult[] = [];

        for (const chunk of chunks) {
            try {
                const result: EnhancedSearchResult = {
                    id: `${chunk.filePath}-${chunk.startLine}`,
                    title: this.extractTitle(chunk),
                    description: this.extractDescription(chunk),
                    filePath: chunk.filePath,
                    language: chunk.language || 'unknown',
                    lineNumber: chunk.startLine || 1,
                    similarity: chunk.similarity || 0,
                    context: chunk.content || '',
                    preview: chunk.content?.substring(0, 200) + '...' || '',
                    lastModified: new Date(), // Would be populated from file stats
                    fileSize: 0, // Would be populated from file stats
                    chunkType: chunk.type || 'unknown'
                };

                results.push(result);
            } catch (error) {
                console.error('SearchManager: Error transforming result:', error);
            }
        }

        return results;
    }

    /**
     * Applies advanced filters to search results
     */
    private applyAdvancedFilters(results: EnhancedSearchResult[], filters: SearchFilters): EnhancedSearchResult[] {
        let filtered = results;

        // Filter by file types
        if (filters.fileTypes && filters.fileTypes.length > 0) {
            filtered = filtered.filter(result => 
                filters.fileTypes!.some(type => result.filePath.endsWith(type))
            );
        }

        // Filter by languages
        if (filters.languages && filters.languages.length > 0) {
            filtered = filtered.filter(result => 
                filters.languages!.includes(result.language)
            );
        }

        // Filter by date range
        if (filters.dateRange) {
            if (filters.dateRange.from) {
                filtered = filtered.filter(result => 
                    result.lastModified >= filters.dateRange!.from!
                );
            }
            if (filters.dateRange.to) {
                filtered = filtered.filter(result => 
                    result.lastModified <= filters.dateRange!.to!
                );
            }
        }

        // Filter by minimum similarity
        if (filters.minSimilarity !== undefined) {
            filtered = filtered.filter(result => 
                result.similarity >= filters.minSimilarity!
            );
        }

        return filtered;
    }

    /**
     * Sorts search results by relevance and similarity
     */
    private sortResults(results: EnhancedSearchResult[]): EnhancedSearchResult[] {
        return results.sort((a, b) => {
            // Primary sort: similarity score
            if (a.similarity !== b.similarity) {
                return b.similarity - a.similarity;
            }

            // Secondary sort: file type preference (source files over tests)
            const aIsTest = a.filePath.includes('test') || a.filePath.includes('spec');
            const bIsTest = b.filePath.includes('test') || b.filePath.includes('spec');
            if (aIsTest !== bIsTest) {
                return aIsTest ? 1 : -1;
            }

            // Tertiary sort: last modified date
            return b.lastModified.getTime() - a.lastModified.getTime();
        });
    }

    /**
     * Generates cache key for search results
     */
    private generateCacheKey(query: string, filters: SearchFilters): string {
        return `${query}-${JSON.stringify(filters)}`;
    }

    /**
     * Caches search results with timeout
     */
    private cacheResults(key: string, results: EnhancedSearchResult[]): void {
        this.resultCache.set(key, results);
        
        // Set timeout to clear cache entry
        setTimeout(() => {
            this.resultCache.delete(key);
        }, this.cacheTimeout);
    }

    /**
     * Adds search to history
     */
    private addToHistory(query: string, filters: SearchFilters, resultCount: number): void {
        const entry: SearchHistoryEntry = {
            query,
            filters,
            timestamp: new Date(),
            resultCount
        };

        // Remove duplicate queries
        this.searchHistory = this.searchHistory.filter(h => h.query !== query);
        
        // Add new entry at the beginning
        this.searchHistory.unshift(entry);

        // Limit history size
        if (this.searchHistory.length > this.maxHistoryEntries) {
            this.searchHistory = this.searchHistory.slice(0, this.maxHistoryEntries);
        }

        this.saveSearchHistory();
    }

    /**
     * Extracts title from chunk content
     */
    private extractTitle(chunk: any): string {
        if (chunk.metadata?.functionName) {
            return `Function: ${chunk.metadata.functionName}`;
        }
        if (chunk.metadata?.className) {
            return `Class: ${chunk.metadata.className}`;
        }
        
        // Extract first meaningful line
        const lines = chunk.content?.split('\n') || [];
        const meaningfulLine = lines.find((line: string) =>
            line.trim() && !line.trim().startsWith('//') && !line.trim().startsWith('*')
        );
        
        return meaningfulLine?.trim().substring(0, 50) + '...' || 'Code snippet';
    }

    /**
     * Extracts description from chunk content
     */
    private extractDescription(chunk: any): string {
        const content = chunk.content || '';
        const lines = content.split('\n');
        
        // Look for comments that might describe the code
        const commentLine = lines.find((line: string) =>
            line.trim().startsWith('//') || line.trim().startsWith('*')
        );
        
        if (commentLine) {
            return commentLine.trim().replace(/^[\/\*\s]+/, '').substring(0, 100);
        }
        
        // Fallback to first few lines
        return lines.slice(0, 2).join(' ').trim().substring(0, 100) + '...';
    }

    /**
     * Loads search history from storage
     */
    private loadSearchHistory(): void {
        // In a real implementation, this would load from VS Code's global state
        // For now, we'll start with an empty history
        this.searchHistory = [];
    }

    /**
     * Saves search history to storage
     */
    private saveSearchHistory(): void {
        // In a real implementation, this would save to VS Code's global state
        console.log('SearchManager: Search history saved');
    }

    /**
     * Disposes of the SearchManager and cleans up resources
     */
    dispose(): void {
        this.resultCache.clear();
        console.log('SearchManager: Disposed');
    }
}
</file>

<file path="webview/src/lib/components/ErrorBoundary.svelte">
<script lang="ts">
    import { onMount } from 'svelte';
    import { appActions } from '$lib/stores/appStore';
    import { registerCoreComponents } from '$lib/utils/fluentUI';

    // Register Fluent UI components
    registerCoreComponents();

    // Props
    export let fallbackMessage = 'Something went wrong. Please try again.';
    export let showDetails = false;
    export let onError: ((error: Error) => void) | null = null;

    // State
    let hasError = false;
    let errorMessage = '';
    let errorStack = '';
    let errorDetails = '';

    // Error handler
    function handleError(error: Error | ErrorEvent | PromiseRejectionEvent) {
        hasError = true;
        
        if (error instanceof Error) {
            errorMessage = error.message;
            errorStack = error.stack || '';
            errorDetails = `${error.name}: ${error.message}`;
        } else if (error instanceof ErrorEvent) {
            errorMessage = error.message;
            errorStack = error.error?.stack || '';
            errorDetails = `${error.filename}:${error.lineno}:${error.colno} - ${error.message}`;
        } else if (error instanceof PromiseRejectionEvent) {
            errorMessage = error.reason?.message || 'Promise rejection';
            errorStack = error.reason?.stack || '';
            errorDetails = `Unhandled Promise Rejection: ${error.reason}`;
        } else {
            errorMessage = 'Unknown error occurred';
            errorDetails = String(error);
        }

        // Log error for debugging
        console.error('ErrorBoundary caught error:', error);
        
        // Report to app store
        appActions.setError(errorMessage);
        
        // Call custom error handler if provided
        if (onError && error instanceof Error) {
            try {
                onError(error);
            } catch (handlerError) {
                console.error('Error in custom error handler:', handlerError);
            }
        }
    }

    // Reset error state
    function resetError() {
        hasError = false;
        errorMessage = '';
        errorStack = '';
        errorDetails = '';
        appActions.clearError();
    }

    // Reload the component/page
    function reloadComponent() {
        resetError();
        // Force a re-render by updating a reactive variable
        window.location.reload();
    }

    onMount(() => {
        // Global error handlers
        const handleGlobalError = (event: ErrorEvent) => {
            handleError(event);
        };

        const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
            handleError(event);
        };

        // Add global error listeners
        window.addEventListener('error', handleGlobalError);
        window.addEventListener('unhandledrejection', handleUnhandledRejection);

        return () => {
            window.removeEventListener('error', handleGlobalError);
            window.removeEventListener('unhandledrejection', handleUnhandledRejection);
        };
    });

    // Reactive statement to catch component errors
    $: if (hasError) {
        console.warn('Component is in error state:', errorMessage);
    }
</script>

{#if hasError}
    <div class="error-boundary">
        <fluent-card class="error-card">
            <div class="error-content">
                <div class="error-icon"></div>
                <h3 class="error-title">Oops! Something went wrong</h3>
                <p class="error-message">{fallbackMessage}</p>
                
                {#if showDetails && errorDetails}
                    <details class="error-details">
                        <summary>Technical Details</summary>
                        <div class="error-details-content">
                            <p><strong>Error:</strong> {errorMessage}</p>
                            {#if errorStack}
                                <pre class="error-stack">{errorStack}</pre>
                            {/if}
                        </div>
                    </details>
                {/if}

                <div class="error-actions">
                    <fluent-button
                        appearance="accent"
                        on:click={resetError}
                        on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && resetError()}
                        role="button"
                        tabindex="0"
                    >
                        Try Again
                    </fluent-button>

                    <fluent-button
                        on:click={reloadComponent}
                        on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && reloadComponent()}
                        role="button"
                        tabindex="0"
                    >
                        Reload
                    </fluent-button>
                </div>
            </div>
        </fluent-card>
    </div>
{:else}
    <slot />
{/if}

<style>
    .error-boundary {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 200px;
        padding: 20px;
    }

    .error-card {
        max-width: 500px;
        width: 100%;
        padding: 30px;
        text-align: center;
    }

    .error-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    .error-icon {
        font-size: 48px;
        margin-bottom: 10px;
    }

    .error-title {
        margin: 0;
        color: var(--vscode-errorForeground);
        font-size: 20px;
        font-weight: 600;
    }

    .error-message {
        margin: 0;
        color: var(--vscode-foreground);
        font-size: 16px;
        line-height: 1.5;
    }

    .error-details {
        width: 100%;
        margin-top: 15px;
        text-align: left;
    }

    .error-details summary {
        cursor: pointer;
        font-weight: 500;
        color: var(--vscode-textLink-foreground);
        margin-bottom: 10px;
    }

    .error-details summary:hover {
        color: var(--vscode-textLink-activeForeground);
    }

    .error-details-content {
        padding: 10px;
        background-color: var(--vscode-textCodeBlock-background);
        border-radius: 4px;
        border: 1px solid var(--vscode-panel-border);
    }

    .error-details-content p {
        margin: 0 0 10px 0;
        font-size: 14px;
    }

    .error-stack {
        margin: 0;
        padding: 10px;
        background-color: var(--vscode-editor-background);
        border: 1px solid var(--vscode-panel-border);
        border-radius: 3px;
        font-family: var(--vscode-editor-font-family);
        font-size: 12px;
        line-height: 1.4;
        color: var(--vscode-foreground);
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .error-actions {
        display: flex;
        gap: 10px;
        margin-top: 20px;
    }

    .error-actions fluent-button {
        min-width: 100px;
    }

    /* Responsive design */
    @media (max-width: 600px) {
        .error-boundary {
            padding: 10px;
        }

        .error-card {
            padding: 20px;
        }

        .error-actions {
            flex-direction: column;
            width: 100%;
        }

        .error-actions fluent-button {
            width: 100%;
        }
    }
</style>
</file>

<file path="webview/src/lib/components/SetupView.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import {
        provideFluentDesignSystem,
        fluentButton,
        fluentTextField,
        fluentSelect,
        fluentOption,
        fluentProgressRing,
        fluentCard
    } from '@fluentui/web-components';
    import { postMessage, onMessage } from '$lib/vscodeApi';
    import {
        setupState,
        indexingState,
        setupActions,
        indexingActions,
        appActions,
        isSetupComplete,
        canStartIndexing
    } from '$lib/stores/appStore';
    import ValidatedInput from './ValidatedInput.svelte';
    import ConnectionTester from './ConnectionTester.svelte';
    import { validators } from '$lib/utils/validation';
    import type { ValidationResult } from '$lib/utils/validation';
    
    // Register Fluent UI components
    provideFluentDesignSystem().register(
        fluentButton(),
        fluentTextField(),
        fluentSelect(),
        fluentOption(),
        fluentProgressRing(),
        fluentCard()
    );

    // Local UI state (non-persistent)
    let errorMessage = '';
    let successMessage = '';

    // Validation state
    let databaseValidation: ValidationResult | null = null;
    let providerValidation: ValidationResult | null = null;
    let databaseConfigFields = {
        host: '',
        port: '',
        apiKey: '',
        environment: ''
    };
    let providerConfigFields = {
        apiKey: '',
        endpoint: '',
        model: ''
    };

    // Message handlers
    let unsubscribeFunctions: (() => void)[] = [];

    onMount(() => {
        // Set up message listeners using the wrapper
        unsubscribeFunctions.push(
            onMessage('databaseStatus', (message) => {
                setupActions.setDatabaseStatus(message.status);
            }),
            onMessage('providerStatus', (message) => {
                setupActions.setProviderStatus(message.status);
            }),
            onMessage('indexingProgress', (message) => {
                indexingActions.updateProgress(
                    message.percentage || 0,
                    message.message || 'Indexing in progress...',
                    message.filesProcessed,
                    message.totalFiles,
                    message.currentFile
                );
            }),
            onMessage('indexingCompleted', (message) => {
                indexingActions.completeIndexing(message.success ?? false, message.totalFiles);
                if (message.success) {
                    successMessage = 'Indexing completed successfully!';
                } else {
                    errorMessage = 'Indexing failed. Please check the logs.';
                }
            }),
            onMessage('error', (message) => {
                errorMessage = message.message;
                appActions.setError(message.message);
            })
        );

        // Request initial status
        postMessage('getSetupStatus');
    });

    onDestroy(() => {
        // Clean up message listeners
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    });





    function startDatabase() {
        const currentSetup = $setupState;
        if (!currentSetup.selectedDatabase) {
            errorMessage = 'Please select a database first';
            return;
        }

        setupActions.setDatabaseStatus('starting');
        errorMessage = '';

        postMessage('startDatabase', {
            database: currentSetup.selectedDatabase
        });
    }

    function configureProvider() {
        const currentSetup = $setupState;
        if (!currentSetup.selectedProvider) {
            errorMessage = 'Please select a provider first';
            return;
        }

        setupActions.setProviderStatus('starting');
        errorMessage = '';

        postMessage('configureProvider', {
            provider: currentSetup.selectedProvider
        });
    }

    function startIndexing() {
        const currentSetup = $setupState;
        if (!$canStartIndexing) {
            errorMessage = 'Please complete database and provider setup first';
            return;
        }

        indexingActions.startIndexing();
        errorMessage = '';

        postMessage('startIndexing', {
            configuration: {
                database: currentSetup.selectedDatabase,
                provider: currentSetup.selectedProvider
            }
        });
    }

    function clearMessages() {
        errorMessage = '';
        successMessage = '';
    }


</script>

<div class="setup-view">
    <div class="setup-header">
        <h1>Welcome to Code Context Engine</h1>
        <p>Let's get you set up! Configure your database and embedding provider to start indexing your code.</p>
    </div>

    <!-- Progress Steps -->
    <div class="setup-progress">
        <div class="progress-step" class:active={$setupState.databaseStatus === 'idle' || $setupState.databaseStatus === 'starting'} class:completed={$setupState.databaseStatus === 'ready'}>
            <div class="step-number">1</div>
            <div class="step-label">Database</div>
        </div>
        <div class="progress-line"></div>
        <div class="progress-step" class:active={$setupState.providerStatus === 'idle' || $setupState.providerStatus === 'starting'} class:completed={$setupState.providerStatus === 'ready'}>
            <div class="step-number">2</div>
            <div class="step-label">Provider</div>
        </div>
        <div class="progress-line"></div>
        <div class="progress-step" class:active={$isSetupComplete} class:completed={false}>
            <div class="step-number">3</div>
            <div class="step-label">Ready</div>
        </div>
    </div>

    <!-- Error/Success Messages -->
    {#if errorMessage}
        <div class="notification error">
            {errorMessage}
            <button class="notification-close" on:click={clearMessages}></button>
        </div>
    {/if}

    {#if successMessage}
        <div class="notification success">
            {successMessage}
            <button class="notification-close" on:click={clearMessages}></button>
        </div>
    {/if}

    <!-- Database Setup -->
    <fluent-card class="setup-section">
        <h3>Database Configuration</h3>
        <p>Select and configure your vector database for code indexing.</p>
        
        <ValidatedInput
            type="select"
            label="Vector Database"
            value={$setupState.selectedDatabase}
            required={true}
            placeholder="Select a database..."
            options={[
                { value: "qdrant", label: "Qdrant (Local/Docker)" },
                { value: "chromadb", label: "ChromaDB (Local/Docker)" },
                { value: "pinecone", label: "Pinecone (Cloud)" }
            ]}
            validator={(value) => validators.required(value, 'Database')}
            on:input={(e) => {
                setupActions.setSelectedDatabase(e.detail.value);
                errorMessage = '';
            }}
            on:validation={(e) => {
                databaseValidation = e.detail.result;
            }}
        />

        {#if $setupState.selectedDatabase}
            <!-- Database-specific configuration fields -->
            {#if $setupState.selectedDatabase === 'qdrant' || $setupState.selectedDatabase === 'chromadb'}
                <div class="config-fields">
                    <ValidatedInput
                        type="text"
                        label="Host"
                        value={databaseConfigFields.host}
                        placeholder="localhost"
                        validator={(value) => value ? validators.url(`http://${value}`, 'Host') : { isValid: true, errors: [], warnings: [], suggestions: ['Default localhost will be used'] }}
                        on:input={(e) => {
                            databaseConfigFields.host = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="number"
                        label="Port"
                        value={databaseConfigFields.port}
                        placeholder={$setupState.selectedDatabase === 'qdrant' ? '6333' : '8000'}
                        validator={(value) => value ? validators.port(value, 'Port') : { isValid: true, errors: [], warnings: [], suggestions: [`Default port ${$setupState.selectedDatabase === 'qdrant' ? '6333' : '8000'} will be used`] }}
                        on:input={(e) => {
                            databaseConfigFields.port = e.detail.value;
                        }}
                    />
                </div>
            {:else if $setupState.selectedDatabase === 'pinecone'}
                <div class="config-fields">
                    <ValidatedInput
                        type="password"
                        label="API Key"
                        value={databaseConfigFields.apiKey}
                        placeholder="Enter your Pinecone API key"
                        required={true}
                        validator={(value) => validators.apiKey(value, 'Pinecone API Key')}
                        on:input={(e) => {
                            databaseConfigFields.apiKey = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="text"
                        label="Environment"
                        value={databaseConfigFields.environment}
                        placeholder="us-west1-gcp"
                        required={true}
                        validator={(value) => validators.stringLength(value, 1, 50, 'Environment')}
                        on:input={(e) => {
                            databaseConfigFields.environment = e.detail.value;
                        }}
                    />
                </div>
            {/if}

            <!-- Connection Testing -->
            <ConnectionTester
                type="database"
                config={{
                    type: $setupState.selectedDatabase as 'qdrant' | 'chromadb' | 'pinecone',
                    host: databaseConfigFields.host || 'localhost',
                    port: databaseConfigFields.port ? parseInt(databaseConfigFields.port) : undefined,
                    apiKey: databaseConfigFields.apiKey,
                    environment: databaseConfigFields.environment
                }}
                disabled={$setupState.databaseStatus === 'starting'}
                showDetails={true}
                on:testComplete={(e) => {
                    if (e.detail.result.success) {
                        successMessage = 'Database connection test successful!';
                    } else {
                        errorMessage = `Database connection test failed: ${e.detail.result.message}`;
                    }
                }}
            />

            <div class="action-section">
                <fluent-button
                    appearance="accent"
                    disabled={$setupState.databaseStatus === 'starting' || $setupState.databaseStatus === 'ready'}
                    on:click={startDatabase}
                    role="button"
                    tabindex="0"
                    on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && startDatabase()}
                >
                    {#if $setupState.databaseStatus === 'starting'}
                        <fluent-progress-ring></fluent-progress-ring>
                        Starting...
                    {:else if $setupState.databaseStatus === 'ready'}
                         Database Ready
                    {:else}
                        Start {$setupState.selectedDatabase === 'pinecone' ? 'Validate' : 'Local'} {$setupState.selectedDatabase}
                    {/if}
                </fluent-button>
            </div>
        {/if}
    </fluent-card>

    <!-- Provider Setup -->
    <fluent-card class="setup-section">
        <h3>Embedding Provider Configuration</h3>
        <p>Choose your AI embedding provider for semantic code search.</p>
        
        <ValidatedInput
            type="select"
            label="Embedding Provider"
            value={$setupState.selectedProvider}
            required={true}
            placeholder="Select a provider..."
            options={[
                { value: "ollama", label: "Ollama (Local)" },
                { value: "openai", label: "OpenAI" },
                { value: "azure", label: "Azure OpenAI" }
            ]}
            validator={(value) => validators.required(value, 'Provider')}
            on:input={(e) => {
                setupActions.setSelectedProvider(e.detail.value);
                errorMessage = '';
            }}
            on:validation={(e) => {
                providerValidation = e.detail.result;
            }}
        />

        {#if $setupState.selectedProvider}
            <!-- Provider-specific configuration fields -->
            {#if $setupState.selectedProvider === 'openai'}
                <div class="config-fields">
                    <ValidatedInput
                        type="password"
                        label="OpenAI API Key"
                        value={providerConfigFields.apiKey}
                        placeholder="sk-..."
                        required={true}
                        validator={(value) => validators.apiKey(value, 'OpenAI API Key')}
                        on:input={(e) => {
                            providerConfigFields.apiKey = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="text"
                        label="Model (Optional)"
                        value={providerConfigFields.model}
                        placeholder="text-embedding-ada-002"
                        validator={(value) => value ? validators.stringLength(value, 1, 100, 'Model') : { isValid: true, errors: [], warnings: [], suggestions: [] }}
                        on:input={(e) => {
                            providerConfigFields.model = e.detail.value;
                        }}
                    />
                </div>
            {:else if $setupState.selectedProvider === 'azure'}
                <div class="config-fields">
                    <ValidatedInput
                        type="password"
                        label="Azure API Key"
                        value={providerConfigFields.apiKey}
                        placeholder="Enter your Azure API key"
                        required={true}
                        validator={(value) => validators.apiKey(value, 'Azure API Key')}
                        on:input={(e) => {
                            providerConfigFields.apiKey = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="url"
                        label="Azure Endpoint"
                        value={providerConfigFields.endpoint}
                        placeholder="https://your-resource.openai.azure.com/"
                        required={true}
                        validator={(value) => validators.url(value, 'Azure Endpoint')}
                        on:input={(e) => {
                            providerConfigFields.endpoint = e.detail.value;
                        }}
                    />
                </div>
            {:else if $setupState.selectedProvider === 'ollama'}
                <div class="config-fields">
                    <ValidatedInput
                        type="url"
                        label="Ollama Endpoint"
                        value={providerConfigFields.endpoint}
                        placeholder="http://localhost:11434"
                        validator={(value) => value ? validators.url(value, 'Ollama Endpoint') : { isValid: true, errors: [], warnings: [], suggestions: ['Default endpoint http://localhost:11434 will be used'] }}
                        on:input={(e) => {
                            providerConfigFields.endpoint = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="text"
                        label="Model (Optional)"
                        value={providerConfigFields.model}
                        placeholder="nomic-embed-text"
                        validator={(value) => value ? validators.stringLength(value, 1, 100, 'Model') : { isValid: true, errors: [], warnings: [], suggestions: [] }}
                        on:input={(e) => {
                            providerConfigFields.model = e.detail.value;
                        }}
                    />
                </div>
            {/if}

            <!-- Connection Testing -->
            <ConnectionTester
                type="provider"
                config={{
                    type: $setupState.selectedProvider as 'ollama' | 'openai' | 'azure',
                    apiKey: providerConfigFields.apiKey,
                    endpoint: providerConfigFields.endpoint,
                    model: providerConfigFields.model
                }}
                disabled={$setupState.providerStatus === 'starting'}
                showDetails={true}
                on:testComplete={(e) => {
                    if (e.detail.result.success) {
                        successMessage = 'Provider connection test successful!';
                    } else {
                        errorMessage = `Provider connection test failed: ${e.detail.result.message}`;
                    }
                }}
            />

            <div class="action-section">
                <fluent-button
                    appearance="accent"
                    disabled={$setupState.providerStatus === 'starting' || $setupState.providerStatus === 'ready'}
                    on:click={configureProvider}
                    role="button"
                    tabindex="0"
                    on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && configureProvider()}
                >
                    {#if $setupState.providerStatus === 'starting'}
                        <fluent-progress-ring></fluent-progress-ring>
                        Configuring...
                    {:else if $setupState.providerStatus === 'ready'}
                         Provider Ready
                    {:else}
                        Configure {$setupState.selectedProvider}
                    {/if}
                </fluent-button>
            </div>
        {/if}
    </fluent-card>

    <!-- Indexing Section -->
    <div class="setup-actions">
        <fluent-button
            appearance="accent"
            size="large"
            disabled={!$canStartIndexing}
            on:click={startIndexing}
            role="button"
            tabindex="0"
            on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && startIndexing()}
        >
            {#if $indexingState.isIndexing}
                <fluent-progress-ring></fluent-progress-ring>
                Indexing...
            {:else}
                 Index Now
            {/if}
        </fluent-button>
        
        <p class="action-help">
            {#if $isSetupComplete}
                Ready to index your codebase!
            {:else}
                Complete the configuration above to enable indexing.
            {/if}
        </p>
    </div>

    <!-- Indexing Progress -->
    {#if $indexingState.isIndexing}
        <fluent-card class="indexing-progress">
            <h3>Indexing in Progress</h3>
            <div class="progress-bar">
                <div class="progress-fill" style="width: {$indexingState.progress}%"></div>
            </div>
            <p class="progress-text">{$indexingState.message}</p>
        </fluent-card>
    {/if}
</div>

<style>
    .setup-view {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        font-family: var(--vscode-font-family);
    }

    .setup-header {
        text-align: center;
        margin-bottom: 30px;
    }

    .setup-header h1 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
        font-size: 28px;
    }

    .setup-header p {
        margin: 0;
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
    }

    .setup-progress {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 40px;
        padding: 20px;
    }

    .progress-step {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }

    .step-number {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        border: 2px solid var(--vscode-panel-border);
        background-color: var(--vscode-sideBar-background);
        color: var(--vscode-descriptionForeground);
        transition: all 0.3s ease;
    }

    .progress-step.active .step-number {
        background-color: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
        border-color: var(--vscode-button-background);
    }

    .progress-step.completed .step-number {
        background-color: var(--vscode-charts-green);
        color: white;
        border-color: var(--vscode-charts-green);
    }

    .step-label {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
        font-weight: 500;
    }

    .progress-step.active .step-label {
        color: var(--vscode-foreground);
    }

    .progress-line {
        width: 60px;
        height: 2px;
        background-color: var(--vscode-panel-border);
        margin: 0 10px;
    }

    .setup-section {
        margin-bottom: 20px;
        padding: 20px;
    }

    .setup-section h3 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
    }

    .setup-section p {
        margin: 0 0 20px 0;
        color: var(--vscode-descriptionForeground);
    }

    .config-fields {
        margin: 20px 0;
        padding: 16px;
        background-color: var(--vscode-textCodeBlock-background);
        border-radius: 6px;
        border: 1px solid var(--vscode-panel-border);
    }



    .action-section {
        margin-top: 15px;
    }

    .setup-actions {
        text-align: center;
        padding: 20px;
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        background-color: var(--vscode-sideBar-background);
        margin-bottom: 20px;
    }

    .action-help {
        margin: 10px 0 0 0;
        font-size: 14px;
        color: var(--vscode-descriptionForeground);
    }

    .indexing-progress {
        padding: 20px;
    }

    .indexing-progress h3 {
        margin: 0 0 15px 0;
        color: var(--vscode-textLink-foreground);
    }

    .progress-bar {
        width: 100%;
        height: 8px;
        background-color: var(--vscode-progressBar-background);
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 10px;
    }

    .progress-fill {
        height: 100%;
        background-color: var(--vscode-progressBar-foreground);
        transition: width 0.3s ease;
    }

    .progress-text {
        margin: 0;
        font-size: 14px;
        color: var(--vscode-foreground);
    }

    .notification {
        padding: 12px 16px;
        border-radius: 4px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .notification.error {
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        color: var(--vscode-inputValidation-errorForeground);
    }

    .notification.success {
        background-color: var(--vscode-charts-green);
        color: white;
    }

    .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
        margin-left: 10px;
    }
</style>
</file>

<file path="webview/src/routes/+page.svelte">
<script lang="ts">
    import { onMount } from 'svelte';
    import { currentView, type ViewType } from '$lib/stores/viewStore';
    import { initializePersistence } from '$lib/stores/persistence';
    import { appActions } from '$lib/stores/appStore';
    import ErrorBoundary from '$lib/components/ErrorBoundary.svelte';
    import { performanceTracker, measureComponentLoad } from '$lib/utils/performance';
    import { registerCoreComponents } from '$lib/utils/fluentUI';
    import { fadeIn, slideInFromBottom } from '$lib/utils/animations';

    // Dynamic imports for code splitting
    let SetupView: any = null;
    let IndexingView: any = null;
    let QueryView: any = null;
    let DiagnosticsView: any = null;

    // Loading states
    let componentsLoaded = {
        setup: false,
        indexing: false,
        query: false,
        diagnostics: false
    };

    // Component container references for animations
    let componentContainer: HTMLElement;

    // Current view state
    let view: ViewType = 'setup';

    /**
     * Animate component when it loads
     */
    function animateComponentLoad() {
        if (componentContainer) {
            slideInFromBottom(componentContainer, { duration: 400 });
        }
    }

    /**
     * Dynamically load a component
     */
    async function loadComponent(componentName: 'setup' | 'indexing' | 'query' | 'diagnostics') {
        if (componentsLoaded[componentName]) return;

        const loadMeasure = measureComponentLoad(componentName);
        loadMeasure.start();

        try {
            switch (componentName) {
                case 'setup':
                    if (!SetupView) {
                        const module = await import('$lib/components/SetupView.svelte');
                        SetupView = module.default;
                        componentsLoaded.setup = true;
                        // Trigger animation after component is ready
                        setTimeout(animateComponentLoad, 50);
                    }
                    break;
                case 'indexing':
                    if (!IndexingView) {
                        const module = await import('$lib/components/IndexingView.svelte');
                        IndexingView = module.default;
                        componentsLoaded.indexing = true;
                    }
                    break;
                case 'query':
                    if (!QueryView) {
                        const module = await import('$lib/components/QueryView.svelte');
                        QueryView = module.default;
                        componentsLoaded.query = true;
                    }
                    break;
                case 'diagnostics':
                    if (!DiagnosticsView) {
                        const module = await import('$lib/components/DiagnosticsView.svelte');
                        DiagnosticsView = module.default;
                        componentsLoaded.diagnostics = true;
                    }
                    break;
            }
            loadMeasure.end();
        } catch (error) {
            loadMeasure.end();
            console.error(`Failed to load ${componentName} component:`, error);
        }
    }

    /**
     * Preload components based on current view
     */
    async function preloadComponents(currentView: ViewType) {
        // Always load the current view
        await loadComponent(currentView);

        // Preload likely next views
        if (currentView === 'setup') {
            // Preload indexing view as it's the next logical step
            setTimeout(() => loadComponent('indexing'), 100);
        } else if (currentView === 'indexing') {
            // Preload query view as it's the final step
            setTimeout(() => loadComponent('query'), 100);
        }
    }

    // Subscribe to view store changes
    onMount(() => {
        // Start performance tracking
        performanceTracker.start('app-initialization');

        // Register core Fluent UI components
        registerCoreComponents();

        // Initialize persistence system
        const cleanupPersistence = initializePersistence();

        // Initialize app
        appActions.initialize();

        // End performance tracking
        performanceTracker.end('app-initialization');

        const unsubscribe = currentView.subscribe(async (newView) => {
            view = newView;
            await preloadComponents(newView);
        });

        // VS Code API for receiving initial view state
        const vscode = (window as any).acquireVsCodeApi();

        // Listen for view change messages from extension
        window.addEventListener('message', (event) => {
            const message = event.data;
            if (message.command === 'setView') {
                currentView.set(message.view);
            }
        });

        // Request initial view state
        vscode.postMessage({ command: 'getInitialView' });

        // Load initial component
        preloadComponents(view);

        return () => {
            unsubscribe();
            cleanupPersistence();
        };
    });
</script>

<main class="app-container">
    <ErrorBoundary
        fallbackMessage="The application encountered an error. Please try refreshing or contact support if the problem persists."
        showDetails={true}
        onError={(error) => console.error('Application error:', error)}
    >
        {#if view === 'setup'}
            {#if SetupView}
                <div bind:this={componentContainer} class="component-container">
                    <svelte:component this={SetupView} />
                </div>
            {:else}
                <div class="loading-component">
                    <div class="loading-spinner"></div>
                    <p>Loading Setup...</p>
                </div>
            {/if}
        {:else if view === 'indexing'}
            {#if IndexingView}
                <svelte:component this={IndexingView} />
            {:else}
                <div class="loading-component">
                    <div class="loading-spinner"></div>
                    <p>Loading Indexing...</p>
                </div>
            {/if}
        {:else if view === 'query'}
            {#if QueryView}
                <svelte:component this={QueryView} />
            {:else}
                <div class="loading-component">
                    <div class="loading-spinner"></div>
                    <p>Loading Query...</p>
                </div>
            {/if}
        {:else if view === 'diagnostics'}
            {#if DiagnosticsView}
                <svelte:component this={DiagnosticsView} />
            {:else}
                <div class="loading-component">
                    <div class="loading-spinner"></div>
                    <p>Loading Diagnostics...</p>
                </div>
            {/if}
        {:else}
            <!-- Fallback to setup view -->
            {#if SetupView}
                <svelte:component this={SetupView} />
            {:else}
                <div class="loading-component">
                    <div class="loading-spinner"></div>
                    <p>Loading...</p>
                </div>
            {/if}
        {/if}
    </ErrorBoundary>
</main>

<style>
    .app-container {
        min-height: 100vh;
        background-color: var(--vscode-editor-background);
        color: var(--vscode-foreground);
    }

    .component-container {
        /* Initial state for animation */
        opacity: 0;
        transform: translateY(20px);
    }

    .loading-component {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 200px;
        padding: 40px 20px;
        text-align: center;
    }

    .loading-spinner {
        width: 32px;
        height: 32px;
        border: 3px solid var(--vscode-panel-border);
        border-top: 3px solid var(--vscode-button-background);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 16px;
    }

    .loading-component p {
        margin: 0;
        font-size: 14px;
        color: var(--vscode-descriptionForeground);
        font-weight: 500;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Fade in animation for loaded components */
    :global(.component-fade-in) {
        animation: fadeIn 0.3s ease-in-out;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    :global(body) {
        margin: 0;
        padding: 0;
        font-family: var(--vscode-font-family);
        background-color: var(--vscode-editor-background);
        color: var(--vscode-foreground);
    }

    :global(*) {
        box-sizing: border-box;
    }
</style>
</file>

<file path="webview/src/app.css">
/**
 * Global Application Styles
 *
 * Base styles for the Code Context Engine webview application.
 * Uses VS Code theme variables for consistent styling.
 */

/* Reset and base styles */
* {
    box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
    font-weight: var(--vscode-font-weight);
    color: var(--vscode-foreground);
    background-color: var(--vscode-editor-background);
    line-height: 1.5;
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: var(--vscode-scrollbarSlider-background);
}

::-webkit-scrollbar-thumb {
    background: var(--vscode-scrollbarSlider-background);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--vscode-scrollbarSlider-hoverBackground);
}

/* Focus styles */
:focus {
    outline: 1px solid var(--vscode-focusBorder);
    outline-offset: 1px;
}

/* Selection styles */
::selection {
    background-color: var(--vscode-editor-selectionBackground);
    color: var(--vscode-editor-selectionForeground);
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
    margin: 0 0 16px 0;
    font-weight: 600;
    line-height: 1.3;
}

h1 { font-size: 24px; }
h2 { font-size: 20px; }
h3 { font-size: 18px; }
h4 { font-size: 16px; }
h5 { font-size: 14px; }
h6 { font-size: 12px; }

p {
    margin: 0 0 12px 0;
}

/* Links */
a {
    color: var(--vscode-textLink-foreground);
    text-decoration: none;
}

a:hover {
    color: var(--vscode-textLink-activeForeground);
    text-decoration: underline;
}

/* Code */
code {
    font-family: var(--vscode-editor-font-family);
    font-size: 0.9em;
    background-color: var(--vscode-textCodeBlock-background);
    padding: 2px 4px;
    border-radius: 3px;
}

pre {
    font-family: var(--vscode-editor-font-family);
    background-color: var(--vscode-textCodeBlock-background);
    padding: 12px;
    border-radius: 4px;
    overflow-x: auto;
    margin: 0 0 12px 0;
}

/* Utility classes */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

.font-bold { font-weight: 600; }
.font-normal { font-weight: 400; }

.mb-0 { margin-bottom: 0; }
.mb-1 { margin-bottom: 4px; }
.mb-2 { margin-bottom: 8px; }
.mb-3 { margin-bottom: 12px; }
.mb-4 { margin-bottom: 16px; }

.mt-0 { margin-top: 0; }
.mt-1 { margin-top: 4px; }
.mt-2 { margin-top: 8px; }
.mt-3 { margin-top: 12px; }
.mt-4 { margin-top: 16px; }
</file>

<file path="webview/tsconfig.json">
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// To make changes to top-level options such as include and exclude, we recommend extending
	// the generated config; see https://svelte.dev/docs/kit/configuration#typescript
}
</file>

<file path="webview/vite.config.ts">
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [sveltekit()],
	build: {
		// Optimize bundle size
		minify: 'terser',
		terserOptions: {
			compress: {
				drop_console: true,
				drop_debugger: true,
			},
		},
		// Enable tree-shaking
		rollupOptions: {
			output: {
				manualChunks: (id) => {
					// Separate vendor chunks for better caching
					if (id.includes('node_modules')) {
						if (id.includes('@fluentui/web-components')) {
							return 'fluent-ui';
						}
						return 'vendor';
					}
				},
			},
		},
		// Set chunk size warning limit
		chunkSizeWarningLimit: 1000,
	},
	// Optimize dependencies
	optimizeDeps: {
		include: ['@fluentui/web-components'],
	},
	test: {
		expect: { requireAssertions: true },
		projects: [
			{
				extends: './vite.config.ts',
				test: {
					name: 'client',
					environment: 'browser',
					browser: {
						enabled: true,
						provider: 'playwright',
						instances: [{ browser: 'chromium' }]
					},
					include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
					exclude: ['src/lib/server/**'],
					setupFiles: ['./vitest-setup-client.ts']
				}
			},
			{
				extends: './vite.config.ts',
				test: {
					name: 'server',
					environment: 'node',
					include: ['src/**/*.{test,spec}.{js,ts}'],
					exclude: ['src/**/*.svelte.{test,spec}.{js,ts}']
				}
			}
		]
	}
});
</file>

<file path="src/indexing/fileWalker.ts">
/**
 * File system traversal and management utilities.
 * This module provides functionality for walking through a workspace,
 * finding files based on patterns, and filtering them according to ignore rules.
 *
 * The FileWalker class is responsible for discovering all relevant code files
 * in a workspace while respecting .gitignore patterns and other exclusion rules.
 * It supports multiple programming languages and file types, making it
 * suitable for diverse codebases.
 */
import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import ignore from 'ignore';

/**
 * FileWalker class for traversing and filtering files in a workspace.
 * Handles file discovery, pattern matching, and respects gitignore rules.
 *
 * This class implements a comprehensive file discovery system that:
 * - Scans the entire workspace directory tree
 * - Supports multiple programming languages and file extensions
 * - Respects .gitignore and custom ignore patterns
 * - Provides statistics about discovered files
 * - Filters out non-code files and build artifacts
 */
export class FileWalker {
    /** Root directory of the workspace to scan */
    private workspaceRoot: string;
    /** Instance of ignore package to handle file exclusion patterns */
    private ignoreInstance: ReturnType<typeof ignore>;

    /**
     * Creates a new FileWalker instance
     * @param workspaceRoot - The absolute path to the workspace root directory
     *
     * Initializes the FileWalker with the workspace root directory and sets up
     * default ignore patterns for common build artifacts and directories.
     */
    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
        this.ignoreInstance = ignore();
        
        // Add common patterns to ignore by default
        // These patterns exclude build artifacts, dependencies, and IDE configurations
        this.ignoreInstance.add([
            'node_modules/**',      // Node.js dependencies
            '.git/**',             // Git version control directory
            'dist/**',             // Distribution/build directories
            'build/**',            // Build output directories
            'out/**',              // Output directories
            '*.min.js',            // Minified JavaScript files
            '*.map',               // Source map files
            '.vscode/**',          // VS Code workspace configuration
            '.idea/**',            // IntelliJ IDEA workspace configuration
            '*.log',               // Log files
            'coverage/**',         // Code coverage reports
            '.nyc_output/**'       // NYC test coverage output
        ]);
    }

    /**
     * Loads and parses the .gitignore file from the workspace root
     * Adds all valid ignore patterns to the ignore instance
     * If no .gitignore file is found, continues with default patterns
     *
     * This method reads the .gitignore file (if it exists) and processes each line
     * to extract valid ignore patterns. It filters out comments (lines starting with #)
     * and empty lines, then adds the valid patterns to the ignore instance.
     *
     * @returns Promise that resolves when gitignore is loaded
     */
    private async loadGitignore(): Promise<void> {
        const gitignorePath = path.join(this.workspaceRoot, '.gitignore');
        
        try {
            // Read the gitignore file content
            const gitignoreContent = await fs.promises.readFile(gitignorePath, 'utf8');
            // Process the content: split by lines, trim whitespace, and filter out comments and empty lines
            const lines = gitignoreContent
                .split('\n')
                .map(line => line.trim())
                .filter(line => line && !line.startsWith('#'));
            
            // Add the processed patterns to our ignore instance
            this.ignoreInstance.add(lines);
        } catch (error) {
            // .gitignore file not found or not readable, continue with default patterns
            // This is not an error - we just use the default ignore patterns
            console.log('No .gitignore file found or not readable, using default ignore patterns');
        }
    }

    /**
     * Finds all files in the workspace that match the specified patterns
     * and aren't excluded by ignore rules
     *
     * This method performs a comprehensive search for all relevant files in the workspace.
     * It first loads .gitignore patterns, then searches for files matching multiple
     * patterns for different programming languages and file types. The results are
     * deduplicated and filtered according to the ignore rules.
     *
     * @returns Promise resolving to an array of absolute file paths
     */
    public async findAllFiles(): Promise<string[]> {
        // Load gitignore patterns before searching for files
        // This ensures we respect the project's ignore rules
        await this.loadGitignore();

        // Define patterns for code files we want to index
        // Includes most common programming languages and config file types
        const patterns = [
            '**/*.ts',    // TypeScript
            '**/*.tsx',   // TypeScript React
            '**/*.js',    // JavaScript
            '**/*.jsx',   // JavaScript React
            '**/*.py',    // Python
            '**/*.cs',    // C#
            '**/*.java',  // Java
            '**/*.cpp',   // C++
            '**/*.c',     // C
            '**/*.h',     // C/C++ header
            '**/*.hpp',   // C++ header
            '**/*.go',    // Go
            '**/*.rs',    // Rust
            '**/*.php',   // PHP
            '**/*.rb',    // Ruby
            '**/*.swift', // Swift
            '**/*.kt',    // Kotlin
            '**/*.scala', // Scala
            '**/*.clj',   // Clojure
            '**/*.sh',    // Shell script
            '**/*.ps1',   // PowerShell
            '**/*.sql',   // SQL
            '**/*.md',    // Markdown
            '**/*.json',  // JSON
            '**/*.yaml',  // YAML
            '**/*.yml',   // YAML alternative
            '**/*.xml',   // XML
            '**/*.html',  // HTML
            '**/*.css',   // CSS
            '**/*.scss',  // SCSS
            '**/*.less'   // LESS
        ];

        const allFiles: string[] = [];

        // Process each pattern and collect matching files
        // We use glob to efficiently find files matching each pattern
        for (const pattern of patterns) {
            try {
                // Use glob to find files matching the current pattern
                const files = await new Promise<string[]>((resolve, reject) => {
                    glob.glob(pattern, {
                        cwd: this.workspaceRoot,
                        absolute: true, // Return absolute paths
                        nodir: true,    // Don't include directories
                        dot: false      // Ignore dot files by default
                    }, (err, matches) => {
                        if (err) reject(err);
                        else resolve(matches);
                    });
                });
                // Add found files to our collection
                allFiles.push(...files);
            } catch (error) {
                console.error(`Error finding files with pattern ${pattern}:`, error);
            }
        }

        // Remove duplicates (files that match multiple patterns)
        // For example, a .ts file might match both '**/*.ts' and '**/*.tsx' patterns
        const uniqueFiles = [...new Set(allFiles)];
        
        // Apply ignore patterns to filter out excluded files
        // This respects both .gitignore patterns and our default ignore patterns
        const filteredFiles = uniqueFiles.filter(filePath => {
            // Convert to relative path for ignore pattern matching
            const relativePath = path.relative(this.workspaceRoot, filePath);
            return !this.ignoreInstance.ignores(relativePath);
        });

        return filteredFiles;
    }

    /**
     * Collects statistics about files in the workspace
     *
     * This method provides insights into the composition of the workspace by
     * counting files by their extensions. This information can be useful for
     * understanding the technology stack and estimating indexing time.
     *
     * @returns Promise resolving to an object containing:
     *   - totalFiles: The total number of files found
     *   - filesByExtension: A record mapping file extensions to their count
     */
    public async getFileStats(): Promise<{ totalFiles: number; filesByExtension: Record<string, number> }> {
        // Get all files in the workspace
        const files = await this.findAllFiles();
        const filesByExtension: Record<string, number> = {};

        // Count files by extension
        // This helps understand the distribution of file types in the workspace
        files.forEach(filePath => {
            const ext = path.extname(filePath).toLowerCase();
            filesByExtension[ext] = (filesByExtension[ext] || 0) + 1;
        });

        return {
            totalFiles: files.length,
            filesByExtension
        };
    }

    /**
     * Determines if a file is a code file based on its extension
     *
     * This method checks if a file has a code-related extension, which helps
     * distinguish between source code files and configuration files, documentation,
     * or other non-code files that might be present in the workspace.
     *
     * @param filePath - The path to the file to check
     * @returns true if the file is a code file, false otherwise
     */
    public isCodeFile(filePath: string): boolean {
        // List of extensions considered as code files
        // This includes most common programming language source files
        const codeExtensions = [
            '.ts', '.tsx', '.js', '.jsx', '.py', '.cs', '.java',
            '.cpp', '.c', '.h', '.hpp', '.go', '.rs', '.php',
            '.rb', '.swift', '.kt', '.scala', '.clj'
        ];
        
        // Extract and check the file extension
        const ext = path.extname(filePath).toLowerCase();
        return codeExtensions.includes(ext);
    }
}
</file>

<file path="src/indexing/indexingService.ts">
/**
 * Code indexing and search service for the VS Code extension.
 *
 * This module provides the core functionality for indexing code files in a workspace,
 * generating embeddings, and storing them in a vector database for semantic search.
 * It orchestrates the entire indexing pipeline from file discovery to vector storage.
 */
import * as vscode from 'vscode';
import * as fs from 'fs';
import { FileWalker } from './fileWalker';
import { AstParser, SupportedLanguage } from '../parsing/astParser';
import { Chunker, CodeChunk, ChunkType } from '../parsing/chunker';
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider, EmbeddingProviderFactory, EmbeddingConfig } from '../embeddings/embeddingProvider';
import { LSPService } from '../lsp/lspService';
import { StateManager } from '../stateManager';

/**
 * Progress tracking interface for the indexing process.
 *
 * This interface provides real-time updates about the indexing progress,
 * allowing the UI to show the current status and progress to the user.
 */
export interface IndexingProgress {
    /** Currently being processed file path */
    currentFile: string;
    /** Number of files that have been processed so far */
    processedFiles: number;
    /** Total number of files to be processed */
    totalFiles: number;
    /** Current phase of the indexing process */
    currentPhase: 'discovering' | 'parsing' | 'chunking' | 'embedding' | 'storing' | 'complete';
    /** Array of chunks generated so far */
    chunks: CodeChunk[];
    /** Array of error messages encountered during indexing */
    errors: string[];
    /** Optional progress information for embedding generation */
    embeddingProgress?: {
        /** Number of chunks that have been embedded */
        processedChunks: number;
        /** Total number of chunks to be embedded */
        totalChunks: number;
    };
}

/**
 * Result interface for the indexing operation.
 *
 * This interface contains comprehensive information about the indexing operation,
 * including success status, generated chunks, statistics, and any errors encountered.
 */
export interface IndexingResult {
    /** Whether the indexing operation completed successfully */
    success: boolean;
    /** Array of code chunks generated during indexing */
    chunks: CodeChunk[];
    /** Total number of files in the workspace */
    totalFiles: number;
    /** Number of files that were successfully processed */
    processedFiles: number;
    /** Array of error messages encountered during indexing */
    errors: string[];
    /** Duration of the indexing operation in milliseconds */
    duration: number;
    /** Name of the Qdrant collection where chunks were stored */
    collectionName?: string;
    /** Name of the embedding provider used */
    embeddingProvider?: string;
    /** Comprehensive statistics about the indexing operation */
    stats: {
        /** Count of files processed by programming language */
        filesByLanguage: Record<string, number>;
        /** Count of chunks by their type */
        chunksByType: Record<ChunkType, number>;
        /** Total number of lines of code processed */
        totalLines: number;
        /** Total number of bytes processed */
        totalBytes: number;
        /** Total number of embeddings generated */
        totalEmbeddings: number;
        /** Dimensionality of the vector embeddings */
        vectorDimensions: number;
    };
}

/**
 * Main indexing service that orchestrates the entire code indexing pipeline.
 *
 * The IndexingService coordinates all aspects of the indexing process:
 * - File discovery using FileWalker
 * - AST parsing using AstParser
 * - Code chunking using Chunker
 * - Embedding generation using embedding providers
 * - Vector storage using QdrantService
 *
 * It provides a high-level API for starting indexing operations and retrieving
 * workspace statistics, as well as searching through indexed code.
 */
export class IndexingService {
    /** Root directory of the workspace being indexed */
    private workspaceRoot: string;
    /** File walker for discovering and filtering files in the workspace */
    private fileWalker: FileWalker;
    /** AST parser for analyzing code structure and semantics */
    private astParser: AstParser;
    /** Chunker for breaking down code into manageable pieces */
    private chunker: Chunker;
    /** Service for interacting with the Qdrant vector database */
    private qdrantService: QdrantService;
    /** Embedding provider for generating vector representations of code */
    private embeddingProvider: IEmbeddingProvider;
    /** Service for interacting with Language Server Protocol */
    private lspService: LSPService;
    /** State manager for tracking application state and preventing concurrent operations */
    private stateManager: StateManager;

    /**
     * Creates a new IndexingService instance using dependency injection
     * @param workspaceRoot - The absolute path to the workspace root directory
     * @param fileWalker - Injected FileWalker instance
     * @param astParser - Injected AstParser instance
     * @param chunker - Injected Chunker instance
     * @param qdrantService - Injected QdrantService instance
     * @param embeddingProvider - Injected embedding provider instance
     * @param lspService - Injected LSPService instance
     * @param stateManager - Injected StateManager instance
     */
    constructor(
        workspaceRoot: string,
        fileWalker: FileWalker,
        astParser: AstParser,
        chunker: Chunker,
        qdrantService: QdrantService,
        embeddingProvider: IEmbeddingProvider,
        lspService: LSPService,
        stateManager: StateManager
    ) {
        this.workspaceRoot = workspaceRoot;
        this.fileWalker = fileWalker;
        this.astParser = astParser;
        this.chunker = chunker;
        this.qdrantService = qdrantService;
        this.embeddingProvider = embeddingProvider;
        this.lspService = lspService;
        this.stateManager = stateManager;
    }



    /**
     * Starts the indexing process for the entire workspace.
     *
     * This method orchestrates the complete indexing pipeline:
     * 1. Initialize embedding provider
     * 2. Discover all relevant files in the workspace
     * 3. Process each file (parse AST, create chunks)
     * 4. Generate embeddings for all chunks
     * 5. Store chunks and embeddings in Qdrant
     *
     * The method provides progress updates through the callback function,
     * allowing the UI to show real-time progress to the user.
     *
     * @param progressCallback - Optional callback function for progress updates
     * @returns Promise resolving to an IndexingResult with comprehensive statistics
     */
    public async startIndexing(
        progressCallback?: (progress: IndexingProgress) => void
    ): Promise<IndexingResult> {
        // Check if indexing is already in progress
        if (this.stateManager.isIndexing()) {
            console.warn('IndexingService: Indexing already in progress, skipping new request');
            throw new Error('Indexing is already in progress');
        }

        const startTime = Date.now();
        const result: IndexingResult = {
            success: false,
            chunks: [],
            totalFiles: 0,
            processedFiles: 0,
            errors: [],
            duration: 0,
            stats: {
                filesByLanguage: {},
                chunksByType: {} as Record<ChunkType, number>,
                totalLines: 0,
                totalBytes: 0,
                totalEmbeddings: 0,
                vectorDimensions: 0
            }
        };

        // Set indexing state to true
        this.stateManager.setIndexing(true, 'Starting indexing process');

        try {
            // Phase 1: Initialize embedding provider
            // This must be done first as it's required for the rest of the pipeline
            progressCallback?.({
                currentFile: '',
                processedFiles: 0,
                totalFiles: 0,
                currentPhase: 'discovering',
                chunks: [],
                errors: []
            });



            // Phase 2: Discover files
            // Find all relevant files in the workspace that match our patterns
            progressCallback?.({
                currentFile: '',
                processedFiles: 0,
                totalFiles: 0,
                currentPhase: 'discovering',
                chunks: [],
                errors: []
            });

            const files = await this.fileWalker.findAllFiles();
            const codeFiles = files.filter(file => this.fileWalker.isCodeFile(file));
            
            result.totalFiles = codeFiles.length;

            // If no code files found, return early with success status
            if (codeFiles.length === 0) {
                result.success = true;
                result.duration = Date.now() - startTime;
                return result;
            }

            // Phase 3: Process files
            // For each file, parse the AST and create code chunks
            for (let i = 0; i < codeFiles.length; i++) {
                const filePath = codeFiles[i];
                
                try {
                    progressCallback?.({
                        currentFile: filePath,
                        processedFiles: i,
                        totalFiles: codeFiles.length,
                        currentPhase: 'parsing',
                        chunks: result.chunks,
                        errors: result.errors
                    });

                    const fileResult = await this.processFile(filePath);
                    
                    if (fileResult.success) {
                        result.chunks.push(...fileResult.chunks);
                        
                        // Update stats
                        if (fileResult.language) {
                            result.stats.filesByLanguage[fileResult.language] =
                                (result.stats.filesByLanguage[fileResult.language] || 0) + 1;
                        }
                        
                        result.stats.totalLines += fileResult.lineCount;
                        result.stats.totalBytes += fileResult.byteCount;
                        
                        // Update chunk stats
                        for (const chunk of fileResult.chunks) {
                            result.stats.chunksByType[chunk.type] =
                                (result.stats.chunksByType[chunk.type] || 0) + 1;
                        }
                    } else {
                        result.errors.push(...fileResult.errors);
                    }
                    
                    result.processedFiles++;
                    
                } catch (error) {
                    const errorMessage = `Error processing file ${filePath}: ${error instanceof Error ? error.message : String(error)}`;
                    result.errors.push(errorMessage);
                    console.error(errorMessage);
                }
            }

            // Phase 4: Generate embeddings
            // If we have chunks and an embedding provider, generate vector embeddings
            if (result.chunks.length > 0 && this.embeddingProvider) {
                progressCallback?.({
                    currentFile: '',
                    processedFiles: result.processedFiles,
                    totalFiles: result.totalFiles,
                    currentPhase: 'embedding',
                    chunks: result.chunks,
                    errors: result.errors,
                    embeddingProgress: {
                        processedChunks: 0,
                        totalChunks: result.chunks.length
                    }
                });

                const chunkContents = result.chunks.map(chunk => chunk.content);
                const embeddings = await this.embeddingProvider.generateEmbeddings(chunkContents);

                result.stats.totalEmbeddings = embeddings.length;
                result.stats.vectorDimensions = this.embeddingProvider.getDimensions();
                result.embeddingProvider = this.embeddingProvider.getProviderName();

                // Phase 5: Store in Qdrant
                // Store the chunks and their embeddings in the vector database
                progressCallback?.({
                    currentFile: '',
                    processedFiles: result.processedFiles,
                    totalFiles: result.totalFiles,
                    currentPhase: 'storing',
                    chunks: result.chunks,
                    errors: result.errors
                });

                const collectionName = this.generateCollectionName();
                result.collectionName = collectionName;

                // Create collection if it doesn't exist
                const collectionCreated = await this.qdrantService.createCollectionIfNotExists(
                    collectionName,
                    this.embeddingProvider.getDimensions()
                );

                if (!collectionCreated) {
                    result.errors.push('Failed to create Qdrant collection');
                } else {
                    // Store chunks with embeddings
                    const stored = await this.qdrantService.upsertChunks(
                        collectionName,
                        result.chunks,
                        embeddings
                    );

                    if (!stored) {
                        result.errors.push('Failed to store chunks in Qdrant');
                    }
                }
            }

            // Phase 6: Complete
            // Mark the indexing process as complete
            progressCallback?.({
                currentFile: '',
                processedFiles: result.processedFiles,
                totalFiles: result.totalFiles,
                currentPhase: 'complete',
                chunks: result.chunks,
                errors: result.errors
            });

            result.success = true;
            result.duration = Date.now() - startTime;

        } catch (error) {
            const errorMessage = `Indexing failed: ${error instanceof Error ? error.message : String(error)}`;
            result.errors.push(errorMessage);
            console.error(errorMessage);
            this.stateManager.setError(errorMessage);
        } finally {
            // Always reset the indexing state, regardless of success or failure
            this.stateManager.setIndexing(false);
        }

        result.duration = Date.now() - startTime;
        return result;
    }

    /**
     * Processes a single file by reading its content, parsing its AST,
     * and creating code chunks.
     *
     * This method handles the complete processing pipeline for a single file:
     * 1. Read the file content
     * 2. Determine the programming language
     * 3. Parse the Abstract Syntax Tree (AST)
     * 4. Create code chunks from the parsed tree
     *
     * The method includes error recovery and handles various failure scenarios
     * gracefully, returning appropriate error messages when issues occur.
     *
     * @param filePath - The path to the file to process
     * @returns Promise resolving to a processing result with chunks and metadata
     */
    private async processFile(filePath: string): Promise<{
        success: boolean;
        chunks: CodeChunk[];
        language?: SupportedLanguage;
        lineCount: number;
        byteCount: number;
        errors: string[];
    }> {
        const errors: string[] = [];
        
        try {
            // Read file content
            // This is the first step in processing any file
            const content = await fs.promises.readFile(filePath, 'utf8');
            const lineCount = content.split('\n').length;
            const byteCount = Buffer.byteLength(content, 'utf8');
            
            // Determine language
            // We need to know the language to use the correct parser
            const language = this.getLanguage(filePath);
            if (!language) {
                return {
                    success: false,
                    chunks: [],
                    lineCount,
                    byteCount,
                    errors: [`Unsupported file type: ${filePath}`]
                };
            }

            // Parse AST
            // This creates a structured representation of the code
            const parseResult = this.astParser.parseWithErrorRecovery(language, content);
            if (parseResult.errors.length > 0) {
                errors.push(...parseResult.errors.map(err => `${filePath}: ${err}`));
            }

            if (!parseResult.tree) {
                return {
                    success: false,
                    chunks: [],
                    language,
                    lineCount,
                    byteCount,
                    errors: [`Failed to parse AST for ${filePath}`, ...errors]
                };
            }

            // Create chunks
            // Break down the code into manageable pieces for embedding
            const chunks = this.chunker.chunk(filePath, parseResult.tree, content, language);

            // Enhance chunks with LSP metadata
            // This adds semantic information like symbols, definitions, and references
            const enhancedChunks = await this.enhanceChunksWithLSP(chunks, filePath, content, language);

            return {
                success: true,
                chunks: enhancedChunks,
                language,
                lineCount,
                byteCount,
                errors
            };

        } catch (error) {
            return {
                success: false,
                chunks: [],
                lineCount: 0,
                byteCount: 0,
                errors: [`Error processing ${filePath}: ${error instanceof Error ? error.message : String(error)}`]
            };
        }
    }

    /**
     * Enhance code chunks with LSP metadata
     *
     * This method adds semantic information from the Language Server Protocol
     * to each code chunk, including symbols, definitions, references, and hover info.
     *
     * @param chunks - The code chunks to enhance
     * @param filePath - The path to the source file
     * @param content - The full file content
     * @param language - The programming language
     * @returns Promise resolving to enhanced chunks with LSP metadata
     */
    private async enhanceChunksWithLSP(
        chunks: CodeChunk[],
        filePath: string,
        content: string,
        language: SupportedLanguage
    ): Promise<CodeChunk[]> {
        try {
            // Check if LSP is available for this language
            const isLSPAvailable = await this.lspService.isLSPAvailable(language);
            if (!isLSPAvailable) {
                console.log(`LSP not available for ${language}, skipping LSP enhancement`);
                return chunks;
            }

            // Enhance each chunk with LSP metadata
            const enhancedChunks: CodeChunk[] = [];
            for (const chunk of chunks) {
                try {
                    const lspMetadata = await this.lspService.getMetadataForChunk(
                        filePath,
                        chunk.content,
                        chunk.startLine,
                        chunk.endLine,
                        language
                    );

                    enhancedChunks.push({
                        ...chunk,
                        lspMetadata
                    });
                } catch (error) {
                    console.warn(`Failed to get LSP metadata for chunk in ${filePath}:`, error);
                    // Add chunk without LSP metadata
                    enhancedChunks.push(chunk);
                }
            }

            return enhancedChunks;
        } catch (error) {
            console.warn(`Failed to enhance chunks with LSP for ${filePath}:`, error);
            return chunks; // Return original chunks if LSP enhancement fails
        }
    }

    /**
     * Determines the programming language of a file based on its extension.
     *
     * This method delegates to the AST parser to identify the language,
     * which ensures consistency with the parsing capabilities.
     *
     * @param filePath - The path to the file to analyze
     * @returns The supported language or null if the language is not supported
     */
    private getLanguage(filePath: string): SupportedLanguage | null {
        return this.astParser.getLanguageFromFilePath(filePath);
    }

    /**
     * Generates a unique collection name for the Qdrant database.
     *
     * This method creates a sanitized version of the workspace name to use
     * as the collection name. This ensures that the collection name is
     * valid for Qdrant and unique per workspace.
     *
     * @returns A sanitized collection name string
     */
    private generateCollectionName(): string {
        // Generate a collection name based on workspace root
        // This helps organize collections by workspace
        const workspaceName = this.workspaceRoot.split('/').pop() || 'workspace';
        const sanitizedName = workspaceName.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        return `code_context_${sanitizedName}`;
    }

    /**
     * Gets statistics about the workspace for planning purposes.
     *
     * This method provides useful information about the workspace composition,
     * including the total number of files, distribution by file extension,
     * and an estimated indexing time based on the number of code files.
     *
     * @returns Promise resolving to workspace statistics
     */
    public async getWorkspaceStats(): Promise<{
        totalFiles: number;
        filesByExtension: Record<string, number>;
        estimatedIndexingTime: number;
    }> {
        const stats = await this.fileWalker.getFileStats();
        const codeFileCount = Object.entries(stats.filesByExtension)
            .filter(([ext]) => this.fileWalker.isCodeFile(`dummy${ext}`))
            .reduce((sum, [, count]) => sum + count, 0);
        
        // Rough estimate: 50ms per file
        // This is a heuristic that can be refined based on actual performance
        const estimatedIndexingTime = codeFileCount * 50;

        return {
            totalFiles: stats.totalFiles,
            filesByExtension: stats.filesByExtension,
            estimatedIndexingTime
        };
    }

    /**
     * Gets the list of supported programming languages.
     *
     * This method returns all languages that the AST parser can handle,
     * which is useful for UI components that need to show supported languages
     * or filter files by language.
     *
     * @returns Array of supported language identifiers
     */
    public getSupportedLanguages(): SupportedLanguage[] {
        return this.astParser.getSupportedLanguages();
    }

    /**
     * Performs semantic search through the indexed code.
     *
     * This method takes a natural language query, generates an embedding for it,
     * and searches the Qdrant vector database for similar code chunks. The search
     * is based on semantic similarity rather than keyword matching.
     *
     * @param query - The search query in natural language
     * @param limit - Maximum number of results to return (default: 10)
     * @returns Promise resolving to search results
     */
    public async searchCode(query: string, limit: number = 10): Promise<any[]> {
        // Ensure embedding provider is available
        if (!this.embeddingProvider) {
            throw new Error('Embedding provider not available');
        }

        if (!this.embeddingProvider) {
            throw new Error('Embedding provider not available');
        }

        try {
            // Generate embedding for the query
            // This converts the natural language query into a vector representation
            const queryEmbeddings = await this.embeddingProvider.generateEmbeddings([query]);
            if (queryEmbeddings.length === 0) {
                return [];
            }

            const collectionName = this.generateCollectionName();

            // Search in Qdrant
            // This finds the most similar code chunks based on vector similarity
            const results = await this.qdrantService.search(
                collectionName,
                queryEmbeddings[0],
                limit
            );

            return results;
        } catch (error) {
            console.error('Search failed:', error);
            return [];
        }
    }

    /**
     * Gets information about the Qdrant collection used for storing embeddings.
     *
     * This method retrieves metadata about the collection, such as the number
     * of vectors, vector dimensions, and other collection properties. This is
     * useful for debugging and monitoring purposes.
     *
     * @returns Promise resolving to collection information
     */
    public async getCollectionInfo(): Promise<any> {
        const collectionName = this.generateCollectionName();
        return await this.qdrantService.getCollectionInfo(collectionName);
    }

    /**
     * Checks if the Qdrant service is available and responsive.
     *
     * This method performs a health check on the Qdrant service to ensure
     * that the vector database is running and accessible. This is useful
     * for determining if indexing and search operations can proceed.
     *
     * @returns Promise resolving to true if Qdrant is available, false otherwise
     */
    public async isQdrantAvailable(): Promise<boolean> {
        return await this.qdrantService.healthCheck();
    }
}
</file>

<file path="src/parsing/chunker.ts">
import Parser from 'tree-sitter';
import { SupportedLanguage } from './astParser';
import { LSPMetadata } from '../lsp/lspService';
// TODO: (agent) we should be able to process all files except for executables
export interface CodeChunk {
    filePath: string;
    content: string;
    startLine: number;
    endLine: number;
    type: ChunkType;
    name?: string;
    signature?: string;
    docstring?: string;
    language: SupportedLanguage;
    metadata?: Record<string, any>;
    /** LSP metadata including symbols, definitions, and references */
    lspMetadata?: LSPMetadata;
}

export enum ChunkType {
    FUNCTION = 'function',
    CLASS = 'class',
    METHOD = 'method',
    INTERFACE = 'interface',
    ENUM = 'enum',
    VARIABLE = 'variable',
    IMPORT = 'import',
    COMMENT = 'comment',
    MODULE = 'module',
    NAMESPACE = 'namespace',
    PROPERTY = 'property',
    CONSTRUCTOR = 'constructor',
    DECORATOR = 'decorator',
    TYPE_ALIAS = 'type_alias',
    GENERIC = 'generic'
}

export class Chunker {
    private languageQueries: Map<SupportedLanguage, Map<ChunkType, string>>;

    constructor() {
        this.languageQueries = new Map();
        this.initializeQueries();
    }

    private initializeQueries(): void {
        // TypeScript/JavaScript queries
        const tsQueries = new Map<ChunkType, string>();
        tsQueries.set(ChunkType.FUNCTION, `
            (function_declaration
                name: (identifier) @name
                parameters: (formal_parameters) @params
                body: (statement_block) @body) @function
        `);
        tsQueries.set(ChunkType.CLASS, `
            (class_declaration
                name: (type_identifier) @name
                body: (class_body) @body) @class
        `);
        tsQueries.set(ChunkType.METHOD, `
            (method_definition
                name: (property_identifier) @name
                parameters: (formal_parameters) @params
                body: (statement_block) @body) @method
        `);
        tsQueries.set(ChunkType.INTERFACE, `
            (interface_declaration
                name: (type_identifier) @name
                body: (object_type) @body) @interface
        `);
        tsQueries.set(ChunkType.ENUM, `
            (enum_declaration
                name: (identifier) @name
                body: (enum_body) @body) @enum
        `);
        tsQueries.set(ChunkType.IMPORT, `
            (import_statement) @import
        `);

        this.languageQueries.set('typescript', tsQueries);
        this.languageQueries.set('javascript', tsQueries);

        // Python queries
        const pyQueries = new Map<ChunkType, string>();
        pyQueries.set(ChunkType.FUNCTION, `
            (function_definition
                name: (identifier) @name
                parameters: (parameters) @params
                body: (block) @body) @function
        `);
        pyQueries.set(ChunkType.CLASS, `
            (class_definition
                name: (identifier) @name
                body: (block) @body) @class
        `);
        pyQueries.set(ChunkType.METHOD, `
            (function_definition
                name: (identifier) @name
                parameters: (parameters) @params
                body: (block) @body) @method
        `);
        pyQueries.set(ChunkType.IMPORT, `
            (import_statement) @import
            (import_from_statement) @import
        `);

        this.languageQueries.set('python', pyQueries);

        // C# queries
        const csQueries = new Map<ChunkType, string>();
        csQueries.set(ChunkType.CLASS, `
            (class_declaration
                name: (identifier) @name
                body: (declaration_list) @body) @class
        `);
        csQueries.set(ChunkType.METHOD, `
            (method_declaration
                name: (identifier) @name
                parameters: (parameter_list) @params
                body: (block) @body) @method
        `);
        csQueries.set(ChunkType.INTERFACE, `
            (interface_declaration
                name: (identifier) @name
                body: (declaration_list) @body) @interface
        `);
        csQueries.set(ChunkType.NAMESPACE, `
            (namespace_declaration
                name: (identifier) @name
                body: (declaration_list) @body) @namespace
        `);

        this.languageQueries.set('csharp', csQueries);
    }

    public chunk(filePath: string, tree: Parser.Tree, code: string, language: SupportedLanguage): CodeChunk[] {
        const chunks: CodeChunk[] = [];
        const queries = this.languageQueries.get(language);

        if (!queries) {
            console.warn(`No queries defined for language: ${language}`);
            return this.createFileChunk(filePath, code, language);
        }

        // Extract chunks for each type
        for (const [chunkType, queryString] of queries) {
            try {
                const languageGrammar = this.getLanguageGrammar(language);
                if (!languageGrammar) continue;

                const query = new Parser.Query(languageGrammar, queryString);
                const matches = query.matches(tree.rootNode);

                for (const match of matches) {
                    const chunk = this.createChunkFromMatch(filePath, match, code, chunkType, language);
                    if (chunk) {
                        chunks.push(chunk);
                    }
                }
            } catch (error) {
                console.error(`Error processing ${chunkType} chunks for ${language}:`, error);
            }
        }

        // If no chunks were found, create a file-level chunk
        if (chunks.length === 0) {
            chunks.push(...this.createFileChunk(filePath, code, language));
        }

        return chunks;
    }

    private createChunkFromMatch(
        filePath: string,
        match: Parser.QueryMatch,
        code: string,
        chunkType: ChunkType,
        language: SupportedLanguage
    ): CodeChunk | null {
        const captures = match.captures;
        const mainCapture = captures.find((c: any) => c.name === chunkType) || captures[0];
        
        if (!mainCapture) return null;

        const node = mainCapture.node;
        const content = code.slice(node.startIndex, node.endIndex);
        
        // Extract name if available
        const nameCapture = captures.find((c: any) => c.name === 'name');
        const name = nameCapture ? code.slice(nameCapture.node.startIndex, nameCapture.node.endIndex) : undefined;

        // Extract parameters/signature if available
        const paramsCapture = captures.find((c: any) => c.name === 'params');
        const signature = paramsCapture ? code.slice(paramsCapture.node.startIndex, paramsCapture.node.endIndex) : undefined;

        // Extract docstring for Python
        let docstring: string | undefined;
        if (language === 'python' && chunkType === ChunkType.FUNCTION) {
            docstring = this.extractPythonDocstring(node, code);
        }

        return {
            filePath,
            content,
            startLine: node.startPosition.row + 1,
            endLine: node.endPosition.row + 1,
            type: chunkType,
            name,
            signature,
            docstring,
            language,
            metadata: {
                nodeType: node.type,
                hasError: node.hasError(),
                byteLength: node.endIndex - node.startIndex
            }
        };
    }

    private createFileChunk(filePath: string, code: string, language: SupportedLanguage): CodeChunk[] {
        const lines = code.split('\n');
        return [{
            filePath,
            content: code,
            startLine: 1,
            endLine: lines.length,
            type: ChunkType.MODULE,
            name: filePath.split('/').pop()?.split('.')[0],
            language,
            metadata: {
                isFileLevel: true,
                lineCount: lines.length,
                charCount: code.length
            }
        }];
    }

    private extractPythonDocstring(node: Parser.SyntaxNode, code: string): string | undefined {
        // Look for string literal as first statement in function body
        for (let i = 0; i < node.childCount; i++) {
            const child = node.child(i);
            if (child?.type === 'block') {
                const firstStatement = child.child(1); // Skip the colon
                if (firstStatement?.type === 'expression_statement') {
                    const expr = firstStatement.child(0);
                    if (expr?.type === 'string') {
                        return code.slice(expr.startIndex, expr.endIndex);
                    }
                }
                break;
            }
        }
        return undefined;
    }

    private getLanguageGrammar(language: SupportedLanguage): any {
        // Import the actual language grammars
        try {
            switch (language) {
                case 'typescript':
                    return require('tree-sitter-typescript').typescript;
                case 'javascript':
                    return require('tree-sitter-typescript').javascript;
                case 'python':
                    return require('tree-sitter-python');
                case 'csharp':
                    return require('tree-sitter-c-sharp');
                default:
                    return null;
            }
        } catch (error) {
            console.error(`Failed to load grammar for ${language}:`, error);
            return null;
        }
    }

    public getChunksByType(chunks: CodeChunk[], type: ChunkType): CodeChunk[] {
        return chunks.filter(chunk => chunk.type === type);
    }

    public getChunkStats(chunks: CodeChunk[]): Record<ChunkType, number> {
        const stats: Record<ChunkType, number> = {} as Record<ChunkType, number>;
        
        for (const chunk of chunks) {
            stats[chunk.type] = (stats[chunk.type] || 0) + 1;
        }
        
        return stats;
    }
}
</file>

<file path="src/webviewManager.ts">
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { MessageRouter } from './messageRouter';
import { StateManager } from './stateManager';

/**
 * WebviewManager class responsible for managing all webview panels and their lifecycle.
 * 
 * This class centralizes webview creation, content management, and message handling,
 * providing a clean separation between webview logic and command handlers.
 * It handles:
 * - Main panel and settings panel creation and lifecycle
 * - Webview content loading with proper resource URIs
 * - Panel state management (showing, hiding, disposing)
 * - Integration with ExtensionManager for service access
 */
export class WebviewManager {
    private context: vscode.ExtensionContext;
    private extensionManager: any; // Will be properly typed when we integrate
    private stateManager: StateManager;
    private mainPanel: vscode.WebviewPanel | undefined;
    private settingsPanel: vscode.WebviewPanel | undefined;
    private diagnosticsPanel: vscode.WebviewPanel | undefined;
    private messageRouter: MessageRouter | undefined;

    /**
     * Creates a new WebviewManager instance
     * @param context - The VS Code extension context
     * @param extensionManager - The ExtensionManager instance for service access
     * @param stateManager - The StateManager instance for state management
     */
    constructor(context: vscode.ExtensionContext, extensionManager: any, stateManager: StateManager) {
        this.context = context;
        this.extensionManager = extensionManager;
        this.stateManager = stateManager;
        this.initializeMessageRouter();
    }

    /**
     * Initializes the MessageRouter with services from ExtensionManager
     */
    private initializeMessageRouter(): void {
        try {
            if (this.extensionManager &&
                this.extensionManager.getContextService &&
                this.extensionManager.getIndexingService) {

                const contextService = this.extensionManager.getContextService();
                const indexingService = this.extensionManager.getIndexingService();

                if (contextService && indexingService) {
                    this.messageRouter = new MessageRouter(contextService, indexingService, this.context, this.stateManager);

                    // Set advanced managers if available
                    if (this.extensionManager.getSearchManager &&
                        this.extensionManager.getConfigurationManager &&
                        this.extensionManager.getPerformanceManager) {

                        const searchManager = this.extensionManager.getSearchManager();
                        const configurationManager = this.extensionManager.getConfigurationManager();
                        const performanceManager = this.extensionManager.getPerformanceManager();

                        if (searchManager && configurationManager && performanceManager) {
                            this.messageRouter.setAdvancedManagers(
                                searchManager,
                                configurationManager,
                                performanceManager
                            );
                        }
                    }

                    console.log('WebviewManager: MessageRouter initialized');
                }
            }
        } catch (error) {
            console.error('WebviewManager: Failed to initialize MessageRouter:', error);
        }
    }

    /**
     * Shows the main Code Context Engine panel
     * Creates a new panel if one doesn't exist, or reveals the existing one
     */
    public showMainPanel(): void {
        // If panel already exists, just reveal it
        if (this.mainPanel) {
            this.mainPanel.reveal(vscode.ViewColumn.One);
            return;
        }

        // Create new main panel
        this.mainPanel = vscode.window.createWebviewPanel(
            'codeContextMain',
            'Code Context Engine',
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [
                    vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'build'))
                ]
            }
        );

        // Set the webview content
        this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, 'main');

        // Handle panel disposal
        this.mainPanel.onDidDispose(() => {
            this.mainPanel = undefined;
        });

        // Set up message handling for the main panel
        this.setupMessageHandling(this.mainPanel.webview);

        console.log('WebviewManager: Main panel created and shown');
    }

    /**
     * Shows the settings panel
     * Creates a new panel if one doesn't exist, or reveals the existing one
     * @deprecated The settings are now managed in the native VS Code Settings UI.
     * This webview will be repurposed for diagnostics.
     */
    public showSettingsPanel(): void {
        // If panel already exists, just reveal it
        if (this.settingsPanel) {
            this.settingsPanel.reveal(vscode.ViewColumn.Two);
            return;
        }

        // Create new settings panel
        this.settingsPanel = vscode.window.createWebviewPanel(
            'codeContextSettings',
            'Code Context Settings',
            vscode.ViewColumn.Two,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [
                    vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'build'))
                ]
            }
        );

        // Set the webview content
        this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, 'settings');

        // Handle panel disposal
        this.settingsPanel.onDidDispose(() => {
            this.settingsPanel = undefined;
        });

        // Set up message handling for the settings panel
        this.setupMessageHandling(this.settingsPanel.webview);

        console.log('WebviewManager: Settings panel created and shown');
    }

    /**
     * Shows the diagnostics panel
     * Creates a new panel if one doesn't exist, or reveals the existing one
     */
    public showDiagnosticsPanel(): void {
        // If panel already exists, just reveal it
        if (this.diagnosticsPanel) {
            this.diagnosticsPanel.reveal(vscode.ViewColumn.Two);
            return;
        }

        // Create new diagnostics panel
        this.diagnosticsPanel = vscode.window.createWebviewPanel(
            'codeContextDiagnostics',
            'Code Context Diagnostics',
            vscode.ViewColumn.Two,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [
                    vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'build'))
                ]
            }
        );

        // Set the webview content
        this.diagnosticsPanel.webview.html = this.getWebviewContent(this.diagnosticsPanel.webview, 'diagnostics');

        // Handle panel disposal
        this.diagnosticsPanel.onDidDispose(() => {
            this.diagnosticsPanel = undefined;
        });

        // Set up message handling for the diagnostics panel
        this.setupMessageHandling(this.diagnosticsPanel.webview);

        // Set the view to diagnostics after a short delay to ensure the webview is ready
        setTimeout(() => {
            if (this.diagnosticsPanel) {
                this.diagnosticsPanel.webview.postMessage({
                    command: 'setView',
                    view: 'diagnostics'
                });
            }
        }, 100);

        console.log('WebviewManager: Diagnostics panel created and shown');
    }

    /**
     * Gets the HTML content for a webview panel
     * Reads the HTML template and replaces placeholders with proper webview URIs
     * @param webview - The webview instance
     * @param panelName - The name of the panel ('main' or 'settings')
     * @returns The HTML content with proper resource URIs
     */
    private getWebviewContent(webview: vscode.Webview, panelName: string): string {
        try {
            // Path to the SvelteKit build HTML file
            const htmlPath = path.join(this.context.extensionPath, 'webview', 'build', 'index.html');

            // Check if the HTML file exists
            if (!fs.existsSync(htmlPath)) {
                console.warn('WebviewManager: HTML file not found, using fallback content');
                return this.getFallbackContent(panelName);
            }

            // Read the HTML content
            let htmlContent = fs.readFileSync(htmlPath, 'utf8');

            // Replace SvelteKit asset paths with webview-specific URIs
            // This handles SvelteKit's /_app/ paths and other assets
            htmlContent = htmlContent.replace(
                /(<script[^>]+src="|<link[^>]+href="|src="|href=")(?!https?:\/\/)([^"]*)/g,
                (_match, prefix, relativePath) => {
                    // Remove leading slash if present
                    const cleanPath = relativePath.startsWith('/') ? relativePath.substring(1) : relativePath;
                    const resourcePath = path.join(this.context.extensionPath, 'webview', 'build', cleanPath);
                    const uri = webview.asWebviewUri(vscode.Uri.file(resourcePath));
                    return `${prefix}${uri}`;
                }
            );

            return htmlContent;
        } catch (error) {
            console.error('WebviewManager: Error loading webview content:', error);
            return this.getFallbackContent(panelName);
        }
    }

    /**
     * Provides fallback HTML content when the main webview files are not available
     * @param panelName - The name of the panel
     * @returns Basic HTML content
     */
    private getFallbackContent(panelName: string): string {
        let title: string;
        let content: string;

        switch (panelName) {
            case 'main':
                title = 'Code Context Engine';
                content = `
                    <h1>Code Context Engine</h1>
                    <p>Welcome to Code Context Engine!</p>
                    <p>This is a placeholder interface. The full webview is being developed.</p>
                    <button onclick="startIndexing()">Start Indexing</button>
                    <script>
                        const vscode = acquireVsCodeApi();
                        function startIndexing() {
                            vscode.postMessage({ command: 'startIndexing' });
                        }
                    </script>
                `;
                break;
            case 'diagnostics':
                title = 'Code Context Diagnostics';
                content = `
                    <h1>Status & Diagnostics</h1>

                    <div style="margin-bottom: 30px;">
                        <h2>Current Configuration</h2>
                        <div style="background-color: var(--vscode-editor-background); padding: 15px; border-radius: 4px; border: 1px solid var(--vscode-panel-border);">
                            <p><strong>Embedding Provider:</strong> <span id="embeddingProvider">Loading...</span></p>
                            <p><strong>Database Connection:</strong> <span id="databaseConnection">Loading...</span></p>
                            <p><strong>Model:</strong> <span id="embeddingModel">Loading...</span></p>
                        </div>
                        <button onclick="editSettings()" style="margin-top: 10px;">Edit Configuration</button>
                    </div>

                    <div>
                        <h2>Actions</h2>
                        <button onclick="testDatabase()" style="margin-right: 10px;">Test Database Connection</button>
                        <button onclick="testEmbedding()">Test Embedding Provider</button>
                    </div>

                    <script>
                        const vscode = acquireVsCodeApi();

                        // Request current settings on load
                        vscode.postMessage({ command: 'getSettings' });

                        function editSettings() {
                            vscode.postMessage({ command: 'MapToSettings' });
                        }

                        function testDatabase() {
                            vscode.postMessage({ command: 'testDatabaseConnection' });
                        }

                        function testEmbedding() {
                            vscode.postMessage({ command: 'testEmbeddingProvider' });
                        }

                        // Listen for messages from the extension
                        window.addEventListener('message', event => {
                            const message = event.data;
                            if (message.command === 'updateSettings') {
                                document.getElementById('embeddingProvider').textContent = message.data.embeddingProvider || 'Not configured';
                                document.getElementById('databaseConnection').textContent = message.data.databaseConnectionString || 'Not configured';
                                document.getElementById('embeddingModel').textContent = message.data.embeddingModel || 'Not configured';
                            }
                        });
                    </script>
                `;
                break;
            default:
                title = 'Code Context Settings';
                content = `
                    <h1>Code Context Settings</h1>
                    <p>Configure your Code Context Engine settings here.</p>
                    <p>This is a placeholder interface. The full settings panel is being developed.</p>
                `;
        }

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            padding: 20px;
        }
        h1 {
            color: var(--vscode-textLink-foreground);
        }
        button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }
    </style>
</head>
<body>
    ${content}
</body>
</html>`;
    }

    /**
     * Sets up message handling for a webview using MessageRouter
     * @param webview - The webview to set up message handling for
     */
    private setupMessageHandling(webview: vscode.Webview): void {
        webview.onDidReceiveMessage(async (message) => {
            try {
                console.log('WebviewManager: Received message:', message.command);

                if (this.messageRouter) {
                    // Use MessageRouter for centralized message handling
                    await this.messageRouter.handleMessage(message, webview);
                } else {
                    // Fallback for basic commands when MessageRouter is not available
                    console.warn('WebviewManager: MessageRouter not available, using fallback handling');

                    switch (message.command) {
                        case 'startIndexing':
                            // Delegate to command
                            await vscode.commands.executeCommand('code-context-engine.startIndexing');
                            break;
                        default:
                            console.log('WebviewManager: Unknown command:', message.command);
                            await webview.postMessage({
                                command: 'error',
                                message: `Command not supported: ${message.command}`
                            });
                            break;
                    }
                }
            } catch (error) {
                console.error('WebviewManager: Error handling message:', error);
                await webview.postMessage({
                    command: 'error',
                    message: error instanceof Error ? error.message : String(error)
                });
            }
        });
    }

    /**
     * Disposes of all webview panels and cleans up resources
     */
    public dispose(): void {
        console.log('WebviewManager: Starting disposal...');

        if (this.mainPanel) {
            this.mainPanel.dispose();
            this.mainPanel = undefined;
        }

        if (this.settingsPanel) {
            this.settingsPanel.dispose();
            this.settingsPanel = undefined;
        }

        if (this.diagnosticsPanel) {
            this.diagnosticsPanel.dispose();
            this.diagnosticsPanel = undefined;
        }

        console.log('WebviewManager: Disposal completed');
    }

    /**
     * Gets the current main panel instance
     * @returns The main panel or undefined if not created
     */
    public getMainPanel(): vscode.WebviewPanel | undefined {
        return this.mainPanel;
    }

    /**
     * Gets the current settings panel instance
     * @returns The settings panel or undefined if not created
     */
    public getSettingsPanel(): vscode.WebviewPanel | undefined {
        return this.settingsPanel;
    }
}
</file>

<file path="webview/package.json">
{
	"name": "webview",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"build:analyze": "vite build --mode analyze",
		"test": "vitest",
		"test:run": "vitest run",
		"test:coverage": "vitest run --coverage",
		"test:ui": "vitest --ui",
		"preview": "vite preview",
		"prepare": "svelte-kit sync || echo ''",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"test:e2e": "playwright test",
		"test:e2e": "playwright test",
		"test:unit": "vitest",
		"format": "prettier --write .",
		"lint": "prettier --check ."
	},
	"devDependencies": {
		"@playwright/test": "^1.49.1",
		"@sveltejs/adapter-auto": "^6.0.0",
		"@sveltejs/adapter-static": "^3.0.9",
		"@sveltejs/kit": "^2.22.0",
		"@sveltejs/vite-plugin-svelte": "^6.0.0",
		"@tailwindcss/forms": "^0.5.9",
		"@tailwindcss/typography": "^0.5.15",
		"@tailwindcss/vite": "^4.0.0",
		"@testing-library/jest-dom": "^6.8.0",
		"@testing-library/svelte": "^5.2.8",
		"@vitest/browser": "^3.2.3",
		"jsdom": "^26.1.0",
		"playwright": "^1.53.0",
		"prettier": "^3.4.2",
		"prettier-plugin-svelte": "^3.3.3",
		"svelte": "^5.0.0",
		"svelte-check": "^4.0.0",
		"tailwindcss": "^4.0.0",
		"terser": "^5.43.1",
		"typescript": "^5.0.0",
		"vite": "^7.0.4",
		"vitest": "^3.2.3",
		"vitest-browser-svelte": "^0.1.0"
	},
	"dependencies": {
		"@fluentui/web-components": "^2.6.1"
	}
}
</file>

<file path=".gitignore">
.codersinflow
.vscode
node_modules
.env
.venv
.codex
out
dist
*.vsix
.claude
CLAUDE.md
.DS_Store
.git
*.log
*.tmp
__pycache__
*.pyc
.env.local
.next
.github

.repomix-output.xml

# Database storage directories
qdrant_storage/
ollama_data/
</file>

<file path="README.md">
# Code Context Engine

AI-powered code context and search extension for VS Code.

## Development Setup

### Prerequisites
- Node.js 16.x or higher
- VS Code

### Installation
1. Clone the repository
2. Install dependencies:
   ```bash
   npm install
   cd webview && npm install
   ```

### Building
1. Build the extension:
   ```bash
   npm run compile
   ```

2. Build the webview:
   ```bash
   cd webview && npm run build
   ```

### Testing the Extension

1. Open this project in VS Code
2. Press `F5` to launch the Extension Development Host
3. In the new VS Code window, open the Command Palette (`Cmd+Shift+P` on Mac, `Ctrl+Shift+P` on Windows/Linux)
4. Run the command: "Open Code Context Panel"
5. The webview should open with the Code Context Engine interface

### Features Implemented

#### Sprint 1: VS Code Extension Boilerplate & UI Setup 
-  VS Code Extension boilerplate with TypeScript
-  Webview integration with Fluent UI components
-  Basic UI with Index Now button and progress indicators
-  VS Code theme integration (light/dark mode support)
-  Message passing between extension and webview
-  Mock search functionality
-  Settings integration

#### Sprint 2: AST Parser & Code Chunking 
-  Tree-sitter integration for TypeScript, JavaScript, Python, and C#
-  FileWalker service for discovering and filtering code files
-  AstParser service for parsing code into Abstract Syntax Trees
-  Chunker service for breaking ASTs into meaningful code segments
-  IndexingService orchestrating the complete indexing pipeline
-  Real-time progress reporting during indexing
-  Support for .gitignore patterns and common ignore rules
-  Comprehensive error handling and recovery

#### Sprint 3: Vectorization & DB Integration 
-  Qdrant vector database integration with Docker Compose setup
-  QdrantService for collection management and vector operations
-  IEmbeddingProvider interface for pluggable embedding providers
-  OllamaProvider for local embedding generation (nomic-embed-text)
-  OpenAIProvider for cloud-based embeddings (text-embedding-ada-002)
-  Complete vectorization pipeline integrated into IndexingService
-  Semantic search functionality with similarity scoring
-  Automatic collection creation and batch vector storage
-  Real-time search through indexed code with VS Code integration

#### Sprint 4: Context Query API 
-  ContextService for advanced query logic and file operations
-  File content retrieval with related chunks discovery
-  Related files discovery with similarity-based ranking
-  Advanced context queries with filtering and metadata
-  Comprehensive webview message handling and API routing
-  TypeScript API client with request/response management
-  Enhanced UI with service status, related files, and file preview
-  Real-time service health monitoring and status display
-  Modal file content viewer with syntax highlighting

#### Sprint 5: Settings UI & Configuration 
-  Comprehensive configuration schema with 12+ settings
-  Settings command registration and webview panel
-  Complete settings UI with provider selection and testing
-  Settings API handlers for get/save/reset operations
-  Connection testing for Qdrant and embedding providers
-  Configuration-driven service initialization
-  Real-time settings validation and error handling
-  Secure API key storage in VS Code settings
-  Advanced options for batch sizes, thresholds, and patterns

#### Sprint 6: LSP Integration & DevOps 
-  LSP service integration with VS Code language servers
-  Enhanced code chunks with semantic metadata (symbols, definitions, references)
-  Automatic LSP data enrichment during indexing process
-  Comprehensive GitHub Actions CI/CD pipeline
-  Multi-Node.js version testing (18.x, 20.x)
-  Automated VSIX packaging and artifact generation
-  Security scanning and code quality checks
-  Docker services integration for testing with Qdrant
-  Release automation with GitHub releases

### Commands Available

- `code-context-engine.openMainPanel` - Opens the main Code Context Engine panel
- `code-context-engine.startIndexing` - Starts repository indexing (placeholder implementation)

### Configuration

The extension contributes the following settings:

- `code-context-engine.embeddingProvider` - Choose between "ollama" and "openai"
- `code-context-engine.databaseConnectionString` - Qdrant database connection string
- `code-context-engine.openaiApiKey` - OpenAI API key (stored securely)

## Next Steps

This completes Sprint 1. The next sprints will implement:

- Sprint 2: AST parsing and code chunking with tree-sitter
- Sprint 3: Vectorization and Qdrant database integration
- Sprint 4: Context query API
- Sprint 5: Settings UI
- Sprint 6: LSP integration and DevOps
- Sprint 7: Documentation and marketplace publishing

## Project Structure

```
 src/
    extension.ts          # Main extension logic
    indexing/
       fileWalker.ts    # File discovery and filtering service
       indexingService.ts # Main indexing orchestrator
    parsing/
       astParser.ts     # AST parsing with tree-sitter
       chunker.ts       # Code chunking service
    db/
       qdrantService.ts # Vector database operations
    embeddings/
       embeddingProvider.ts # Embedding provider interface
       ollamaProvider.ts    # Local Ollama embeddings
       openaiProvider.ts    # OpenAI embeddings
    context/
       contextService.ts    # Advanced context queries and file operations
    types/
        tree-sitter-languages.d.ts # Type declarations
 webview/
    src/
       index.ts         # Webview TypeScript entry point
       index.html       # Webview HTML template
       styles.css       # Webview styles with VS Code theme integration
       lib/
           vscodeApi.ts # VS Code API client wrapper
    dist/                # Built webview files
    package.json         # Webview dependencies
 out/                     # Compiled extension files
 docker-compose.yml       # Qdrant database setup
 package.json             # Extension manifest and dependencies
 tsconfig.json           # TypeScript configuration
```
</file>

<file path="tsconfig.json">
{
	"compilerOptions": {
		"module": "commonjs",
		"target": "ES2020",
		"outDir": "out",
		"lib": [
			"ES2020",
			"DOM"
		],
		"sourceMap": true,
		"rootDir": "src",
		"strict": true,
		"esModuleInterop": true,
		"allowSyntheticDefaultImports": true
	},
	"exclude": [
		"webview/**/*",
		"webview-backup-*/**/*"
	]
}
</file>

<file path="src/context/contextService.ts">
/**
 * Context Service Module
 * 
 * This module provides a service for managing and querying code context within a VS Code workspace.
 * It leverages vector embeddings and similarity search to find related code chunks and files,
 * enabling semantic code navigation and contextual understanding of codebases.
 * 
 * The service integrates with:
 * - QdrantService for vector database operations
 * - EmbeddingProvider for generating semantic embeddings
 * - IndexingService for processing and indexing code files
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { IndexingService } from '../indexing/indexingService';
import { QdrantService, SearchResult } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';

/**
 * Represents the result of a file content retrieval operation
 * 
 * @property filePath - Path to the file that was retrieved
 * @property content - The text content of the file
 * @property language - Programming language of the file (derived from extension)
 * @property size - File size in bytes
 * @property lastModified - Last modification timestamp
 * @property relatedChunks - Optional array of semantically related code chunks from the same file
 */
export interface FileContentResult {
    filePath: string;
    content: string;
    language?: string;
    size: number;
    lastModified: Date;
    relatedChunks?: SearchResult[];
}

/**
 * Represents a file that is semantically related to a query or another file
 * 
 * @property filePath - Path to the related file
 * @property similarity - Similarity score (0-1) indicating relevance
 * @property reason - Human-readable explanation of why this file is related
 * @property chunkCount - Number of code chunks that matched the query
 * @property language - Programming language of the file
 */
export interface RelatedFile {
    filePath: string;
    similarity: number;
    reason: string;
    chunkCount: number;
    language?: string;
}

/**
 * Parameters for performing a context query
 * 
 * @property query - The search query text
 * @property filePath - Optional current file path for context
 * @property includeRelated - Whether to include related files in results
 * @property maxResults - Maximum number of results to return
 * @property minSimilarity - Minimum similarity threshold (0-1)
 * @property fileTypes - Optional array of file types to filter by
 */
export interface ContextQuery {
    query: string;
    filePath?: string;
    includeRelated?: boolean;
    maxResults?: number;
    minSimilarity?: number;
    fileTypes?: string[];
}

/**
 * Results of a context query operation
 * 
 * @property query - The original search query
 * @property results - Array of matching code chunks
 * @property relatedFiles - Array of related files
 * @property totalResults - Total number of results found
 * @property processingTime - Time taken to process the query in milliseconds
 */
export interface ContextResult {
    query: string;
    results: SearchResult[];
    relatedFiles: RelatedFile[];
    totalResults: number;
    processingTime: number;
}

/**
 * Core service for managing and querying code context
 * 
 * This service provides methods for:
 * - Retrieving file content with related chunks
 * - Finding files related to a query or current file
 * - Performing semantic searches across the codebase
 * - Checking service status and readiness
 */
export class ContextService {
    private workspaceRoot: string;
    private indexingService: IndexingService;
    private qdrantService: QdrantService;
    private embeddingProvider: IEmbeddingProvider;
    
    // Configuration constants
    private readonly DEFAULT_CHUNK_LIMIT = 50;
    private readonly DEFAULT_RELATED_FILES_LIMIT = 10;
    
    /**
     * Creates an empty context result object
     * Helper method to reduce code duplication
     * 
     * @param query - The original query string
     * @param startTime - Optional start time for calculating processing time
     * @returns An empty ContextResult object
     */
    private createEmptyResult(query: string, startTime?: number): ContextResult {
        return {
            query: query,
            results: [],
            relatedFiles: [],
            totalResults: 0,
            processingTime: startTime ? Date.now() - startTime : 0
        };
    }

    /**
     * Constructor now uses dependency injection for better testability and decoupling
     * 
     * @param workspaceRoot - The workspace root path
     * @param qdrantService - Injected QdrantService instance
     * @param embeddingProvider - Injected embedding provider instance
     * @param indexingService - Injected IndexingService instance
     */
    constructor(
        workspaceRoot: string,
        qdrantService: QdrantService,
        embeddingProvider: IEmbeddingProvider,
        indexingService: IndexingService
    ) {
        this.workspaceRoot = workspaceRoot;
        this.qdrantService = qdrantService;
        this.embeddingProvider = embeddingProvider;
        this.indexingService = indexingService;
    }

    /**
     * Generates a unique collection name for the current workspace
     * 
     * The collection name is derived from the workspace folder name,
     * sanitized to ensure compatibility with Qdrant naming requirements.
     * 
     * @returns A sanitized collection name string
     */
    /**
     * Generates a unique collection name for the current workspace
     * 
     * The collection name is derived from the workspace folder name,
     * sanitized to ensure compatibility with Qdrant naming requirements.
     * Uses path module for cross-platform compatibility.
     * 
     * @returns A sanitized collection name string
     */
    private generateCollectionName(): string {
        const workspaceName = path.basename(this.workspaceRoot) || 'workspace';
        const sanitizedName = workspaceName.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        return `code_context_${sanitizedName}`;
    }

    /**
     * Retrieves file content with optional related chunks
     * 
     * @param filePath - Path to the file to retrieve
     * @param includeRelatedChunks - Whether to include semantically related chunks from the same file
     * @returns Promise resolving to file content and metadata
     * @throws Error if file cannot be read or processed
     */
    async getFileContent(filePath: string, includeRelatedChunks: boolean = false): Promise<FileContentResult> {
        try {
            // Resolve absolute path
            const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(this.workspaceRoot, filePath);
            const uri = vscode.Uri.file(absolutePath);

            // Read file content
            const fileData = await vscode.workspace.fs.readFile(uri);
            const content = Buffer.from(fileData).toString('utf8');

            // Get file stats
            const stats = await vscode.workspace.fs.stat(uri);
            
            // Check file size to prevent memory issues with very large files
            const MAX_SAFE_FILE_SIZE = 10 * 1024 * 1024; // 10MB
            if (stats.size > MAX_SAFE_FILE_SIZE) {
                console.warn(`Large file detected (${(stats.size / 1024 / 1024).toFixed(2)}MB): ${filePath}`);
            }
            
            // Determine language from file extension
            const language = this.getLanguageFromPath(filePath);

            const result: FileContentResult = {
                filePath: filePath,
                content: content,
                language: language,
                size: stats.size,
                lastModified: new Date(stats.mtime)
            };

            // Optionally include related chunks
            if (includeRelatedChunks) {
                if (!this.embeddingProvider) {
                    console.warn('Embedding provider not available, cannot include related chunks');
                } else {
                    // Search for chunks from this file
                    const collectionName = this.generateCollectionName();
                    const searchResults = await this.qdrantService.search(
                        collectionName,
                        [], // Empty vector, we'll use filter instead
                        this.DEFAULT_CHUNK_LIMIT,
                        {
                            must: [
                                {
                                    key: 'filePath',
                                    match: { value: filePath }
                                }
                            ]
                        }
                    );
                    result.relatedChunks = searchResults;
                }
            }

            return result;
        } catch (error) {
            console.error(`Failed to get file content for ${filePath}:`, error);
            throw new Error(`Failed to read file: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Finds files related to a query or current file
     * 
     * This method performs semantic search to find files that are conceptually
     * related to the provided query. It groups results by file and calculates
     * file-level similarity scores.
     * 
     * @param query - The search query text
     * @param currentFilePath - Optional current file path to exclude from results
     * @param maxResults - Maximum number of related files to return
     * @param minSimilarity - Minimum similarity threshold (0-1)
     * @returns Promise resolving to array of related files
     */
    async findRelatedFiles(
        query: string,
        currentFilePath?: string,
        maxResults?: number,
        minSimilarity?: number
    ): Promise<RelatedFile[]> {
        // Get configuration values with fallbacks
        const config = vscode.workspace.getConfiguration('code-context-engine');
        maxResults = maxResults ?? config.get<number>('maxSearchResults') ?? 10;
        minSimilarity = minSimilarity ?? config.get<number>('minSimilarityThreshold') ?? 0.5;
        try {
            if (!this.embeddingProvider) {
                throw new Error('Embedding provider not available');
            }

            // Generate embedding for the query
            const queryEmbeddings = await this.embeddingProvider.generateEmbeddings([query]);
            if (queryEmbeddings.length === 0) {
                return [];
            }

            const collectionName = this.generateCollectionName();
            
            // Search for similar chunks - get 3x results to ensure good file coverage
            const searchResults = await this.qdrantService.search(
                collectionName,
                queryEmbeddings[0],
                maxResults * 3 // Get more results to group by file
            );

            // Group results by file and calculate file-level similarity
            const fileGroups = new Map<string, {
                chunks: SearchResult[];
                maxScore: number;
                avgScore: number;
                language?: string;
            }>();

            // Process search results and group by file path
            for (const result of searchResults) {
                // Skip results below similarity threshold
                if (result.score < minSimilarity) continue;
                // Skip current file if provided
                if (currentFilePath && result.payload.filePath === currentFilePath) continue;

                const filePath = result.payload.filePath;
                // Initialize group if this is the first chunk for this file
                if (!fileGroups.has(filePath)) {
                    fileGroups.set(filePath, {
                        chunks: [],
                        maxScore: 0,
                        avgScore: 0,
                        language: result.payload.language
                    });
                }

                // Add chunk to file group and update max score
                const group = fileGroups.get(filePath)!;
                group.chunks.push(result);
                group.maxScore = Math.max(group.maxScore, result.score);
            }

            // Calculate average scores and create RelatedFile objects
            const relatedFiles: RelatedFile[] = [];
            for (const [filePath, group] of fileGroups) {
                // Calculate average similarity score across all chunks
                group.avgScore = group.chunks.reduce((sum, chunk) => sum + chunk.score, 0) / group.chunks.length;
                
                // Generate human-readable reason for the relation
                const topChunk = group.chunks[0];
                const reason = this.generateRelationReason(topChunk, group.chunks.length);

                relatedFiles.push({
                    filePath: filePath,
                    similarity: group.maxScore, // Use max score as the file similarity
                    reason: reason,
                    chunkCount: group.chunks.length,
                    language: group.language
                });
            }

            // Sort by similarity (descending) and return top results
            return relatedFiles
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, maxResults);

        } catch (error) {
            console.error('Failed to find related files:', error);
            return [];
        }
    }

    /**
     * Performs an advanced context query
     * 
     * This is the main entry point for semantic code search. It supports:
     * - Filtering by file type
     * - Including related files
     * - Minimum similarity thresholds
     * - Performance tracking
     * 
     * @param contextQuery - Query parameters
     * @returns Promise resolving to query results
     */
    async queryContext(contextQuery: ContextQuery): Promise<ContextResult> {
        const startTime = Date.now();
        
        try {
            if (!this.embeddingProvider) {
                throw new Error('Embedding provider not available');
            }

            // Generate embedding for the query
            const queryEmbeddings = await this.embeddingProvider.generateEmbeddings([contextQuery.query]);
            if (queryEmbeddings.length === 0) {
                return this.createEmptyResult(contextQuery.query, startTime);
            }

            const collectionName = this.generateCollectionName();

            // Get configuration values with fallbacks
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const maxResults = contextQuery.maxResults ?? config.get<number>('maxSearchResults') ?? 20;
            const defaultMinSimilarity = config.get<number>('minSimilarityThreshold') ?? 0.5;
            
            // Build filter for file types if specified
            let filter: { should: Array<{ key: string, match: { value: string } }> } | undefined = undefined;
            if (contextQuery.fileTypes && contextQuery.fileTypes.length > 0) {
                // Create a filter that matches any of the specified languages
                filter = {
                    should: contextQuery.fileTypes.map(lang => ({
                        key: 'language',
                        match: { value: lang }
                    }))
                };
            }

            // Search for similar chunks
            const searchResults = await this.qdrantService.search(
                collectionName,
                queryEmbeddings[0],
                maxResults,
                filter
            );

            // Filter by minimum similarity if specified
            const minSimilarity = contextQuery.minSimilarity ?? defaultMinSimilarity;
            const filteredResults = searchResults.filter(r => r.score >= minSimilarity);

            // Find related files if requested
            let relatedFiles: RelatedFile[] = [];
            if (contextQuery.includeRelated) {
                relatedFiles = await this.findRelatedFiles(
                    contextQuery.query,
                    contextQuery.filePath,
                    this.DEFAULT_RELATED_FILES_LIMIT, // Use configurable constant
                    minSimilarity
                );
            }

            // Return complete result object with timing information
            return {
                query: contextQuery.query,
                results: filteredResults,
                relatedFiles: relatedFiles,
                totalResults: filteredResults.length,
                processingTime: Date.now() - startTime
            };

        } catch (error) {
            console.error('Context query failed:', error);
            // Return empty results with timing information on error
            return this.createEmptyResult(contextQuery.query, startTime);
        }
    }

    /**
     * Maps file extensions to programming language identifiers
     * 
     * @param filePath - Path to the file
     * @returns Language identifier or undefined if not recognized
     */
    /**
     * Maps file extensions to programming language identifiers
     * Supports common file types and can be extended as needed
     * 
     * @param filePath - Path to the file
     * @returns Language identifier or undefined if not recognized
     */
    private getLanguageFromPath(filePath: string): string | undefined {
        const ext = path.extname(filePath).toLowerCase();
        const languageMap: Record<string, string> = {
            // JavaScript family
            '.ts': 'typescript',
            '.tsx': 'typescript',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.mjs': 'javascript',
            '.cjs': 'javascript',
            
            // Web technologies
            '.html': 'html',
            '.css': 'css',
            '.scss': 'scss',
            '.less': 'less',
            '.vue': 'vue',
            '.svelte': 'svelte',
            
            // Backend languages
            '.py': 'python',
            '.rb': 'ruby',
            '.php': 'php',
            '.java': 'java',
            '.cs': 'csharp',
            '.go': 'go',
            '.rs': 'rust',
            
            // Data formats
            '.json': 'json',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.xml': 'xml',
            '.md': 'markdown',
            
            // Shell scripts
            '.sh': 'shell',
            '.bash': 'shell',
            '.zsh': 'shell',
            '.ps1': 'powershell'
        };
        
        return languageMap[ext];
    }

    /**
     * Generates a human-readable reason for why a file is related
     * 
     * @param topChunk - The highest-scoring chunk from the file
     * @param chunkCount - Total number of matching chunks in the file
     * @returns A descriptive string explaining the relation
     */
    private generateRelationReason(topChunk: SearchResult, chunkCount: number): string {
        const type = topChunk.payload.type;
        const name = topChunk.payload.name;
        
        if (chunkCount > 1) {
            return `Contains ${chunkCount} related ${type}s${name ? ` including "${name}"` : ''}`;
        } else {
            return `Contains related ${type}${name ? ` "${name}"` : ''}`;
        }
    }

    /**
     * Checks if the context service is ready for use
     * 
     * Verifies that both the vector database and embedding provider are available.
     * 
     * @returns Promise resolving to boolean indicating readiness
     */
    /**
     * Checks if the context service is ready for use
     * 
     * Verifies that both the vector database and embedding provider are available.
     * Logs any errors encountered during the check.
     * 
     * @returns Promise resolving to boolean indicating readiness
     */
    async isReady(): Promise<boolean> {
        try {
            // Check if Qdrant is available
            const qdrantReady = await this.qdrantService.healthCheck();
            if (!qdrantReady) {
                console.warn('Qdrant service health check failed');
                return false;
            }

            // Check if embedding provider is available
            if (!this.embeddingProvider) {
                console.warn('Embedding provider not available');
                return false;
            }
            
            return true;
        } catch (error) {
            console.error('Error checking service readiness:', error);
            return false;
        }
    }

    /**
     * Gets detailed status information about the service
     * 
     * Provides information about:
     * - Vector database connection
     * - Embedding provider availability
     * - Collection existence and metadata
     * 
     * @returns Promise resolving to status object
     */
    async getStatus(): Promise<{
        qdrantConnected: boolean;
        embeddingProvider: string | null;
        collectionExists: boolean;
        collectionInfo?: any;
    }> {
        // Check Qdrant connection
        const qdrantConnected = await this.qdrantService.healthCheck();
        
        // Get embedding provider name if available
        let embeddingProvider: string | null = null;
        try {
            embeddingProvider = this.embeddingProvider?.getProviderName() || null;
        } catch {
            // Provider not available
        }

        // Check if collection exists and get its info
        const collectionName = this.generateCollectionName();
        const collectionInfo = await this.qdrantService.getCollectionInfo(collectionName);
        const collectionExists = collectionInfo !== null;

        // Return comprehensive status object
        return {
            qdrantConnected,
            embeddingProvider,
            collectionExists,
            collectionInfo: collectionExists ? collectionInfo : undefined
        };
    }
}
</file>

<file path="src/messageRouter.ts">
import * as vscode from 'vscode';
import { ContextService, ContextQuery, RelatedFile } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { SearchManager, SearchFilters } from './searchManager';
import { ConfigurationManager as LegacyConfigurationManager } from './configurationManager';
import { PerformanceManager } from './performanceManager';
import { SystemValidator } from './validation/systemValidator';
import { TroubleshootingSystem } from './validation/troubleshootingGuide';
import { ConfigurationManager } from './configuration/configurationManager';
import { StateManager } from './stateManager';

/**
 * MessageRouter class responsible for routing and handling messages from webview panels.
 * 
 * This class centralizes all webview message handling logic, providing a clean separation
 * between webview communication and service logic. It handles:
 * - Message routing based on command types
 * - Service integration for handling requests
 * - Response formatting and error handling
 * - Type-safe message handling
 */
export class MessageRouter {
    private contextService: ContextService;
    private indexingService: IndexingService;
    private searchManager?: SearchManager;
    private legacyConfigurationManager?: LegacyConfigurationManager;
    private performanceManager?: PerformanceManager;
    private context: vscode.ExtensionContext;
    private systemValidator: SystemValidator;
    private troubleshootingSystem: TroubleshootingSystem;
    private configurationManager: ConfigurationManager;
    private stateManager: StateManager;

    /**
     * Creates a new MessageRouter instance
     * @param contextService - The ContextService instance for context operations
     * @param indexingService - The IndexingService instance for indexing operations
     * @param context - The VS Code extension context for accessing secrets and other APIs
     * @param stateManager - The StateManager instance for state management
     */
    constructor(contextService: ContextService, indexingService: IndexingService, context: vscode.ExtensionContext, stateManager: StateManager) {
        this.contextService = contextService;
        this.indexingService = indexingService;
        this.context = context;
        this.stateManager = stateManager;
        this.systemValidator = new SystemValidator(context);
        this.troubleshootingSystem = new TroubleshootingSystem();
        this.configurationManager = new ConfigurationManager(context);
    }

    /**
     * Sets the advanced managers for enhanced functionality
     * @param searchManager - The SearchManager instance
     * @param legacyConfigurationManager - The legacy ConfigurationManager instance
     * @param performanceManager - The PerformanceManager instance
     */
    setAdvancedManagers(
        searchManager: SearchManager,
        legacyConfigurationManager: LegacyConfigurationManager,
        performanceManager: PerformanceManager
    ): void {
        this.searchManager = searchManager;
        this.legacyConfigurationManager = legacyConfigurationManager;
        this.performanceManager = performanceManager;
        console.log('MessageRouter: Advanced managers set');
    }

    /**
     * Routes and handles a message from a webview
     * @param message - The message object from the webview
     * @param webview - The webview that sent the message
     */
    async handleMessage(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling message:', message.command);

            switch (message.command) {
                case 'ping':
                    await this.handlePing(message, webview);
                    break;
                case 'checkSetupStatus':
                    await this.handleCheckSetupStatus(message, webview);
                    break;
                case 'startDatabase':
                    await this.handleStartDatabase(message, webview);
                    break;
                case 'validateDatabase':
                    await this.handleValidateDatabase(message, webview);
                    break;
                case 'saveSecretValue':
                    await this.handleSaveSecretValue(message, webview);
                    break;
                case 'getSecretValue':
                    await this.handleGetSecretValue(message, webview);
                    break;
                case 'runSystemValidation':
                    await this.handleRunSystemValidation(message, webview);
                    break;
                case 'getTroubleshootingGuides':
                    await this.handleGetTroubleshootingGuides(message, webview);
                    break;
                case 'runAutoFix':
                    await this.handleRunAutoFix(message, webview);
                    break;
                case 'openTroubleshootingGuide':
                    await this.handleOpenTroubleshootingGuide(message, webview);
                    break;
                case 'exportConfiguration':
                    await this.handleExportConfiguration(message, webview);
                    break;
                case 'importConfiguration':
                    await this.handleImportConfiguration(message, webview);
                    break;
                case 'getConfigurationTemplates':
                    await this.handleGetConfigurationTemplates(message, webview);
                    break;
                case 'getConfigurationBackups':
                    await this.handleGetConfigurationBackups(message, webview);
                    break;
                case 'validateConfiguration':
                    await this.handleValidateConfiguration(message, webview);
                    break;
                case 'applyConfigurationTemplate':
                    await this.handleApplyConfigurationTemplate(message, webview);
                    break;
                case 'createConfigurationBackup':
                    await this.handleCreateConfigurationBackup(message, webview);
                    break;
                case 'restoreConfigurationBackup':
                    await this.handleRestoreConfigurationBackup(message, webview);
                    break;
                case 'getFileContent':
                    await this.handleGetFileContent(message, webview);
                    break;
                case 'findRelatedFiles':
                    await this.handleFindRelatedFiles(message, webview);
                    break;
                case 'queryContext':
                    await this.handleQueryContext(message, webview);
                    break;
                case 'getServiceStatus':
                    await this.handleGetServiceStatus(webview);
                    break;
                case 'startIndexing':
                    await this.handleStartIndexing(webview);
                    break;
                case 'advancedSearch':
                    await this.handleAdvancedSearch(message, webview);
                    break;
                case 'getSearchSuggestions':
                    await this.handleGetSearchSuggestions(message, webview);
                    break;
                case 'getSearchHistory':
                    await this.handleGetSearchHistory(webview);
                    break;
                case 'validateConfiguration':
                    await this.handleValidateConfiguration(message, webview);
                    break;
                case 'getConfigurationPresets':
                    await this.handleGetConfigurationPresets(webview);
                    break;
                case 'applyConfigurationPreset':
                    await this.handleApplyConfigurationPreset(message, webview);
                    break;
                case 'getPerformanceMetrics':
                    await this.handleGetPerformanceMetrics(webview);
                    break;
                case 'getFilePreview':
                    await this.handleGetFilePreview(message, webview);
                    break;
                case 'MapToSettings':
                    await this.handleMapToSettings(webview);
                    break;
                case 'openSettings':
                    await this.handleMapToSettings(webview);
                    break;
                default:
                    console.warn('MessageRouter: Unknown command:', message.command);
                    await this.sendErrorResponse(webview, `Unknown command: ${message.command}`);
                    break;
            }
        } catch (error) {
            console.error('MessageRouter: Error handling message:', error);
            await this.sendErrorResponse(webview, error instanceof Error ? error.message : String(error));
        }
    }

    /**
     * Handles the 'ping' message
     * Simple ping-pong test for communication verification
     */
    private async handlePing(message: any, webview: vscode.Webview): Promise<void> {
        console.log('MessageRouter: Received ping from webview', message.requestId);

        await webview.postMessage({
            command: 'pong',
            requestId: message.requestId,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Handles the 'checkSetupStatus' message
     * Checks if the workspace is configured for first-time setup
     */
    private async handleCheckSetupStatus(message: any, webview: vscode.Webview): Promise<void> {
        try {
            // Check if workspace has configuration
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                await webview.postMessage({
                    command: 'response',
                    requestId: message.requestId,
                    data: {
                        isConfigured: false,
                        reason: 'No workspace folder'
                    }
                });
                return;
            }

            // Check if services are configured and running
            const status = await this.contextService.getStatus();
            const isConfigured = status.qdrantConnected && status.embeddingProvider !== null;

            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                data: {
                    isConfigured,
                    status: status
                }
            });

        } catch (error) {
            console.error('MessageRouter: Error checking setup status:', error);
            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                error: error instanceof Error ? error.message : String(error),
                data: {
                    isConfigured: false
                }
            });
        }
    }

    /**
     * Handles the 'startDatabase' message
     * Starts the local database (Qdrant, ChromaDB via Docker)
     */
    private async handleStartDatabase(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { database, config } = message;
            console.log('MessageRouter: Starting database:', database, config);

            switch (database) {
                case 'qdrant':
                    await this.startQdrant(webview);
                    break;
                case 'chromadb':
                    await this.startChromaDB(webview, config);
                    break;
                default:
                    throw new Error(`Unsupported database type for starting: ${database}`);
            }

        } catch (error) {
            console.error('MessageRouter: Error starting database:', error);
            await webview.postMessage({
                command: 'databaseStatus',
                data: {
                    status: 'error',
                    error: error instanceof Error ? error.message : String(error)
                }
            });
        }
    }

    /**
     * Handles the 'validateDatabase' message
     * Validates cloud database connections (e.g., Pinecone)
     */
    private async handleValidateDatabase(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { database, config } = message;
            console.log('MessageRouter: Validating database:', database);

            switch (database) {
                case 'pinecone':
                    await this.validatePinecone(webview, config);
                    break;
                default:
                    throw new Error(`Unsupported database type for validation: ${database}`);
            }

        } catch (error) {
            console.error('MessageRouter: Error validating database:', error);
            await webview.postMessage({
                command: 'databaseStatus',
                data: {
                    status: 'error',
                    error: error instanceof Error ? error.message : String(error)
                }
            });
        }
    }

    /**
     * Start Qdrant database
     */
    private async startQdrant(webview: vscode.Webview): Promise<void> {
        const terminal = vscode.window.createTerminal('Qdrant Database');
        terminal.sendText('docker run -p 6333:6333 qdrant/qdrant');
        terminal.show();

        await webview.postMessage({
            command: 'databaseStarted',
            data: { database: 'qdrant', status: 'starting' }
        });

        this.pollDatabaseHealth(webview, 'qdrant');
    }

    /**
     * Start ChromaDB database
     */
    private async startChromaDB(webview: vscode.Webview, config: any): Promise<void> {
        const port = config?.port || 8000;
        const terminal = vscode.window.createTerminal('ChromaDB Database');
        terminal.sendText(`docker run -p ${port}:8000 chromadb/chroma`);
        terminal.show();

        await webview.postMessage({
            command: 'databaseStarted',
            data: { database: 'chromadb', status: 'starting' }
        });

        this.pollDatabaseHealth(webview, 'chromadb', config);
    }

    /**
     * Validate Pinecone connection
     */
    private async validatePinecone(webview: vscode.Webview, config: any): Promise<void> {
        if (!config?.apiKey || !config?.environment) {
            throw new Error('Pinecone API key and environment are required');
        }

        try {
            // Test Pinecone connection by listing indexes
            const response = await fetch(`https://controller.${config.environment}.pinecone.io/databases`, {
                method: 'GET',
                headers: {
                    'Api-Key': config.apiKey,
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                await webview.postMessage({
                    command: 'databaseStatus',
                    data: { status: 'running' }
                });
            } else if (response.status === 401) {
                throw new Error('Invalid Pinecone API key');
            } else if (response.status === 403) {
                throw new Error('Access denied - check your API key permissions');
            } else {
                throw new Error(`Pinecone connection failed: ${response.status} ${response.statusText}`);
            }

        } catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('Pinecone connection timeout - check your environment');
            }
            throw error;
        }
    }

    /**
     * Poll database health and update webview
     */
    private async pollDatabaseHealth(webview: vscode.Webview, database: string, config?: any): Promise<void> {
        const maxAttempts = 30; // 30 seconds
        let attempts = 0;

        const checkHealth = async (): Promise<void> => {
            try {
                attempts++;
                let healthUrl: string;

                switch (database) {
                    case 'qdrant':
                        healthUrl = 'http://localhost:6333/health';
                        break;
                    case 'chromadb':
                        const port = config?.port || 8000;
                        healthUrl = `http://localhost:${port}/api/v1/heartbeat`;
                        break;
                    default:
                        throw new Error(`Unsupported database for health check: ${database}`);
                }

                const response = await fetch(healthUrl);
                if (response.ok) {
                    await webview.postMessage({
                        command: 'databaseStatus',
                        data: { status: 'running' }
                    });
                    return;
                }

                if (attempts < maxAttempts) {
                    setTimeout(checkHealth, 1000); // Check again in 1 second
                } else {
                    await webview.postMessage({
                        command: 'databaseStatus',
                        data: {
                            status: 'error',
                            error: `${database} failed to start within 30 seconds`
                        }
                    });
                }

            } catch (error) {
                if (attempts < maxAttempts) {
                    setTimeout(checkHealth, 1000); // Check again in 1 second
                } else {
                    await webview.postMessage({
                        command: 'databaseStatus',
                        data: {
                            status: 'error',
                            error: `${database} health check failed`
                        }
                    });
                }
            }
        };

        // Start health checking
        setTimeout(checkHealth, 2000); // Wait 2 seconds before first check
    }

    /**
     * Handles the 'getFileContent' message
     * Retrieves file content with optional related chunks
     */
    private async handleGetFileContent(message: any, webview: vscode.Webview): Promise<void> {
        const { filePath, includeRelatedChunks = false } = message;
        
        if (!filePath) {
            await this.sendErrorResponse(webview, 'File path is required');
            return;
        }

        const result = await this.contextService.getFileContent(filePath, includeRelatedChunks);
        
        await webview.postMessage({
            command: 'fileContentResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Handles the 'findRelatedFiles' message
     * Finds files related to a query
     */
    private async handleFindRelatedFiles(message: any, webview: vscode.Webview): Promise<void> {
        const { query, currentFilePath, maxResults = 10, minSimilarity = 0.5 } = message;
        
        if (!query) {
            await this.sendErrorResponse(webview, 'Query is required');
            return;
        }

        const result = await this.contextService.findRelatedFiles(
            query, 
            currentFilePath, 
            maxResults, 
            minSimilarity
        );
        
        await webview.postMessage({
            command: 'relatedFilesResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Handles the 'queryContext' message
     * Performs advanced context queries
     */
    private async handleQueryContext(message: any, webview: vscode.Webview): Promise<void> {
        const { contextQuery } = message;
        
        if (!contextQuery) {
            await this.sendErrorResponse(webview, 'Context query is required');
            return;
        }

        const result = await this.contextService.queryContext(contextQuery as ContextQuery);
        
        await webview.postMessage({
            command: 'contextQueryResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Handles the 'getServiceStatus' message
     * Retrieves the current status of all services
     */
    private async handleGetServiceStatus(webview: vscode.Webview): Promise<void> {
        const status = await this.contextService.getStatus();
        
        await webview.postMessage({
            command: 'serviceStatusResponse',
            data: status
        });
    }

    /**
     * Handles the 'startIndexing' message
     * Starts the indexing process with progress updates
     */
    private async handleStartIndexing(webview: vscode.Webview): Promise<void> {
        try {
            // Check if indexing is already in progress
            if (this.stateManager.isIndexing()) {
                await this.sendErrorResponse(webview, 'Indexing is already in progress. Please wait for the current operation to complete.');
                return;
            }

            // Check if workspace is available
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                await this.sendErrorResponse(webview, 'No workspace folder is open');
                return;
            }

            // Send initial response
            await webview.postMessage({
                command: 'indexingStarted',
                message: 'Indexing process started'
            });

            // Start indexing with progress callback
            const result = await this.indexingService.startIndexing((progressInfo) => {
                webview.postMessage({
                    command: 'indexingProgress',
                    data: {
                        phase: progressInfo.currentPhase,
                        currentFile: progressInfo.currentFile,
                        processedFiles: progressInfo.processedFiles,
                        totalFiles: progressInfo.totalFiles,
                        percentage: Math.round((progressInfo.processedFiles / progressInfo.totalFiles) * 100)
                    }
                });
            });

            // Send completion response
            await webview.postMessage({
                command: 'indexingCompleted',
                data: {
                    success: result.success,
                    processedFiles: result.processedFiles,
                    chunksCreated: result.chunks.length,
                    errors: result.errors
                }
            });

        } catch (error) {
            await this.sendErrorResponse(webview, `Indexing failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Handles the 'advancedSearch' message
     * Performs advanced search with filters
     */
    private async handleAdvancedSearch(message: any, webview: vscode.Webview): Promise<void> {
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'Advanced search not available');
            return;
        }

        const { query, filters } = message;

        if (!query) {
            await this.sendErrorResponse(webview, 'Search query is required');
            return;
        }

        const results = await this.performanceManager?.measurePerformance('advancedSearch', async () => {
            return this.searchManager!.search(query, filters as SearchFilters);
        }) || await this.searchManager.search(query, filters as SearchFilters);

        await webview.postMessage({
            command: 'advancedSearchResponse',
            requestId: message.requestId,
            data: results
        });
    }

    /**
     * Handles the 'getSearchSuggestions' message
     * Gets search suggestions based on partial query
     */
    private async handleGetSearchSuggestions(message: any, webview: vscode.Webview): Promise<void> {
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'Search suggestions not available');
            return;
        }

        const { partialQuery } = message;
        const suggestions = this.searchManager.getSuggestions(partialQuery || '');

        await webview.postMessage({
            command: 'searchSuggestionsResponse',
            requestId: message.requestId,
            data: suggestions
        });
    }

    /**
     * Handles the 'getSearchHistory' message
     * Gets recent search history
     */
    private async handleGetSearchHistory(webview: vscode.Webview): Promise<void> {
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'Search history not available');
            return;
        }

        const history = this.searchManager.getSearchHistory();

        await webview.postMessage({
            command: 'searchHistoryResponse',
            data: history
        });
    }



    /**
     * Handles the 'getConfigurationPresets' message
     * Gets available configuration presets
     */
    private async handleGetConfigurationPresets(webview: vscode.Webview): Promise<void> {
        if (!this.configurationManager) {
            await this.sendErrorResponse(webview, 'Configuration presets not available');
            return;
        }

        const presets = this.configurationManager.getConfigurationPresets();

        await webview.postMessage({
            command: 'configurationPresetsResponse',
            data: presets
        });
    }

    /**
     * Handles the 'applyConfigurationPreset' message
     * Applies a configuration preset
     */
    private async handleApplyConfigurationPreset(message: any, webview: vscode.Webview): Promise<void> {
        if (!this.configurationManager) {
            await this.sendErrorResponse(webview, 'Configuration presets not available');
            return;
        }

        const { presetName } = message;

        if (!presetName) {
            await this.sendErrorResponse(webview, 'Preset name is required');
            return;
        }

        try {
            await this.configurationManager.applyPreset(presetName);

            await webview.postMessage({
                command: 'configurationPresetAppliedResponse',
                requestId: message.requestId,
                data: { success: true, presetName }
            });
        } catch (error) {
            await this.sendErrorResponse(webview, `Failed to apply preset: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Handles the 'getPerformanceMetrics' message
     * Gets current performance metrics
     */
    private async handleGetPerformanceMetrics(webview: vscode.Webview): Promise<void> {
        if (!this.performanceManager) {
            await this.sendErrorResponse(webview, 'Performance metrics not available');
            return;
        }

        const metrics = this.performanceManager.getMetrics();

        await webview.postMessage({
            command: 'performanceMetricsResponse',
            data: metrics
        });
    }

    /**
     * Handles the 'getFilePreview' message
     * Gets file preview for a specific location
     */
    private async handleGetFilePreview(message: any, webview: vscode.Webview): Promise<void> {
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'File preview not available');
            return;
        }

        const { filePath, lineNumber, contextLines } = message;

        if (!filePath || !lineNumber) {
            await this.sendErrorResponse(webview, 'File path and line number are required');
            return;
        }

        try {
            const preview = await this.searchManager.getFilePreview(filePath, lineNumber, contextLines);

            await webview.postMessage({
                command: 'filePreviewResponse',
                requestId: message.requestId,
                data: { preview, filePath, lineNumber }
            });
        } catch (error) {
            await this.sendErrorResponse(webview, `Failed to get file preview: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Sends an error response to the webview
     * @param webview - The webview to send the error to
     * @param message - The error message
     */
    private async sendErrorResponse(webview: vscode.Webview, message: string): Promise<void> {
        await webview.postMessage({
            command: 'error',
            message: message
        });
    }

    /**
     * Handles the 'saveSecretValue' message
     * Saves sensitive data securely using VS Code's SecretStorage API
     */
    private async handleSaveSecretValue(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { key, value } = message;

            if (!key || !value) {
                throw new Error('Key and value are required for saving secrets');
            }

            // Use VS Code's SecretStorage API to store the value securely
            await this.context.secrets.store(key, value);

            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                data: { success: true }
            });

            console.log(`MessageRouter: Secret value saved for key: ${key}`);

        } catch (error) {
            console.error('MessageRouter: Error saving secret value:', error);
            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                error: error instanceof Error ? error.message : String(error),
                data: { success: false }
            });
        }
    }

    /**
     * Handles the 'getSecretValue' message
     * Retrieves sensitive data securely using VS Code's SecretStorage API
     */
    private async handleGetSecretValue(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { key } = message;

            if (!key) {
                throw new Error('Key is required for retrieving secrets');
            }

            // Use VS Code's SecretStorage API to retrieve the value securely
            const value = await this.context.secrets.get(key);

            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                data: { value: value || null }
            });

            console.log(`MessageRouter: Secret value retrieved for key: ${key} (${value ? 'found' : 'not found'})`);

        } catch (error) {
            console.error('MessageRouter: Error retrieving secret value:', error);
            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                error: error instanceof Error ? error.message : String(error),
                data: { value: null }
            });
        }
    }

    /**
     * Handles the 'runSystemValidation' message
     * Runs comprehensive system validation checks
     */
    private async handleRunSystemValidation(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Running system validation');

            const validationReport = await this.systemValidator.validateSystem();

            await webview.postMessage({
                command: 'validationResults',
                data: validationReport
            });

            console.log(`MessageRouter: System validation completed - ${validationReport.overallStatus}`);

        } catch (error) {
            console.error('MessageRouter: Error running system validation:', error);
            await webview.postMessage({
                command: 'validationResults',
                data: {
                    overallStatus: 'fail',
                    results: [{
                        isValid: false,
                        category: 'system',
                        check: 'System Validation',
                        status: 'fail',
                        message: 'Failed to run system validation',
                        details: error instanceof Error ? error.message : String(error)
                    }],
                    summary: { passed: 0, warnings: 0, failed: 1 }
                }
            });
        }
    }

    /**
     * Handles the 'getTroubleshootingGuides' message
     * Gets relevant troubleshooting guides based on validation results
     */
    private async handleGetTroubleshootingGuides(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { validationResults } = message;
            console.log('MessageRouter: Getting troubleshooting guides');

            const suggestedGuides = this.troubleshootingSystem.getSuggestedGuides(validationResults);

            await webview.postMessage({
                command: 'troubleshootingGuides',
                data: suggestedGuides
            });

            console.log(`MessageRouter: Found ${suggestedGuides.length} troubleshooting guides`);

        } catch (error) {
            console.error('MessageRouter: Error getting troubleshooting guides:', error);
            await webview.postMessage({
                command: 'troubleshootingGuides',
                data: []
            });
        }
    }

    /**
     * Handles the 'runAutoFix' message
     * Attempts to automatically fix common issues
     */
    private async handleRunAutoFix(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { check } = message;
            console.log(`MessageRouter: Running auto-fix for: ${check}`);

            const result = await this.systemValidator.autoFix(check);

            await webview.postMessage({
                command: 'autoFixResult',
                data: result
            });

            console.log(`MessageRouter: Auto-fix result: ${result.success ? 'success' : 'failed'}`);

        } catch (error) {
            console.error('MessageRouter: Error running auto-fix:', error);
            await webview.postMessage({
                command: 'autoFixResult',
                data: {
                    success: false,
                    message: `Auto-fix failed: ${error instanceof Error ? error.message : String(error)}`
                }
            });
        }
    }

    /**
     * Handles the 'openTroubleshootingGuide' message
     * Opens a specific troubleshooting guide in a new webview
     */
    private async handleOpenTroubleshootingGuide(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { guideId } = message;
            console.log(`MessageRouter: Opening troubleshooting guide: ${guideId}`);

            const guide = this.troubleshootingSystem.getGuide(guideId);

            if (guide) {
                // For now, we'll send the guide data back to the webview
                // In a full implementation, you might open a new webview panel
                await webview.postMessage({
                    command: 'troubleshootingGuideOpened',
                    data: guide
                });
            } else {
                await webview.postMessage({
                    command: 'error',
                    data: { message: `Troubleshooting guide not found: ${guideId}` }
                });
            }

        } catch (error) {
            console.error('MessageRouter: Error opening troubleshooting guide:', error);
            await webview.postMessage({
                command: 'error',
                data: { message: `Failed to open troubleshooting guide: ${error}` }
            });
        }
    }

    /**
     * Handles the 'exportConfiguration' message
     * Exports current configuration to a file
     */
    private async handleExportConfiguration(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { options } = message;
            console.log('MessageRouter: Exporting configuration');

            // Get current configuration (this would be implemented based on your current config storage)
            const currentConfig = this.configurationManager.createDefaultConfiguration();

            const result = await this.configurationManager.exportConfiguration(currentConfig, undefined, options);

            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: result.success,
                    message: result.success ? `Configuration exported to ${result.filePath}` : result.error,
                    type: 'export'
                }
            });

        } catch (error) {
            console.error('MessageRouter: Error exporting configuration:', error);
            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: false,
                    message: `Export failed: ${error instanceof Error ? error.message : String(error)}`,
                    type: 'export'
                }
            });
        }
    }

    /**
     * Handles the 'importConfiguration' message
     * Imports configuration from provided data
     */
    private async handleImportConfiguration(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { configData, options } = message;
            console.log('MessageRouter: Importing configuration');

            // Validate the imported configuration
            const validation = this.configurationManager.validateConfiguration(configData);

            if (!validation.isValid) {
                await webview.postMessage({
                    command: 'configurationOperationResult',
                    data: {
                        success: false,
                        message: `Invalid configuration: ${validation.errors.map(e => e.message).join(', ')}`,
                        type: 'import'
                    }
                });
                return;
            }

            // Here you would apply the configuration to your system
            // For now, we'll just report success
            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: true,
                    message: 'Configuration imported successfully',
                    type: 'import'
                }
            });

        } catch (error) {
            console.error('MessageRouter: Error importing configuration:', error);
            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: false,
                    message: `Import failed: ${error instanceof Error ? error.message : String(error)}`,
                    type: 'import'
                }
            });
        }
    }

    /**
     * Handles the 'getConfigurationTemplates' message
     * Gets available configuration templates
     */
    private async handleGetConfigurationTemplates(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Getting configuration templates');

            const templates = await this.configurationManager.listTemplates();
            const presets = this.configurationManager.getConfigurationPresets();

            // Combine templates and presets
            const allTemplates = [...templates, ...presets];

            await webview.postMessage({
                command: 'configurationTemplates',
                data: allTemplates
            });

        } catch (error) {
            console.error('MessageRouter: Error getting configuration templates:', error);
            await webview.postMessage({
                command: 'configurationTemplates',
                data: []
            });
        }
    }

    /**
     * Handles the 'getConfigurationBackups' message
     * Gets available configuration backups
     */
    private async handleGetConfigurationBackups(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Getting configuration backups');

            const backups = await this.configurationManager.listBackups();

            await webview.postMessage({
                command: 'configurationBackups',
                data: backups
            });

        } catch (error) {
            console.error('MessageRouter: Error getting configuration backups:', error);
            await webview.postMessage({
                command: 'configurationBackups',
                data: []
            });
        }
    }

    /**
     * Handles the 'validateConfiguration' message
     * Validates current configuration
     */
    private async handleValidateConfiguration(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Validating configuration');

            // Get current configuration (this would be implemented based on your current config storage)
            const currentConfig = this.configurationManager.createDefaultConfiguration();

            const validation = this.configurationManager.validateConfiguration(currentConfig);

            await webview.postMessage({
                command: 'validationResult',
                data: validation
            });

        } catch (error) {
            console.error('MessageRouter: Error validating configuration:', error);
            await webview.postMessage({
                command: 'validationResult',
                data: {
                    isValid: false,
                    errors: [{
                        path: 'system',
                        message: 'Failed to validate configuration',
                        severity: 'error'
                    }],
                    warnings: []
                }
            });
        }
    }

    /**
     * Handles the 'applyConfigurationTemplate' message
     * Applies a configuration template
     */
    private async handleApplyConfigurationTemplate(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { templateId } = message;
            console.log(`MessageRouter: Applying configuration template: ${templateId}`);

            const result = await this.configurationManager.applyPreset(templateId);

            if (!result.success) {
                // Try loading as custom template
                const templateResult = await this.configurationManager.loadTemplate(templateId);
                if (templateResult.success && templateResult.template) {
                    await webview.postMessage({
                        command: 'configurationOperationResult',
                        data: {
                            success: true,
                            message: `Template "${templateResult.template.name}" applied successfully`,
                            type: 'template'
                        }
                    });
                    return;
                }
            }

            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: result.success,
                    message: result.success ? 'Template applied successfully' : result.error,
                    type: 'template'
                }
            });

        } catch (error) {
            console.error('MessageRouter: Error applying configuration template:', error);
            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: false,
                    message: `Failed to apply template: ${error instanceof Error ? error.message : String(error)}`,
                    type: 'template'
                }
            });
        }
    }

    /**
     * Handles the 'createConfigurationBackup' message
     * Creates a new configuration backup
     */
    private async handleCreateConfigurationBackup(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { reason, description } = message;
            console.log('MessageRouter: Creating configuration backup');

            // Get current configuration (this would be implemented based on your current config storage)
            const currentConfig = this.configurationManager.createDefaultConfiguration();

            const result = await this.configurationManager.createBackup(currentConfig, reason, description);

            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: result.success,
                    message: result.success ? 'Backup created successfully' : result.error,
                    type: 'backup'
                }
            });

        } catch (error) {
            console.error('MessageRouter: Error creating configuration backup:', error);
            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: false,
                    message: `Failed to create backup: ${error instanceof Error ? error.message : String(error)}`,
                    type: 'backup'
                }
            });
        }
    }

    /**
     * Handles the 'restoreConfigurationBackup' message
     * Restores configuration from a backup
     */
    private async handleRestoreConfigurationBackup(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { backupId } = message;
            console.log(`MessageRouter: Restoring configuration backup: ${backupId}`);

            const result = await this.configurationManager.restoreBackup(backupId);

            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: result.success,
                    message: result.success ? 'Configuration restored successfully' : result.error,
                    type: 'restore'
                }
            });

        } catch (error) {
            console.error('MessageRouter: Error restoring configuration backup:', error);
            await webview.postMessage({
                command: 'configurationOperationResult',
                data: {
                    success: false,
                    message: `Failed to restore backup: ${error instanceof Error ? error.message : String(error)}`,
                    type: 'restore'
                }
            });
        }
    }

    /**
     * Updates the services used by the message router
     * This allows for dynamic service updates if needed
     * @param contextService - New ContextService instance
     * @param indexingService - New IndexingService instance
     */
    public updateServices(contextService: ContextService, indexingService: IndexingService): void {
        this.contextService = contextService;
        this.indexingService = indexingService;
        console.log('MessageRouter: Services updated');
    }

    /**
     * Handles the 'MapToSettings' message
     * Opens the native VS Code settings UI filtered for this extension
     */
    private async handleMapToSettings(webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Opening native settings from diagnostics panel...');

            // Open the native VS Code settings UI, filtered for this extension
            await vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');

            console.log('MessageRouter: Native settings opened successfully from diagnostics panel');
        } catch (error) {
            console.error('MessageRouter: Failed to open settings from diagnostics panel:', error);
            await this.sendErrorResponse(webview, 'Failed to open settings');
        }
    }
}
</file>

<file path="webview/src/lib/vscodeApi.ts">
/**
 * VS Code API Wrapper
 * 
 * This module provides a clean, typed interface for communicating with the VS Code extension.
 * It wraps the acquireVsCodeApi() call and provides helper functions for message passing.
 */

// Types for VS Code API communication
export interface VSCodeMessage {
    command: string;
    requestId?: string;
    [key: string]: any;
}

export interface VSCodeResponse {
    command: string;
    requestId?: string;
    success?: boolean;
    data?: any;
    error?: string;
    [key: string]: any;
}

// Message handler type
export type MessageHandler = (message: VSCodeResponse) => void;

// VS Code API instance
let vscodeApi: any = null;

// Message handlers registry
const messageHandlers = new Map<string, MessageHandler[]>();

// Request-response tracking
const pendingRequests = new Map<string, {
    resolve: (value: any) => void;
    reject: (error: any) => void;
    timeout: NodeJS.Timeout;
}>();

/**
 * Initialize the VS Code API
 * This should be called once when the webview loads
 */
export function initializeVSCodeApi(): void {
    if (typeof window !== 'undefined' && (window as any).acquireVsCodeApi) {
        vscodeApi = (window as any).acquireVsCodeApi();
        
        // Set up the global message listener
        window.addEventListener('message', handleIncomingMessage);
        
        console.log('VS Code API initialized');
    } else {
        console.warn('VS Code API not available - running outside of VS Code webview');
    }
}

/**
 * Handle incoming messages from the extension
 */
function handleIncomingMessage(event: MessageEvent): void {
    const message: VSCodeResponse = event.data;
    
    // Handle request-response pattern
    if (message.requestId && pendingRequests.has(message.requestId)) {
        const request = pendingRequests.get(message.requestId)!;
        clearTimeout(request.timeout);
        pendingRequests.delete(message.requestId);
        
        if (message.error) {
            request.reject(new Error(message.error));
        } else {
            request.resolve(message.data || message);
        }
        return;
    }
    
    // Handle command-based messages
    if (message.command && messageHandlers.has(message.command)) {
        const handlers = messageHandlers.get(message.command)!;
        handlers.forEach(handler => {
            try {
                handler(message);
            } catch (error) {
                console.error(`Error in message handler for command '${message.command}':`, error);
            }
        });
    }
}

/**
 * Send a message to the VS Code extension
 * @param command - The command to send
 * @param data - Additional data to send with the command
 */
export function postMessage(command: string, data: any = {}): void {
    if (!vscodeApi) {
        console.warn('VS Code API not initialized. Call initializeVSCodeApi() first.');
        return;
    }
    
    const message: VSCodeMessage = {
        command,
        ...data
    };
    
    vscodeApi.postMessage(message);
}

/**
 * Send a message and wait for a response
 * @param command - The command to send
 * @param data - Additional data to send with the command
 * @param timeout - Timeout in milliseconds (default: 10000)
 * @returns Promise that resolves with the response
 */
export function sendRequest(command: string, data: any = {}, timeout: number = 10000): Promise<any> {
    return new Promise((resolve, reject) => {
        if (!vscodeApi) {
            reject(new Error('VS Code API not initialized'));
            return;
        }
        
        const requestId = generateRequestId();
        
        // Set up timeout
        const timeoutHandle = setTimeout(() => {
            pendingRequests.delete(requestId);
            reject(new Error(`Request timeout for command: ${command}`));
        }, timeout);
        
        // Store the request
        pendingRequests.set(requestId, {
            resolve,
            reject,
            timeout: timeoutHandle
        });
        
        // Send the message
        const message: VSCodeMessage = {
            command,
            requestId,
            ...data
        };
        
        vscodeApi.postMessage(message);
    });
}

/**
 * Register a message handler for a specific command
 * @param command - The command to listen for
 * @param handler - The handler function
 * @returns Unsubscribe function
 */
export function onMessage(command: string, handler: MessageHandler): () => void {
    if (!messageHandlers.has(command)) {
        messageHandlers.set(command, []);
    }
    
    const handlers = messageHandlers.get(command)!;
    handlers.push(handler);
    
    // Return unsubscribe function
    return () => {
        const index = handlers.indexOf(handler);
        if (index > -1) {
            handlers.splice(index, 1);
        }
        
        // Clean up empty handler arrays
        if (handlers.length === 0) {
            messageHandlers.delete(command);
        }
    };
}

/**
 * Remove all message handlers for a command
 * @param command - The command to clear handlers for
 */
export function clearMessageHandlers(command?: string): void {
    if (command) {
        messageHandlers.delete(command);
    } else {
        messageHandlers.clear();
    }
}

/**
 * Generate a unique request ID
 */
function generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Get the current state of the VS Code API
 */
export function getState(): any {
    if (!vscodeApi) {
        return null;
    }
    return vscodeApi.getState();
}

/**
 * Set the state in VS Code
 * @param state - The state to save
 */
export function setState(state: any): void {
    if (!vscodeApi) {
        console.warn('VS Code API not initialized');
        return;
    }
    vscodeApi.setState(state);
}

/**
 * Check if the VS Code API is available and initialized
 */
export function isInitialized(): boolean {
    return vscodeApi !== null;
}

// Auto-initialize when the module is loaded
if (typeof window !== 'undefined') {
    // Initialize on next tick to ensure DOM is ready
    setTimeout(initializeVSCodeApi, 0);
}
</file>

<file path="src/extension.ts">
/**
 * Code Context Engine Extension
 * 
 * This is the main entry point for the VS Code extension that provides AI-powered
 * code context and search capabilities for your workspace.
 */

import * as vscode from 'vscode';
import { ExtensionManager } from './extensionManager';

/**
 * Singleton class to manage extension state and resources
 * This ensures proper cleanup and prevents memory leaks
 */
class ExtensionStateManager {
    private static instance: ExtensionStateManager;
    private extensionManager: ExtensionManager | null = null;

    private constructor() {}

    static getInstance(): ExtensionStateManager {
        if (!ExtensionStateManager.instance) {
            ExtensionStateManager.instance = new ExtensionStateManager();
        }
        return ExtensionStateManager.instance;
    }

    setExtensionManager(manager: ExtensionManager): void {
        this.extensionManager = manager;
    }

    getExtensionManager(): ExtensionManager | null {
        return this.extensionManager;
    }

    dispose(): void {
        if (this.extensionManager) {
            this.extensionManager.dispose();
            this.extensionManager = null;
        }
    }
}

// Global extension state manager instance
const extensionState = ExtensionStateManager.getInstance();

/**
 * Extension activation point
 * 
 * This function is called when the extension is activated.
 * It initializes the ExtensionManager which handles all services and commands.
 */
export async function activate(context: vscode.ExtensionContext) {
    console.log('Congratulations, your extension "code-context-engine" is now active!');

    try {
        // Initialize ExtensionManager and all services
        const manager = new ExtensionManager(context);
        await manager.initialize();
        extensionState.setExtensionManager(manager);
        console.log('ExtensionManager initialized successfully');
        
        // All commands are now registered through the ExtensionManager's CommandManager
        // All webview management is handled through the WebviewManager
        // All message routing is handled through the MessageRouter
        
    } catch (error) {
        console.error('Failed to initialize ExtensionManager:', error);
        vscode.window.showErrorMessage('Code Context Engine failed to initialize. Please check the logs.');
        throw error;
    }
}

/**
 * Extension deactivation point
 *
 * This function is called when the extension is deactivated.
 * Properly disposes of the ExtensionManager and all its resources.
 */
export function deactivate() {
    // Use the state manager to clean up all resources
    extensionState.dispose();
}
</file>

<file path="package.json">
{
  "name": "code-context-engine",
  "displayName": "Code Context Engine",
  "description": "AI-powered code context and search extension for VS Code",
  "version": "0.0.1",
  "publisher": "bramburn",
  "engines": {
    "vscode": "^1.74.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/bramburn/bigcontext.git"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onCommand:code-context-engine.openMainPanel"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "code-context-engine.openMainPanel",
        "title": "Open Main Panel",
        "category": "Code Context"
      },
      {
        "command": "code-context-engine.startIndexing",
        "title": "Start Indexing",
        "category": "Code Context"
      },
      {
        "command": "code-context-engine.setupProject",
        "title": "Setup Project",
        "category": "Code Context"
      },
      {
        "command": "code-context-engine.openSettings",
        "title": "Open Settings",
        "category": "Code Context"
      },
      {
        "command": "code-context-engine.openDiagnostics",
        "title": "Open Diagnostics",
        "category": "Code Context"
      }
    ],
    "configuration": {
      "title": "Code Context Engine",
      "properties": {
        "code-context-engine.embeddingProvider": {
          "type": "string",
          "default": "ollama",
          "enum": [
            "ollama",
            "openai"
          ],
          "description": "Embedding provider to use for vectorization",
          "enumDescriptions": [
            "Local Ollama embedding service (free, private)",
            "OpenAI embedding service (requires API key)"
          ]
        },
        "code-context-engine.databaseConnectionString": {
          "type": "string",
          "default": "http://localhost:6333",
          "description": "Qdrant vector database connection string",
          "pattern": "^https?://.*:\\d+$",
          "patternErrorMessage": "Must be a valid HTTP/HTTPS URL with port (e.g., http://localhost:6333)"
        },
        "code-context-engine.openaiApiKey": {
          "type": "string",
          "default": "",
          "description": "OpenAI API key for embedding generation (stored securely in VS Code settings)"
        },
        "code-context-engine.ollamaModel": {
          "type": "string",
          "default": "nomic-embed-text",
          "description": "Ollama model to use for embeddings",
          "enum": [
            "nomic-embed-text",
            "all-minilm",
            "mxbai-embed-large"
          ],
          "enumDescriptions": [
            "Nomic Embed Text (768 dimensions, recommended)",
            "All-MiniLM (384 dimensions, faster)",
            "MxBai Embed Large (1024 dimensions, more accurate)"
          ]
        },
        "code-context-engine.openaiModel": {
          "type": "string",
          "default": "text-embedding-ada-002",
          "description": "OpenAI model to use for embeddings",
          "enum": [
            "text-embedding-ada-002",
            "text-embedding-3-small",
            "text-embedding-3-large"
          ],
          "enumDescriptions": [
            "Ada-002 (1536 dimensions, cost-effective)",
            "Embedding-3-Small (1536 dimensions, improved performance)",
            "Embedding-3-Large (3072 dimensions, highest quality)"
          ]
        },
        "code-context-engine.maxSearchResults": {
          "type": "number",
          "default": 20,
          "minimum": 1,
          "maximum": 100,
          "description": "Maximum number of search results to return"
        },
        "code-context-engine.minSimilarityThreshold": {
          "type": "number",
          "default": 0.5,
          "minimum": 0,
          "maximum": 1,
          "description": "Minimum similarity threshold for search results (0.0 to 1.0)"
        },
        "code-context-engine.autoIndexOnStartup": {
          "type": "boolean",
          "default": false,
          "description": "Automatically start indexing when workspace is opened"
        },
        "code-context-engine.indexingBatchSize": {
          "type": "number",
          "default": 100,
          "minimum": 10,
          "maximum": 1000,
          "description": "Number of code chunks to process in each batch during indexing"
        },
        "code-context-engine.enableDebugLogging": {
          "type": "boolean",
          "default": false,
          "description": "Enable detailed debug logging for troubleshooting"
        },
        "code-context-engine.excludePatterns": {
          "type": "array",
          "default": [
            "**/node_modules/**",
            "**/dist/**",
            "**/build/**",
            "**/.git/**",
            "**/coverage/**"
          ],
          "items": {
            "type": "string"
          },
          "description": "File patterns to exclude from indexing (in addition to .gitignore)"
        },
        "code-context-engine.supportedLanguages": {
          "type": "array",
          "default": [
            "typescript",
            "javascript",
            "python",
            "csharp"
          ],
          "items": {
            "type": "string",
            "enum": [
              "typescript",
              "javascript",
              "python",
              "csharp"
            ]
          },
          "description": "Programming languages to include in indexing"
        }
      }
    },
    "keybindings": [
      {
        "command": "code-context-engine.openMainPanel",
        "key": "ctrl+alt+c",
        "mac": "cmd+alt+c",
        "when": "editorTextFocus"
      },
      {
        "command": "code-context-engine.startIndexing",
        "key": "ctrl+alt+i",
        "mac": "cmd+alt+i",
        "when": "editorTextFocus"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile && npm run build-webview",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "pretest": "npm run compile && npm run lint",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js",
    "build-webview": "cd webview && npm run build",
    "package": "vsce package --no-dependencies",
    "publish": "vsce publish --no-dependencies",
    "clean": "rimraf out *.vsix",
    "dev": "npm run watch"
  },
  "devDependencies": {
    "@types/mocha": "^10.0.10",
    "@types/node": "16.x",
    "@types/vscode": "^1.74.0",
    "@typescript-eslint/eslint-plugin": "^5.45.0",
    "@typescript-eslint/parser": "^5.45.0",
    "@vscode/test-electron": "^2.5.2",
    "eslint": "^8.28.0",
    "mocha": "^11.7.1",
    "rimraf": "^5.0.10",
    "typescript": "^4.9.4",
    "vsce": "^2.15.0"
  },
  "dependencies": {
    "@qdrant/js-client-rest": "^1.7.0",
    "axios": "^1.6.0",
    "glob": "^8.0.3",
    "ignore": "^5.2.4",
    "tree-sitter": "^0.20.4",
    "tree-sitter-c-sharp": "^0.20.0",
    "tree-sitter-python": "^0.20.4",
    "tree-sitter-typescript": "^0.20.3",
    "vscode-languageclient": "^9.0.1",
    "vscode-languageserver": "^9.0.1"
  }
}
</file>

</files>
