This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  todo/
    extension/
      backlog_sub_sprint_1_dependency_injection_centralized_config.md
      backlog_sub_sprint_2_extension_command_managers.md
      backlog_sub_sprint_3_centralized_webview_management.md
      backlog_sub_sprint_4_message_routing_state.md
      implementation_sub_sprint_1_dependency_injection_centralized_config.md
      implementation_sub_sprint_2_extension_command_managers.md
      implementation_sub_sprint_3_centralized_webview_management.md
      implementation_sub_sprint_4_message_routing_state.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
      tasklist_sprint_03.md
      tasklist_sprint_04.md
    extension2/
      backlog_sprint_1_webview_panel_lifecycle.md
      backlog_sprint_2_message_routing_api.md
      implementation_sprint_1_webview_panel_lifecycle.md
      prd.md
    fe/
      backlog_sprint_1_setup_view_implementation.md
      backlog_sprint_1_web_api_boilerplate.md
      backlog_sprint_2_extensible_client_framework.md
      backlog_sprint_3_backend_process_management.md
      backlog_sprint_4_onboarding_setup_ui.md
      backlog_sprint_5_concrete_client_implementation.md
      backlog_sprint_6_end_to_end_indexing_query_ui.md
      backlog_sub_sprint_1_database_configuration_component.md
      backlog_sub_sprint_2_embedding_provider_workflow_logic.md
      implementation_sprint_1_setup_view_implementation.md
      implementation_sprint_1_web_api_boilerplate.md
      implementation_sprint_2_extensible_client_framework.md
      implementation_sprint_3_backend_process_management.md
      implementation_sprint_4_onboarding_setup_ui.md
      implementation_sprint_5_concrete_client_implementation.md
      implementation_sub_sprint_1_database_configuration_component.md
      implementation_sub_sprint_2_embedding_provider_workflow_logic.md
      prd.md
    setup/
      backlog_sprint_6_lsp_integration_devops.md
      backlog_sprint_7_documentation_publishing.md
      backlog_sub_sprint_1_vs_code_extension_boilerplate_setup.md
      backlog_sub_sprint_2_sveltekit_fluent_ui_integration.md
      backlog_sub_sprint_5_implement_context_query_api.md
      backlog_sub_sprint_6_develop_settings_ui.md
      implementation_sprint_6_lsp_integration_devops.md
      implementation_sprint_7_documentation_publishing.md
      implementation_sub_sprint_1_vs_code_extension_boilerplate_setup.md
      implementation_sub_sprint_2_sveltekit_fluent_ui_integration.md
      implementation_sub_sprint_5_implement_context_query_api.md
      implementation_sub_sprint_6_develop_settings_ui.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
      tasklist_sprint_03.md
      tasklist_sprint_04.md
      tasklist_sprint_05.md
      tasklist_sprint_06.md
      tasklist_sprint_07.md
    svelte-continue/
      backlog_sub_sprint_1_sveltekit_project_scaffolding.md
      backlog_sub_sprint_2_recreate_ui_as_svelte_components.md
      backlog_sub_sprint_3_centralized_webview_management.md
      backlog_sub_sprint_4_message_routing_state.md
      implementation_sub_sprint_1_sveltekit_project_scaffolding.md
      implementation_sub_sprint_2_recreate_ui_as_svelte_components.md
      implementation_sub_sprint_3_centralized_webview_management.md
      implementation_sub_sprint_4_message_routing_state.md
      prd.md
      tasklist_sprint_01.md
      tasklist_sprint_02.md
      tasklist_sprint_03.md
      tasklist_sprint_04.md
    ux/
      prd.md
      tasklist_sprint_01.md
  sprint3-usage.md
  sprint4-usage.md
src/
  context/
    contextService.ts
  db/
    qdrantService.ts
  embeddings/
    embeddingProvider.ts
    ollamaProvider.ts
    openaiProvider.ts
  indexing/
    fileWalker.ts
    indexingService.ts
  lsp/
    lspService.ts
  parsing/
    astParser.ts
    chunker.ts
  test/
    suite/
      configService.test.ts
      dependencyInjection.test.ts
      index.ts
    mocks.ts
    runTest.ts
  types/
    tree-sitter-languages.d.ts
  commandManager.ts
  configService.ts
  configurationManager.ts
  extension.ts
  extensionManager.ts
  messageRouter.ts
  performanceManager.ts
  searchManager.ts
  webviewManager.ts
webview/
  src/
    lib/
      vscodeApi.ts
    index.html
    index.js
    index.js.map
    index.ts
    styles.css
  package.json
  tsconfig.json
  webpack.config.js
.eslintrc.json
.gitignore
.repomixignore
.vscodeignore
docker-compose.yml
package.json
README.md
repomix.config.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/todo/svelte-continue/backlog_sub_sprint_1_sveltekit_project_scaffolding.md">
# Backlog: Sub-Sprint 1 - SvelteKit Project Scaffolding

**Objective:** To replace the existing `webview/` content with a new, properly configured SvelteKit project and add the Fluent UI component library.

**Parent Sprint:** PRD 1, Sprint 1: SvelteKit Scaffolding & UI Components

---

### User Story 1: Setup SvelteKit Foundation
**As a** Frontend Developer (Frank), **I want to** initialize a new SvelteKit project in the `webview/` directory, **so that** I have a modern, standardized, and scalable foundation for building the extension's user interface.

**Actions to Undertake:**
1.  **Filepath**: `webview/`
    -   **Action**: **Clear Existing Content**: Remove all files and folders from the `webview/` directory to ensure a clean slate.
    -   **Implementation**: `rm -rf webview/*` or manual deletion.
    -   **Imports**: N/A.
2.  **Filepath**: `(root)`
    -   **Action**: **Scaffold SvelteKit Project**: Run the SvelteKit creation command to generate a new "Skeleton project" with TypeScript support inside the `webview/` directory.
    -   **Implementation**: `npm create svelte@latest webview` (Select "Skeleton project", "TypeScript").
    -   **Imports**: N/A.
3.  **Filepath**: `webview/package.json`
    -   **Action**: **Install Static Adapter**: Add the `@sveltejs/adapter-static` package as a development dependency to enable static site generation.
    -   **Implementation**: `npm install -D @sveltejs/adapter-static` (run inside `webview/` directory).
    -   **Imports**: N/A.
4.  **Filepath**: `webview/package.json`
    -   **Action**: **Install Fluent UI**: Add the `@fluentui/web-components` package as a dependency to make the Fluent UI component library available to the project.
    -   **Implementation**: `npm install @fluentui/web-components` (run inside `webview/` directory).
    -   **Imports**: N/A.

**Acceptance Criteria:**
-   The `webview/` directory is completely replaced by a new SvelteKit project structure.
-   `@sveltejs/adapter-static` is listed as a `devDependency` in `webview/package.json`.
-   `@fluentui/web-components` is listed as a `dependency` in `webview/package.json`.

**Testing Plan:**
-   **Test Case 1**: Navigate into the `webview/` directory and run `npm install`. The command should complete without errors.
-   **Test Case 2**: Verify that the `node_modules` directory is created inside `webview/` and contains the new dependencies.

---

### User Story 2: Configure Static Build
**As a** Backend Developer (Alisha), **I want** the SvelteKit project to be configured to output a static `index.html` file, **so that** the VS Code extension can load it directly into a webview without needing a running dev server.

**Actions to Undertake:**
1.  **Filepath**: `webview/svelte.config.js`
    -   **Action**: **Configure Static Adapter**: Modify the SvelteKit configuration to import and use `adapter-static`. The configuration should specify `build` as the output directory and set a fallback page to handle client-side routing within the webview.
    -   **Implementation**:
        ```javascript
        import adapter from '@sveltejs/adapter-static';

        /** @type {import('@sveltejs/kit').Config} */
        const config = {
          kit: {
            adapter: adapter({
              pages: 'build',
              assets: 'build',
              fallback: 'index.html', // Use index.html as the fallback for SPA-like behavior
              precompress: false,
              strict: true
            })
          }
        };

        export default config;
        ```
    -   **Imports**: `import adapter from '@sveltejs/adapter-static';`

**Acceptance Criteria:**
-   The `webview/svelte.config.js` file correctly imports and configures `@sveltejs/adapter-static`.
-   Running `npm run build` inside the `webview/` directory successfully generates a `build/` folder.
-   The `webview/build/` folder contains an `index.html` file.

**Testing Plan:**
-   **Test Case 1**: Navigate into the `webview/` directory and run `npm run build`. The command must complete successfully.
-   **Test Case 2**: Verify that the `webview/build/index.html` file has been created.
-   **Test Case 3**: Open the generated `webview/build/index.html` in a web browser. It should render the basic SvelteKit welcome page.
</file>

<file path="docs/todo/svelte-continue/backlog_sub_sprint_2_recreate_ui_as_svelte_components.md">
# Backlog: Sub-Sprint 2 - Recreate UI as Svelte Components

**Objective:** To build the three primary UI views as distinct Svelte components, replicating the functionality and layout from the original inline HTML.

**Parent Sprint:** PRD 1, Sprint 1: SvelteKit Scaffolding & UI Components

---

### User Story 1: Create Core View Components
**As a** Frontend Developer (Frank), **I want to** create separate Svelte components for each of the main UI views (Setup, Indexing, Query), **so that** the UI is modular, maintainable, and easy to manage.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/SetupView.svelte` (New File)
    -   **Action**: **Create SetupView Component**: Create a new Svelte component and transfer the relevant HTML structure from the `getSetupWebviewContent` function in `src/extension.ts`. Replace standard HTML elements with corresponding Fluent UI components (e.g., `<fluent-select>`, `<fluent-text-field>`, `<fluent-button>`).
    -   **Implementation**: See implementation guide for code structure.
    -   **Imports**: `import "@fluentui/web-components";`
2.  **Filepath**: `webview/src/lib/components/IndexingView.svelte` (New File)
    -   **Action**: **Create IndexingView Component**: Create a new Svelte component for the indexing progress view. This includes the progress bar/ring and status text area from the `getWebviewContent` function.
    -   **Implementation**: See implementation guide for code structure.
    -   **Imports**: `import "@fluentui/web-components";`
3.  **Filepath**: `webview/src/lib/components/QueryView.svelte` (New File)
    -   **Action**: **Create QueryView Component**: Create a new Svelte component for the search/query interface. This includes the search input field, search button, and results area from the `getWebviewContent` function.
    -   **Implementation**: See implementation guide for code structure.
    -   **Imports**: `import "@fluentui/web-components";`

**Acceptance Criteria:**
-   Three new files exist: `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte`.
-   Each file contains the basic UI structure corresponding to its purpose, derived from `extension.ts`.
-   The components use Fluent UI web components for their interactive elements.

**Testing Plan:**
-   **Test Case 1**: Manually inspect each component file to ensure it contains the correct HTML structure and Fluent UI tags.
-   **Test Case 2**: Ensure the project still builds successfully with `npm run build` after creating these components.

---

### User Story 2: Implement View Management
**As a** Frontend Developer (Frank), **I want** a centralized state management system to control which view is currently visible, **so that** the application can easily switch between the Setup, Indexing, and Query states.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/stores/viewStore.ts` (New File)
    -   **Action**: **Create View State Store**: Create a new file to house a Svelte writable store. This store will hold a string value representing the current view state (e.g., 'setup', 'indexing', 'query').
    -   **Implementation**: `import { writable } from 'svelte/store'; export const currentView = writable('setup');`
    -   **Imports**: `import { writable } from 'svelte/store';`
2.  **Filepath**: `webview/src/routes/+page.svelte`
    -   **Action**: **Create View Manager**: Modify the main page component to act as a view controller. It should import the three view components and the `viewStore`.
    -   **Implementation**: Use an `{#if ... else if ...}` block that subscribes to the `currentView` store and conditionally renders the correct view component based on the store's value.
    -   **Imports**: `import SetupView from '$lib/components/SetupView.svelte';`, `import IndexingView from '$lib/components/IndexingView.svelte';`, `import QueryView from '$lib/components/QueryView.svelte';`, `import { currentView } from '$lib/stores/viewStore';`

**Acceptance Criteria:**
-   A `viewStore.ts` file exists and exports a writable Svelte store.
-   The main `+page.svelte` correctly imports and uses the store.
-   Changing the value of the store (e.g., via browser devtools) correctly switches the rendered component in the UI.

**Testing Plan:**
-   **Test Case 1**: Run the app using `npm run dev`. Verify the default view (`SetupView`) is displayed.
-   **Test Case 2**: Use the browser's JavaScript console to import the store and set its value (e.g., `window.currentView.set('query')`). Verify the UI correctly updates to show the `QueryView` component.
</file>

<file path="docs/todo/svelte-continue/backlog_sub_sprint_3_centralized_webview_management.md">
# Backlog: Sub-Sprint 3 - Centralized Webview Management

**Objective:** To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, cleaning up the command handlers and `extension.ts`.

**Parent Sprint:** PRD 2, Sprint 3: Webview Management

---

### User Story 1: Centralize Webview Creation
**As a** Developer, **I want to** create a `WebviewManager` class that handles the creation and lifecycle of webview panels, **so that** webview logic is centralized, reusable, and decoupled from command handlers.

**Actions to Undertake:**
1.  **Filepath**: `src/webviewManager.ts` (New File)
    -   **Action**: **Create WebviewManager Class**: Define a new class named `WebviewManager`. It should have a private constructor, a static property to hold the panel instance (e.g., `public static currentPanel`), and a static `createOrShow` method.
    -   **Implementation**: See implementation guide for the full class structure.
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Implement Singleton Pattern**: The `createOrShow` method should check if `currentPanel` already exists. If it does, it should call `.reveal()` on the existing panel. If not, it should create a new `vscode.WebviewPanel` and instantiate `WebviewManager`.
    -   **Implementation**: `if (WebviewManager.currentPanel) { WebviewManager.currentPanel._panel.reveal(); return; }`
    -   **Imports**: N/A.
3.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Handle Panel Disposal**: In the private constructor, set up an `onDidDispose` listener for the webview panel. This listener must clean up resources and set the static `currentPanel` reference back to `undefined`.
    -   **Implementation**: `this._panel.onDidDispose(() => this.dispose(), null, this._disposables);`
    -   **Imports**: N/A.

**Acceptance Criteria:**
-   A new `WebviewManager.ts` file exists with a class that properly implements the singleton pattern for a `WebviewPanel`.
-   Calling the `createOrShow` method multiple times results in only one panel being created, with subsequent calls bringing the existing panel to the front.
-   Closing the webview panel correctly disposes of the panel object and allows a new one to be created on the next call.

**Testing Plan:**
-   **Test Case 1**: Trigger the command to open the webview. Verify the panel appears.
-   **Test Case 2**: Trigger the command again. Verify that a new panel does *not* appear, but the existing one remains or regains focus.
-   **Test Case 3**: Close the panel and trigger the command again. Verify a new panel appears successfully.

---

### User Story 2: Refactor Commands to Use WebviewManager
**As a** Developer, **I want to** refactor the existing command handlers to use the new `WebviewManager`, **so that** `extension.ts` and `commandManager.ts` are no longer directly responsible for creating webviews.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts` or `src/commandManager.ts`
    -   **Action**: **Update `openMainPanel` Command**: Locate the command registration for `code-context-engine.openMainPanel`. Replace the entire `vscode.window.createWebviewPanel` logic with a single call to `WebviewManager.createOrShow(context.extensionUri)`.
    -   **Implementation**: `vscode.commands.registerCommand('code-context-engine.openMainPanel', () => { WebviewManager.createOrShow(context.extensionUri); });`
    -   **Imports**: `import { WebviewManager } from './webviewManager';`
2.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Implement HTML Content Loading**: Create a private method within `WebviewManager` (e.g., `_getHtmlForWebview`) that is responsible for reading the `index.html` from the SvelteKit build output (`webview/build/index.html`).
    -   **Implementation**: Use `fs.readFileSync` to get the HTML content.
    -   **Imports**: `import * as fs from 'fs';`, `import * as path from 'path';`
3.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Implement Asset Path Rewriting**: Within the `_getHtmlForWebview` method, use `webview.asWebviewUri` to correctly transform the paths for CSS and JS files referenced in the `index.html` (e.g., paths starting with `/_app/`).
    -   **Implementation**: Use string replacement or a regular expression to find and replace asset URIs.
    -   **Imports**: N/A.

**Acceptance Criteria:**
-   The `createWebviewPanel` logic is completely removed from `extension.ts` and/or `commandManager.ts`.
-   The `openMainPanel` command successfully opens the webview using the `WebviewManager`.
-   The SvelteKit application loads correctly inside the webview, including all its CSS and JavaScript assets, proving the path rewriting is working.

**Testing Plan:**
-   **Test Case 1**: Run the extension and trigger the `openMainPanel` command. Verify the SvelteKit UI renders correctly.
-   **Test Case 2**: Check the developer tools console for the webview to ensure there are no 404 errors for CSS or JS files.
</file>

<file path="docs/todo/svelte-continue/backlog_sub_sprint_4_message_routing_state.md">
# Backlog: Sub-Sprint 4 - Message Routing & State

**Objective:** To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

**Parent Sprint:** PRD 2, Sprint 4: Communication & State Mgmt

---

### User Story 1: Centralize Global State
**As a** Developer (Alisha), **I want to** create a `StateManager` class, **so that** I have a single, reliable source of truth for the global state of the extension (e.g., whether indexing is in progress).

**Actions to Undertake:**
1.  **Filepath**: `src/stateManager.ts` (New File)
    -   **Action**: **Create StateManager Class**: Define a new `StateManager` class. It should contain private properties for state flags (e.g., `private _isIndexing = false;`).
    -   **Implementation**: See implementation guide.
    -   **Imports**: N/A.
2.  **Filepath**: `src/stateManager.ts`
    -   **Action**: **Implement Getters and Setters**: For each state property, create public getter (e.g., `public isIndexing()`) and setter (e.g., `public setIndexing(state: boolean)`) methods.
    -   **Implementation**: `public isIndexing() { return this._isIndexing; }`
    -   **Imports**: N/A.
3.  **Filepath**: `src/extensionManager.ts`
    -   **Action**: **Instantiate StateManager**: In the `ExtensionManager` constructor, create a public instance of the `StateManager` so it can be injected into other services.
    -   **Implementation**: `this.stateManager = new StateManager();`
    -   **Imports**: `import { StateManager } from './stateManager';`

**Acceptance Criteria:**
-   A new `StateManager.ts` file exists with a class that encapsulates state properties.
-   The `ExtensionManager` creates and holds a single instance of the `StateManager`.
-   Other services can access state via the manager (e.g., `this.extensionManager.stateManager.isIndexing()`).

**Testing Plan:**
-   **Test Case 1**: Verify that services requiring state can be instantiated correctly with the `StateManager` passed into their constructors.

---

### User Story 2: Decouple Message Handling
**As a** Developer, **I want to** create a `MessageRouter` class to handle all incoming messages from the webview, **so that** communication logic is cleanly separated from webview lifecycle management.

**Actions to Undertake:**
1.  **Filepath**: `src/messageRouter.ts` (New File)
    -   **Action**: **Create MessageRouter Class**: Define a new `MessageRouter` class. Its constructor should accept the `ExtensionManager` and the `vscode.Webview` instance.
    -   **Implementation**: See implementation guide.
    -   **Imports**: `import * as vscode from 'vscode';`, `import { ExtensionManager } from './extensionManager';`
2.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: **Implement Message Listener**: In the constructor, set up the `webview.onDidReceiveMessage` listener to call a private `_routeMessage` method.
    -   **Implementation**: `this._webview.onDidReceiveMessage(this._routeMessage, this, this._disposables);`
    -   **Imports**: N/A.
3.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: **Implement `_routeMessage` Method**: Move the large `switch` statement for handling messages from its current location (`extension.ts` or `webviewManager.ts`) into the `_routeMessage` method.
    -   **Implementation**: `private async _routeMessage(message: any) { switch (message.command) { ... } }`
    -   **Imports**: N/A.
4.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: **Integrate MessageRouter**: In the `WebviewManager` constructor, instead of handling messages directly, instantiate the new `MessageRouter`.
    -   **Implementation**: `new MessageRouter(this._extensionManager, this._panel.webview);`
    -   **Imports**: `import { MessageRouter } from './messageRouter';`
5.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: **Update Service to Use StateManager**: Inject the `StateManager` into the `IndexingService`. Call `this.stateManager.setIndexing(true)` at the beginning of the `startIndexing` method and `this.stateManager.setIndexing(false)` in a `finally` block to ensure it is always reset.
    -   **Implementation**: `startIndexing() { this.stateManager.setIndexing(true); try { ... } finally { this.stateManager.setIndexing(false); } }`
    -   **Imports**: `import { StateManager } from '../stateManager';`

**Acceptance Criteria:**
-   The `onDidReceiveMessage` listener in `WebviewManager` is now a single line that instantiates the `MessageRouter`.
-   The `MessageRouter` correctly routes commands from the webview to the appropriate services.
-   The `IndexingService` correctly updates the `StateManager` before and after indexing.
-   Attempting to start a new indexing job while one is already running is gracefully handled by checking the state in the `MessageRouter`, and an appropriate error is sent to the UI.

**Testing Plan:**
-   **Test Case 1**: Verify that all previous UI interactions (e.g., starting a search) still work correctly, confirming the router is delegating properly.
-   **Test Case 2**: Start an indexing process. While it is running, try to start it again. Verify that the second request is rejected and a message is sent to the webview indicating that indexing is already in progress.
</file>

<file path="docs/todo/svelte-continue/implementation_sub_sprint_1_sveltekit_project_scaffolding.md">
hat# Implementation Guidance: Sub-Sprint 1 - SvelteKit Project Scaffolding

**Objective:** To replace the existing `webview/` content with a new, properly configured SvelteKit project and add the Fluent UI component library.

---

### 1. Overview

This guide provides the technical steps to scaffold a new SvelteKit project within the `webview` directory. The goal is to create a modern frontend foundation that builds to a static site, which can be loaded directly by the VS Code extension's webview panel.

### 2. Step-by-Step Implementation

#### Step 2.1: Clear and Initialize the SvelteKit Project

First, ensure the `webview/` directory is empty. Then, use the official SvelteKit scaffolding tool to create a new project.

```bash
# Navigate to the project root
# Make sure the webview directory is empty
rm -rf webview/*

# Run the SvelteKit initializer
npm create svelte@latest webview
```

When prompted by the `create-svelte` wizard, choose the following options:
-   **Which Svelte app template?** `Skeleton project`
-   **Add type checking with TypeScript?** `Yes`
-   **Select additional options:** (You can skip ESLint, Prettier, etc. for now if desired)

#### Step 2.2: Install Dependencies

Navigate into the newly created `webview` directory and install the necessary dependencies for static site generation and the Fluent UI component library.

```bash
# Navigate into the new webview directory
cd webview

# Install the static adapter for SvelteKit
npm install -D @sveltejs/adapter-static

# Install the Fluent UI web components library
npm install @fluentui/web-components
```

#### Step 2.3: Configure the Static Adapter

Modify the `svelte.config.js` file to use the static adapter. This is critical for ensuring the SvelteKit application builds into a set of static files that the VS Code extension can serve.

**File:** `webview/svelte.config.js`
```javascript
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: vitePreprocess(),

  kit: {
    adapter: adapter({
      // The output directory for the build.
      pages: 'build',
      assets: 'build',

      // A fallback page is crucial for SPA-like behavior in a webview.
      // It ensures that all routes are directed to index.html.
      fallback: 'index.html',

      precompress: false,
      strict: true
    }),
    // This is important for VS Code webviews to correctly resolve asset paths.
    // It tells SvelteKit that all paths are relative to the root.
    paths: {
      relative: true
    }
  }
};

export default config;
```
**Note on `paths: { relative: true }`**: While the PRD doesn't explicitly mention this, using relative paths is often a good practice for webviews to avoid issues with `file://` protocols or custom URI schemes used by VS Code. However, the ultimate solution in Sprint 2 will involve the extension rewriting paths, so this can be considered a preliminary setup.

### 3. Integrating Fluent UI

With `@fluentui/web-components` installed, you can begin using its components in your Svelte files. Fluent UI Web Components are standard Custom Elements, so they can be used directly in your markup.

You may need to define the custom elements in a root layout or component. A common practice is to import the necessary component definitions in your main `+layout.svelte` or `+page.svelte`.

**Example:** `webview/src/routes/+layout.svelte`
```html
<script>
  import { provideFluentDesignSystem, fluentButton, fluentTextField } from "@fluentui/web-components";
  import { onMount } from "svelte";

  // It's good practice to only interact with the design system after the component has mounted.
  onMount(() => {
    provideFluentDesignSystem().register(fluentButton(), fluentTextField());
  });
</script>

<slot></slot>

<style>
  /* Add any global styles here */
</style>
```

### 4. External Resources

-   **SvelteKit Static Adapter:** [Official Documentation](https://kit.svelte.dev/docs/adapter-static)
-   **Fluent UI Web Components:** [Official Documentation & Storybook](https://fluentui.dev/)

After completing these steps, you can run `npm run build` inside the `webview` directory to generate the static output in the `webview/build` folder, verifying the setup is correct.
</file>

<file path="docs/todo/svelte-continue/implementation_sub_sprint_2_recreate_ui_as_svelte_components.md">
# Implementation Guidance: Sub-Sprint 2 - Recreate UI as Svelte Components

**Objective:** To build the three primary UI views as distinct Svelte components, replicating the functionality and layout from the original inline HTML.

---

### 1. Overview

This guide details how to translate the raw HTML found in `src/extension.ts` into modular and reusable Svelte components. This is a foundational step in decoupling the frontend from the backend. We will create three core components and a simple state management system to control which component is visible.

### 2. Step-by-Step Implementation

#### Step 2.1: Create the View State Store

First, create a centralized store to manage the application's current state. This allows components to be decoupled while sharing the global state of which view should be active.

**File:** `webview/src/lib/stores/viewStore.ts` (New File)
```typescript
import { writable } from 'svelte/store';

// This type definition ensures we only use valid view names
export type View = 'setup' | 'indexing' | 'query';

// The store holds the current active view. 'setup' is the default.
export const currentView = writable<View>('setup');
```

#### Step 2.2: Create the Svelte View Components

Next, create the three Svelte components. For each component, you will copy the relevant HTML structure from `src/extension.ts` and convert it to Svelte syntax, using Fluent UI components.

**1. Setup View**

This component replicates the UI from the `getSetupWebviewContent` function.

**File:** `webview/src/lib/components/SetupView.svelte` (New File)
```html
<script lang="ts">
  // Import specific Fluent UI components you will use
  import { fluentSelect, fluentTextField, fluentButton } from "@fluentui/web-components";
  import { onMount } from "svelte";

  onMount(() => {
    // Register components with the Fluent Design System
    fluentSelect();
    fluentTextField();
    fluentButton();
  });

  // In future sprints, you will add logic here to handle button clicks
  // and post messages to the VS Code extension.
</script>

<div class="setup-step">
    <h3>Step 1: Vector Database Configuration</h3>
    <fluent-select id="databaseType">
        <fluent-option value="qdrant">Qdrant (Recommended)</fluent-option>
    </fluent-select>
    <fluent-text-field id="databaseConnectionString" value="http://localhost:6333" placeholder="http://localhost:6333">Connection String</fluent-text-field>
    <fluent-button appearance="secondary">Start Local Qdrant</fluent-button>
</div>

<div class="setup-step">
    <h3>Step 2: Embedding Provider Configuration</h3>
    <fluent-select id="embeddingProvider">
        <fluent-option value="ollama">Ollama (Local)</fluent-option>
        <fluent-option value="openai">OpenAI (Cloud)</fluent-option>
    </fluent-select>
</div>

<div class="final-step">
    <h3>Ready to Index?</h3>
    <fluent-button appearance="accent">Save & Start Indexing</fluent-button>
</div>

<style>
  .setup-step, .final-step {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 8px;
  }
  h3 {
    margin-top: 0;
  }
</style>
```

**2. Indexing View**

This component shows the progress of an indexing operation, taken from the `getWebviewContent` function.

**File:** `webview/src/lib/components/IndexingView.svelte` (New File)
```html
<script lang="ts">
  import { fluentProgress, fluentProgressBar } from "@fluentui/web-components";
  import { onMount } from "svelte";

  onMount(() => {
    fluentProgress();
    fluentProgressBar();
  });

  // This will be driven by messages from the extension in a future sprint
  export let progress = 50; // Example progress value
  export let statusText = "Indexing file_name.ts...";
</script>

<div class="section">
    <h2>Repository Indexing</h2>
    <p>Please wait while your repository is being indexed.</p>
    
    <fluent-progress-bar value={progress}></fluent-progress-bar>
    <p>{statusText}</p>
</div>

<style>
  .section {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
  }
</style>
```

**3. Query View**

This component provides the main search interface, also from `getWebviewContent`.

**File:** `webview/src/lib/components/QueryView.svelte` (New File)
```html
<script lang="ts">
  import { fluentTextField, fluentButton } from "@fluentui/web-components";
  import { onMount } from "svelte";

  onMount(() => {
    fluentTextField();
    fluentButton();
  });
</script>

<div class="section">
    <h2>Search & Context</h2>
    <p>Search through your indexed code and get AI-powered context.</p>
    <fluent-text-field placeholder="Search your code..." style="width: 100%; margin-bottom: 10px;"></fluent-text-field>
    <fluent-button appearance="accent">Search</fluent-button>

    <div id="search-results" style="margin-top: 20px;">
        <!-- Search results will be rendered here based on extension messages -->
    </div>
</div>

<style>
  .section {
    padding: 20px;
    border: 1px solid var(--vscode-panel-border);
    border-radius: 4px;
  }
</style>
```

#### Step 2.3: Create the View Manager

Finally, update the main `+page.svelte` to act as a controller that renders the correct view based on the state in `viewStore`.

**File:** `webview/src/routes/+page.svelte` (Modify)
```html
<script lang="ts">
  import SetupView from '$lib/components/SetupView.svelte';
  import IndexingView from '$lib/components/IndexingView.svelte';
  import QueryView from '$lib/components/QueryView.svelte';
  import { currentView } from '$lib/stores/viewStore';

  // To test, you can expose the store to the window object
  import { onMount } from 'svelte';
  onMount(() => {
    if (typeof window !== 'undefined') {
      (window as any).currentView = currentView;
    }
  });
</script>

<main>
  {#if $currentView === 'setup'}
    <SetupView />
  {:else if $currentView === 'indexing'}
    <IndexingView />
  {:else if $currentView === 'query'}
    <QueryView />
  {/if}
</main>

<style>
  main {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }
</style>
```

### 3. Verification

After creating these files, run the SvelteKit development server from within the `webview` directory:

```bash
cd webview
npm run dev
```

Open your browser to the specified localhost address. You should see the `SetupView` component rendered by default. You can test the view switching by opening the browser's developer console and running `window.currentView.set('query')` or `window.currentView.set('indexing')`. The UI should update instantly to show the corresponding component.
</file>

<file path="docs/todo/svelte-continue/implementation_sub_sprint_3_centralized_webview_management.md">
# Implementation Guidance: Sub-Sprint 3 - Centralized Webview Management

**Objective:** To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, centralizing control and cleaning up the extension's entry point.

---

### 1. Overview

This guide provides a step-by-step walkthrough for creating a `WebviewManager` class. This class will act as a singleton manager for our main webview panel, ensuring that only one instance of the panel exists at any time. This pattern is a best practice for managing resource-intensive webviews in VS Code extensions.

We will follow the singleton pattern where the class manages its own instance via a static property and a static creation method.

### 2. Step-by-Step Implementation

#### Step 2.1: Create the `WebviewManager.ts` File

First, create the new file that will house our manager class.

**File:** `src/webviewManager.ts` (New File)

#### Step 2.2: Implement the WebviewManager Class

Populate the new file with the following class structure. This code is adapted from VS Code extension best practices for singleton webview management.

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export class WebviewManager {
    // Static property to hold the single instance of the panel
    public static currentPanel: WebviewManager | undefined;

    private readonly _panel: vscode.WebviewPanel;
    private readonly _extensionUri: vscode.Uri;
    private _disposables: vscode.Disposable[] = [];

    /**
     * Creates or shows a webview panel.
     * @param extensionUri The URI of the extension.
     */
    public static createOrShow(extensionUri: vscode.Uri) {
        const column = vscode.window.activeTextEditor
            ? vscode.window.activeTextEditor.viewColumn
            : undefined;

        // If we already have a panel, show it.
        if (WebviewManager.currentPanel) {
            WebviewManager.currentPanel._panel.reveal(column);
            return;
        }

        // Otherwise, create a new panel.
        const panel = vscode.window.createWebviewPanel(
            'codeContextEngine', // Internal ID for the webview type
            'Code Context Engine', // Title of the panel displayed to the user
            column || vscode.ViewColumn.One,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [
                    vscode.Uri.joinPath(extensionUri, 'webview', 'build')
                ]
            }
        );

        WebviewManager.currentPanel = new WebviewManager(panel, extensionUri);
    }

    private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
        this._panel = panel;
        this._extensionUri = extensionUri;

        // Set the webview's initial HTML content
        this._update();

        // Listen for when the panel is disposed (i.e., when the user closes it)
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

        // TODO: In Sprint 4, the message handler will be moved here.
        // this._panel.webview.onDidReceiveMessage(...);
    }

    /**
     * Cleans up all disposables and resets the current panel instance.
     */
    public dispose() {
        WebviewManager.currentPanel = undefined;

        // Dispose of the panel
        this._panel.dispose();

        // Dispose of all disposables
        while (this._disposables.length) {
            const x = this._disposables.pop();
            if (x) {
                x.dispose();
            }
        }
    }

    /**
     * Sets the HTML content for the webview panel.
     */
    private _update() {
        const webview = this._panel.webview;
        this._panel.webview.html = this._getHtmlForWebview(webview);
    }

    /**
     * Reads the SvelteKit build output and prepares it for the webview.
     */
    private _getHtmlForWebview(webview: vscode.Webview): string {
        const buildPath = path.join(this._extensionUri.fsPath, 'webview', 'build');
        const indexPath = path.join(buildPath, 'index.html');
        let html = fs.readFileSync(indexPath, 'utf-8');

        // Replace asset paths with webview-compatible URIs
        html = html.replace(/<(script|link).*?(src|href)="(.*?)"/g,
            (match, tag, attribute, src) => {
                const resourcePath = path.join(buildPath, src);
                const resourceUri = webview.asWebviewUri(vscode.Uri.file(resourcePath));
                return `<${tag} ${attribute}="${resourceUri}"`;
            });

        return html;
    }
}
```

#### Step 2.3: Refactor the `openMainPanel` Command

Now, go back to `src/extension.ts` (or `src/commandManager.ts` if you have it) and replace the old `createWebviewPanel` logic with a simple call to your new manager.

**File:** `src/extension.ts` (or `src/commandManager.ts`)
```typescript
// At the top of the file
import { WebviewManager } from './webviewManager';

// Inside the activate function or command registration
// ...

const openPanelDisposable = vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
    // This single line replaces all the previous panel creation logic
    WebviewManager.createOrShow(context.extensionUri);
});

// ...
```

### 3. Key Concepts in this Implementation

-   **Singleton Pattern**: The `currentPanel` static property ensures only one `WebviewManager` instance exists. The `createOrShow` static method is the single entry point for creating or revealing the panel.
-   **Lifecycle Management**: The `onDidDispose` event is critical. When the user closes the panel, we clean up by calling `dispose()` and, most importantly, setting `WebviewManager.currentPanel = undefined`. This allows a new panel to be created next time the command is run.
-   **Asset Path Rewriting**: The `_getHtmlForWebview` method is now the single source of truth for loading the UI. It reads the `index.html` from the SvelteKit build output and uses a regular expression to find all `src` and `href` attributes. It then uses `webview.asWebviewUri` to convert the file paths into special URIs that the webview can securely access. This is the standard and required way to load local resources.

### 4. Verification

1.  Run the extension from the debug panel.
2.  Execute the `Code Context Engine: Open Main Panel` command from the command palette.
3.  The webview should open and display your SvelteKit application.
4.  Run the command again. A new panel should **not** be created; the existing one should just regain focus.
5.  Close the panel and run the command one more time. A new panel should be created successfully.
6.  Check the webview developer tools (`Developer: Open Webview Developer Tools`) to ensure there are no errors related to loading scripts or stylesheets.
</file>

<file path="docs/todo/svelte-continue/implementation_sub_sprint_4_message_routing_state.md">
# Implementation Guidance: Sub-Sprint 4 - Message Routing & State

**Objective:** To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

---

### 1. Overview

This guide covers the final refactoring steps to fully decouple the extension's components. We will create two classes:
1.  `StateManager`: A simple, centralized store for global extension state, such as whether an indexing operation is currently active.
2.  `MessageRouter`: A dedicated class whose sole responsibility is to listen for messages from a webview and route them to the appropriate service.

This separation of concerns makes the codebase cleaner, more testable, and easier to maintain.

### 2. Step-by-Step Implementation

#### Step 2.1: Create the `StateManager`

This class will be a simple property bag with getters and setters to prevent direct modification of state properties from outside the class.

**File:** `src/stateManager.ts` (New File)
```typescript
/**
 * Manages the global state of the extension.
 */
export class StateManager {
    private _isIndexing = false;
    private _isBackendHealthy = true; // Example of another potential state

    // --- isIndexing State ---

    public isIndexing(): boolean {
        return this._isIndexing;
    }

    public setIndexing(state: boolean): void {
        this._isIndexing = state;
        // In the future, we could add an event emitter here to notify other parts
        // of the extension about state changes.
    }

    // --- isBackendHealthy State ---

    public isBackendHealthy(): boolean {
        return this._isBackendHealthy;
    }

    public setBackendHealthy(state: boolean): void {
        this._isBackendHealthy = state;
    }
}
```

#### Step 2.2: Instantiate `StateManager` in `ExtensionManager`

The `ExtensionManager` should create and hold the single instance of the `StateManager`.

**File:** `src/extensionManager.ts` (Modify)
```typescript
// Add the import
import { StateManager } from './stateManager';

export class ExtensionManager {
    public readonly stateManager: StateManager;
    // ... other properties

    constructor(context: vscode.ExtensionContext) {
        this.stateManager = new StateManager();
        // ... other initializations
    }

    // ...
}
```

#### Step 2.3: Create the `MessageRouter`

This class will listen for webview messages and delegate them. It requires access to the `ExtensionManager` to get to all the services and managers.

**File:** `src/messageRouter.ts` (New File)
```typescript
import * as vscode from 'vscode';
import { ExtensionManager } from './extensionManager';

/**
 * Handles all incoming messages from a webview and routes them to the appropriate service.
 */
export class MessageRouter {
    private _disposables: vscode.Disposable[] = [];

    constructor(
        private readonly _extensionManager: ExtensionManager,
        private readonly _webview: vscode.Webview
    ) {
        this._webview.onDidReceiveMessage(
            this._routeMessage, 
            this, 
            this._disposables
        );
    }

    private async _routeMessage(message: { command: string; [key: string]: any }) {
        const { command, ...rest } = message;

        // Example of using the StateManager as a guard
        if (command === 'startIndexing' && this._extensionManager.stateManager.isIndexing()) {
            this._webview.postMessage({
                command: 'indexingError',
                error: 'An indexing process is already running.'
            });
            return;
        }

        // The main switch statement for routing commands
        switch (command) {
            case 'startIndexing':
                // Delegate to the command manager or directly to the service
                vscode.commands.executeCommand('code-context-engine.startIndexing');
                break;

            case 'search':
                const searchManager = this._extensionManager.getSearchManager();
                await searchManager.performSearch(rest.query, this._webview);
                break;

            // ... add all other cases from the old switch statement

            default:
                console.warn(`Unknown command received: ${command}`);
        }
    }

    public dispose() {
        while (this._disposables.length) {
            const x = this._disposables.pop();
            if (x) {
                x.dispose();
            }
        }
    }
}
```

#### Step 2.4: Integrate `MessageRouter` into `WebviewManager`

Now, simplify the `WebviewManager` by removing the message handling logic and replacing it with an instantiation of the `MessageRouter`.

**File:** `src/webviewManager.ts` (Modify)
```typescript
// Add the new imports
import { MessageRouter } from './messageRouter';
import { ExtensionManager } from './extensionManager'; // Assuming you pass this in

export class WebviewManager {
    // ... (currentPanel, _panel, _extensionUri, _disposables)

    // The constructor should now accept the ExtensionManager
    private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri, extensionManager: ExtensionManager) {
        this._panel = panel;
        this._extensionUri = extensionUri;

        this._update();

        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

        // This is the key change: instantiate the router and let it handle messages.
        // The router will add its own disposables to this._disposables.
        const router = new MessageRouter(extensionManager, this._panel.webview);
        this._disposables.push(router);
    }

    // The createOrShow method will also need to accept the ExtensionManager
    public static createOrShow(extensionUri: vscode.Uri, extensionManager: ExtensionManager) {
        // ... (existing singleton logic)

        // Pass extensionManager to the constructor
        WebviewManager.currentPanel = new WebviewManager(panel, extensionUri, extensionManager);
    }
    
    // ... (rest of the class)
}
```

#### Step 2.5: Update a Service to Use the `StateManager`

Finally, update a service like `IndexingService` to report its status.

**File:** `src/indexing/indexingService.ts` (Modify)
```typescript
import { StateManager } from '../stateManager';

export class IndexingService {
    // The constructor now needs the StateManager
    constructor(private readonly stateManager: StateManager) {}

    public async startIndexing(/*...args...*/) {
        if (this.stateManager.isIndexing()) {
            console.warn("Indexing already in progress.");
            return;
        }

        this.stateManager.setIndexing(true);
        try {
            // ... your existing indexing logic ...
        } catch (error) {
            console.error("Indexing failed", error);
        } finally {
            // This `finally` block ensures the state is always reset, even if an error occurs.
            this.stateManager.setIndexing(false);
        }
    }
}
```

### 3. Verification

After this refactoring, run the extension and test all the webview functionality. The primary test is to confirm that a user cannot start a second indexing process while one is already running. The UI should receive and display the error message sent from the `MessageRouter`'s guard clause.
</file>

<file path="docs/todo/svelte-continue/tasklist_sprint_01.md">
# Task List: Sprint 01 - SvelteKit Scaffolding & UI Components

**Goal:** To replace the legacy webview implementation with a new, properly structured SvelteKit application and recreate the core UI views as modular components.

**Methodology:** These tasks are sequential. Each step should be completed before moving to the next. TDD is encouraged: for logic-heavy parts like the state store, consider writing a test first.

---

### **Part 1: Project Scaffolding**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Backup & Clean `webview` Directory:** Before deleting, make a backup of the existing `webview/` directory to another location, then delete all contents within `webview/`. | `webview/` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** In the root directory, run `npm create svelte@latest webview`. Select the `Skeleton project` template and choose `Yes` for TypeScript support. | `webview/` (New project) |
| **1.3** |  To Do | **Install Static Adapter:** `cd` into the `webview` directory. Run `npm install -D @sveltejs/adapter-static`. This is required to build the SvelteKit app into static files the extension can load. | `webview/package.json` |
| **1.4** |  To Do | **Configure Static Adapter:** Modify `webview/svelte.config.js` to import and use the static adapter. Set the output `pages` and `assets` directory to `build` and set `fallback` to `index.html`. | `webview/svelte.config.js` |
| **1.5** |  To Do | **Install Fluent UI Components:** In the `webview/` directory, run `npm install @fluentui/web-components` to add the UI component library. | `webview/package.json` |
| **1.6** |  To Do | **Verify Build:** In the `webview/` directory, run `npm run build`. Ensure a `build` directory is created inside `webview/` and that it contains an `index.html` file. | `webview/build/` |

---

### **Part 2: UI Component Creation**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.7** |  To Do | **Create View State Store:** Create a new file for a Svelte writable store to manage the currently active view. The default value should be `'setup'`. | `webview/src/lib/stores/viewStore.ts` (New) |
| **1.8** |  To Do | **Create `SetupView` Component:** Create the file for the Setup view. Copy the HTML structure from the `getSetupWebviewContent` function in `src/extension.ts` and convert it to Svelte syntax using Fluent UI components. | `webview/src/lib/components/SetupView.svelte` (New) |
| **1.9** |  To Do | **Create `IndexingView` Component:** Create the file for the Indexing view. Replicate the progress bar and status text UI from `getWebviewContent` in `src/extension.ts`. | `webview/src/lib/components/IndexingView.svelte` (New) |
| **1.10**|  To Do | **Create `QueryView` Component:** Create the file for the Query view. Replicate the search input and results area from `getWebviewContent` in `src/extension.ts`. | `webview/src/lib/components/QueryView.svelte` (New) |
| **1.11**|  To Do | **Create Main Page Layout:** In the main Svelte page, import the three view components and the `viewStore`. Use an `{#if}` block to conditionally render the correct view based on the store's value. | `webview/src/routes/+page.svelte` |
| **1.12**|  To Do | **Verify View Switching:** Run the dev server with `npm run dev` in `webview/`. Open the browser console and manually set the store's value (e.g., `(await import('./src/lib/stores/viewStore.ts')).currentView.set('query')`) to confirm the view changes. | `(Manual Test)` |
</file>

<file path="docs/todo/svelte-continue/tasklist_sprint_02.md">
# Task List: Sprint 02 - Extension Integration & Communication

**Goal:** To decouple the extension from the old inline HTML by loading the new SvelteKit application into the webview and establishing a robust, standardized communication channel between the extension and the UI.

**Methodology:** These tasks are sequential. The focus is on refactoring the extension's backend to serve the static UI and creating a clean API for frontend-backend communication.

---

### **Part 1: Loading the SvelteKit Application**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Remove Old HTML Generation:** In `src/extension.ts`, delete the entire `getWebviewContent`, `getSettingsWebviewContent`, and `getSetupWebviewContent` functions. | `src/extension.ts` |
| **2.2** |  To Do | **Create New `getWebviewContent`:** Create a new, single `getWebviewContent` function that takes the `webview` and `extensionUri` as arguments. | `src/extension.ts` |
| **2.3** |  To Do | **Read `index.html`:** Inside the new function, use `fs.readFileSync` to read the contents of `webview/build/index.html`. | `src/extension.ts` |
| **2.4** |  To Do | **Implement Asset Path Rewriting:** Use `webview.asWebviewUri` to generate correct, secure URIs for all JS and CSS assets referenced in the `index.html`. A regular expression is best for finding all `src` and `href` attributes. | `src/extension.ts` |
| **2.5** |  To Do | **Update Panel Creation:** In the `openMainPanel` command logic, replace the old call to `getWebviewContent` with a call to the new one. | `src/extension.ts` |
| **2.6** |  To Do | **Verify UI Loading:** Run the extension and open the main panel. The SvelteKit UI should load correctly. Use the webview developer tools to verify there are no 404 errors for assets. | `(Manual Test)` |

---

### **Part 2: Standardized Communication API**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.7** |  To Do | **Create `vscodeApi` Wrapper:** Create a new file to encapsulate the `acquireVsCodeApi()` call. This avoids calling it in every component and provides a single, typed interface for communication. | `webview/src/lib/vscodeApi.ts` (New) |
| **2.8** |  To Do | **Implement `postMessage` Wrapper:** In `vscodeApi.ts`, export a function `postMessage(command, data)` that calls `vscode.postMessage({ command, ...data })`. | `webview/src/lib/vscodeApi.ts` |
| **2.9** |  To Do | **Implement `onMessage` Wrapper:** In `vscodeApi.ts`, export a function `onMessage(callback)` that adds a listener to `window.addEventListener('message', ...)` and handles routing messages to the provided callback. | `webview/src/lib/vscodeApi.ts` |
| **2.10**|  To Do | **Refactor Components to Use `vscodeApi`:** Go through all Svelte components (`SetupView`, etc.) and replace any direct `postMessage` or `addEventListener` calls with the new wrapper functions from `vscodeApi.ts`. | `webview/src/lib/components/*.svelte` |
| **2.11**|  To Do | **Re-implement "Start Database" Action:** In `SetupView.svelte`, ensure the button's `on:click` event calls `postMessage('startDatabase', { ... })` using the new API wrapper. | `webview/src/lib/components/SetupView.svelte` |
| **2.12**|  To Do | **Re-implement `databaseStatus` Listener:** In `SetupView.svelte`, use the `onMessage` wrapper to listen for `databaseStatus` messages from the extension and update the UI accordingly. | `webview/src/lib/components/SetupView.svelte` |
| **2.13**|  To Do | **Verify End-to-End Communication:** Manually test that clicking the "Start Database" button in the UI correctly triggers the `handleStartDatabase` function in `extension.ts` and that the UI updates with the response. | `(Manual Test)` |
</file>

<file path="docs/todo/svelte-continue/tasklist_sprint_03.md">
# Task List: Sprint 03 - Webview Management

**Goal:** To centralize all webview creation and lifecycle logic into a dedicated `WebviewManager` class, fully decoupling panel management from command handlers and the main extension file.

**Methodology:** This sprint is a pure refactoring effort. The external behavior of the extension should not change, but the internal architecture will be significantly cleaner. Each step builds on the previous one.

---

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Create `WebviewManager.ts` File:** Create the new file and a `WebviewManager` class shell with a private constructor, a `dispose` method, and a public static `currentPanel` property. | `src/webviewManager.ts` (New) |
| **3.2** |  To Do | **Implement `createOrShow` Static Method:** Add a public static `createOrShow` method. This method will contain the singleton logic: if `currentPanel` exists, call `.reveal()` on it; otherwise, create a new `WebviewPanel` and a new `WebviewManager` instance. | `src/webviewManager.ts` |
| **3.3** |  To Do | **Move `getWebviewContent` Logic:** Move the `getWebviewContent` function (created in Sprint 2) into `WebviewManager` as a private helper method (`_getHtmlForWebview`). | `src/webviewManager.ts`, `src/extension.ts` |
| **3.4** |  To Do | **Implement Panel Disposal:** In the `WebviewManager` constructor, add an `onDidDispose` listener to the panel. This listener must call the manager's `dispose` method, which should nullify the static `currentPanel` reference and clean up any other disposables. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Instantiate in `ExtensionManager`:** In `src/extensionManager.ts`, add a new public property `webviewManager` and instantiate your new `WebviewManager` in the constructor. | `src/extensionManager.ts` |
| **3.6** |  To Do | **Refactor `openMainPanel` Command:** In `src/commandManager.ts` (or `extension.ts`), find the `openMainPanel` command registration. Replace its entire body with a single call to `this.extensionManager.webviewManager.createOrShow()`. | `src/commandManager.ts` |
| **3.7** |  To Do | **Refactor `openSettingsPanel` Command:** Do the same for the `openSettingsPanel` command, creating a corresponding `createOrShowSettings` method in the `WebviewManager` if necessary to handle a separate settings panel singleton. | `src/commandManager.ts`, `src/webviewManager.ts` |
| **3.8** |  To Do | **Verify Functionality:** Thoroughly test opening, closing, and re-opening both the main and settings panels. Confirm that the singleton pattern is working correctly and that no new panels are created when one is already open. | `(Manual Test)` |
</file>

<file path="docs/todo/svelte-continue/tasklist_sprint_04.md">
# Task List: Sprint 04 - Communication & State Management

**Goal:** To formalize the webview communication layer with a `MessageRouter` and centralize global application state with a `StateManager`, completing the major architectural refactoring.

**Methodology:** This sprint finalizes the separation of concerns. The `StateManager` introduces a predictable state container, while the `MessageRouter` decouples message handling from the UI lifecycle.

---

### **Part 1: State Management**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `StateManager.ts` File:** Create the new file and a `StateManager` class. Add a private boolean `_isIndexing` property with a default of `false`. | `src/stateManager.ts` (New) |
| **4.2** |  To Do | **Add State Getters/Setters:** In `StateManager`, create a public getter `isIndexing()` and a public setter `setIndexing(state: boolean)`. | `src/stateManager.ts` |
| **4.3** |  To Do | **Instantiate `StateManager`:** In `ExtensionManager`, create and expose a public, readonly instance of the `StateManager`. | `src/extensionManager.ts` |
| **4.4** |  To Do | **Inject `StateManager` into `IndexingService`:** Update the `IndexingService` constructor to accept the `StateManager`. Update its instantiation in `ExtensionManager` to pass the manager instance. | `src/indexing/indexingService.ts`, `src/extensionManager.ts` |
| **4.5** |  To Do | **Update `IndexingService` Logic:** In `IndexingService`, call `this.stateManager.setIndexing(true)` at the very beginning of the `startIndexing` method and `this.stateManager.setIndexing(false)` inside a `finally` block to ensure it's always reset. | `src/indexing/indexingService.ts` |

---

### **Part 2: Message Routing**

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.6** |  To Do | **Create `MessageRouter.ts` File:** Create the new file and a `MessageRouter` class. The constructor should accept the `ExtensionManager` and the `vscode.Webview` instance. | `src/messageRouter.ts` (New) |
| **4.7** |  To Do | **Implement Message Listener:** In the `MessageRouter` constructor, subscribe to the `webview.onDidReceiveMessage` event and bind it to a private `_routeMessage` method. | `src/messageRouter.ts` |
| **4.8** |  To Do | **Move Message `switch` Statement:** Move the entire `switch` statement for message handling from `extension.ts` into the `_routeMessage` method. | `src/messageRouter.ts`, `src/extension.ts` |
| **4.9** |  To Do | **Integrate `MessageRouter` into `WebviewManager`:** In the `WebviewManager` constructor, remove the old `onDidReceiveMessage` logic and replace it with `new MessageRouter(this.extensionManager, this.mainPanel.webview)`. | `src/webviewManager.ts` |
| **4.10**|  To Do | **Integrate State Check:** In the `MessageRouter`'s `_routeMessage` method, add a guard clause at the top of the `startIndexing` case: `if (this.extensionManager.stateManager.isIndexing()) { ... post error message ...; return; }`. | `src/messageRouter.ts` |
| **4.11**|  To Do | **Verify Full Functionality:** Test all webview interactions. Specifically, start an indexing job and immediately try to start another. Verify the second attempt is gracefully rejected with an error message in the UI. | `(Manual Test)` |
</file>

<file path="docs/todo/extension/backlog_sub_sprint_1_dependency_injection_centralized_config.md">
### User Story 1: Refactor Services for Dependency Injection
**As Alisha, I want to** refactor services to receive dependencies via their constructor, **so that** I can unit test them with mocks.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Modify the constructor to accept `qdrantService: QdrantService` and `embeddingProvider: IEmbeddingProvider` as arguments. Remove any `new` keywords for these dependencies.
    -   **Implementation**:
        ```typescript
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';

        export class ContextService {
            constructor(
                private qdrantService: QdrantService,
                private embeddingProvider: IEmbeddingProvider
            ) {
                // ... existing constructor logic ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: `import { QdrantService } from '../db/qdrantService'; import { IEmbeddingProvider } from '../embeddings/embeddingProvider';`
2.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Modify the constructor to accept its dependencies (`fileWalker`, `astParser`, `chunker`, `qdrantService`, `embeddingProvider`, `lspService`) as arguments. Remove any `new` keywords for these dependencies.
    -   **Implementation**:
        ```typescript
        import { FileWalker } from './fileWalker';
        import { AstParser } from '../parsing/astParser';
        import { Chunker } from '../parsing/chunker';
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
        import { LspService } from '../lsp/lspService';

        export class IndexingService {
            constructor(
                private fileWalker: FileWalker,
                private astParser: AstParser,
                private chunker: Chunker,
                private qdrantService: QdrantService,
                private embeddingProvider: IEmbeddingProvider,
                private lspService: LspService
            ) {
                // ... existing constructor logic ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: `import { FileWalker } from './fileWalker'; import { AstParser } from '../parsing/astParser'; import { Chunker } from '../parsing/chunker'; import { QdrantService } from '../db/qdrantService'; import { IEmbeddingProvider } from '../embeddings/embeddingProvider'; import { LspService } from '../lsp/lspService';`
3.  **Filepath**: `src/db/qdrantService.ts`
    -   **Action**: Modify the constructor to accept `connectionString: string`. Remove any `getConfiguration` calls.
    -   **Implementation**:
        ```typescript
        export class QdrantService {
            constructor(private connectionString: string) {
                // ... existing constructor logic, use connectionString ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: None.
4.  **Filepath**: `src/embeddings/ollamaProvider.ts`
    -   **Action**: Modify the constructor to accept `config: OllamaConfig` object. Remove any `getConfiguration` calls.
    -   **Implementation**:
        ```typescript
        interface OllamaConfig {
            apiUrl: string;
            // ... other Ollama specific config ...
        }

        export class OllamaProvider implements IEmbeddingProvider {
            constructor(private config: OllamaConfig) {
                // ... existing constructor logic, use config ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: None.
5.  **Filepath**: `src/embeddings/openaiProvider.ts`
    -   **Action**: Modify the constructor to accept `config: OpenAIConfig` object. Remove any `getConfiguration` calls.
    -   **Implementation**:
        ```typescript
        interface OpenAIConfig {
            apiKey: string;
            // ... other OpenAI specific config ...
        }

        export class OpenAIProvider implements IEmbeddingProvider {
            constructor(private config: OpenAIConfig) {
                // ... existing constructor logic, use config ...
            }
            // ... rest of the class ...
        }
        ```
    -   **Imports**: None.
6.  **Filepath**: `src/embeddings/embeddingProvider.ts`
    -   **Action**: Update the `EmbeddingProviderFactory` (or similar factory class/function) to accept the `ConfigService` and pass the correct configuration down to the provider it creates.
    -   **Implementation**: (This will depend on the existing factory structure, but generally involves passing `ConfigService` and using its getters)
        ```typescript
        // Assuming a factory function or class
        import { ConfigService } from '../configService'; // New import
        import { OllamaProvider } from './ollamaProvider';
        import { OpenAIProvider } from './openaiProvider';

        export function createEmbeddingProvider(type: 'ollama' | 'openai', configService: ConfigService): IEmbeddingProvider {
            if (type === 'ollama') {
                return new OllamaProvider(configService.getOllamaConfig());
            } else if (type === 'openai') {
                return new OpenAIProvider(configService.getOpenAIConfig());
            }
            throw new Error('Unknown embedding provider type');
        }
        ```
    -   **Imports**: `import { ConfigService } from '../configService'; import { OllamaProvider } from './ollamaProvider'; import { OpenAIProvider } from './openaiProvider';`

### User Story 2: Centralized Configuration Service
**As Alisha, I want to** create a central configuration service, **so that** settings are managed in one place.

**Actions to Undertake:**
1.  **Filepath**: `src/configService.ts` (New File)
    -   **Action**: Create a new `ConfigService` class that reads all settings from `vscode.workspace.getConfiguration('code-context-engine')` on startup and provides them via getter methods.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';

        interface ExtensionConfig {
            qdrantConnectionString: string;
            ollama: {
                apiUrl: string;
                // ... other ollama specific config ...
            };
            openai: {
                apiKey: string;
                // ... other openai specific config ...
            };
            // ... add other configuration properties as needed ...
        }

        export class ConfigService {
            private config: ExtensionConfig;

            constructor() {
                this.config = vscode.workspace.getConfiguration('code-context-engine') as any; // Cast to any for simplicity, refine with proper type
            }

            public getQdrantConnectionString(): string {
                return this.config.qdrantConnectionString;
            }

            public getOllamaConfig(): { apiUrl: string } {
                return this.config.ollama;
            }

            public getOpenAIConfig(): { apiKey: string } {
                return this.config.openai;
            }

            // Add more getters for other configuration properties
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Update `extension.ts` to instantiate `ConfigService` and pass its instance to other services during their instantiation.
    -   **Implementation**: (Conceptual, exact placement depends on existing `extension.ts` structure)
        ```typescript
        import * as vscode from 'vscode';
        import { ConfigService } from './configService';
        import { QdrantService } from './db/qdrantService';
        import { createEmbeddingProvider } from './embeddings/embeddingProvider';
        import { ContextService } from './context/contextService';
        import { IndexingService } from './indexing/indexingService';
        import { FileWalker } from './indexing/fileWalker';
        import { AstParser } from './parsing/astParser';
        import { Chunker } from './parsing/chunker';
        import { LspService } from './lsp/lspService';

        export function activate(context: vscode.ExtensionContext) {
            const configService = new ConfigService();
            const qdrantService = new QdrantService(configService.getQdrantConnectionString());
            const embeddingProvider = createEmbeddingProvider('ollama', configService); // Example, choose based on config
            const contextService = new ContextService(qdrantService, embeddingProvider);

            const fileWalker = new FileWalker(); // Assuming no dependencies for now
            const astParser = new AstParser(); // Assuming no dependencies for now
            const chunker = new Chunker(); // Assuming no dependencies for now
            const lspService = new LspService(); // Assuming no dependencies for now

            const indexingService = new IndexingService(
                fileWalker,
                astParser,
                chunker,
                qdrantService,
                embeddingProvider,
                lspService
            );

            // ... register commands, etc. ...
        }
        ```
    -   **Imports**: `import { ConfigService } from './configService'; import { QdrantService } './db/qdrantService'; import { createEmbeddingProvider } from './embeddings/embeddingProvider'; import { ContextService } from './context/contextService'; import { IndexingService } from './indexing/indexingService'; import { FileWalker } from './indexing/fileWalker'; import { AstParser } from './parsing/astParser'; import { Chunker } from './parsing/chunker'; import { LspService } from './lsp/lspService';`

### User Story 3: Update Unit Tests for DI
**As Alisha, I want to** update existing unit tests and add new ones, **so that** I can verify service logic with mocked dependencies.

**Actions to Undertake:**
1.  **Filepath**: `src/test/mocks.ts` (New File)
    -   **Action**: Create mock implementations for `QdrantService` and `IEmbeddingProvider` for use in unit tests.
    -   **Implementation**:
        ```typescript
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';

        export class MockQdrantService implements Partial<QdrantService> {
            // Implement mock methods as needed for tests
            // For example:
            // async upsertVectors(vectors: any[]): Promise<void> { /* mock implementation */ }
        }

        export class MockEmbeddingProvider implements Partial<IEmbeddingProvider> {
            // Implement mock methods as needed for tests
            // For example:
            // async embed(text: string): Promise<number[]> { return [0.1, 0.2, 0.3]; }
        }
        ```
    -   **Imports**: `import { QdrantService } from '../db/qdrantService'; import { IEmbeddingProvider } from '../embeddings/embeddingProvider';`
2.  **Filepath**: `src/test/contextService.test.ts`
    -   **Action**: Modify existing tests to pass mocked dependencies to the `ContextService` constructor. Add new tests to cover scenarios with mocked dependencies.
    -   **Implementation**: (Conceptual, depends on testing framework, e.g., Mocha/Chai, Jest)
        ```typescript
        import { expect } from 'chai'; // or 'jest'
        import { ContextService } from '../context/contextService';
        import { MockQdrantService, MockEmbeddingProvider } from './mocks';

        describe('ContextService', () => {
            let mockQdrantService: MockQdrantService;
            let mockEmbeddingProvider: MockEmbeddingProvider;
            let contextService: ContextService;

            beforeEach(() => {
                mockQdrantService = new MockQdrantService();
                mockEmbeddingProvider = new MockEmbeddingProvider();
                contextService = new ContextService(
                    mockQdrantService as any, // Cast to any for partial mock
                    mockEmbeddingProvider as any // Cast to any for partial mock
                );
            });

            it('should do something with mocked dependencies', async () => {
                // Example test:
                // (mockQdrantService as any).someMethod = () => Promise.resolve('mocked result');
                // const result = await contextService.someMethodCallingQdrant();
                // expect(result).to.equal('mocked result');
            });
        });
        ```
    -   **Imports**: `import { expect } from 'chai'; import { ContextService } from '../context/contextService'; import { MockQdrantService, MockEmbeddingProvider } from './mocks';`

**Acceptance Criteria:**
- No service uses the `new` keyword to create its long-lived dependencies.
- No service directly calls `vscode.workspace.getConfiguration()`.
- Unit tests for services can run without needing the VS Code API.

**Testing Plan:**
- **Test Case 1**: Run existing unit tests for `ContextService` and `IndexingService` to ensure they pass with mocked dependencies.
- **Test Case 2**: Add new unit tests for `ConfigService` to verify it correctly reads and provides configuration values.
- **Test Case 3**: Verify that `QdrantService`, `OllamaProvider`, and `OpenAIProvider` constructors correctly receive their configuration/connection strings.
- **Test Case 4**: Ensure that the `EmbeddingProviderFactory` correctly instantiates providers with the configuration from `ConfigService`.
</file>

<file path="docs/todo/extension/backlog_sub_sprint_2_extension_command_managers.md">
### User Story 1: Create ExtensionManager
**As Alisha, I want to** introduce an `ExtensionManager` to handle the extension's lifecycle, **so that** `extension.ts` becomes a simple entry point.

**Actions to Undertake:**
1.  **Filepath**: `src/extensionManager.ts` (New File)
    -   **Action**: Create a new `ExtensionManager` class. Its constructor will instantiate all services (using the DI pattern from Sub-Sprint 1) and managers. It will also have an `initialize` method and a `dispose` method.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { ConfigService } from './configService';
        import { QdrantService } from './db/qdrantService';
        import { createEmbeddingProvider } from './embeddings/embeddingProvider';
        import { ContextService } from './context/contextService';
        import { IndexingService } from './indexing/indexingService';
        import { FileWalker } from './indexing/fileWalker';
        import { AstParser } from './parsing/astParser';
        import { Chunker } from './parsing/chunker';
        import { LspService } from './lsp/lspService';
        import { CommandManager } from './commandManager'; // Will be created in next step

        export class ExtensionManager implements vscode.Disposable {
            private configService: ConfigService;
            private qdrantService: QdrantService;
            private embeddingProvider: IEmbeddingProvider;
            private contextService: ContextService;
            private indexingService: IndexingService;
            private commandManager: CommandManager;

            private disposables: vscode.Disposable[] = [];

            constructor(private context: vscode.ExtensionContext) {
                // Instantiate ConfigService
                this.configService = new ConfigService();

                // Instantiate QdrantService
                this.qdrantService = new QdrantService(this.configService.getQdrantConnectionString());

                // Instantiate EmbeddingProvider
                this.embeddingProvider = createEmbeddingProvider('ollama', this.configService); // Example, choose based on config

                // Instantiate ContextService
                this.contextService = new ContextService(this.qdrantService, this.embeddingProvider);

                // Instantiate other core dependencies
                const fileWalker = new FileWalker();
                const astParser = new AstParser();
                const chunker = new Chunker();
                const lspService = new LspService();

                // Instantiate IndexingService
                this.indexingService = new IndexingService(
                    fileWalker,
                    astParser,
                    chunker,
                    this.qdrantService,
                    this.embeddingProvider,
                    lspService
                );

                // Instantiate CommandManager (pass services it needs)
                this.commandManager = new CommandManager(this.indexingService /*, other services as needed */);
            }

            public initialize(): void {
                // Register commands
                this.disposables.push(...this.commandManager.registerCommands());

                // Add all disposables to the extension context
                this.context.subscriptions.push(...this.disposables);
            }

            public dispose(): void {
                this.disposables.forEach(d => d.dispose());
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { ConfigService } from './configService'; import { QdrantService } from './db/qdrantService'; import { createEmbeddingProvider, IEmbeddingProvider } from './embeddings/embeddingProvider'; import { ContextService } from './context/contextService'; import { IndexingService } from './indexing/indexingService'; import { FileWalker } from './indexing/fileWalker'; import { AstParser } from './parsing/astParser'; import { Chunker } from './parsing/chunker'; import { LspService } from './lsp/lspService'; import { CommandManager } from './commandManager';`

### User Story 2: Create CommandManager
**As Alisha, I want to** create a `CommandManager` to handle all command registrations, **so that** this logic is decoupled from the main activation file.

**Actions to Undertake:**
1.  **Filepath**: `src/commandManager.ts` (New File)
    -   **Action**: Create a new `CommandManager` class. It should have a constructor that accepts the necessary services (e.g., `IndexingService`) and a `registerCommands` method that returns an array of `vscode.Disposable`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { IndexingService } from './indexing/indexingService';

        export class CommandManager {
            constructor(private indexingService: IndexingService) {}

            public registerCommands(): vscode.Disposable[] {
                const disposables: vscode.Disposable[] = [];

                disposables.push(
                    vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                        // This will be handled by WebviewManager in Sub-Sprint 3
                        vscode.window.showInformationMessage('Open Main Panel (placeholder)');
                    }),
                    vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
                        this.indexingService.startIndexing();
                        vscode.window.showInformationMessage('Indexing started!');
                    }),
                    vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                        // This will be handled by WebviewManager in Sub-Sprint 3
                        vscode.window.showInformationMessage('Open Settings (placeholder)');
                    })
                );

                return disposables;
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { IndexingService } from './indexing/indexingService';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Refactor `extension.ts` to simplify `activate` to only create and initialize an `ExtensionManager`. The `deactivate` function should call `extensionManager.dispose()`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { ExtensionManager } from './extensionManager';

        let extensionManager: ExtensionManager;

        export function activate(context: vscode.ExtensionContext) {
            extensionManager = new ExtensionManager(context);
            extensionManager.initialize();
            console.log('Code Context Engine extension activated.');
        }

        export function deactivate() {
            if (extensionManager) {
                extensionManager.dispose();
            }
            console.log('Code Context Engine extension deactivated.');
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { ExtensionManager } from './extensionManager';`

**Acceptance Criteria:**
- The `extension.ts` file is less than 50 lines of code.
- All previously functional commands are still registered and work correctly.
- The extension activates and deactivates cleanly without errors.

**Testing Plan:**
- **Test Case 1**: Install and activate the extension. Verify that the `activate` and `deactivate` console logs appear correctly.
- **Test Case 2**: Execute each of the registered commands (`code-context-engine.openMainPanel`, `code-context-engine.startIndexing`, `code-context-engine.openSettings`) from the VS Code Command Palette. Verify that the corresponding placeholder messages or actions are triggered.
- **Test Case 3**: Reload the VS Code window multiple times to ensure clean activation and deactivation without memory leaks or errors.
- **Test Case 4**: Verify that `extension.ts` contains only the `activate` and `deactivate` functions and the `ExtensionManager` instantiation, and its line count is below 50 lines.
</file>

<file path="docs/todo/extension/backlog_sub_sprint_3_centralized_webview_management.md">
### User Story 1: Create WebviewManager
**As a** developer, **I want to** create a `WebviewManager` to handle the lifecycle of all webview panels, **so that** UI creation logic is centralized and reusable.

**Actions to Undertake:**
1.  **Filepath**: `src/webviewManager.ts` (New File)
    -   **Action**: Create the new file and the `WebviewManager` class structure with a constructor that accepts `vscode.ExtensionContext` and a `dispose` method.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';

        export class WebviewManager implements vscode.Disposable {
            private mainPanel: vscode.WebviewPanel | undefined;
            private settingsPanel: vscode.WebviewPanel | undefined;

            constructor(private context: vscode.ExtensionContext) {}

            private getWebviewContent(webview: vscode.Webview, panelName: string): string {
                const htmlPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');
                let htmlContent = fs.readFileSync(htmlPath, 'utf8');

                // Replace placeholders for webview assets
                const scriptUri = webview.asWebviewUri(vscode.Uri.file(
                    path.join(this.context.extensionPath, 'webview', 'dist', 'index.js')
                ));
                const styleUri = webview.asWebviewUri(vscode.Uri.file(
                    path.join(this.context.extensionPath, 'webview', 'dist', 'styles.css')
                ));

                htmlContent = htmlContent.replace('{{scriptUri}}', scriptUri.toString());
                htmlContent = htmlContent.replace('{{styleUri}}', styleUri.toString());

                // You might want to pass initial data to the webview here
                // For example, a global variable or a message
                htmlContent = htmlContent.replace('{{panelName}}', panelName);

                return htmlContent;
            }

            public showMainPanel(): void {
                if (this.mainPanel) {
                    this.mainPanel.reveal(vscode.ViewColumn.One);
                    return;
                }

                this.mainPanel = vscode.window.createWebviewPanel(
                    'codeContextEngineMain',
                    'Code Context Engine',
                    vscode.ViewColumn.One,
                    {
                        enableScripts: true,
                        localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
                    }
                );

                this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, 'main');

                this.mainPanel.onDidDispose(() => {
                    this.mainPanel = undefined;
                }, null, this.context.subscriptions);
            }

            public showSettingsPanel(): void {
                if (this.settingsPanel) {
                    this.settingsPanel.reveal(vscode.ViewColumn.Two);
                    return;
                }

                this.settingsPanel = vscode.window.createWebviewPanel(
                    'codeContextEngineSettings',
                    'Code Context Settings',
                    vscode.ViewColumn.Two,
                    {
                        enableScripts: true,
                        localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
                    }
                );

                this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, 'settings');

                this.settingsPanel.onDidDispose(() => {
                    this.settingsPanel = undefined;
                }, null, this.context.subscriptions);
            }

            public dispose(): void {
                this.mainPanel?.dispose();
                this.settingsPanel?.dispose();
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import * as path from 'path'; import * as fs from 'fs';`
2.  **Filepath**: `src/extensionManager.ts`
    -   **Action**: Instantiate the `WebviewManager` in the `ExtensionManager`'s constructor and make it accessible.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        // ... other imports ...
        import { WebviewManager } from './webviewManager';

        export class ExtensionManager implements vscode.Disposable {
            // ... existing private members ...
            public webviewManager: WebviewManager;

            constructor(private context: vscode.ExtensionContext) {
                // ... existing instantiations ...

                // Instantiate WebviewManager
                this.webviewManager = new WebviewManager(this.context);

                // Instantiate CommandManager (pass services it needs, including webviewManager)
                this.commandManager = new CommandManager(this.indexingService, this.webviewManager);
            }

            // ... rest of the class ...
        }
        ```
    -   **Imports**: `import { WebviewManager } from './webviewManager';`
3.  **Filepath**: `src/commandManager.ts`
    -   **Action**: Update the `CommandManager` to accept `WebviewManager` and change the `openMainPanel` and `openSettings` command callbacks to call the appropriate methods on the `WebviewManager` instance.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { IndexingService } from './indexing/indexingService';
        import { WebviewManager } from './webviewManager';

        export class CommandManager {
            constructor(private indexingService: IndexingService, private webviewManager: WebviewManager) {}

            public registerCommands(): vscode.Disposable[] {
                const disposables: vscode.Disposable[] = [];

                disposables.push(
                    vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                        this.webviewManager.showMainPanel();
                    }),
                    vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
                        this.indexingService.startIndexing();
                        vscode.window.showInformationMessage('Indexing started!');
                    }),
                    vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                        this.webviewManager.showSettingsPanel();
                    })
                );

                return disposables;
            }
        }
        ```
    -   **Imports**: `import { WebviewManager } from './webviewManager';`

**Acceptance Criteria:**
- All `vscode.window.createWebviewPanel` calls are located exclusively within `WebviewManager.ts`.
- The `openMainPanel` and `openSettings` commands correctly open their respective UIs.
- Attempting to open a panel that is already open simply brings the existing panel into focus.

**Testing Plan:**
- **Test Case 1**: Run the extension. Execute the command `code-context-engine.openMainPanel` from the Command Palette. Verify that the main webview panel opens.
- **Test Case 2**: Execute `code-context-engine.openMainPanel` again. Verify that a new panel is NOT opened, but the existing main panel is brought into focus.
- **Test Case 3**: Run the extension. Execute the command `code-context-engine.openSettings` from the Command Palette. Verify that the settings webview panel opens.
- **Test Case 4**: Execute `code-context-engine.openSettings` again. Verify that a new panel is NOT opened, but the existing settings panel is brought into focus.
- **Test Case 5**: Close both webview panels. Execute the commands again to ensure they can be reopened correctly.
- **Test Case 6**: Verify that the webview content (HTML, JS, CSS) loads correctly within the panels. (This might require inspecting the webview developer tools).
</file>

<file path="docs/todo/extension/backlog_sub_sprint_4_message_routing_state.md">
### User Story 1: Create StateManager
**As Alisha, I want to** introduce a basic `StateManager` to track the global state of the extension, **so that** services don't need to communicate directly with each other for status updates.

**Actions to Undertake:**
1.  **Filepath**: `src/stateManager.ts` (New File)
    -   **Action**: Create a simple `StateManager` class with private properties (e.g., `_isIndexing = false`) and public getter/setter methods.
    -   **Implementation**:
        ```typescript
        export class StateManager {
            private _isIndexing: boolean = false;

            public isIndexing(): boolean {
                return this._isIndexing;
            }

            public setIndexing(state: boolean): void {
                this._isIndexing = state;
            }

            // Add more state properties and their getters/setters as needed
            // private _isProcessingQuery: boolean = false;
            // public isProcessingQuery(): boolean { return this._isProcessingQuery; }
            // public setProcessingQuery(state: boolean): void { this._isProcessingQuery = state; }
        }
        ```
    -   **Imports**: None.

### User Story 2: Create MessageRouter
**As a** developer, **I want to** create a `MessageRouter` to handle all incoming messages from the webview, **so that** communication logic is decoupled and clean.

**Actions to Undertake:**
1.  **Filepath**: `src/messageRouter.ts` (New File)
    -   **Action**: Develop the class with a constructor that accepts the `ExtensionManager` (to access all services and managers) and the `vscode.Webview`. The constructor will set up the `onDidReceiveMessage` listener.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { ExtensionManager } from './extensionManager';

        export class MessageRouter {
            constructor(
                private extensionManager: ExtensionManager,
                private webview: vscode.Webview
            ) {
                this.webview.onDidReceiveMessage(async message => {
                    await this.routeMessage(message);
                }, undefined, this.extensionManager.context.subscriptions);
            }

            private async routeMessage(message: any): Promise<void> {
                const { command, requestId, payload } = message;

                let result: any;
                let error: string | undefined;

                try {
                    switch (command) {
                        case 'startIndexing':
                            if (this.extensionManager.stateManager.isIndexing()) {
                                throw new Error('Indexing is already in progress.');
                            }
                            this.extensionManager.indexingService.startIndexing();
                            result = { success: true };
                            break;
                        // Add more cases for other commands
                        case 'getSettings':
                            result = this.extensionManager.configService.getSettings(); // Assuming ConfigService has a getSettings method
                            break;
                        default:
                            throw new Error(`Unknown command: ${command}`);
                    }
                } catch (e: any) {
                    error = e.message;
                }

                // Send response back to webview
                this.webview.postMessage({
                    command: `${command}Response`,
                    requestId,
                    result,
                    error
                });
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { ExtensionManager } from './extensionManager';`

### User Story 3: Integrate StateManager
**As Alisha, I want to** update services to use the `StateManager`, **so that** the `MessageRouter` can query the state to prevent conflicting actions.

**Actions to Undertake:**
1.  **Filepath**: `src/extensionManager.ts`
    -   **Action**: Instantiate the `StateManager` in `ExtensionManager` and make it accessible to other services.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        // ... other imports ...
        import { StateManager } from './stateManager';

        export class ExtensionManager implements vscode.Disposable {
            // ... existing private members ...
            public stateManager: StateManager;

            constructor(private context: vscode.ExtensionContext) {
                // ... existing instantiations ...

                // Instantiate StateManager
                this.stateManager = new StateManager();

                // Pass StateManager to services that need it
                this.indexingService = new IndexingService(
                    fileWalker,
                    astParser,
                    chunker,
                    this.qdrantService,
                    this.embeddingProvider,
                    lspService,
                    this.stateManager // Pass stateManager here
                );

                // ... other instantiations ...
            }

            // ... rest of the class ...
        }
        ```
    -   **Imports**: `import { StateManager } from './stateManager';`
2.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Inject the `StateManager` instance into the `IndexingService`. Call `this.stateManager.setIndexing(true)` at the beginning of `startIndexing` and `false` in a `finally` block at the end.
    -   **Implementation**:
        ```typescript
        import { StateManager } from '../stateManager';
        // ... other imports ...

        export class IndexingService {
            constructor(
                // ... existing dependencies ...
                private stateManager: StateManager
            ) {}

            public async startIndexing(): Promise<void> {
                this.stateManager.setIndexing(true);
                try {
                    // ... existing indexing logic ...
                    console.log('Indexing started...');
                    // Simulate async work
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    console.log('Indexing complete.');
                } finally {
                    this.stateManager.setIndexing(false);
                }
            }
        }
        ```
    -   **Imports**: `import { StateManager } from '../stateManager';`
3.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: In `WebviewManager`, when a panel is created, remove the old `onDidReceiveMessage` logic and replace it with `new MessageRouter(this.extensionManager, this.mainPanel.webview)`.
    -   **Implementation**:
        ```typescript
        import { MessageRouter } from './messageRouter';
        // ... other imports ...

        export class WebviewManager implements vscode.Disposable {
            // ... existing properties ...

            constructor(private context: vscode.ExtensionContext, private extensionManager: ExtensionManager) {}

            public showMainPanel(): void {
                // ... existing panel creation logic ...

                // Replace old onDidReceiveMessage with MessageRouter
                new MessageRouter(this.extensionManager, this.mainPanel.webview);

                // ... existing onDidDispose ...
            }

            public showSettingsPanel(): void {
                // ... existing panel creation logic ...

                // Replace old onDidReceiveMessage with MessageRouter
                new MessageRouter(this.extensionManager, this.settingsPanel.webview);

                // ... existing onDidDispose ...
            }

            // ... dispose method ...
        }
        ```
    -   **Imports**: `import { MessageRouter } from './messageRouter';`

**Acceptance Criteria:**
- The `onDidReceiveMessage` listener in `WebviewManager` is a single line that instantiates and uses the `MessageRouter`.
- The `MessageRouter` correctly routes commands to the appropriate services.
- Attempting to start a new indexing job while one is already running is gracefully rejected with an error message sent back to the UI.

**Testing Plan:**
- **Test Case 1**: Open the main webview panel. Send a `startIndexing` message from the webview. Verify that indexing starts and the `isIndexing` state is set to `true`.
- **Test Case 2**: While indexing is in progress (from Test Case 1), send another `startIndexing` message. Verify that the `MessageRouter` rejects the command and sends an error message back to the webview.
- **Test Case 3**: After indexing completes, send another `startIndexing` message. Verify that it starts successfully.
- **Test Case 4**: Implement a simple message from the webview (e.g., `getSettings`) and verify that the `MessageRouter` correctly routes it to the `ConfigService` and sends a response back.
- **Test Case 5**: Verify that the `extension.ts` file remains clean and its line count is minimal.
</file>

<file path="docs/todo/extension/implementation_sub_sprint_1_dependency_injection_centralized_config.md">
## Implementation Guidance: Sub-Sprint 1 - Dependency Injection & Centralized Config

This guide provides detailed instructions and code examples for implementing Dependency Injection (DI) and a centralized configuration service within the VS Code extension. The goal is to decouple services, improve testability, and streamline configuration management.

### 1. Centralized Configuration (`ConfigService.ts`)

**Purpose:** To encapsulate all extension settings, providing a single source of truth and preventing direct `vscode.workspace.getConfiguration()` calls throughout the codebase.

**API Information:**
- `vscode.workspace.getConfiguration('section')`: Retrieves a configuration object for a specific section (e.g., 'code-context-engine').

**Code Example (`src/configService.ts` - New File):**
```typescript
import * as vscode from 'vscode';

// Define an interface for your extension's configuration structure
interface ExtensionConfig {
    qdrantConnectionString: string;
    ollama: {
        apiUrl: string;
        // Add other Ollama specific config properties
    };
    openai: {
        apiKey: string;
        // Add other OpenAI specific config properties
    };
    // Add any other top-level configuration properties here
}

export class ConfigService {
    private config: ExtensionConfig;

    constructor() {
        // Load the configuration once during instantiation
        // The 'code-context-engine' string should match your extension's configuration section in package.json
        this.config = vscode.workspace.getConfiguration('code-context-engine') as any; // Cast to any for initial simplicity
    }

    public getQdrantConnectionString(): string {
        return this.config.qdrantConnectionString;
    }

    public getOllamaConfig(): { apiUrl: string } {
        return this.config.ollama;
    }

    public getOpenAIConfig(): { apiKey: string } {
        return this.config.openai;
    }

    // Add more public getter methods for other configuration properties as needed
    // Example:
    // public getSomeOtherSetting(): boolean {
    //     return this.config.someOtherSetting;
    // }
}
```

### 2. Refactoring Services for Dependency Injection

**Purpose:** To modify service constructors to accept their dependencies as arguments, rather than instantiating them internally. This enables easier testing and promotes loose coupling.

**General Approach:**
1.  Identify all `new` keyword usages within a service's constructor or initialization logic that create other long-lived service instances.
2.  Add parameters to the service's constructor for each of these dependencies.
3.  Update the `extension.ts` (or later, `ExtensionManager`) to instantiate these dependencies and pass them to the service constructors.

**Code Examples:**

**a) `src/db/qdrantService.ts`**

Modify the constructor to accept the connection string directly:
```typescript
// src/db/qdrantService.ts

export class QdrantService {
    constructor(private connectionString: string) {
        // Use this.connectionString to initialize Qdrant client
        console.log(`QdrantService initialized with connection: ${this.connectionString}`);
    }

    // ... rest of your QdrantService methods ...
}
```

**b) `src/embeddings/ollamaProvider.ts` and `src/embeddings/openaiProvider.ts`**

Define configuration interfaces and update constructors:

**`src/embeddings/ollamaProvider.ts`**
```typescript
// src/embeddings/ollamaProvider.ts
import { IEmbeddingProvider } from './embeddingProvider';

export interface OllamaConfig {
    apiUrl: string;
    // Add other Ollama specific config properties like model name, etc.
}

export class OllamaProvider implements IEmbeddingProvider {
    constructor(private config: OllamaConfig) {
        console.log(`OllamaProvider initialized with API URL: ${this.config.apiUrl}`);
    }

    async embed(text: string): Promise<number[]> {
        // Implementation using this.config.apiUrl
        return [/* embedding vector */];
    }
}
```

**`src/embeddings/openaiProvider.ts`**
```typescript
// src/embeddings/openaiProvider.ts
import { IEmbeddingProvider } from './embeddingProvider';

export interface OpenAIConfig {
    apiKey: string;
    // Add other OpenAI specific config properties
}

export class OpenAIProvider implements IEmbeddingProvider {
    constructor(private config: OpenAIConfig) {
        console.log(`OpenAIProvider initialized with API Key: ${this.config.apiKey ? '*****' : 'N/A'}`);
    }

    async embed(text: string): Promise<number[]> {
        // Implementation using this.config.apiKey
        return [/* embedding vector */];
    }
}
```

**c) `src/embeddings/embeddingProvider.ts` (Factory Update)**

If you have a factory function or class for creating embedding providers, update it to accept `ConfigService` and pass the relevant config:
```typescript
// src/embeddings/embeddingProvider.ts (assuming this file contains the factory)
import { ConfigService } from '../configService';
import { OllamaProvider, OllamaConfig } from './ollamaProvider';
import { OpenAIProvider, OpenAIConfig } from './openaiProvider';

export interface IEmbeddingProvider {
    embed(text: string): Promise<number[]>;
}

export function createEmbeddingProvider(type: 'ollama' | 'openai', configService: ConfigService): IEmbeddingProvider {
    switch (type) {
        case 'ollama':
            return new OllamaProvider(configService.getOllamaConfig());
        case 'openai':
            return new OpenAIProvider(configService.getOpenAIConfig());
        default:
            throw new Error(`Unsupported embedding provider type: ${type}`);
    }
}
```

**d) `src/context/contextService.ts`**

Update constructor to accept `QdrantService` and `IEmbeddingProvider`:
```typescript
// src/context/contextService.ts
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';

export class ContextService {
    constructor(
        private qdrantService: QdrantService,
        private embeddingProvider: IEmbeddingProvider
    ) {
        // Now you can use this.qdrantService and this.embeddingProvider
    }

    // ... rest of your ContextService methods ...
}
```

**e) `src/indexing/indexingService.ts`**

Update constructor to accept all its dependencies:
```typescript
// src/indexing/indexingService.ts
import { FileWalker } from './fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker } from '../parsing/chunker';
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { LspService } from '../lsp/lspService';

export class IndexingService {
    constructor(
        private fileWalker: FileWalker,
        private astParser: AstParser,
        private chunker: Chunker,
        private qdrantService: QdrantService,
        private embeddingProvider: IEmbeddingProvider,
        private lspService: LspService
    ) {
        // Now you can use these injected dependencies
    }

    // ... rest of your IndexingService methods ...
}
```

### 3. Updating `extension.ts` (Initial Wiring)

**Purpose:** To act as the composition root where all services are instantiated and their dependencies are resolved and passed. This file will become much cleaner in subsequent sprints with the `ExtensionManager`.

**Code Example (`src/extension.ts` - Partial Update):**
```typescript
// src/extension.ts
import * as vscode from 'vscode';
import { ConfigService } from './configService';
import { QdrantService } from './db/qdrantService';
import { createEmbeddingProvider } from './embeddings/embeddingProvider';
import { ContextService } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { FileWalker } from './indexing/fileWalker'; // Assuming no dependencies for now
import { AstParser } from './parsing/astParser';   // Assuming no dependencies for now
import { Chunker } from './parsing/chunker';     // Assuming no dependencies for now
import { LspService } from './lsp/lspService';     // Assuming no dependencies for now

export function activate(context: vscode.ExtensionContext) {
    // 1. Instantiate ConfigService first
    const configService = new ConfigService();

    // 2. Instantiate QdrantService with config
    const qdrantService = new QdrantService(configService.getQdrantConnectionString());

    // 3. Instantiate EmbeddingProvider using the factory and config
    // You might have logic here to determine which provider to use (ollama/openai)
    const embeddingProvider = createEmbeddingProvider('ollama', configService); // Example: using ollama

    // 4. Instantiate ContextService with its dependencies
    const contextService = new ContextService(qdrantService, embeddingProvider);

    // 5. Instantiate other core dependencies (if they don't have their own complex dependencies yet)
    const fileWalker = new FileWalker();
    const astParser = new AstParser();
    const chunker = new Chunker();
    const lspService = new LspService();

    // 6. Instantiate IndexingService with all its dependencies
    const indexingService = new IndexingService(
        fileWalker,
        astParser,
        chunker,
        qdrantService,
        embeddingProvider,
        lspService
    );

    // Register commands, etc., using these instantiated services
    // Example:
    // context.subscriptions.push(
    //     vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
    //         indexingService.startIndexing();
    //     })
    // );

    console.log('Code Context Engine extension activated.');
}

export function deactivate() {
    console.log('Code Context Engine extension deactivated.');
}
```

### 4. Updating Unit Tests

**Purpose:** To ensure that services can be tested in isolation by providing mocked dependencies, verifying their logic without relying on the actual VS Code API or other complex services.

**General Approach:**
1.  Create mock classes or objects that implement the interfaces or mimic the behavior of the real dependencies.
2.  In your test setup (e.g., `beforeEach`), instantiate your service under test, passing in these mock objects.
3.  Use your testing framework's assertion capabilities to verify the service's behavior.

**Code Example (`src/test/mocks.ts` - New File):**
```typescript
// src/test/mocks.ts
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { FileWalker } from '../indexing/fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker } from '../parsing/chunker';
import { LspService } from '../lsp/lspService';

// Partial mocks for services that might have methods called by other services
export class MockQdrantService implements Partial<QdrantService> {
    // Example mock method
    async upsertVectors(vectors: any[]): Promise<void> { /* do nothing or return a mock value */ }
    // Add other methods that ContextService or IndexingService might call
}

export class MockEmbeddingProvider implements Partial<IEmbeddingProvider> {
    async embed(text: string): Promise<number[]> {
        return [0.1, 0.2, 0.3]; // Return a dummy embedding
    }
}

// Full mocks for simple dependencies or those not yet refactored with complex logic
export class MockFileWalker implements Partial<FileWalker> {
    // Implement methods if IndexingService calls them
}

export class MockAstParser implements Partial<AstParser> {
    // Implement methods if IndexingService calls them
}

export class MockChunker implements Partial<Chunker> {
    // Implement methods if IndexingService calls them
}

export class MockLspService implements Partial<LspService> {
    // Implement methods if IndexingService calls them
}
```

**Code Example (`src/test/contextService.test.ts` - Update Existing Test File):**
```typescript
// src/test/contextService.test.ts
import { expect } from 'chai'; // Assuming Chai for assertions, adjust for Jest/other
import { ContextService } from '../context/contextService';
import { MockQdrantService, MockEmbeddingProvider } from './mocks';

describe('ContextService', () => {
    let mockQdrantService: MockQdrantService;
    let mockEmbeddingProvider: MockEmbeddingProvider;
    let contextService: ContextService;

    beforeEach(() => {
        // Instantiate mocks before each test
        mockQdrantService = new MockQdrantService();
        mockEmbeddingProvider = new MockEmbeddingProvider();

        // Instantiate ContextService with the mocks
        contextService = new ContextService(
            mockQdrantService as any, // Cast to any if using Partial<T> for mocks
            mockEmbeddingProvider as any
        );
    });

    it('should call qdrantService when querying context', async () => {
        // Example: Mock a method call and assert it was called
        const queryStub = (mockQdrantService as any).query = sinon.stub().returns(Promise.resolve([])); // Assuming Sinon for stubbing

        await contextService.queryContext('test query');

        expect(queryStub.calledOnce).to.be.true;
    });

    it('should use embeddingProvider to embed query', async () => {
        const embedStub = (mockEmbeddingProvider as any).embed = sinon.stub().returns(Promise.resolve([0.1, 0.2, 0.3]));

        await contextService.queryContext('another query');

        expect(embedStub.calledOnceWith('another query')).to.be.true;
    });

    // Add more tests to cover various scenarios and edge cases
});
```

**Further Guidance:**
*   **Testing Frameworks:** If not already set up, consider using a testing framework like Mocha with Chai (for assertions) and Sinon (for stubs/spies) or Jest (all-in-one).
*   **Type Safety with Mocks:** Using `Partial<T>` is a quick way to create mocks, but for more robust testing, consider dedicated mocking libraries or manually implementing the full interface/class for mocks.
*   **Configuration Schema:** For `ConfigService`, consider defining a JSON schema for your extension's configuration in `package.json` to provide validation and IntelliSense for users.
*   **Error Handling:** Ensure proper error handling is in place for configuration retrieval (e.g., default values if a setting is missing).
</file>

<file path="docs/todo/extension/implementation_sub_sprint_2_extension_command_managers.md">
## Implementation Guidance: Sub-Sprint 2 - Extension & Command Managers

This guide details the creation of `ExtensionManager` and `CommandManager` classes to centralize extension lifecycle management and command registration, significantly simplifying `extension.ts`.

### 1. `ExtensionManager` (`src/extensionManager.ts` - New File)

**Purpose:** To act as the main orchestrator for the extension, responsible for instantiating all services and managers, initializing them, and handling their disposal. It becomes the single entry point for the extension's core logic.

**Key Responsibilities:**
-   **Composition Root:** Instantiates all top-level services and managers (e.g., `ConfigService`, `QdrantService`, `IndexingService`, `CommandManager`).
-   **Initialization:** Calls `initialize` methods on its managed components.
-   **Lifecycle Management:** Manages the `vscode.Disposable` objects for all components, ensuring proper cleanup during deactivation.

**Code Example (`src/extensionManager.ts`):**
```typescript
import * as vscode from 'vscode';
import { ConfigService } from './configService';
import { QdrantService } from './db/qdrantService';
import { createEmbeddingProvider, IEmbeddingProvider } from './embeddings/embeddingProvider';
import { ContextService } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { FileWalker } from './indexing/fileWalker';
import { AstParser } from './parsing/astParser';
import { Chunker } from './parsing/chunker';
import { LspService } from './lsp/lspService';
import { CommandManager } from './commandManager';

export class ExtensionManager implements vscode.Disposable {
    private configService: ConfigService;
    private qdrantService: QdrantService;
    private embeddingProvider: IEmbeddingProvider;
    private contextService: ContextService;
    private indexingService: IndexingService;
    private commandManager: CommandManager;

    private disposables: vscode.Disposable[] = [];

    constructor(private context: vscode.ExtensionContext) {
        // Instantiate ConfigService (from Sub-Sprint 1)
        this.configService = new ConfigService();

        // Instantiate QdrantService (from Sub-Sprint 1)
        this.qdrantService = new QdrantService(this.configService.getQdrantConnectionString());

        // Instantiate EmbeddingProvider (from Sub-Sprint 1)
        // The choice of provider (ollama/openai) can be made based on configService
        this.embeddingProvider = createEmbeddingProvider('ollama', this.configService); 

        // Instantiate ContextService (from Sub-Sprint 1)
        this.contextService = new ContextService(this.qdrantService, this.embeddingProvider);

        // Instantiate other core dependencies that IndexingService needs
        const fileWalker = new FileWalker();
        const astParser = new AstParser();
        const chunker = new Chunker();
        const lspService = new LspService();

        // Instantiate IndexingService (from Sub-Sprint 1)
        this.indexingService = new IndexingService(
            fileWalker,
            astParser,
            chunker,
            this.qdrantService,
            this.embeddingProvider,
            lspService
        );

        // Instantiate CommandManager, passing the services it needs to execute commands
        this.commandManager = new CommandManager(this.indexingService /*, other services as they are created */);
    }

    public initialize(): void {
        // Register all commands and collect their disposables
        this.disposables.push(...this.commandManager.registerCommands());

        // Add all collected disposables to the extension's context subscriptions
        // This ensures they are disposed of when the extension deactivates
        this.context.subscriptions.push(...this.disposables);

        console.log('ExtensionManager initialized.');
    }

    public dispose(): void {
        // Dispose of all managed disposables
        this.disposables.forEach(d => d.dispose());
        console.log('ExtensionManager disposed.');
    }
}
```

### 2. `CommandManager` (`src/commandManager.ts` - New File)

**Purpose:** To centralize the registration of all VS Code commands, decoupling this logic from `extension.ts`. It acts as a dispatcher, delegating command execution to the appropriate service.

**Key Responsibilities:**
-   **Command Registration:** Uses `vscode.commands.registerCommand` to register all commands defined by the extension.
-   **Delegation:** Calls methods on the relevant services (e.g., `IndexingService`) to perform the actual command logic.
-   **Disposable Management:** Returns an array of `vscode.Disposable` objects for the registered commands, which `ExtensionManager` will manage.

**Code Example (`src/commandManager.ts`):**
```typescript
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';

export class CommandManager {
    // The constructor receives instances of services that will handle command logic
    constructor(private indexingService: IndexingService) {}

    public registerCommands(): vscode.Disposable[] {
        const disposables: vscode.Disposable[] = [];

        // Register the 'openMainPanel' command
        disposables.push(
            vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                // In Sub-Sprint 3, this will call a method on WebviewManager
                vscode.window.showInformationMessage('Main Panel command executed (placeholder).');
            })
        );

        // Register the 'startIndexing' command
        disposables.push(
            vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
                this.indexingService.startIndexing();
                vscode.window.showInformationMessage('Indexing started via command!');
            })
        );

        // Register the 'openSettings' command
        disposables.push(
            vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                // In Sub-Sprint 3, this will call a method on WebviewManager
                vscode.window.showInformationMessage('Settings command executed (placeholder).');
            })
        );

        // Add more commands as needed

        return disposables;
    }
}
```

### 3. Refactoring `extension.ts`

**Purpose:** To transform `extension.ts` into a lean entry point that primarily instantiates and initializes the `ExtensionManager`, and handles its disposal. This significantly reduces its complexity and improves maintainability.

**Key Changes:**
-   Remove all direct service instantiations.
-   Remove all direct `vscode.commands.registerCommand` calls.
-   The `activate` function will create an instance of `ExtensionManager` and call its `initialize` method.
-   The `deactivate` function will call the `dispose` method on the `ExtensionManager` instance.

**Code Example (`src/extension.ts`):**
```typescript
import * as vscode from 'vscode';
import { ExtensionManager } from './extensionManager';

// Declare extensionManager outside activate/deactivate to maintain its state
let extensionManager: ExtensionManager;

export function activate(context: vscode.ExtensionContext) {
    // Instantiate the main ExtensionManager
    extensionManager = new ExtensionManager(context);

    // Initialize the ExtensionManager, which in turn sets up all services and commands
    extensionManager.initialize();

    console.log('Code Context Engine extension activated successfully.');
}

export function deactivate() {
    // Dispose of the ExtensionManager and all its managed resources
    if (extensionManager) {
        extensionManager.dispose();
    }
    console.log('Code Context Engine extension deactivated.');
}
```

### Further Guidance:

*   **Error Handling:** Consider adding `try-catch` blocks in `ExtensionManager`'s constructor and `initialize` method to gracefully handle errors during service instantiation or command registration.
*   **Logging:** Implement a consistent logging mechanism (e.g., using `vscode.window.showInformationMessage` for user-facing messages, and `console.log` or a dedicated logger for internal debugging) across your managers and services.
*   **Testability:** With `ExtensionManager` and `CommandManager` in place, you can now write unit tests for `CommandManager` by passing mocked service instances to its constructor, verifying that commands are registered correctly and delegate to the right methods.
*   **Dependency Order:** Pay close attention to the order of instantiation in `ExtensionManager`. Services that are dependencies of others must be instantiated first. The current example follows a logical order based on the previous sub-sprint.
*   **`vscode.Disposable`:** Ensure that any objects that implement `vscode.Disposable` (like `WebviewPanel`s, `EventEmitter`s, `FileSystemWatcher`s, etc.) are properly disposed of by adding them to `context.subscriptions` or managing them within your `ExtensionManager`'s `disposables` array.
</file>

<file path="docs/todo/extension/implementation_sub_sprint_3_centralized_webview_management.md">
## Implementation Guidance: Sub-Sprint 3 - Centralized Webview Management

This guide focuses on creating the `WebviewManager` class to centralize all webview panel creation, display, and lifecycle management. This refactoring will clean up command handlers and `extension.ts` by abstracting webview-related logic.

### 1. `WebviewManager` (`src/webviewManager.ts` - New File)

**Purpose:** To encapsulate all logic related to creating, showing, and disposing of webview panels. It ensures that only one instance of a specific panel type (e.g., main panel, settings panel) exists at a time and handles the loading of webview content.

**Key Responsibilities:**
-   **Panel Creation:** Uses `vscode.window.createWebviewPanel` to create new webview instances.
-   **Panel Management:** Keeps track of active panels and brings them to focus if they already exist.
-   **Content Loading:** Reads the `index.html` file from the `webview/dist` directory and correctly resolves local resource URIs for scripts and stylesheets.
-   **Lifecycle:** Handles panel disposal events to clean up references.

**API Information:**
-   `vscode.window.createWebviewPanel(viewType, title, showOptions, options)`: Creates and shows a new webview panel.
-   `panel.reveal(viewColumn)`: Brings the panel to the foreground.
-   `panel.webview.html = content`: Sets the HTML content of the webview.
-   `panel.webview.asWebviewUri(uri)`: Converts a local file URI into a URI that can be loaded by the webview. Essential for loading local scripts, styles, and images.
-   `panel.onDidDispose(() => { ... })`: Event fired when the webview panel is closed by the user or programmatically.
-   `vscode.Uri.file(path)`: Creates a URI from a file system path.
-   `path.join(...)`: Node.js `path` module for joining path segments.
-   `fs.readFileSync(...)`: Node.js `fs` module for reading file content synchronously.

**Code Example (`src/webviewManager.ts`):**
```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs'; // Node.js file system module

export class WebviewManager implements vscode.Disposable {
    private mainPanel: vscode.WebviewPanel | undefined; // Stores the main webview panel instance
    private settingsPanel: vscode.WebviewPanel | undefined; // Stores the settings webview panel instance

    constructor(private context: vscode.ExtensionContext) {}

    /**
     * Generates the HTML content for the webview, resolving local resource URIs.
     * @param webview The webview instance.
     * @param panelName A name to identify the panel type (e.g., 'main', 'settings').
     * @returns The complete HTML string for the webview.
     */
    private getWebviewContent(webview: vscode.Webview, panelName: string): string {
        // Path to the webview's HTML file in the bundled extension
        const htmlPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');
        let htmlContent = fs.readFileSync(htmlPath, 'utf8');

        // Resolve URIs for local webview resources (JS, CSS)
        const scriptUri = webview.asWebviewUri(vscode.Uri.file(
            path.join(this.context.extensionPath, 'webview', 'dist', 'index.js')
        ));
        const styleUri = webview.asWebviewUri(vscode.Uri.file(
            path.join(this.context.extensionPath, 'webview', 'dist', 'styles.css')
        ));

        // Replace placeholders in the HTML with the actual URIs
        // Ensure your index.html has these placeholders, e.g., <script src="{{scriptUri}}"></script>
        htmlContent = htmlContent.replace('{{scriptUri}}', scriptUri.toString());
        htmlContent = htmlContent.replace('{{styleUri}}', styleUri.toString());

        // You can also pass initial data to the webview here, e.g., a global variable
        htmlContent = htmlContent.replace('{{panelName}}', panelName); // Example: pass panel type

        return htmlContent;
    }

    /**
     * Shows or reveals the main webview panel.
     */
    public showMainPanel(): void {
        if (this.mainPanel) {
            // If panel already exists, just reveal it
            this.mainPanel.reveal(vscode.ViewColumn.One);
            return;
        }

        // Create a new webview panel
        this.mainPanel = vscode.window.createWebviewPanel(
            'codeContextEngineMain', // Unique ID for the panel type
            'Code Context Engine',   // Title displayed to the user
            vscode.ViewColumn.One,   // Column to show the panel in
            {
                enableScripts: true, // Enable JavaScript in the webview
                // Restrict the webview to only load resources from the 'webview/dist' directory
                localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
            }
        );

        // Set the HTML content for the webview
        this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, 'main');

        // Handle panel disposal: clear the reference when the panel is closed
        this.mainPanel.onDidDispose(() => {
            this.mainPanel = undefined;
        }, null, this.context.subscriptions); // Add to context subscriptions for automatic disposal
    }

    /**
     * Shows or reveals the settings webview panel.
     */
    public showSettingsPanel(): void {
        if (this.settingsPanel) {
            this.settingsPanel.reveal(vscode.ViewColumn.Two);
            return;
        }

        this.settingsPanel = vscode.window.createWebviewPanel(
            'codeContextEngineSettings',
            'Code Context Settings',
            vscode.ViewColumn.Two,
            {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
            }
        );

        this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, 'settings');

        this.settingsPanel.onDidDispose(() => {
            this.settingsPanel = undefined;
        }, null, this.context.subscriptions);
    }

    /**
     * Disposes of all active webview panels.
     */
    public dispose(): void {
        this.mainPanel?.dispose();
        this.settingsPanel?.dispose();
    }
}
```

### 2. Update `ExtensionManager` (`src/extensionManager.ts`)

**Purpose:** To instantiate the `WebviewManager` and make it accessible to other parts of the extension, particularly the `CommandManager`.

**Code Example (`src/extensionManager.ts` - Partial Update):**
```typescript
// src/extensionManager.ts
import * as vscode from 'vscode';
// ... other imports ...
import { WebviewManager } from './webviewManager'; // New import

export class ExtensionManager implements vscode.Disposable {
    // ... existing private members for services ...
    public webviewManager: WebviewManager; // Make webviewManager public for access by CommandManager
    private commandManager: CommandManager;

    private disposables: vscode.Disposable[] = [];

    constructor(private context: vscode.ExtensionContext) {
        // ... existing service instantiations ...

        // Instantiate WebviewManager, passing the extension context
        this.webviewManager = new WebviewManager(this.context);

        // Instantiate CommandManager, passing the services it needs, including webviewManager
        this.commandManager = new CommandManager(this.indexingService, this.webviewManager);

        // Add webviewManager to disposables if it needs explicit disposal
        this.disposables.push(this.webviewManager);
    }

    // ... initialize and dispose methods ...
}
```

### 3. Update `CommandManager` (`src/commandManager.ts`)

**Purpose:** To delegate the `openMainPanel` and `openSettings` commands to the newly created `WebviewManager`.

**Code Example (`src/commandManager.ts` - Partial Update):**
```typescript
// src/commandManager.ts
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';
import { WebviewManager } from './webviewManager'; // New import

export class CommandManager {
    constructor(private indexingService: IndexingService, private webviewManager: WebviewManager) {}

    public registerCommands(): vscode.Disposable[] {
        const disposables: vscode.Disposable[] = [];

        disposables.push(
            vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                this.webviewManager.showMainPanel(); // Delegate to WebviewManager
            }),
            vscode.commands.registerCommand('code-context-engine.startIndexing', () => {
                this.indexingService.startIndexing();
                vscode.window.showInformationMessage('Indexing started!');
            }),
            vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                this.webviewManager.showSettingsPanel(); // Delegate to WebviewManager
            })
        );

        return disposables;
    }
}
```

### Further Guidance:

*   **`index.html` Placeholders:** Ensure your `webview/dist/index.html` file has the `{{scriptUri}}` and `{{styleUri}}` placeholders where the JavaScript and CSS files should be linked. For example:
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Code Context Engine</title>
        <link rel="stylesheet" href="{{styleUri}}">
    </head>
    <body>
        <div id="root"></div>
        <script src="{{scriptUri}}"></script>
    </body>
    </html>
    ```
*   **Webview Security:** The `localResourceRoots` option in `createWebviewPanel` is crucial for security. It restricts the webview from loading arbitrary local files. Only allow access to the `webview/dist` directory where your bundled webview assets reside.
*   **Message Passing:** While this sub-sprint focuses on webview management, the next sub-sprint will cover communication between the webview and the extension. Be mindful that `WebviewManager` will eventually need to set up `onDidReceiveMessage` listeners and potentially `postMessage` calls.
*   **Error Handling:** Add error handling for `fs.readFileSync` in `getWebviewContent` to gracefully manage cases where the HTML file might not be found.
</file>

<file path="docs/todo/extension/implementation_sub_sprint_4_message_routing_state.md">
## Implementation Guidance: Sub-Sprint 4 - Message Routing & State

This guide focuses on formalizing the communication layer between the webview and the extension's backend, and centralizing the extension's global state. This involves creating `StateManager` and `MessageRouter` classes.

### 1. `StateManager` (`src/stateManager.ts` - New File)

**Purpose:** To provide a centralized, simple mechanism for tracking the global state of the extension. This prevents services from needing to directly query each other for status updates and allows for consistent state checks (e.g., preventing duplicate operations).

**Key Responsibilities:**
-   **State Storage:** Holds simple boolean flags or other primitive state variables.
-   **State Access:** Provides public getter and setter methods for each state property.

**Code Example (`src/stateManager.ts`):**
```typescript
// src/stateManager.ts

export class StateManager {
    private _isIndexing: boolean = false; // Example state: is an indexing operation currently running?
    private _isProcessingQuery: boolean = false; // Example state: is a query being processed?

    /**
     * Checks if an indexing operation is currently in progress.
     */
    public isIndexing(): boolean {
        return this._isIndexing;
    }

    /**
     * Sets the status of the indexing operation.
     * @param state True if indexing is in progress, false otherwise.
     */
    public setIndexing(state: boolean): void {
        this._isIndexing = state;
    }

    /**
     * Checks if a query is currently being processed.
     */
    public isProcessingQuery(): boolean {
        return this._isProcessingQuery;
    }

    /**
     * Sets the status of the query processing operation.
     * @param state True if a query is being processed, false otherwise.
     */
    public setProcessingQuery(state: boolean): void {
        this._isProcessingQuery = state;
    }

    // Add more state properties and their corresponding getters/setters as your extension grows
}
```

### 2. `MessageRouter` (`src/messageRouter.ts` - New File)

**Purpose:** To centralize the handling of messages received from the webview. It acts as a dispatcher, routing messages to the appropriate backend services and sending responses back to the webview. This replaces large `switch` statements in the webview's `onDidReceiveMessage` listener.

**Key Responsibilities:**
-   **Message Listening:** Sets up the `onDidReceiveMessage` listener for a given webview.
-   **Command Routing:** Parses incoming messages and delegates the execution to the correct service method.
-   **Response Handling:** Sends structured responses (including results or errors) back to the webview.
-   **State Integration:** Uses the `StateManager` to check conditions before executing commands.

**API Information:**
-   `webview.onDidReceiveMessage(callback, thisArgs?, disposables?)`: Event fired when the webview posts a message to the extension.
-   `webview.postMessage(message)`: Sends a message from the extension to the webview.

**Code Example (`src/messageRouter.ts`):**
```typescript
// src/messageRouter.ts
import * as vscode from 'vscode';
import { ExtensionManager } from './extensionManager'; // Import the ExtensionManager

export class MessageRouter {
    constructor(
        private extensionManager: ExtensionManager, // Access to all services and managers
        private webview: vscode.Webview
    ) {
        // Set up the listener for messages from the webview
        this.webview.onDidReceiveMessage(async message => {
            await this.routeMessage(message);
        }, undefined, this.extensionManager.context.subscriptions); // Ensure proper disposal
    }

    /**
     * Routes incoming messages from the webview to the appropriate handler.
     * Messages are expected to have a 'command' and optionally 'requestId' and 'payload'.
     */
    private async routeMessage(message: any): Promise<void> {
        const { command, requestId, payload } = message;

        let result: any; // To store the result of the command execution
        let error: string | undefined; // To store any error messages

        try {
            switch (command) {
                case 'startIndexing':
                    // Check state before starting indexing
                    if (this.extensionManager.stateManager.isIndexing()) {
                        throw new Error('Indexing is already in progress. Please wait.');
                    }
                    // Delegate to IndexingService
                    await this.extensionManager.indexingService.startIndexing();
                    result = { success: true, message: 'Indexing initiated.' };
                    break;

                case 'getSettings':
                    // Example: Assuming ConfigService has a method to return settings
                    result = this.extensionManager.configService.getSettings(); 
                    break;

                // Add more cases for other commands from the webview
                // case 'queryContext':
                //     result = await this.extensionManager.contextService.queryContext(payload.query);
                //     break;

                default:
                    throw new Error(`Unknown command: ${command}`);
            }
        } catch (e: any) {
            // Catch any errors during command execution and store the message
            error = e.message;
        }

        // Send a response back to the webview
        this.webview.postMessage({
            command: `${command}Response`, // Convention: commandName + 'Response'
            requestId, // Include requestId to match responses with requests on the webview side
            result,    // The result of the operation
            error      // Any error message
        });
    }
}
```

### 3. Integrate `StateManager` into `ExtensionManager` and Services

**Purpose:** To make the `StateManager` available throughout the extension and ensure services update the state as their operations begin and end.

**a) Update `ExtensionManager` (`src/extensionManager.ts` - Partial Update):**

Instantiate `StateManager` and pass it to services that need to interact with the global state.
```typescript
// src/extensionManager.ts
import * as vscode from 'vscode';
// ... other imports ...
import { StateManager } from './stateManager'; // New import

export class ExtensionManager implements vscode.Disposable {
    // ... existing private members ...
    public stateManager: StateManager; // Make StateManager public for access by MessageRouter and other services

    constructor(private context: vscode.ExtensionContext) {
        // ... existing instantiations ...

        // Instantiate StateManager
        this.stateManager = new StateManager();

        // Pass StateManager to services that need to update or read global state
        this.indexingService = new IndexingService(
            fileWalker,
            astParser,
            chunker,
            this.qdrantService,
            this.embeddingProvider,
            lspService,
            this.stateManager // Pass stateManager here
        );

        // ... other instantiations ...
    }

    // ... initialize and dispose methods ...
}
```

**b) Update `IndexingService` (`src/indexing/indexingService.ts` - Partial Update):**

Modify `IndexingService` to accept `StateManager` in its constructor and update the `isIndexing` state during its `startIndexing` method.
```typescript
// src/indexing/indexingService.ts
import { StateManager } from '../stateManager'; // New import
// ... other imports ...

export class IndexingService {
    constructor(
        private fileWalker: FileWalker,
        private astParser: AstParser,
        private chunker: Chunker,
        private qdrantService: QdrantService,
        private embeddingProvider: IEmbeddingProvider,
        private lspService: LspService,
        private stateManager: StateManager // New dependency
    ) {
        // ...
    }

    public async startIndexing(): Promise<void> {
        this.stateManager.setIndexing(true); // Set state to true when indexing starts
        try {
            console.log('Indexing started...');
            // Simulate actual indexing work
            await new Promise(resolve => setTimeout(resolve, 3000)); 
            console.log('Indexing complete.');
        } catch (error) {
            console.error('Indexing failed:', error);
            throw error; // Re-throw to propagate the error
        } finally {
            this.stateManager.setIndexing(false); // Always set state to false when indexing finishes (success or failure)
        }
    }

    // ... other methods ...
}
```

### 4. Integrate `MessageRouter` into `WebviewManager`

**Purpose:** To replace the direct `onDidReceiveMessage` listener in `WebviewManager` with an instantiation of `MessageRouter`, making the webview communication cleaner and more modular.

**a) Update `WebviewManager` (`src/webviewManager.ts` - Partial Update):**

Modify the `showMainPanel` and `showSettingsPanel` methods to instantiate `MessageRouter` and pass it the `ExtensionManager` and the webview instance.
```typescript
// src/webviewManager.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { ExtensionManager } from './extensionManager'; // Import ExtensionManager
import { MessageRouter } from './messageRouter'; // New import

export class WebviewManager implements vscode.Disposable {
    // ... existing properties ...

    // WebviewManager now needs ExtensionManager to pass to MessageRouter
    constructor(private context: vscode.ExtensionContext, private extensionManager: ExtensionManager) {}

    // ... getWebviewContent method ...

    public showMainPanel(): void {
        if (this.mainPanel) {
            this.mainPanel.reveal(vscode.ViewColumn.One);
            return;
        }

        this.mainPanel = vscode.window.createWebviewPanel(
            'codeContextEngineMain',
            'Code Context Engine',
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
            }
        );

        this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, 'main');

        // Instantiate MessageRouter for this panel
        new MessageRouter(this.extensionManager, this.mainPanel.webview);

        this.mainPanel.onDidDispose(() => {
            this.mainPanel = undefined;
        }, null, this.context.subscriptions);
    }

    public showSettingsPanel(): void {
        if (this.settingsPanel) {
            this.settingsPanel.reveal(vscode.ViewColumn.Two);
            return;
        }

        this.settingsPanel = vscode.window.createWebviewPanel(
            'codeContextEngineSettings',
            'Code Context Settings',
            vscode.ViewColumn.Two,
            {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
            }
        );

        this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, 'settings');

        // Instantiate MessageRouter for this panel
        new MessageRouter(this.extensionManager, this.settingsPanel.webview);

        this.settingsPanel.onDidDispose(() => {
            this.settingsPanel = undefined;
        }, null, this.context.subscriptions);
    }

    // ... dispose method ...
}
```

**b) Update `ExtensionManager` (`src/extensionManager.ts` - Partial Update):**

Modify `ExtensionManager`'s constructor to pass itself to `WebviewManager`.
```typescript
// src/extensionManager.ts
import * as vscode from 'vscode';
// ... other imports ...
import { WebviewManager } from './webviewManager';

export class ExtensionManager implements vscode.Disposable {
    // ... existing private members ...

    constructor(private context: vscode.ExtensionContext) {
        // ... existing instantiations ...

        // Instantiate WebviewManager, passing the extension context AND itself (this)
        this.webviewManager = new WebviewManager(this.context, this);

        // ... existing commandManager instantiation ...
    }

    // ... initialize and dispose methods ...
}
```

### Further Guidance:

*   **Webview-Side Communication:** On the webview (frontend) side, you'll need to use `vscode.postMessage` to send messages to the extension and listen for responses. A common pattern is to have a utility function that wraps `postMessage` and returns a Promise that resolves when a corresponding response is received (matching `requestId`).
*   **Error Handling:** Implement robust error handling in `MessageRouter` and ensure that errors are clearly communicated back to the webview. Consider different error types (e.g., validation errors, service errors).
*   **Message Structure:** Define a clear message structure for communication between the webview and extension (e.g., `{ command: string, requestId?: string, payload?: any }` for requests and `{ command: string, requestId?: string, result?: any, error?: string }` for responses).
*   **State Granularity:** The `StateManager` is kept simple here. For more complex state management, consider libraries like Redux or MobX, but for most VS Code extensions, a simple custom `StateManager` is sufficient.
*   **Disposables:** Ensure that any `onDidReceiveMessage` listeners are properly disposed of when the webview panel is closed to prevent memory leaks. The `MessageRouter` handles this by adding its listener to `extensionManager.context.subscriptions`.
</file>

<file path="docs/todo/extension/prd.md">
<prd>Of course. Based on the technical debt analysis and the goal of making the extension more robust, I've broken down the refactoring effort into two distinct, sequential phases. The first phase will focus on foundational backend decoupling, and the second will address the webview and communication layers.

Here are the PRDs for this initiative.

-----

### **New Document: PRD 1: Foundational - Backend Decoupling & Refactoring**

**1. Title & Overview**

  * **Project:** Code Context Engine - Backend Refactoring
  * **Summary:** This phase addresses critical technical debt in the extension's backend. We will refactor the core services to use Dependency Injection (DI) for managing dependencies and centralize configuration handling. We will also begin decoupling the monolithic `extension.ts` file by creating dedicated managers for commands and overall extension lifecycle, establishing a more scalable and testable architecture.
  * **Dependencies:** Requires the existing codebase to be stable and all current features to be functional.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Increase development velocity for future features by creating a more maintainable and understandable codebase.
      * Improve the overall stability and reliability of the extension by reducing tight coupling and side effects.
  * **Developer & System Success Metrics:**
      * Core services (`IndexingService`, `ContextService`, etc.) no longer instantiate their own dependencies.
      * Configuration is read from a single, centralized source and passed to services.
      * Unit test coverage for core services increases by at least 50%, as they can now be tested in isolation with mocked dependencies.
      * The `extension.ts` file is significantly smaller, with its primary responsibilities delegated to new manager classes.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha needs to add new features and fix bugs efficiently. A decoupled architecture allows her to work on individual components without understanding the entire system and to write reliable unit tests for her changes.
  * **Devin (Developer - End User):** While this is a backend refactor, Devin will benefit from the increased stability and faster feature development that results from a cleaner codebase.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Refactoring** | **Sprint 1: Dependency & Config Mgmt** | As Alisha, I want to refactor services to receive dependencies via their constructor so I can unit test them with mocks. | 1. `IndexingService` and `ContextService` constructors are updated to accept dependencies like `QdrantService` and `IEmbeddingProvider`.\<br/\>2. The services no longer use the `new` keyword to create their own dependencies.\<br/\>3. Existing unit tests are updated, and new tests are added to verify service logic with mocked dependencies. | **2 Weeks** |
| | | As Alisha, I want to create a central configuration service so that settings are managed in one place. | 1. A new `ConfigService` is created that reads all settings from `vscode.workspace.getConfiguration()` on startup.\<br/\>2. Services that require configuration (e.g., `QdrantService`) receive the necessary values (like a connection string) via their constructor.\<br/\>3. Services no longer call `vscode.workspace.getConfiguration()` directly. | |
| **Phase 1: Refactoring** | **Sprint 2: Lifecycle & Command Mgmt** | As Alisha, I want to introduce an `ExtensionManager` to handle the extension's lifecycle so that `extension.ts` becomes a simple entry point. | 1. A new `ExtensionManager` class is created to manage the initialization and disposal of all services and managers.\<br/\>2. The `activate` function in `extension.ts` is reduced to creating and initializing the `ExtensionManager`.\<br/\>3. The `deactivate` function calls a `dispose` method on the `ExtensionManager`. | **2 Weeks** |
| | | As Alisha, I want to create a `CommandManager` to handle all command registrations so that this logic is decoupled from the main activation file. | 1. A new `CommandManager` class is created.\<br/\>2. All `vscode.commands.registerCommand` calls are moved from `extension.ts` into the `CommandManager`.\<br/\>3. The `CommandManager` delegates the command's execution logic to the appropriate service (e.g., `IndexingService.startIndexing`).\<br/\>4. The `ExtensionManager` is responsible for creating and initializing the `CommandManager`. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** Dependency & Configuration Management (2 Weeks)
  * **Sprint 2:** Lifecycle & Command Management (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The current feature set is well-understood, allowing for a safe refactoring process without introducing regressions.
  * **Risk:** The refactoring effort might take longer than estimated if unforeseen complexities arise in the existing code.
      * **Mitigation:** Prioritize a "lift and shift" approach initially. Move existing logic into new classes without significantly altering the logic itself. Deeper refactoring of the logic can be a separate, future task.
  * **Risk:** Improperly managing the lifecycle of services and disposables in the new manager classes could lead to memory leaks.
      * **Mitigation:** Implement a clear `dispose` pattern in all manager classes and ensure the top-level `ExtensionManager` correctly calls `dispose` on all its managed components.

-----

### **New Document: Sub-Sprint 1: Dependency Injection & Centralized Config**

**Objective:**
To refactor all core services to use constructor-based dependency injection and to receive configuration from a centralized source.

**Parent Sprint:**
PRD 1, Sprint 1: Dependency & Config Mgmt

**Tasks:**

1.  **Create `ConfigService.ts`:** Develop a service that loads all extension settings from `vscode.workspace.getConfiguration()` once and provides them via getter methods.
2.  **Refactor `QdrantService`:** Update its constructor to accept the database connection string directly.
3.  **Refactor `EmbeddingProvider` implementations:** Update their constructors to accept necessary parameters (e.g., API keys, model names).
4.  **Refactor `IndexingService` & `ContextService`:** Update their constructors to accept instances of their dependencies (e.g., `qdrantService`, `embeddingProvider`, `configService`).
5.  **Update Unit Tests:** Modify existing tests to pass mocked dependencies to the service constructors, improving test isolation.

**Acceptance Criteria:**

  * No service uses the `new` keyword to create its long-lived dependencies.
  * No service directly calls `vscode.workspace.getConfiguration()`.
  * Unit tests for services can run without needing the VS Code API.

**Dependencies:**

  * A clear understanding of the existing service dependencies.

**Timeline:**

  * **Start Date:** 2025-08-25
  * **End Date:** 2025-09-05

-----

### **New Document: Sub-Sprint 2: Extension & Command Managers**

**Objective:**
To create the initial `ExtensionManager` and `CommandManager` classes, moving the core lifecycle and command registration logic out of `extension.ts`.

**Parent Sprint:**
PRD 1, Sprint 2: Lifecycle & Command Mgmt

**Tasks:**

1.  **Create `ExtensionManager.ts`:** This class will have an `initialize` method where it instantiates all services (using the DI pattern from Sub-Sprint 1) and managers. It will also have a `dispose` method.
2.  **Create `CommandManager.ts`:** This class will have a constructor that accepts the `ExtensionManager` instance (to access services) and a `registerCommands` method.
3.  **Move Command Logic:** Transfer all `vscode.commands.registerCommand` calls from `extension.ts` to `CommandManager.registerCommands`.
4.  **Refactor `extension.ts`:** Simplify `activate` to only `new ExtensionManager(context).initialize()`. Simplify `deactivate` to call `extensionManager.dispose()`.

**Acceptance Criteria:**

  * The `extension.ts` file is less than 50 lines of code.
  * All previously functional commands are still registered and work correctly.
  * The extension activates and deactivates cleanly without errors.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2025-09-08
  * **End Date:** 2025-09-19

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Dependency & Config Mgmt

**Goal:** To refactor core services to eliminate tight coupling and centralize configuration management, improving testability and maintainability.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Create `ConfigService.ts`:** Create the file and implement a class that reads all settings from `vscode.workspace.getConfiguration('code-context-engine')` in its constructor and stores them in private properties with public getters. | `src/configService.ts` (New) |
| **1.2** |  To Do | **Refactor `QdrantService`:** Modify the constructor to accept `connectionString: string`. Remove the `getConfiguration` call. | `src/db/qdrantService.ts` |
| **1.3** |  To Do | **Refactor `OllamaProvider`:** Modify the constructor to accept `config: OllamaConfig` object. Remove the `getConfiguration` call. | `src/embeddings/ollamaProvider.ts` |
| **1.4** |  To Do | **Refactor `OpenAIProvider`:** Modify the constructor to accept `config: OpenAIConfig` object. Remove the `getConfiguration` call. | `src/embeddings/openaiProvider.ts` |
| **1.5** |  To Do | **Refactor `EmbeddingProviderFactory`:** Update the factory to accept the `ConfigService` and pass the correct configuration down to the provider it creates. | `src/embeddings/embeddingProvider.ts` |
| **1.6** |  To Do | **Refactor `ContextService`:** Modify the constructor to accept `qdrantService: QdrantService` and `embeddingProvider: IEmbeddingProvider` as arguments. Remove the `new` keywords. | `src/context/contextService.ts` |
| **1.7** |  To Do | **Refactor `IndexingService`:** Modify the constructor to accept its dependencies (`fileWalker`, `astParser`, `chunker`, `qdrantService`, `embeddingProvider`, `lspService`) as arguments. Remove the `new` keywords. | `src/indexing/indexingService.ts` |
| **1.8** |  To Do | **Create Test Mocks:** Create mock implementations for `QdrantService` and `IEmbeddingProvider` for use in unit tests. | `src/test/mocks.ts` (New) |
| **1.9** |  To Do | **Update `ContextService` Tests:** Write/update unit tests for `ContextService`, passing in the mocked dependencies to its constructor. | `src/test/contextService.test.ts` |

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Lifecycle & Command Mgmt

**Goal:** To decouple the main `extension.ts` file by creating dedicated managers for the extension's lifecycle and command registration.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Create `CommandManager.ts`:** Create the new file and `CommandManager` class. It should have a constructor that accepts the `ExtensionManager` and a `registerCommands` method. | `src/commandManager.ts` (New) |
| **2.2** |  To Do | **Move `openMainPanel` Command:** Move the `registerCommand` logic for `code-context-engine.openMainPanel` from `extension.ts` to `CommandManager`. The callback will call a method on the `WebviewManager` (to be created in the next PRD). | `src/commandManager.ts`, `src/extension.ts` |
| **2.3** |  To Do | **Move `startIndexing` Command:** Move the `registerCommand` logic for `code-context-engine.startIndexing` to `CommandManager`. The callback will call `indexingService.startIndexing()`. | `src/commandManager.ts`, `src/extension.ts` |
| **2.4** |  To Do | **Move `openSettings` Command:** Move the `registerCommand` logic for `code-context-engine.openSettings` to `CommandManager`. The callback will call a method on the `WebviewManager`. | `src/commandManager.ts`, `src/extension.ts` |
| **2.5** |  To Do | **Create `ExtensionManager.ts`:** Create the new file and `ExtensionManager` class. Its constructor will instantiate all services (using DI) and managers. | `src/extensionManager.ts` (New) |
| **2.6** |  To Do | **Implement `initialize` Method:** In `ExtensionManager`, the `initialize` method will call `commandManager.registerCommands()`. | `src/extensionManager.ts` |
| **2.7** |  To Do | **Implement `dispose` Method:** In `ExtensionManager`, the `dispose` method will call `dispose` on any disposable managers (like `CommandManager`). | `src/extensionManager.ts` |
| **2.8** |  To Do | **Refactor `extension.ts`:** Remove all command registration and service instantiation logic. The `activate` function should now only create and initialize an `ExtensionManager`. | `src/extension.ts` |
| **2.9** |  To Do | **Refactor `deactivate`:** The `deactivate` function in `extension.ts` should now only call `extensionManager.dispose()`. | `src/extension.ts` |
Of course. Here is the final PRD to complete the technical debt and refactoring initiative.

-----

### **New Document: PRD 2: Advanced Refactoring - Webview & Communication**

**1. Title & Overview**

  * **Project:** Code Context Engine - Webview & Communication Refactoring
  * **Summary:** This phase completes the decoupling of `extension.ts` by creating dedicated managers for webview lifecycle and message routing. A `WebviewManager` will centralize the logic for creating, showing, and disposing of all webview panels. A `MessageRouter` will handle all communication between the webview and the extension's backend services, creating a clean and robust communication layer.
  * **Dependencies:** PRD 1 (Backend Decoupling & Refactoring) must be complete. The `ExtensionManager` and `CommandManager` should be in place.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Finalize the architectural refactoring to create a fully modular, scalable, and maintainable codebase.
      * Improve the reliability of the UI and its communication with the backend, leading to a better user experience.
  * **Developer & System Success Metrics:**
      * `extension.ts` is purely an activator and contains no direct webview or message handling logic.
      * All webview panel creation and management logic is consolidated within the `WebviewManager`.
      * The large `switch` statement for message handling is replaced by the `MessageRouter`, which cleanly delegates tasks to the appropriate services.
      * Adding a new webview or a new message command is a simple, low-risk operation that requires changes in only one or two focused files.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha can now add new commands and backend logic without ever needing to touch the UI or communication layers. Her work is isolated to the services she owns.
  * **Frank (Frontend Developer):** Frank works on the SvelteKit UI. He now has a single, predictable `MessageRouter` to interact with. He doesn't need to know which backend service implements a feature; he just sends a command, and the router handles the rest.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Refactoring** | **Sprint 3: Webview Management** | As a developer, I want to create a `WebviewManager` to handle the lifecycle of all webview panels so that UI creation logic is centralized and reusable. | 1. A new `WebviewManager` class is created. \<br/\> 2. All `vscode.window.createWebviewPanel` logic is moved from `extension.ts` (or `CommandManager`) into the `WebviewManager`. \<br/\> 3. The manager handles showing the main panel and the settings panel, ensuring only one of each can exist at a time. \<br/\> 4. The manager is responsible for panel disposal and is properly disposed of by the `ExtensionManager`. | **2 Weeks** |
| | | As Frank, I want the `WebviewManager` to be responsible for providing the correct HTML content so that the webview loading process is standardized. | 1. The logic for reading the `index.html` file from the `webview/dist` directory is moved into a private method in `WebviewManager`. \<br/\> 2. The method correctly replaces asset paths with `webview.asWebviewUri` to ensure CSS and JS files load correctly. \<br/\> 3. The `showMainPanel` and `showSettingsPanel` methods use this helper to set the panel's HTML. | |
| **Phase 2: Refactoring** | **Sprint 4: Communication & State Mgmt** | As a developer, I want to create a `MessageRouter` to handle all incoming messages from the webview so that communication logic is decoupled and clean. | 1. A new `MessageRouter` class is created. \<br/\> 2. The `onDidReceiveMessage` listener for each webview is set up to delegate to an instance of the `MessageRouter`. \<br/\> 3. The `MessageRouter`'s `routeMessage` method contains the `switch` statement that calls the appropriate service based on the message command. \<br/\> 4. The router sends results back to the webview with a consistent response format (e.g., `{ command, requestId, result, error }`). | **2 Weeks** |
| | | As Alisha, I want to introduce a basic `StateManager` to track the global state of the extension so that services don't need to communicate directly with each other for status updates. | 1. A new `StateManager` class is created to hold simple boolean flags (e.g., `isIndexing`, `isBackendHealthy`). \<br/\> 2. Services can update the state via the manager (e.g., `stateManager.setIndexing(true)`). \<br/\> 3. The `MessageRouter` can query the state to prevent conflicting actions (e.g., don't start a new index if `isIndexing` is true). | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 3:** Webview Management (2 Weeks)
  * **Sprint 4:** Communication & State Management (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The message-passing API between the webview and the extension is stable and performant enough for all communication needs.
  * **Risk:** Incorrectly managing panel/webview lifecycles in the `WebviewManager` could lead to memory leaks or "ghost" panels that are not properly disposed of.
      * **Mitigation:** Ensure that the `onDidDispose` event for every created panel is correctly handled and that all disposables are added to the extension's context subscriptions.
  * **Risk:** The `StateManager` could become a complex bottleneck if too much logic is added to it.
      * **Mitigation:** Keep the initial `StateManager` extremely simple, holding only essential, global boolean flags. Avoid putting business logic into the state manager itself; its only job is to store and retrieve state.

-----

### **New Document: Sub-Sprint 3: Centralized Webview Management**

**Objective:**
To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, cleaning up the command handlers and `extension.ts`.

**Parent Sprint:**
PRD 2, Sprint 3: Webview Management

**Tasks:**

1.  **Create `WebviewManager.ts`:** Develop the new class with a constructor that accepts the `vscode.ExtensionContext`.
2.  **Implement `showMainPanel`:** Create a method that contains the logic for creating and showing the main webview panel. It should ensure only one instance of the main panel can exist.
3.  **Implement `showSettingsPanel`:** Create a method that contains the logic for creating and showing the settings webview panel.
4.  **Implement `getWebviewContent`:** Create a private helper method that reads the `index.html`, prepares it with the correct URIs for webview assets, and returns the HTML string.
5.  **Refactor `CommandManager`:** Update the callbacks for the `openMainPanel` and `openSettings` commands to simply call the appropriate methods on the `WebviewManager` instance.

**Acceptance Criteria:**

  * All `vscode.window.createWebviewPanel` calls are located exclusively within `WebviewManager.ts`.
  * The `openMainPanel` and `openSettings` commands correctly open their respective UIs.
  * Attempting to open a panel that is already open simply brings the existing panel into focus.

**Dependencies:**

  * `CommandManager` from PRD 1 must be implemented.

**Timeline:**

  * **Start Date:** 2025-09-22
  * **End Date:** 2025-10-03

-----

### **New Document: Sub-Sprint 4: Message Routing & State**

**Objective:**
To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

**Parent Sprint:**
PRD 2, Sprint 4: Communication & State Mgmt

**Tasks:**

1.  **Create `StateManager.ts`:** Develop a simple class with private properties (e.g., `_isIndexing = false`) and public getter/setter methods.
2.  **Create `MessageRouter.ts`:** Develop the class with a constructor that accepts the `ExtensionManager` (to access all services and managers) and the `vscode.Webview`. The constructor will set up the `onDidReceiveMessage` listener.
3.  **Implement `routeMessage` method:** Move the message-handling `switch` statement from `extension.ts` into this private method within the `MessageRouter`.
4.  **Integrate `StateManager`:** In the `MessageRouter`, check the state before delegating actions. For example: `if (this.stateManager.isIndexing) { /* return error */ }`.
5.  **Update Services:** Modify services like `IndexingService` to update the central state (e.g., `this.stateManager.setIndexing(true)` at the start and `false` at the end).
6.  **Integrate `MessageRouter`:** In `WebviewManager`, when a panel is created, instantiate a `MessageRouter` for it, passing in the necessary dependencies.

**Acceptance Criteria:**

  * The `onDidReceiveMessage` listener in `WebviewManager` is a single line that instantiates and uses the `MessageRouter`.
  * The `MessageRouter` correctly routes commands to the appropriate services.
  * Attempting to start a new indexing job while one is already running is gracefully rejected with an error message sent back to the UI.

**Dependencies:**

  * Sub-Sprint 3 must be complete.

**Timeline:**

  * **Start Date:** 2025-10-06
  * **End Date:** 2025-10-17

-----

### **New Document: tasklist\_sprint\_03.md**

# Task List: Sprint 3 - Webview Management

**Goal:** To centralize all webview creation and lifecycle logic into a dedicated `WebviewManager` class.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Create `WebviewManager.ts`:** Create the new file and the `WebviewManager` class structure with a constructor and a `dispose` method. | `src/webviewManager.ts` (New) |
| **3.2** |  To Do | **Implement `getWebviewContent`:** Create a private helper method that takes a webview instance, reads `webview/dist/index.html`, replaces asset paths using `webview.asWebviewUri`, and returns the final HTML string. | `src/webviewManager.ts` |
| **3.3** |  To Do | **Implement `showMainPanel`:** Create a public method that checks if a main panel instance already exists. If not, it calls `vscode.window.createWebviewPanel`, sets its HTML using the helper, and stores the instance. If it exists, it calls `.reveal()`. | `src/webviewManager.ts` |
| **3.4** |  To Do | **Implement `showSettingsPanel`:** Create a public method with the same logic as `showMainPanel`, but for the settings UI, using a different panel ID and title. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Handle Panel Disposal:** In the `show...` methods, add the `onDidDispose` listener to the created panel to nullify the stored instance variable (e.g., `this.mainPanel = undefined`). | `src/webviewManager.ts` |
| **3.6** |  To Do | **Update `ExtensionManager`:** Instantiate the `WebviewManager` in the `ExtensionManager`'s constructor. | `src/extensionManager.ts` |
| **3.7** |  To Do | **Refactor `CommandManager`:** Change the `openMainPanel` and `openSettings` command callbacks to call `extensionManager.webviewManager.showMainPanel()` and `showSettingsPanel()` respectively. | `src/commandManager.ts` |

-----

### **New Document: tasklist\_sprint\_04.md**

# Task List: Sprint 4 - Communication & State Mgmt

**Goal:** To formalize the webview communication layer with a `MessageRouter` and centralize global state with a `StateManager`.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `StateManager.ts`:** Create the new file and a simple `StateManager` class. Add a private boolean `_isIndexing` and public `isIndexing()` getter and `setIndexing(state: boolean)` setter. | `src/stateManager.ts` (New) |
| **4.2** |  To Do | **Create `MessageRouter.ts`:** Create the new file and the `MessageRouter` class. Its constructor will accept the `ExtensionManager` and `vscode.Webview`. | `src/messageRouter.ts` (New) |
| **4.3** |  To Do | **Implement `routeMessage`:** Move the message handling `switch` statement into a private `async routeMessage` method in `MessageRouter`. | `src/messageRouter.ts` |
| **4.4** |  To Do | **Integrate State Check:** In `routeMessage`, before the `startIndexing` case, add a check: `if (this.extensionManager.stateManager.isIndexing()) { ... post error message ... }`. | `src/messageRouter.ts` |
| **4.5** |  To Do | **Update `IndexingService`:** Inject the `StateManager` instance into the `IndexingService`. Call `this.stateManager.setIndexing(true)` at the beginning of `startIndexing` and `false` in a `finally` block at the end. | `src/indexing/indexingService.ts` |
| **4.6** |  To Do | **Instantiate `MessageRouter`:** In `WebviewManager`, when a panel is created, remove the old `onDidReceiveMessage` logic and replace it with `new MessageRouter(this.extensionManager, this.mainPanel.webview)`. | `src/webviewManager.ts` |
| **4.7** |  To Do | **Instantiate `StateManager`:** In `ExtensionManager`, create a public instance of the `StateManager` so it can be accessed by other services. | `src/extensionManager.ts` |
| **4.8** |  To Do | **Update Service Constructors:** Update the constructors of services (like `IndexingService`) that now need the `StateManager`, and update the instantiation logic in `ExtensionManager`. | `src/extensionManager.ts`, `src/indexing/indexingService.ts` |

This completes the full set of PRDs for the refactoring initiative. You now have a comprehensive plan to transform your extension's architecture into a more robust, maintainable, and scalable system.

</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/extension/tasklist_sprint_01.md">
# Task List: Sub-Sprint 1 - Dependency Injection & Centralized Config

**Goal:** To refactor all core services to use constructor-based dependency injection and to receive configuration from a centralized source, improving testability and maintainability.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Create `ConfigService.ts`:** Create the file `src/configService.ts`. Implement a class that reads all extension settings from `vscode.workspace.getConfiguration('code-context-engine')` in its constructor and stores them in private properties with public getter methods for each configuration item (e.g., `getQdrantConnectionString()`, `getOllamaConfig()`, `getOpenAIConfig()`). | `src/configService.ts` (New) |
| **1.2** |  To Do | **Refactor `QdrantService` Constructor:** Open `src/db/qdrantService.ts`. Modify the constructor to accept `connectionString: string` as a parameter. Remove any direct calls to `vscode.workspace.getConfiguration()` within this service. | `src/db/qdrantService.ts` |
| **1.3** |  To Do | **Refactor `OllamaProvider` Constructor:** Open `src/embeddings/ollamaProvider.ts`. Modify the constructor to accept a `config: OllamaConfig` object as a parameter. Define the `OllamaConfig` interface if it doesn't exist. Remove any direct calls to `vscode.workspace.getConfiguration()` within this service. | `src/embeddings/ollamaProvider.ts` |
| **1.4** |  To Do | **Refactor `OpenAIProvider` Constructor:** Open `src/embeddings/openaiProvider.ts`. Modify the constructor to accept a `config: OpenAIConfig` object as a parameter. Define the `OpenAIConfig` interface if it doesn't exist. Remove any direct calls to `vscode.workspace.getConfiguration()` within this service. | `src/embeddings/openaiProvider.ts` |
| **1.5** |  To Do | **Update `EmbeddingProviderFactory`:** Open `src/embeddings/embeddingProvider.ts` (or wherever your factory is located). Modify the factory function/class to accept an instance of `ConfigService`. Use the `ConfigService` to retrieve the appropriate configuration (e.g., `configService.getOllamaConfig()`) and pass it to the `OllamaProvider` or `OpenAIProvider` constructor when creating an instance. | `src/embeddings/embeddingProvider.ts` |
| **1.6** |  To Do | **Refactor `ContextService` Constructor:** Open `src/context/contextService.ts`. Modify the constructor to accept `qdrantService: QdrantService` and `embeddingProvider: IEmbeddingProvider` as parameters. Remove any `new` keyword usages for these dependencies within the constructor. | `src/context/contextService.ts` |
| **1.7** |  To Do | **Refactor `IndexingService` Constructor:** Open `src/indexing/indexingService.ts`. Modify the constructor to accept all its dependencies (`fileWalker`, `astParser`, `chunker`, `qdrantService`, `embeddingProvider`, `lspService`, and `configService` if needed) as parameters. Remove any `new` keyword usages for these dependencies within the constructor. | `src/indexing/indexingService.ts` |
| **1.8** |  To Do | **Create Test Mocks File:** Create a new file `src/test/mocks.ts`. Implement mock classes or objects for `QdrantService`, `IEmbeddingProvider`, `FileWalker`, `AstParser`, `Chunker`, and `LspService` that can be used in unit tests. These mocks should implement the necessary methods that the services under test will call. | `src/test/mocks.ts` (New) |
| **1.9** |  To Do | **Update `ContextService` Unit Tests:** Open `src/test/contextService.test.ts`. Modify existing unit tests to instantiate `ContextService` with the newly created mock dependencies (e.g., `new ContextService(new MockQdrantService(), new MockEmbeddingProvider())`). Add new tests to verify `ContextService` logic using these mocks, ensuring it does not rely on the actual VS Code API. | `src/test/contextService.test.ts` |
| **1.10** |  To Do | **Update `IndexingService` Unit Tests:** Open `src/test/indexingService.test.ts` (if it exists, otherwise create it). Modify existing unit tests or create new ones to instantiate `IndexingService` with the newly created mock dependencies. Verify `IndexingService` logic using these mocks. | `src/test/indexingService.test.ts` (New/Modify) |
| **1.11** |  To Do | **Update `extension.ts` for Initial Wiring:** Open `src/extension.ts`. In the `activate` function, instantiate `ConfigService`. Then, use the `ConfigService` instance to retrieve configuration values and pass them to the constructors of `QdrantService`, `OllamaProvider`, `OpenAIProvider`, `ContextService`, and `IndexingService` during their instantiation. Ensure all services are correctly wired together. | `src/extension.ts` |
</file>

<file path="docs/todo/extension/tasklist_sprint_02.md">
# Task List: Sub-Sprint 2 - Extension & Command Managers

**Goal:** To create the initial `ExtensionManager` and `CommandManager` classes, moving the core lifecycle and command registration logic out of `extension.ts`.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Create `ExtensionManager.ts` File:** Create the new file `src/extensionManager.ts`. Define the `ExtensionManager` class. Its constructor should accept `vscode.ExtensionContext`. Implement an `initialize()` method where all core services (e.g., `ConfigService`, `QdrantService`, `IndexingService`, `ContextService`) are instantiated using the Dependency Injection pattern established in Sub-Sprint 1. Implement a `dispose()` method to clean up resources. | `src/extensionManager.ts` (New) |
| **2.2** |  To Do | **Create `CommandManager.ts` File:** Create the new file `src/commandManager.ts`. Define the `CommandManager` class. Its constructor should accept instances of services it needs to interact with (e.g., `IndexingService`). Implement a `registerCommands()` method that will contain all `vscode.commands.registerCommand` calls and return an array of `vscode.Disposable` objects. | `src/commandManager.ts` (New) |
| **2.3** |  To Do | **Move `openMainPanel` Command:** Open `src/extension.ts`. Locate the `vscode.commands.registerCommand` call for `code-context-engine.openMainPanel`. Cut this entire registration. Paste it into the `registerCommands()` method of `src/commandManager.ts`. For now, the callback can show a simple `vscode.window.showInformationMessage('Open Main Panel (placeholder)');`. | `src/extension.ts`, `src/commandManager.ts` |
| **2.4** |  To Do | **Move `startIndexing` Command:** Open `src/extension.ts`. Locate the `vscode.commands.registerCommand` call for `code-context-engine.startIndexing`. Cut this entire registration. Paste it into the `registerCommands()` method of `src/commandManager.ts`. The callback should call `this.indexingService.startIndexing()`. | `src/extension.ts`, `src/commandManager.ts` |
| **2.5** |  To Do | **Move `openSettings` Command:** Open `src/extension.ts`. Locate the `vscode.commands.registerCommand` call for `code-context-engine.openSettings`. Cut this entire registration. Paste it into the `registerCommands()` method of `src/commandManager.ts`. For now, the callback can show a simple `vscode.window.showInformationMessage('Open Settings (placeholder)');`. | `src/extension.ts`, `src/commandManager.ts` |
| **2.6** |  To Do | **Instantiate `CommandManager` in `ExtensionManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, instantiate `CommandManager`, passing it the necessary service instances (e.g., `this.indexingService`). In the `initialize()` method, call `this.commandManager.registerCommands()` and add the returned disposables to `this.disposables` array. | `src/extensionManager.ts` |
| **2.7** |  To Do | **Refactor `extension.ts` - `activate` Function:** Open `src/extension.ts`. Simplify the `activate` function. It should now only instantiate `ExtensionManager` (passing `context`) and then call its `initialize()` method. Remove all direct service instantiations and command registrations from `activate`. | `src/extension.ts` |
| **2.8** |  To Do | **Refactor `extension.ts` - `deactivate` Function:** Open `src/extension.ts`. Simplify the `deactivate` function. It should now only call `extensionManager.dispose()` (assuming `extensionManager` is a module-scoped variable). | `src/extension.ts` |
| **2.9** |  To Do | **Verify `extension.ts` Line Count:** Ensure that after refactoring, the `src/extension.ts` file contains less than 50 lines of code. | `src/extension.ts` |
</file>

<file path="docs/todo/extension/tasklist_sprint_03.md">
# Task List: Sub-Sprint 3 - Centralized Webview Management

**Goal:** To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, cleaning up the command handlers and `extension.ts`.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Create `WebviewManager.ts` File:** Create the new file `src/webviewManager.ts`. Define the `WebviewManager` class. Its constructor should accept `vscode.ExtensionContext`. Include private properties to hold references to `mainPanel` and `settingsPanel` (both `vscode.WebviewPanel | undefined`). Implement a `dispose()` method to clean up these panels. | `src/webviewManager.ts` (New) |
| **3.2** |  To Do | **Implement `getWebviewContent` Helper:** In `src/webviewManager.ts`, create a private helper method `getWebviewContent(webview: vscode.Webview, panelName: string): string`. This method should read `webview/dist/index.html` using `fs.readFileSync()`. It must then replace placeholders (e.g., `{{scriptUri}}`, `{{styleUri}}`) with URIs generated by `webview.asWebviewUri()` for `webview/dist/index.js` and `webview/dist/styles.css`. | `src/webviewManager.ts` |
| **3.3** |  To Do | **Implement `showMainPanel` Method:** In `src/webviewManager.ts`, create a public method `showMainPanel(): void`. This method should check if `this.mainPanel` already exists. If it does, call `this.mainPanel.reveal(vscode.ViewColumn.One)` and return. If not, create a new `vscode.WebviewPanel` using `vscode.window.createWebviewPanel()`, set its `webview.html` using `getWebviewContent()`, and store the panel in `this.mainPanel`. Add an `onDidDispose` listener to the panel to set `this.mainPanel` back to `undefined` when the panel is closed. | `src/webviewManager.ts` |
| **3.4** |  To Do | **Implement `showSettingsPanel` Method:** In `src/webviewManager.ts`, create a public method `showSettingsPanel(): void`. This method should follow the same logic as `showMainPanel`, but for the settings UI, using a different panel ID and title, and potentially a different `vscode.ViewColumn` (e.g., `vscode.ViewColumn.Two`). Store the panel in `this.settingsPanel`. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Update `ExtensionManager` for `WebviewManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, instantiate `WebviewManager`, passing it the `vscode.ExtensionContext` (e.g., `this.webviewManager = new WebviewManager(this.context);`). Make `webviewManager` a public property so it can be accessed by `CommandManager`. Add `this.webviewManager` to the `disposables` array. | `src/extensionManager.ts` |
| **3.6** |  To Do | **Refactor `CommandManager` for Webview Commands:** Open `src/commandManager.ts`. Modify the constructor to accept `WebviewManager` as a dependency. Update the callbacks for `code-context-engine.openMainPanel` and `code-context-engine.openSettings` commands to call `this.webviewManager.showMainPanel()` and `this.webviewManager.showSettingsPanel()` respectively, replacing the placeholder messages. | `src/commandManager.ts` |
| **3.7** |  To Do | **Verify Webview HTML Placeholders:** Open `webview/dist/index.html`. Ensure it contains `{{scriptUri}}` and `{{styleUri}}` placeholders in the appropriate `<script>` and `<link>` tags for the `getWebviewContent` method to replace. | `webview/dist/index.html` |
</file>

<file path="docs/todo/extension/tasklist_sprint_04.md">
# Task List: Sub-Sprint 4 - Message Routing & State

**Goal:** To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `StateManager.ts` File:** Create the new file `src/stateManager.ts`. Define a simple `StateManager` class. Add a private boolean property `_isIndexing` initialized to `false`. Implement a public getter `isIndexing(): boolean` and a public setter `setIndexing(state: boolean): void` for this property. | `src/stateManager.ts` (New) |
| **4.2** |  To Do | **Create `MessageRouter.ts` File:** Create the new file `src/messageRouter.ts`. Define the `MessageRouter` class. Its constructor should accept `extensionManager: ExtensionManager` and `webview: vscode.Webview`. In the constructor, set up the `webview.onDidReceiveMessage` listener, delegating to a private `routeMessage` method. | `src/messageRouter.ts` (New) |
| **4.3** |  To Do | **Implement `routeMessage` Method:** In `src/messageRouter.ts`, implement the private `async routeMessage(message: any): Promise<void>` method. This method should contain a `switch` statement to handle different `message.command` values (e.g., `'startIndexing'`). It should call the appropriate service method via `this.extensionManager` and send a response back to the webview using `this.webview.postMessage()`, including `requestId`, `result`, and `error` fields. | `src/messageRouter.ts` |
| **4.4** |  To Do | **Integrate State Check in `MessageRouter`:** In `src/messageRouter.ts`, within the `routeMessage` method, for the `'startIndexing'` case, add a check: `if (this.extensionManager.stateManager.isIndexing()) { throw new Error('Indexing is already in progress.'); }` before calling `startIndexing()`. | `src/messageRouter.ts` |
| **4.5** |  To Do | **Update `ExtensionManager` for `StateManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, instantiate `StateManager` (e.g., `this.stateManager = new StateManager();`). Make `stateManager` a public property. Pass the `stateManager` instance as a dependency to `IndexingService` during its instantiation. | `src/extensionManager.ts` |
| **4.6** |  To Do | **Update `IndexingService` to Use `StateManager`:** Open `src/indexing/indexingService.ts`. Modify the constructor to accept `stateManager: StateManager` as a dependency. In the `startIndexing()` method, call `this.stateManager.setIndexing(true)` at the beginning and `this.stateManager.setIndexing(false)` in a `finally` block to ensure the state is reset after the operation completes (whether successful or not). | `src/indexing/indexingService.ts` |
| **4.7** |  To Do | **Integrate `MessageRouter` in `WebviewManager`:** Open `src/webviewManager.ts`. Modify the `showMainPanel()` and `showSettingsPanel()` methods. Remove any existing `webview.onDidReceiveMessage` listener. Instead, instantiate `MessageRouter` (e.g., `new MessageRouter(this.extensionManager, this.mainPanel.webview);`) for each panel. Ensure `WebviewManager`'s constructor now accepts `extensionManager: ExtensionManager` as a dependency. | `src/webviewManager.ts` |
| **4.8** |  To Do | **Update `ExtensionManager` to Pass Itself to `WebviewManager`:** Open `src/extensionManager.ts`. In the `ExtensionManager` constructor, when instantiating `WebviewManager`, pass `this` (the `ExtensionManager` instance itself) as the second argument (e.g., `this.webviewManager = new WebviewManager(this.context, this);`). | `src/extensionManager.ts` |
</file>

<file path="docs/todo/extension2/backlog_sprint_1_webview_panel_lifecycle.md">
### User Story 1: Centralized Webview Panel Management
**As Alisha, I want a** `WebviewManager` class to handle the creation and disposal of webview panels, **so that** UI logic is centralized and decoupled from `extension.ts`.

**Actions to Undertake:**
1.  **Filepath**: `src/webviewManager.ts` (New File)
    -   **Action**: Create a new file `webviewManager.ts` and define the `WebviewManager` class.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';

        export class WebviewManager {
            private static instance: WebviewManager;
            private panel: vscode.WebviewPanel | undefined;
            private readonly context: vscode.ExtensionContext;

            private constructor(context: vscode.ExtensionContext) {
                this.context = context;
            }

            public static getInstance(context: vscode.ExtensionContext): WebviewManager {
                if (!WebviewManager.instance) {
                    WebviewManager.instance = new WebviewManager(context);
                }
                return WebviewManager.instance;
            }

            public showMainPanel() {
                if (this.panel) {
                    this.panel.reveal(vscode.ViewColumn.One);
                    return;
                }

                this.panel = vscode.window.createWebviewPanel(
                    'codeContextEngine',
                    'Code Context Engine',
                    vscode.ViewColumn.One,
                    {
                        enableScripts: true,
                        localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
                    }
                );

                this.panel.webview.html = this.getWebviewContent();

                this.panel.onDidDispose(() => {
                    this.panel = undefined;
                }, null, this.context.subscriptions);
            }

            private getWebviewContent(): string {
                // This will be implemented in the next user story
                return `<!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Code Context Engine</title>
                </head>
                <body>
                    <h1>Loading Webview...</h1>
                </body>
                </html>`;
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import * as path from 'path';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Instantiate `WebviewManager` and call `showMainPanel` from a command.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { WebviewManager } from './webviewManager'; // Add this import

        export function activate(context: vscode.ExtensionContext) {
            console.log('Congratulations, your extension "code-context-engine" is now active!');

            // Instantiate WebviewManager
            const webviewManager = WebviewManager.getInstance(context);

            let disposable = vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                webviewManager.showMainPanel(); // Delegate to WebviewManager
            });

            context.subscriptions.push(disposable);
        }

        export function deactivate() {}
        ```
    -   **Imports**: `import { WebviewManager } from './webviewManager';`

**Acceptance Criteria:**
-   A new file `src/webviewManager.ts` exists containing the `WebviewManager` class.
-   The `WebviewManager` class has a `showMainPanel()` method.
-   Executing the `code-context-engine.openMainPanel` command opens a new VS Code webview panel.
-   If the panel is already open, executing the command reveals the existing panel instead of creating a new one.
-   Closing the webview panel correctly disposes of its instance within the `WebviewManager`.

**Testing Plan:**
-   **Test Case 1**: Run the extension, execute the "Code Context Engine: Open Main Panel" command. Verify a new webview panel appears.
-   **Test Case 2**: Execute the command again. Verify the existing panel is revealed and no new panel is created.
-   **Test Case 3**: Close the webview panel. Execute the command again. Verify a new panel is created.

### User Story 2: Load SvelteKit Build Output
**As Frank, I want the** `WebviewManager` to correctly load the SvelteKit build output, **so my** application renders properly inside VS Code.

**Actions to Undertake:**
1.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: Implement `getWebviewContent` to read `index.html` and replace asset paths.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs'; // Add this import

        export class WebviewManager {
            // ... existing code ...

            private getWebviewContent(): string {
                const webviewPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');
                let htmlContent = fs.readFileSync(webviewPath, 'utf8');

                // Replace relative paths with webview-specific URIs
                htmlContent = htmlContent.replace(
                    /(<script src="|\ssrc="|<link href=")(?!https?:\/\/)([^"]*)"/g,
                    (match, p1, p2) => {
                        const resourcePath = path.join(this.context.extensionPath, 'webview', 'dist', p2);
                        const uri = this.panel!.webview.asWebviewUri(vscode.Uri.file(resourcePath));
                        return `${p1}${uri}"`;
                    }
                );

                return htmlContent;
            }
        }
        ```
    -   **Imports**: `import * as fs from 'fs';`

**Acceptance Criteria:**
-   The SvelteKit application's `index.html` is read and loaded into the webview.
-   All relative asset paths (e.g., `/_app/assets/`) within the `index.html` are correctly converted to `webview.asWebviewUri` format.
-   The SvelteKit application renders correctly within the VS Code webview panel, including its CSS and JavaScript.

**Testing Plan:**
-   **Test Case 1**: Run the extension and open the main panel. Verify the SvelteKit application loads and displays its UI elements (e.g., text, buttons, styling).
-   **Test Case 2**: Open the webview's developer tools (right-click on the webview and select "Inspect Element"). Verify that all loaded resources (JS, CSS) have `vscode-resource:` URIs.
-   **Test Case 3**: Check the console for any errors related to failed resource loading.

### User Story 3: Command Delegation to CommandManager
**As a** developer, **I want the** main panel command to be handled by the `CommandManager`, which delegates to the `WebviewManager`.

**Actions to Undertake:**
1.  **Filepath**: `src/commandManager.ts` (New File)
    -   **Action**: Create a new file `commandManager.ts` and define the `CommandManager` class.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { WebviewManager } from './webviewManager';

        export class CommandManager {
            private readonly context: vscode.ExtensionContext;
            private readonly webviewManager: WebviewManager;

            constructor(context: vscode.ExtensionContext, webviewManager: WebviewManager) {
                this.context = context;
                this.webviewManager = webviewManager;
            }

            public registerCommands() {
                this.context.subscriptions.push(
                    vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
                        this.webviewManager.showMainPanel();
                    })
                );
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode'; import { WebviewManager } from './webviewManager';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Instantiate `CommandManager` and register commands. Remove direct command registration.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { WebviewManager } from './webviewManager';
        import { CommandManager } from './commandManager'; // Add this import

        export function activate(context: vscode.ExtensionContext) {
            console.log('Congratulations, your extension "code-context-engine" is now active!');

            const webviewManager = WebviewManager.getInstance(context);
            const commandManager = new CommandManager(context, webviewManager); // Instantiate CommandManager
            commandManager.registerCommands(); // Register commands

            // Remove the old disposable for 'code-context-engine.openMainPanel'
            // let disposable = vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
            //     webviewManager.showMainPanel();
            // });
            // context.subscriptions.push(disposable);
        }

        export function deactivate() {}
        ```
    -   **Imports**: `import { CommandManager } from './commandManager';`

**Acceptance Criteria:**
-   A new file `src/commandManager.ts` exists containing the `CommandManager` class.
-   The `CommandManager` registers the `code-context-engine.openMainPanel` command.
-   The `extension.ts` file no longer directly registers the `openMainPanel` command but delegates to `CommandManager`.
-   Executing the `code-context-engine.openMainPanel` command still successfully opens/reveals the webview panel.

**Testing Plan:**
-   **Test Case 1**: Run the extension, execute the "Code Context Engine: Open Main Panel" command. Verify the webview panel opens.
-   **Test Case 2**: Inspect `extension.ts` to confirm that the direct `vscode.commands.registerCommand` for `openMainPanel` has been removed.
-   **Test Case 3**: Verify that the `CommandManager` is instantiated and its `registerCommands` method is called in `extension.ts`.
</file>

<file path="docs/todo/extension2/backlog_sprint_2_message_routing_api.md">
### User Story 1: Backend MessageRouter
**As a** developer, **I want a** `MessageRouter` class in the backend to handle all incoming webview messages, **so that** communication logic is centralized and testable.

**Actions to Undertake:**
1.  **Filepath**: `src/messageRouter.ts` (New File)
    -   **Action**: Create a new file `messageRouter.ts` and define the `MessageRouter` class.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';

        export class MessageRouter {
            private webview: vscode.Webview;

            constructor(webview: vscode.Webview) {
                this.webview = webview;
                this.webview.onDidReceiveMessage(message => this.handleMessage(message));
            }

            private async handleMessage(message: any) {
                switch (message.command) {
                    // This will be implemented in the next user story
                    case 'ping':
                        console.log('Received ping from webview');
                        this.webview.postMessage({ command: 'pong', requestId: message.requestId });
                        break;
                    default:
                        console.warn('Unknown command received:', message.command);
                        break;
                }
            }

            public postMessage(message: any) {
                this.webview.postMessage(message);
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/webviewManager.ts`
    -   **Action**: Instantiate `MessageRouter` and pass the webview instance to it. Delegate `onDidReceiveMessage` to `MessageRouter`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';
        import { MessageRouter } from './messageRouter'; // Add this import

        export class WebviewManager {
            private static instance: WebviewManager;
            private panel: vscode.WebviewPanel | undefined;
            private readonly context: vscode.ExtensionContext;
            private messageRouter: MessageRouter | undefined; // Add this line

            private constructor(context: vscode.ExtensionContext) {
                this.context = context;
            }

            public static getInstance(context: vscode.ExtensionContext): WebviewManager {
                if (!WebviewManager.instance) {
                    WebviewManager.instance = new WebviewManager(context);
                }
                return WebviewManager.instance;
            }

            public showMainPanel() {
                if (this.panel) {
                    this.panel.reveal(vscode.ViewColumn.One);
                    return;
                }

                this.panel = vscode.window.createWebviewPanel(
                    'codeContextEngine',
                    'Code Context Engine',
                    vscode.ViewColumn.One,
                    {
                        enableScripts: true,
                        localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]
                    }
                );

                this.messageRouter = new MessageRouter(this.panel.webview); // Instantiate MessageRouter

                this.panel.webview.html = this.getWebviewContent();

                this.panel.onDidDispose(() => {
                    this.panel = undefined;
                    this.messageRouter = undefined; // Clear message router on dispose
                }, null, this.context.subscriptions);
            }

            private getWebviewContent(): string {
                const webviewPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');
                let htmlContent = fs.readFileSync(webviewPath, 'utf8');

                htmlContent = htmlContent.replace(
                    /(<script src="|\ssrc="|<link href=")(?!https?:\/\/)([^"]*)"/g,
                    (match, p1, p2) => {
                        const resourcePath = path.join(this.context.extensionPath, 'webview', 'dist', p2);
                        const uri = this.panel!.webview.asWebviewUri(vscode.Uri.file(resourcePath));
                        return `${p1}${uri}"`;
                    }
                );

                return htmlContent;
            }
        }
        ```
    -   **Imports**: `import { MessageRouter } from './messageRouter';`

**Acceptance Criteria:**
-   A new file `src/messageRouter.ts` exists containing the `MessageRouter` class.
-   The `WebviewManager` instantiates `MessageRouter` when a new webview panel is created.
-   The `MessageRouter` receives messages from the webview via `onDidReceiveMessage`.
-   The `MessageRouter` can send messages back to the webview via `postMessage`.

**Testing Plan:**
-   **Test Case 1**: Set a breakpoint in `MessageRouter.handleMessage`. Send a message from the webview (e.g., via browser console `vscode.postMessage({ command: 'test' })`). Verify the breakpoint is hit.
-   **Test Case 2**: Set a breakpoint in `WebviewManager.showMainPanel` after `messageRouter` is instantiated. Verify `messageRouter` is an instance of `MessageRouter`.

### User Story 2: Frontend vscodeApi Client
**As Frank, I want a** `vscodeApi` client in my SvelteKit app to abstract away the `postMessage` API, **so I can** easily communicate with the extension.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/vscodeApi.ts`
    -   **Action**: Implement the `vscodeApi` client to wrap `acquireVsCodeApi()` and handle message passing.
    -   **Implementation**:
        ```typescript
        // webview/src/lib/vscodeApi.ts

        interface VsCodeApi {
            postMessage(message: any): void;
            setState(newState: any): void;
            getState(): any;
        }

        declare const acquireVsCodeApi: () => VsCodeApi;

        const vscode = acquireVsCodeApi();

        type MessageCallback = (message: any) => void;

        const callbacks = new Map<string, MessageCallback>();
        let requestIdCounter = 0;

        window.addEventListener('message', event => {
            const message = event.data;
            if (message.requestId && callbacks.has(message.requestId)) {
                callbacks.get(message.requestId)?.(message);
                callbacks.delete(message.requestId);
            } else {
                // Handle unsolicited messages or general events
                console.log('Received unsolicited message:', message);
            }
        });

        export const vscodeApi = {
            postMessage: (command: string, payload?: any): Promise<any> => {
                const requestId = `req-${requestIdCounter++}`;
                const message = { command, requestId, payload };
                vscode.postMessage(message);

                return new Promise(resolve => {
                    callbacks.set(requestId, resolve);
                });
            },
            onMessage: (callback: MessageCallback) => {
                // This is a simplified approach for general messages. For specific command responses,
                // the postMessage promise-based approach is preferred.
                window.addEventListener('message', event => {
                    const message = event.data;
                    // Only call callback for messages not handled by requestId
                    if (!message.requestId) {
                        callback(message);
                    }
                });
            },
            getState: () => vscode.getState(),
            setState: (newState: any) => vscode.setState(newState),
        };
        ```
    -   **Imports**: None (uses global `acquireVsCodeApi` and `window`)

**Acceptance Criteria:**
-   A `webview/src/lib/vscodeApi.ts` file exists.
-   It exports a `vscodeApi` object with `postMessage` and `onMessage` methods.
-   The `postMessage` method sends messages to the extension and returns a Promise that resolves with the response.
-   The client correctly handles `requestId` for request-response pairing.
-   Svelte components can import and use `vscodeApi` for communication.

**Testing Plan:**
-   **Test Case 1**: In a Svelte component, import `vscodeApi` and call `vscodeApi.postMessage('test', { data: 'hello' })`. Verify the message is received by the extension (using a breakpoint in `MessageRouter`).
-   **Test Case 2**: From the extension, send a message back to the webview using `webview.postMessage`. Verify the `window.addEventListener('message')` in `vscodeApi.ts` receives it.

### User Story 3: End-to-End Ping Command
**As a** developer, **I want to** implement a "ping" command to verify the communication bridge, **so we can** confirm the connection is working end-to-end.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/index.ts` (or a new Svelte component)
    -   **Action**: Add a button to the Svelte UI that sends a 'ping' command.
    -   **Implementation**:
        ```html
        <!-- Example in a Svelte component (e.g., App.svelte or a new PingTest.svelte) -->
        <script lang="ts">
            import { vscodeApi } from './lib/vscodeApi';
            let responseMessage: string = '';

            async function sendPing() {
                try {
                    responseMessage = 'Sending ping...';
                    const response = await vscodeApi.postMessage('ping');
                    responseMessage = `Received: ${response.command} (requestId: ${response.requestId})`;
                } catch (error) {
                    responseMessage = `Error: ${error.message}`;
                }
            }
        </script>

        <main>
            <h1>Webview Communication Test</h1>
            <button on:click={sendPing}>Send Ping to Extension</button>
            {#if responseMessage}
                <p>{responseMessage}</p>
            {/if}
        </main>

        <style>
            /* Add some basic styling */
            main {
                font-family: sans-serif;
                padding: 20px;
            }
            button {
                padding: 10px 20px;
                font-size: 16px;
                cursor: pointer;
            }
            p {
                margin-top: 15px;
                color: green;
            }
        </style>
        ```
    -   **Imports**: `import { vscodeApi } from './lib/vscodeApi';`
2.  **Filepath**: `src/messageRouter.ts`
    -   **Action**: Ensure the 'ping' command is handled and a 'pong' response is sent.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';

        export class MessageRouter {
            private webview: vscode.Webview;

            constructor(webview: vscode.Webview) {
                this.webview = webview;
                this.webview.onDidReceiveMessage(message => this.handleMessage(message));
            }

            private async handleMessage(message: any) {
                switch (message.command) {
                    case 'ping':
                        console.log('Received ping from webview', message.requestId);
                        // Send pong back with the same requestId
                        this.webview.postMessage({ command: 'pong', requestId: message.requestId });
                        break;
                    default:
                        console.warn('Unknown command received:', message.command);
                        break;
                }
            }

            public postMessage(message: any) {
                this.webview.postMessage(message);
            }
        }
        ```
    -   **Imports**: None (already imported)

**Acceptance Criteria:**
-   A button exists in the Svelte webview UI to send a 'ping' message.
-   Clicking the button sends a message with `command: 'ping'` and a `requestId` to the extension.
-   The extension's `MessageRouter` receives the 'ping' message and sends back a 'pong' message with the same `requestId`.
-   The Svelte UI receives the 'pong' response and displays a success message to the user.

**Testing Plan:**
-   **Test Case 1**: Run the extension, open the webview. Click the "Send Ping to Extension" button. Verify that "Received: pong" is displayed in the webview.
-   **Test Case 2**: Check the VS Code extension output channel and the webview's developer console for any errors or unexpected messages.
</file>

<file path="docs/todo/extension2/implementation_sprint_1_webview_panel_lifecycle.md">
## Implementation Guidance: Sprint 1 - Webview Panel Lifecycle

This guide provides detailed instructions and API information for implementing the Webview Panel Lifecycle sprint, focusing on creating a robust and decoupled webview management system within a VS Code extension.

### 1. Centralized Webview Panel Management (`WebviewManager`)

**Objective:** Create a `WebviewManager` class to encapsulate all logic related to the creation, display, and disposal of VS Code webview panels, thereby decoupling UI management from the main `extension.ts` file.

**Key VS Code APIs & Concepts:**

*   **`vscode.WebviewPanel`**: The core class representing a webview panel. It allows you to display HTML content within VS Code.
    *   **`vscode.window.createWebviewPanel(viewType, title, showOptions, options)`**: This static method is used to create a new webview panel.
        *   `viewType` (string): An identifier for the type of webview. Used internally by VS Code.
        *   `title` (string): The title displayed in the webview's tab.
        *   `showOptions` (`vscode.ViewColumn` or `{ viewColumn: vscode.ViewColumn, preserveFocus?: boolean }`): Specifies where the panel should be shown (e.g., `vscode.ViewColumn.One` for the first editor column).
        *   `options` (`vscode.WebviewOptions`): Configuration for the webview, including `enableScripts` (crucial for SvelteKit apps) and `localResourceRoots` (to allow loading local files).
*   **`panel.reveal(viewColumn?: vscode.ViewColumn, preserveFocus?: boolean)`**: If a panel already exists, this method brings it to the foreground.
*   **`panel.onDidDispose`**: An event that fires when the webview panel is disposed (e.g., when the user closes it). This is critical for cleaning up resources and setting the internal panel reference to `undefined` to prevent memory leaks and ensure correct behavior when the panel is reopened.
*   **`vscode.ExtensionContext`**: Provides access to the extension's environment, including `extensionPath` (the absolute path to your extension's root directory) and `subscriptions` (an array to which disposables are added for automatic cleanup on extension deactivation).

**Implementation Details:**

1.  **Singleton Pattern for `WebviewManager`**: Implement `WebviewManager` as a singleton to ensure only one instance manages the main webview panel. This is achieved by a private constructor and a static `getInstance` method.
2.  **Panel Instance Management**: The `WebviewManager` should hold a private reference to the `vscode.WebviewPanel` instance. Before creating a new panel, check if this reference exists. If it does, call `panel.reveal()` instead of creating a new one.
3.  **Disposal Handling**: Attach an `onDidDispose` listener to the created panel. Inside this listener, set the internal panel reference to `undefined`.
4.  **`localResourceRoots`**: When creating the webview panel, set `localResourceRoots` in the `WebviewOptions` to include the `webview/dist` directory. This is essential for the webview to be able to load local assets (JS, CSS, images) from your SvelteKit build output.
    *   Example: `localResourceRoots: [vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))]`

**File Reference:**
*   `src/webviewManager.ts` (New File)
*   `src/extension.ts` (Modification)

### 2. Load SvelteKit Build Output

**Objective:** Ensure the `WebviewManager` correctly reads the SvelteKit `index.html` and transforms its relative asset paths into VS Code webview-compatible URIs.

**Key VS Code APIs & Concepts:**

*   **`panel.webview.html`**: This property of `vscode.WebviewPanel` is where you set the HTML content to be displayed in the webview. It expects a string containing the full HTML document.
*   **`panel.webview.asWebviewUri(localResource)`**: This is a crucial method for security and functionality. It takes a `vscode.Uri` pointing to a local file (e.g., a JavaScript file, CSS file, image) and returns a special `vscode-resource:` URI that the webview can safely load. Without this, the webview cannot access local files due to security restrictions.
*   **`path` module (Node.js built-in)**: Useful for constructing file paths in a platform-independent way (e.g., `path.join`).
*   **`fs` module (Node.js built-in)**: Used for reading file content (e.g., `fs.readFileSync`).

**Implementation Details:**

1.  **Read `index.html`**: Use `fs.readFileSync` to read the content of `webview/dist/index.html`.
2.  **Path Transformation**: The SvelteKit build process typically generates `index.html` with relative paths for its assets (e.g., `<script src="/_app/immutable/start-XXXX.js">`). These paths need to be converted.
    *   Use a regular expression to find all `src` and `href` attributes that point to relative paths within your `webview/dist` directory.
    *   For each matched relative path, construct an absolute file URI using `vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist', relativePath))`.
    *   Then, convert this absolute URI to a webview-compatible URI using `this.panel.webview.asWebviewUri(absoluteUri)`.
    *   Replace the original relative path in the HTML string with the new `vscode-resource:` URI.

**Example Regex for Path Replacement:**
```javascript
htmlContent = htmlContent.replace(
    /(<script src="|\ssrc="|<link href=")(?!https?:\/\/)([^"]*)"/g,
    (match, p1, p2) => {
        const resourcePath = path.join(this.context.extensionPath, 'webview', 'dist', p2);
        const uri = this.panel!.webview.asWebviewUri(vscode.Uri.file(resourcePath));
        return `${p1}${uri}"`;
    }
);
```

**File Reference:**
*   `src/webviewManager.ts` (Modification)

### 3. Command Delegation to `CommandManager`

**Objective:** Refactor the command registration logic from `extension.ts` into a dedicated `CommandManager` class, promoting a cleaner and more modular architecture.

**Key VS Code APIs & Concepts:**

*   **`vscode.commands.registerCommand(command, callback)`**: Registers a command that can be invoked by users (e.g., via the Command Palette) or programmatically.
*   **`context.subscriptions.push(disposable)`**: All disposables (like the return value of `registerCommand`) should be added to the `context.subscriptions` array. This ensures they are automatically cleaned up when the extension is deactivated.

**Implementation Details:**

1.  **`CommandManager` Class**: Create a new class `CommandManager` that takes `vscode.ExtensionContext` and an instance of `WebviewManager` in its constructor.
2.  **`registerCommands` Method**: This method will contain all the `vscode.commands.registerCommand` calls. Instead of directly calling `webviewManager.showMainPanel()`, it will call `this.webviewManager.showMainPanel()`.
3.  **`extension.ts` Refactor**: In `activate`, instantiate `WebviewManager` first, then pass its instance to the `CommandManager` constructor. Call `commandManager.registerCommands()`.
4.  **Remove Direct Registration**: Ensure that the direct `vscode.commands.registerCommand` call for `code-context-engine.openMainPanel` is removed from `extension.ts`.

**File Reference:**
*   `src/commandManager.ts` (New File)
*   `src/extension.ts` (Modification)
</file>

<file path="docs/todo/extension2/prd.md">
<prd>Of course. Connecting the webview frontend to the main extension is a critical step. Based on your request and the existing codebase, I've created a series of PRDs to establish this communication layer robustly.

This plan focuses on creating a clean, decoupled architecture where `extension.ts` acts as an orchestrator, delegating specific responsibilities like webview management and message handling to dedicated classes.

-----

### **New Document: PRD 1: Foundational - Webview Panel Management**

**1. Title & Overview**

  * **Project:** Code Context Engine - Webview Management
  * **Summary:** This phase focuses on creating a centralized and reusable system for managing the lifecycle of the extension's webview panels. We will create a `WebviewManager` class responsible for creating, showing, and disposing of the main panel and any future panels (like settings). This will decouple all UI panel logic from the main `extension.ts` file.
  * **Dependencies:** The SvelteKit project must have a build process that outputs to the `webview/dist` directory.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Establish a stable and reliable foundation for the extension's user interface.
      * Improve developer efficiency by making the process of adding or managing UI panels predictable and straightforward.
  * **Developer & System Success Metrics:**
      * The `WebviewManager` successfully creates and displays the SvelteKit application within a VS Code panel.
      * All logic for reading `index.html` and rewriting asset paths with `asWebviewUri` is contained within the `WebviewManager`.
      * The extension can open the main panel via a command, and attempting to open it again simply reveals the existing panel.
      * The panel and its resources are properly disposed of when closed by the user or when the extension is deactivated.

-----

**3. User Personas**

  * **Frank (Frontend Developer):** Frank needs a consistent way for the extension to load his SvelteKit application. He shouldn't have to worry about the complexities of the VS Code API; he just needs his built application to be displayed correctly.
  * **Alisha (Backend Developer):** Alisha needs to trigger UI panels from commands. She wants a simple API call (e.g., `webviewManager.showMainPanel()`) to show the UI without needing to manage the panel's state or creation logic herself.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Webview** | **Sprint 1: Webview Panel Lifecycle** | As Alisha, I want a `WebviewManager` class to handle the creation and disposal of webview panels, so that UI logic is centralized and decoupled from `extension.ts`. | 1. A new `WebviewManager.ts` file and class are created.\<br/\>2. The class has a method `showMainPanel()` that creates a `vscode.WebviewPanel`.\<br/\>3. The manager ensures only one instance of the main panel can exist at a time.\<br/\>4. The manager correctly handles the `onDidDispose` event to clean up its reference to the panel. | **2 Weeks** |
| | | As Frank, I want the `WebviewManager` to correctly load the SvelteKit build output, so my application renders properly inside VS Code. | 1. The `WebviewManager` contains a private method to read the `index.html` from `webview/dist`.\<br/\>2. This method correctly replaces relative asset paths (e.g., `/_app/`) with the special `webview.asWebviewUri` format.\<br/\>3. The `showMainPanel()` method uses this helper to set the panel's HTML content. | |
| | | As a developer, I want the main panel command to be handled by the `CommandManager`, which delegates to the `WebviewManager`. | 1. The `CommandManager` has a command for `code-context-engine.openMainPanel`.\<br/\>2. The command's callback invokes `extensionManager.webviewManager.showMainPanel()`.\<br/\>3. The `extension.ts` file no longer contains any direct panel creation logic. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 1:** Webview Panel Lifecycle & Content Loading (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The SvelteKit build output path (`webview/dist`) is stable and predictable.
  * **Risk:** Incorrectly rewriting the asset paths in `index.html` will cause the SvelteKit app to fail to load its CSS or JavaScript, resulting in a blank panel.
      * **Mitigation:** Create a robust regular expression to handle the path replacement and thoroughly test that all assets load correctly in the webview's developer tools.
  * **Risk:** Forgetting to handle the `onDidDispose` event will lead to memory leaks and buggy behavior where the extension thinks a panel is open when it isn't.
      * **Mitigation:** Ensure that the panel reference within the `WebviewManager` is set to `undefined` within the `onDidDispose` callback.

-----

### **New Document: PRD 2: Core - Bidirectional Message Passing**

**1. Title & Overview**

  * **Project:** Code Context Engine - Webview Communication Bridge
  * **Summary:** This phase focuses on establishing a robust, type-safe, and decoupled communication channel between the SvelteKit webview (frontend) and the extension host (backend). We will create a `MessageRouter` class on the backend and a `vscodeApi` client on the frontend to standardize how messages are sent and received.
  * **Dependencies:** PRD 1 must be complete. The `WebviewManager` must be able to successfully display the SvelteKit application.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Enable core application functionality by creating a reliable data channel between the UI and the backend logic.
      * Improve developer experience by providing a simple and predictable API for frontend-backend communication.
  * **Developer & System Success Metrics:**
      * A `MessageRouter` class successfully replaces the `switch` statement for message handling.
      * The frontend `vscodeApi` client can successfully send a message to the extension and receive a response.
      * A defined message structure (e.g., with `command`, `requestId`, `payload`) is used for all communication.
      * An end-to-end "ping-pong" test (UI sends "ping", backend responds with "pong") works correctly, validating the entire communication pipeline.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Comms** | **Sprint 2: Message Routing & API** | As a developer, I want a `MessageRouter` class in the backend to handle all incoming webview messages, so that communication logic is centralized and testable. | 1. A new `MessageRouter.ts` file and class are created.\<br/\>2. The `WebviewManager` instantiates the `MessageRouter` for each panel it creates, passing it the webview instance.\<br/\>3. The `onDidReceiveMessage` listener in `WebviewManager` delegates directly to the `MessageRouter`.\<br/\>4. The `MessageRouter` contains the `switch` logic to route commands to the appropriate services. | **2 Weeks** |
| | | As Frank, I want a `vscodeApi` client in my SvelteKit app to abstract away the `postMessage` API, so I can easily communicate with the extension. | 1. A `vscodeApi.ts` file is created in the `webview` project.\<br/\>2. It exports functions like `postMessage` and `onMessage` that wrap the native `acquireVsCodeApi()` methods.\<br/\>3. The client includes logic to handle request-response pairs using a `requestId`.\<br/\>4. Svelte components import and use this client instead of the global `vscode` API directly. | |
| | | As a developer, I want to implement a "ping" command to verify the communication bridge, so we can confirm the connection is working end-to-end. | 1. The Svelte UI has a test button that, when clicked, sends a `{ command: 'ping' }` message via the `vscodeApi` client.\<br/\>2. The `MessageRouter` has a `case` for "ping" that immediately sends back a `{ command: 'pong' }` message.\<br/\>3. The Svelte UI listens for the "pong" message and displays a success notification to the user. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 2:** Message Routing & API Implementation (2 Weeks)

This completes the PRDs for establishing the connection between the webview and `extension.ts`. You now have a clear plan to build a robust and maintainable foundation for all UI-to-backend communication.</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/fe/backlog_sprint_1_setup_view_implementation.md">
# Backlog: Sprint 1 - Setup View Implementation

**Objective:** To build the complete user onboarding and setup UI within the VS Code extension's webview. This view is the user's first interaction and must clearly guide them through configuring the necessary database and embedding providers for a new, un-indexed repository.

---

### User Story 1: Display Initial Setup Screen

**As a** new user (Devin), **I want to** see a clear setup screen when I open an un-indexed project, **so that** I know what I need to do to get started.

**Workflow:**
1.  The extension's activation logic checks if a `code-context.json` file exists in the root of the opened workspace.
2.  If the file does not exist, the extension opens a new Webview panel displaying the `SetupView`.
3.  The `SetupView` component renders the primary UI structure.

**Codebase Review:**
*   `src/extension.ts`: Will need modification to add the file check and the command to launch the webview.
*   `webview/`: This directory is currently empty. The entire SvelteKit application will be created here.

**File Changes:**
*   `src/extension.ts`: Modify `activate` function.
*   `webview/src/+page.svelte` (New File): To be created as the main `SetupView` component.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    *   **Action**: On activation, check for the existence of `code-context.json` in the workspace root.
    *   **Implementation**: Use `vscode.workspace.findFiles('code-context.json')` to check for the file. If the result is empty, set a context key like `code-context.isConfigured: false`.
    *   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `package.json`
    *   **Action**: Add a `when` clause to the `viewsWelcome` contribution point to show a welcome view with a "Setup Project" button only when `!code-context.isConfigured`.
    *   **Implementation**:
        ```json
        "contributes": {
          "viewsWelcome": [
            {
              "view": "explorer",
              "contents": "Welcome to Code Context! [Setup Project](command:code-context.setup)\n",
              "when": "!code-context.isConfigured"
            }
          ]
        }
        ```
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Register a command `code-context.setup` that creates and shows a new webview panel.
    *   **Implementation**: Use `vscode.window.createWebviewPanel` to create the panel. The panel should load the SvelteKit build output.
    *   **Imports**: `import * as path from 'path';`, `import * as fs from 'fs';`
4.  **Filepath**: `webview/src/+page.svelte` (New File)
    *   **Action**: Create the main Svelte component for the setup view.
    *   **Implementation**:
        ```html
        <script>
          import DatabaseSetup from '$lib/components/DatabaseSetup.svelte';
          import EmbeddingSetup from '$lib/components/EmbeddingSetup.svelte';
        </script>
        <h1>Code Context Setup</h1>
        <DatabaseSetup />
        <EmbeddingSetup />
        ```
    *   **Imports**: None.

**Acceptance Criteria:**
-   When a project without `code-context.json` is opened, a welcome view in the explorer prompts the user to set up the project.
-   Running the setup command opens a webview titled "Code Context Setup".
-   The view contains distinct sections for "Database Configuration" and "Embedding Provider".
-   The primary call-to-action button ("Index Now") is initially disabled.

---

### User Story 2: Configure Vector Database

**As a** new user (Devin), **I want to** select my desired vector database and get help starting it if it's not running, **so that** my code can be indexed.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte` (New File)
    *   **Action**: Create a Svelte component for database configuration.
    *   **Implementation**: Include a Fluent UI `<Select>` for "Qdrant" and a `<Button>` labeled "Start Local Qdrant".
    *   **Imports**: `import { Select, Button } from '@svelte-fui/core';`
2.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Implement the button's `on:click` handler to send a message to the VS Code extension host.
    *   **Implementation**: `vscode.postMessage({ command: 'startDatabase' });`
    *   **Imports**: None.
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Add a message listener to the webview panel to handle the `startDatabase` command.
    *   **Implementation**: The listener will execute `docker-compose up` in a new VS Code terminal.
    *   **Implementation**: `const terminal = vscode.window.createTerminal('Qdrant'); terminal.sendText('docker-compose up'); terminal.show();`
    *   **Imports**: `import * as vscode from 'vscode';`
4.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Display a status icon that changes from "Not Running" to "Running" based on a message from the backend.
    *   **Implementation**: The extension backend will perform a health check and `postMessage` to the webview with the status.
    *   **Imports**: None.

**Acceptance Criteria:**
-   A dropdown allows selecting "Qdrant".
-   Clicking "Start Local Qdrant" opens a new terminal and runs `docker-compose up`.
-   A status indicator correctly reflects the database's running status after a health check from the backend.

---

### User Story 3: Configure Embedding Provider

**As a** new user (Devin), **I want to** choose which embedding model to use for indexing my code, **so that** the context is generated accurately.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/EmbeddingSetup.svelte` (New File)
    *   **Action**: Create a Svelte component for embedding provider selection.
    *   **Implementation**: Use a Fluent UI `<Select>` with options "Ollama" and "OpenAI".
    *   **Imports**: `import { Select } from '@svelte-fui/core';`
2.  **Filepath**: `webview/src/lib/stores/setupStore.ts` (New File)
    *   **Action**: Create a Svelte writable store to manage the setup state.
    *   **Implementation**: `export const setupState = writable({ databaseReady: false, providerSelected: null });`
    *   **Imports**: `import { writable } from 'svelte/store';`
3.  **Filepath**: `webview/src/+page.svelte`
    *   **Action**: Create the main "Index Now" button. Its `disabled` attribute should be reactively bound to the store's state.
    *   **Implementation**: `<Button disabled={!$setupState.databaseReady || !$setupState.providerSelected}>Index Now</Button>`
    *   **Imports**: `import { Button } from '@svelte-fui/core';`, `import { setupState } from '$lib/stores/setupStore';`
4.  **Filepath**: `webview/src/+page.svelte`
    *   **Action**: When clicked, the "Index Now" button sends the selected configuration to the extension backend.
    *   **Implementation**: `vscode.postMessage({ command: 'startIndexing', config: $setupState });`
    *   **Imports**: None.

**Acceptance Criteria:**
-   A dropdown allows selecting "Ollama" or "OpenAI".
-   The "Index Now" button is enabled only after the database is running and an embedding provider is selected.
-   Clicking the button sends the chosen configuration to the extension backend.

**Testing Plan:**
-   **Manual Test Case 1**: Open a project without `code-context.json`. Verify the welcome view appears.
-   **Manual Test Case 2**: Click the setup button. Verify the webview opens.
-   **Manual Test Case 3**: Click "Start Local Qdrant". Verify a terminal opens and runs the command.
-   **Manual Test Case 4**: Select an embedding provider. Verify the "Index Now" button becomes enabled once the DB is "running".
-   **Manual Test Case 5**: Click "Index Now" and verify the configuration is sent to the extension (check debugger).
</file>

<file path="docs/todo/fe/backlog_sprint_1_web_api_boilerplate.md">
### User Story 1: Create C# Web API Foundation
**As Alisha, I want to** create a new ASP.NET Core Web API project, **so that** we have the foundational service for our backend logic.

**Actions to Undertake:**
1.  **Filepath**: `(Project Root)`
    -   **Action**: Create a new .NET solution and three projects: `CodeContext.Api` (webapi), `CodeContext.Core` (classlib), and `CodeContext.Infrastructure` (classlib).
    -   **Implementation**:
        ```bash
        dotnet new sln -n CodeContext
        dotnet new webapi -n CodeContext.Api -o CodeContext.Api
        dotnet new classlib -n CodeContext.Core -o CodeContext.Core
        dotnet new classlib -n CodeContext.Infrastructure -o CodeContext.Infrastructure
        dotnet sln CodeContext.sln add CodeContext.Api/CodeContext.Api.csproj
        dotnet sln CodeContext.sln add CodeContext.Core/CodeContext.Core.csproj
        dotnet sln CodeContext.sln add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Api/CodeContext.Api.csproj`
    -   **Action**: Add project references from `CodeContext.Api` to `CodeContext.Core` and `CodeContext.Infrastructure`.
    -   **Implementation**:
        ```xml
        <ItemGroup>
            <ProjectReference Include="..\CodeContext.Core\CodeContext.Core.csproj" />
            <ProjectReference Include="..\CodeContext.Infrastructure\CodeContext.Infrastructure.csproj" />
        </ItemGroup>
        ```
    -   **Imports**: None.
3.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Implement a basic `/health` endpoint using minimal API syntax.
    -   **Implementation**:
        ```csharp
        app.MapGet("/health", () => Results.Ok());
        ```
    -   **Imports**: `using Microsoft.AspNetCore.Builder;` (already there)
4.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Add Swagger/OpenAPI support.
    -   **Implementation**:
        ```csharp
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();
        // ...
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }
        ```
    -   **Imports**: `using Microsoft.OpenApi.Models;` (not directly in Program.cs, but implicitly used by AddSwaggerGen)
5.  **Filepath**: `CodeContext.Core/`
    -   **Action**: Create placeholder interfaces `IEmbeddingProvider.cs` and `IVectorDatabaseClient.cs` in the `CodeContext.Core` project.
    -   **Implementation**:
        ```csharp
        // CodeContext.Core/IEmbeddingProvider.cs
        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                // Placeholder for future methods
            }
        }

        // CodeContext.Core/IVectorDatabaseClient.cs
        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                // Placeholder for future methods
            }
        }
        ```
    -   **Imports**: None.
6.  **Filepath**: `CodeContext.Infrastructure/`
    -   **Action**: Create placeholder folders `DatabaseClients` and `EmbeddingProviders` in the `CodeContext.Infrastructure` project.
    -   **Implementation**: (This is a folder creation, not code. I'll describe it.)
        ```
        (Create directory CodeContext.Infrastructure/DatabaseClients)
        (Create directory CodeContext.Infrastructure/EmbeddingProviders)
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   A new .NET solution is created containing `CodeContext.Api`, `CodeContext.Core`, and `CodeContext.Infrastructure` projects.
-   The `CodeContext.Api` project correctly references `CodeContext.Core` and `CodeContext.Infrastructure`.
-   A basic `/health` endpoint is accessible and returns a `200 OK` status.
-   Swagger/OpenAPI documentation is available and functional.
-   Placeholder interfaces `IEmbeddingProvider` and `IVectorDatabaseClient` exist in `CodeContext.Core`.
-   Placeholder folders `DatabaseClients` and `EmbeddingProviders` exist in `CodeContext.Infrastructure`.

**Testing Plan:**
-   **Test Case 1**: Run `dotnet build CodeContext.sln` to ensure all projects build successfully.
-   **Test Case 2**: Navigate to the `CodeContext.Api` directory and run `dotnet run`. Verify the API starts without errors.
-   **Test Case 3**: Access `http://localhost:<port>/health` in a browser or via `curl` and confirm a `200 OK` response.
-   **Test Case 4**: Access `http://localhost:<port>/swagger` in a browser and confirm the Swagger UI loads correctly.
</file>

<file path="docs/todo/fe/backlog_sprint_2_extensible_client_framework.md">
### User Story 1: Define Abstract Interfaces for Clients
**As Alisha, I want to** define abstract interfaces for database clients and embedding providers, **so that** we can easily add new implementations in the future.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/IEmbeddingProvider.cs`
    -   **Action**: Add `GenerateEmbeddingsAsync` method to `IEmbeddingProvider` interface.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts);
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`
2.  **Filepath**: `CodeContext.Core/IVectorDatabaseClient.cs`
    -   **Action**: Add `UpsertAsync` and `QueryAsync` methods to `IVectorDatabaseClient` interface.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                Task UpsertAsync(string collectionName, List<VectorData> vectors);
                Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK);
            }

            public class VectorData
            {
                public string Id { get; set; }
                public float[] Vector { get; set; }
                public Dictionary<string, object> Payload { get; set; }
            }

            public class QueryResult
            {
                public string Id { get; set; }
                public double Score { get; set; }
                public Dictionary<string, object> Payload { get; set; }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`

### User Story 2: Implement Dependency Injection for Clients
**As Alisha, I want to** use dependency injection to register and resolve these clients, **so that** the application is loosely coupled and testable.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Configure .NET's built-in dependency injection container.
    -   **Implementation**: (This is more about how to use DI, not a specific code snippet to add, but rather how to register services. I'll provide a conceptual example.)
        ```csharp
        // Example: Registering a concrete implementation (will be done in later sprints)
        // builder.Services.AddSingleton<IEmbeddingProvider, OllamaProvider>();
        // builder.Services.AddSingleton<IVectorDatabaseClient, QdrantClient>();
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Core/ClientFactory.cs` (New File)
    -   **Action**: Create a `ClientFactory` or `ClientStrategy` service that can resolve the correct client implementation based on a configuration string.
    -   **Implementation**:
        ```csharp
        using System;
        using Microsoft.Extensions.DependencyInjection;

        namespace CodeContext.Core
        {
            public class ClientFactory
            {
                private readonly IServiceProvider _serviceProvider;

                public ClientFactory(IServiceProvider serviceProvider)
                {
                    _serviceProvider = serviceProvider;
                }

                public IEmbeddingProvider GetEmbeddingProvider(string providerType)
                {
                    return providerType.ToLowerInvariant() switch
                    {
                        "ollama" => _serviceProvider.GetRequiredService<OllamaProvider>(), // Concrete type will be registered
                        _ => throw new ArgumentException($"Unknown embedding provider type: {providerType}")
                    };
                }

                public IVectorDatabaseClient GetVectorDatabaseClient(string clientType)
                {
                    return clientType.ToLowerInvariant() switch
                    {
                        "qdrant" => _serviceProvider.GetRequiredService<QdrantClient>(), // Concrete type will be registered
                        _ => throw new ArgumentException($"Unknown vector database client type: {clientType}")
                    };
                }
            }
        }
        ```
    -   **Imports**: `using System;`, `using Microsoft.Extensions.DependencyInjection;`
3.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Register the `ClientFactory` with the DI container.
    -   **Implementation**:
        ```csharp
        builder.Services.AddSingleton<ClientFactory>();
        ```
    -   **Imports**: `using CodeContext.Core;`

**Acceptance Criteria:**
-   `IEmbeddingProvider` interface in `CodeContext.Core` includes `GenerateEmbeddingsAsync(List<string> texts)` method.
-   `IVectorDatabaseClient` interface in `CodeContext.Core` includes `UpsertAsync(string collectionName, List<VectorData> vectors)` and `QueryAsync(string collectionName, float[] vector, int topK)` methods, along with `VectorData` and `QueryResult` classes.
-   .NET's built-in dependency injection container is configured to allow registration and resolution of these interfaces.
-   A `ClientFactory` class exists in `CodeContext.Core` that can resolve client implementations based on a string.
-   The `ClientFactory` is registered with the DI container.
-   Unit tests (to be written in a separate test project) verify that the correct client is returned for a given configuration.

**Testing Plan:**
-   **Test Case 1**: (Conceptual, as concrete implementations are not yet present) Verify that the `IEmbeddingProvider` and `IVectorDatabaseClient` interfaces compile without errors.
-   **Test Case 2**: (Conceptual) Write a simple console application or a unit test project that attempts to resolve `ClientFactory` from the DI container and then calls its `GetEmbeddingProvider` and `GetVectorDatabaseClient` methods with dummy strings (e.g., "ollama", "qdrant") to ensure it compiles and the factory logic is sound (it will throw exceptions until concrete types are registered).
-   **Test Case 3**: (Conceptual) Ensure the `VectorData` and `QueryResult` classes are correctly defined and accessible.
</file>

<file path="docs/todo/fe/backlog_sprint_3_backend_process_management.md">
### User Story 1: Auto-Start C# Backend Service
**As a** developer, **I want the** VS Code extension to automatically start the C# backend service when the extension is activated, **so that** I don't have to run it manually.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts` (Assuming this is the main extension file)
    -   **Action**: Implement logic to spawn the C# backend executable using `child_process.spawn`.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
        import * as path from 'path';

        let backendProcess: ChildProcessWithoutNullStreams | null = null;

        export function activate(context: vscode.ExtensionContext) {
            console.log('Code Context extension is now active!');

            // Determine the path to the C# backend executable
            // This path will depend on your build process and where the executable is placed.
            // Example: Assuming it's in a 'bin' folder relative to the extension root
            const backendExecutablePath = path.join(context.extensionPath, 'bin', 'CodeContext.Api'); // Adjust as needed

            backendProcess = spawn(backendExecutablePath, [], {
                cwd: path.dirname(backendExecutablePath), // Run from the executable's directory
                stdio: ['ignore', 'pipe', 'pipe'] // Ignore stdin, pipe stdout/stderr
            });

            backendProcess.stdout.on('data', (data) => {
                console.log(`Backend stdout: ${data}`);
                // You might want to log this to an output channel in VS Code
            });

            backendProcess.stderr.on('data', (data) => {
                console.error(`Backend stderr: ${data}`);
                // Log errors to an output channel
            });

            backendProcess.on('close', (code) => {
                console.log(`Backend process exited with code ${code}`);
                backendProcess = null;
                // Handle process exit, e.g., attempt restart or notify user
            });

            backendProcess.on('error', (err) => {
                console.error('Failed to start backend process:', err);
                vscode.window.showErrorMessage(`Failed to start Code Context backend: ${err.message}`);
                backendProcess = null;
            });

            // Add a disposable to ensure process is killed on deactivate
            context.subscriptions.push({
                dispose: () => {
                    if (backendProcess) {
                        console.log('Terminating backend process...');
                        backendProcess.kill(); // Send SIGTERM
                        backendProcess = null;
                    }
                }
            });
        }

        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill();
                backendProcess = null;
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { spawn, ChildProcessWithoutNullStreams } from 'child_process';`, `import * as path from 'path';`
2.  **Filepath**: `extension.ts`
    -   **Action**: Ensure the child process is terminated when the extension is deactivated.
    -   **Implementation**: (Included in the `activate` and `deactivate` functions above)
        ```typescript
        // In activate:
        context.subscriptions.push({
            dispose: () => {
                if (backendProcess) {
                    console.log('Terminating backend process...');
                    backendProcess.kill();
                    backendProcess = null;
                }
            }
        });

        // In deactivate:
        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill();
                backendProcess = null;
            }
        }
        ```
    -   **Imports**: None.

### User Story 2: Monitor Backend Service Health
**As a** developer, **I want the** extension to monitor the health of the C# backend service, **so that** it can reliably send API requests.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts`
    -   **Action**: Periodically send HTTP GET requests to the backend's `/health` endpoint.
    -   **Implementation**:
        ```typescript
        // Inside activate function, after spawning backendProcess
        const backendPort = 5000; // Or read from configuration
        const healthCheckInterval = 5000; // 5 seconds
        let healthCheckAttempts = 0;
        const maxHealthCheckAttempts = 10;
        let healthCheckTimer: NodeJS.Timeout | null = null;

        function startHealthCheck() {
            if (healthCheckTimer) {
                clearInterval(healthCheckTimer);
            }
            healthCheckTimer = setInterval(async () => {
                if (!backendProcess) {
                    console.log('Backend process not running, stopping health check.');
                    clearInterval(healthCheckTimer!);
                    return;
                }

                try {
                    const response = await fetch(`http://localhost:${backendPort}/health`);
                    if (response.ok) {
                        console.log('Backend is healthy.');
                        healthCheckAttempts = 0;
                        // Update UI state to "Running"
                        // vscode.window.showInformationMessage('Code Context Backend is Running!');
                        // If you have a webview, send a message to it
                        // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'running' });
                    } else {
                        console.warn(`Backend health check failed: ${response.status}`);
                        healthCheckAttempts++;
                        // Update UI state to "Starting" or "Error"
                        // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'starting' });
                        if (healthCheckAttempts >= maxHealthCheckAttempts) {
                            console.error('Max health check attempts reached. Attempting to restart backend.');
                            clearInterval(healthCheckTimer!);
                            restartBackend(); // Implement this function
                        }
                    }
                } catch (error) {
                    console.error('Error during backend health check:', error);
                    healthCheckAttempts++;
                    // Update UI state to "Error"
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'error' });
                    if (healthCheckAttempts >= maxHealthCheckAttempts) {
                        console.error('Max health check attempts reached. Attempting to restart backend.');
                        clearInterval(healthCheckTimer!);
                        restartBackend(); // Implement this function
                    }
                }
            }, healthCheckInterval);
        }

        function restartBackend() {
            if (backendProcess) {
                backendProcess.kill();
                backendProcess = null;
            }
            console.log('Restarting backend process...');
            // Re-call the spawn logic from activate, or a dedicated function
            // For simplicity, let's assume activate handles it, or create a startBackend function
            // startBackend(); // Call a function that encapsulates the spawning logic
            // For now, just log and let the user know
            vscode.window.showWarningMessage('Code Context Backend is restarting due to health check failures.');
            // In a real scenario, you'd re-run the spawn logic here.
            // For this backlog, we'll assume a simple restart mechanism.
            activate(context); // This is a simplified restart, might need more robust logic
        }

        // Call this after backendProcess is successfully spawned
        startHealthCheck();
        ```
    -   **Imports**: `import fetch from 'node-fetch';` (or `import { fetch } from 'undici';` for Node.js 18+)
2.  **Filepath**: `extension.ts`
    -   **Action**: Implement logic to restart the backend if health checks consistently fail.
    -   **Implementation**: (Included in the `startHealthCheck` and `restartBackend` functions above)
    -   **Imports**: None.

**Acceptance Criteria:**
-   The VS Code extension successfully launches the C# backend executable upon activation.
-   `stdout` and `stderr` from the backend process are captured and logged (e.g., to VS Code's output channel).
-   The backend process is reliably terminated when the extension is deactivated or VS Code is closed.
-   The extension periodically pings the backend's `/health` endpoint.
-   The extension can detect when the backend is unhealthy and attempts to restart it after a configurable number of failures.
-   (Implicit) The UI (webview) can receive status updates about the backend's health (e.g., "Starting", "Running", "Error").

**Testing Plan:**
-   **Test Case 1**: Activate the extension and verify that the C# backend process starts (check task manager/process list).
-   **Test Case 2**: Deactivate the extension and verify that the C# backend process is terminated.
-   **Test Case 3**: Introduce a deliberate error in the C# backend's `/health` endpoint (e.g., make it return 500) and observe if the extension attempts to restart the backend after multiple failures.
-   **Test Case 4**: Verify that backend `stdout` and `stderr` messages appear in the VS Code output channel (if implemented).
-   **Test Case 5**: (Manual) Observe the UI state changes (if a basic UI is already present) reflecting the backend's status.
</file>

<file path="docs/todo/fe/backlog_sprint_4_onboarding_setup_ui.md">
### User Story 1: Display Setup/Query UI Based on Index Status
**As Devin, when I open a new project, I want the** extension to check if it's been indexed and show me a setup screen if it hasn't.

**Actions to Undertake:**
1.  **Filepath**: `extension.ts`
    -   **Action**: Check for the existence of `.vscode/code-context.json` on extension activation.
    -   **Implementation**:
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';

        // ... (existing imports and backend process management logic) ...

        export function activate(context: vscode.ExtensionContext) {
            // ... (existing backend process spawning and health check setup) ...

            // Create and show the webview panel
            const panel = vscode.window.createWebviewPanel(
                'codeContext', // Identifies the type of the webview
                'Code Context', // Title of the panel displayed to the user
                vscode.ViewColumn.One, // Editor column to show the new webview panel in
                {
                    enableScripts: true, // Enable JavaScript in the webview
                    localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                }
            );

            // Get path to SvelteKit build output
            const svelteAppPath = path.join(context.extensionPath, 'webview', 'dist', 'index.html');
            panel.webview.html = fs.readFileSync(svelteAppPath, 'utf8');

            // Check for code-context.json
            const workspaceFolders = vscode.workspace.workspaceFolders;
            let configFilePath: string | undefined;
            if (workspaceFolders && workspaceFolders.length > 0) {
                configFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'code-context.json');
            }

            let initialView: 'setup' | 'query' = 'setup';
            if (configFilePath && fs.existsSync(configFilePath)) {
                initialView = 'query';
            }

            // Send initial view state to webview
            panel.webview.postMessage({ type: 'initialView', view: initialView });

            // Handle messages from the webview
            panel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showInformationMessage(message.text);
                            return;
                        case 'startDocker':
                            // Handle Docker command execution
                            handleStartDockerCommand(message.service, context);
                            return;
                        // ... other commands
                    }
                },
                undefined,
                context.subscriptions
            );

            // Add panel to disposables
            context.subscriptions.push(panel);
        }

        // ... (deactivate function) ...
        ```
    -   **Imports**: `import * as fs from 'fs';`
2.  **Filepath**: `webview/src/lib/stores/viewStore.ts` (New File)
    -   **Action**: Create a Svelte store to manage the current view state (`'setup'` or `'query'`).
    -   **Implementation**:
        ```typescript
        import { writable } from 'svelte/store';

        export const currentView = writable<'setup' | 'query'>('setup'); // Default to setup
        ```
    -   **Imports**: `import { writable } from 'svelte/store';`
3.  **Filepath**: `webview/src/App.svelte` (Main Svelte component)
    -   **Action**: Render `SetupView.svelte` or `QueryView.svelte` based on the `currentView` store.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';

            onMount(() => {
                // Listen for messages from the VS Code extension
                window.addEventListener('message', event => {
                    const message = event.data; // The JSON data that the extension sent
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        // ... handle other messages like backend status
                    }
                });
            });
        </script>

        {#if $currentView === 'setup'}
            <SetupView />
        {:else if $currentView === 'query'}
            <QueryView />
        {/if}
        ```
    -   **Imports**: `import { onMount } from 'svelte';`, `import { currentView } from './lib/stores/viewStore';`, `import SetupView from './lib/components/SetupView.svelte';`, `import QueryView from './lib/components/QueryView.svelte';`

### User Story 2: Implement Setup UI with Docker Helper
**As Devin, I want the** setup screen to let me choose my database and embedding provider, with helper buttons to start any required local services.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/SetupView.svelte` (New File)
    -   **Action**: Create the Svelte component for the setup view with dropdowns for database/embedding provider and a "Start Local" button.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { createEventDispatcher } from 'svelte';
            import { postMessageToVsCode } from '../utils/vscode'; // Helper to send messages to extension

            const dispatch = createEventDispatcher();

            let selectedDatabase: string = 'qdrant'; // Default
            let selectedEmbeddingProvider: string = 'ollama'; // Default

            function handleStartLocalService(service: string) {
                postMessageToVsCode('startDocker', { service });
            }

            function handleSaveAndIndex() {
                // Send configuration to extension to save and trigger indexing
                postMessageToVsCode('saveConfigAndIndex', {
                    database: selectedDatabase,
                    embeddingProvider: selectedEmbeddingProvider
                });
            }
        </script>

        <div class="setup-container">
            <h1>Setup Code Context</h1>

            <section>
                <h2>Database Configuration</h2>
                <label for="database-select">Select Database:</label>
                <select id="database-select" bind:value={selectedDatabase}>
                    <option value="qdrant">Qdrant (Local)</option>
                    <!-- Add other options later -->
                </select>
                <button on:click={() => handleStartLocalService('qdrant')}>Start Local Qdrant</button>
                <!-- Add status indicator here -->
            </section>

            <section>
                <h2>Embedding Provider Configuration</h2>
                <label for="embedding-select">Select Embedding Provider:</label>
                <select id="embedding-select" bind:value={selectedEmbeddingProvider}>
                    <option value="ollama">Ollama (Local)</option>
                    <!-- Add other options later -->
                </select>
                <button on:click={() => handleStartLocalService('ollama')}>Start Local Ollama</button>
                <!-- Add status indicator here -->
            </section>

            <button on:click={handleSaveAndIndex}>Save & Index</button>
        </div>

        <style>
            /* Basic styling for layout */
            .setup-container {
                padding: 20px;
                font-family: sans-serif;
            }
            section {
                margin-bottom: 20px;
                border: 1px solid #ccc;
                padding: 15px;
                border-radius: 5px;
            }
            label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            select, button {
                margin-right: 10px;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid #ddd;
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                cursor: pointer;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
        </style>
        ```
    -   **Imports**: `import { createEventDispatcher } from 'svelte';`, `import { postMessageToVsCode } from '../utils/vscode';`
2.  **Filepath**: `webview/src/lib/utils/vscode.ts` (New File)
    -   **Action**: Create a utility function to send messages from the Svelte webview to the VS Code extension.
    -   **Implementation**:
        ```typescript
        // This is how you send messages from the webview to the extension
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        export function postMessageToVsCode(command: string, data: any) {
            vscode.postMessage({ command, ...data });
        }
        ```
    -   **Imports**: None (uses `declare const acquireVsCodeApi: any;` for VS Code API)
3.  **Filepath**: `extension.ts`
    -   **Action**: Implement `handleStartDockerCommand` to open a new VS Code terminal and run `docker-compose` commands.
    -   **Implementation**:
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        function handleStartDockerCommand(service: string, context: vscode.ExtensionContext) {
            let command: string;
            let terminalName: string;

            switch (service) {
                case 'qdrant':
                    command = 'docker-compose -f docker-compose.qdrant.yml up -d'; // Assuming a docker-compose file
                    terminalName = 'Qdrant Docker';
                    break;
                case 'ollama':
                    command = 'docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama'; // Example Ollama command
                    terminalName = 'Ollama Docker';
                    break;
                default:
                    vscode.window.showErrorMessage(`Unknown service to start: ${service}`);
                    return;
            }

            const terminal = vscode.window.createTerminal(terminalName);
            terminal.show();
            terminal.sendText(command);

            // Optional: You might want to poll for service health after starting Docker
            // and send a message back to the webview to update status.
            // For this backlog, we'll assume the command execution is sufficient.
        }
        ```
    -   **Imports**: None.
4.  **Filepath**: `webview/src/lib/components/QueryView.svelte` (New File)
    -   **Action**: Create a placeholder Svelte component for the query view.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            // Placeholder for future query functionality
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <p>Your code is indexed. Query functionality will be available here soon!</p>
            <!-- Future: input box, results display -->
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: sans-serif;
            }
        </style>
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   On extension activation, the webview panel is displayed.
-   If `.vscode/code-context.json` does not exist in the workspace root, the `SetupView` component is rendered.
-   If `.vscode/code-context.json` exists, the `QueryView` component is rendered.
-   The `SetupView` contains dropdowns for selecting database and embedding provider.
-   "Start Local" buttons are present next to the selections.
-   Clicking a "Start Local" button opens a new VS Code terminal and executes the corresponding Docker command.
-   (Implicit) The UI can receive and display status updates (e.g., "Running") for the Docker services.

**Testing Plan:**
-   **Test Case 1**: Start VS Code with an empty workspace (no `.vscode/code-context.json`). Verify the `SetupView` is displayed.
-   **Test Case 2**: Create an empty `.vscode/code-context.json` file in the workspace root. Restart VS Code. Verify the `QueryView` is displayed.
-   **Test Case 3**: In `SetupView`, click the "Start Local Qdrant" button. Verify a new terminal opens and the `docker-compose` command is executed.
-   **Test Case 4**: In `SetupView`, click the "Start Local Ollama" button. Verify a new terminal opens and the `docker run` command is executed.
-   **Test Case 5**: (Manual) Verify that the dropdowns in `SetupView` are functional.
</file>

<file path="docs/todo/fe/backlog_sprint_5_concrete_client_implementation.md">
### User Story 1: Implement Qdrant Client
**As Alisha, I want to** implement the concrete client for Qdrant, **so that** the backend can communicate with the vector database.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Infrastructure/CodeContext.Infrastructure.csproj`
    -   **Action**: Add the `Qdrant.Client` NuGet package.
    -   **Implementation**:
        ```xml
        <ItemGroup>
            <PackageReference Include="Qdrant.Client" Version="1.x.x" /> <!-- Use the latest stable version -->
        </ItemGroup>
        ```
    -   **Imports**: None.
2.  **Filepath**: `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs` (New File)
    -   **Action**: Create `QdrantClient` class implementing `IVectorDatabaseClient` and its `UpsertAsync` method.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IVectorDatabaseClient, VectorData, QueryResult
        using Qdrant.Client;
        using Qdrant.Client.Grpc;

        namespace CodeContext.Infrastructure.DatabaseClients
        {
            public class QdrantClient : IVectorDatabaseClient
            {
                private readonly QdrantGrpcClient _client;
                private readonly string _host;
                private readonly int _port;

                public QdrantClient(string host, int port)
                {
                    _host = host;
                    _port = port;
                    _client = new QdrantGrpcClient(host, port);
                }

                public async Task UpsertAsync(string collectionName, List<VectorData> vectors)
                {
                    // Ensure collection exists (or create it)
                    var collections = await _client.Collections.ListAsync();
                    if (!collections.Any(c => c.Name == collectionName))
                    {
                        await _client.Collections.CreateAsync(
                            collectionName,
                            new VectorParams { Size = vectors.First().Vector.Length, Distance = Distance.Cosine } // Assuming all vectors have same size
                        );
                    }

                    var points = vectors.Select(v => new PointStruct
                    {
                        Id = v.Id,
                        Vectors = v.Vector.ToList(),
                        Payload = v.Payload.ToDictionary(p => p.Key, p => Value.From(p.Value)) // Convert payload to Qdrant's Value
                    }).ToList();

                    await _client.Points.UpsertAsync(collectionName, points);
                }

                public async Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK)
                {
                    var searchResult = await _client.Points.SearchAsync(
                        collectionName,
                        vector.ToList(),
                        limit: (ulong)topK
                    );

                    return searchResult.Select(s => new QueryResult
                    {
                        Id = s.Id,
                        Score = s.Score,
                        Payload = s.Payload.ToDictionary(p => p.Key, p => p.Value.ToValue()) // Convert Qdrant's Value back to object
                    }).ToList();
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Linq;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`, `using Qdrant.Client;`, `using Qdrant.Client.Grpc;`

### User Story 2: Implement Ollama Provider
**As Alisha, I want to** implement the concrete client for Ollama, **so that** the backend can generate embeddings.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs` (New File)
    -   **Action**: Create `OllamaProvider` class implementing `IEmbeddingProvider` and its `GenerateEmbeddingsAsync` method.
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Net.Http;
        using System.Text;
        using System.Text.Json;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider

        namespace CodeContext.Infrastructure.EmbeddingProviders
        {
            public class OllamaProvider : IEmbeddingProvider
            {
                private readonly HttpClient _httpClient;
                private readonly string _ollamaApiUrl;
                private readonly string _modelName;

                public OllamaProvider(HttpClient httpClient, string ollamaApiUrl, string modelName)
                {
                    _httpClient = httpClient;
                    _ollamaApiUrl = ollamaApiUrl;
                    _modelName = modelName;
                }

                public async Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts)
                {
                    var embeddings = new List<float[]>();
                    foreach (var text in texts)
                    {
                        var requestBody = new
                        {
                            model = _modelName,
                            prompt = text
                        };

                        var json = JsonSerializer.Serialize(requestBody);
                        var content = new StringContent(json, Encoding.UTF8, "application/json");

                        var response = await _httpClient.PostAsync($"{_ollamaApiUrl}/api/embeddings", content);
                        response.EnsureSuccessStatusCode(); // Throws an exception if not 2xx

                        var responseBody = await response.Content.ReadAsStringAsync();
                        var jsonDoc = JsonDocument.Parse(responseBody);
                        var embeddingArray = jsonDoc.RootElement.GetProperty("embedding").EnumerateArray().Select(e => (float)e.GetDouble()).ToArray();
                        embeddings.Add(embeddingArray);
                    }
                    return embeddings;
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Linq;`, `using System.Net.Http;`, `using System.Text;`, `using System.Text.Json;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`

### User Story 3: Implement AST Parsing and Indexing Service
**As Alisha, I want to** integrate AST parsing and create an indexing service, **so that** the backend can process code and store embeddings.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/Services/ParsingService.cs` (New File)
    -   **Action**: Create `ParsingService` to handle Abstract Syntax Tree (AST) parsing of code files. (Conceptual, as specific AST library is not chosen yet).
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core.Services
        {
            public class ParsingService
            {
                public Task<List<string>> ParseCodeFileAsync(string filePath)
                {
                    // This is a placeholder. Actual implementation would use a library
                    // like Microsoft.CodeAnalysis (Roslyn) for C#, or similar for other languages.
                    // It would extract meaningful code snippets, function definitions, etc.
                    return Task.FromResult(new List<string> { $"Content of {filePath} for embedding." });
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`
2.  **Filepath**: `CodeContext.Core/Services/IndexingService.cs` (New File)
    -   **Action**: Create `IndexingService` to orchestrate the indexing workflow (parsing, embedding, upserting).
    -   **Implementation**:
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider, IVectorDatabaseClient, VectorData

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                private readonly ParsingService _parsingService;
                private readonly IEmbeddingProvider _embeddingProvider;
                private readonly IVectorDatabaseClient _vectorDatabaseClient;

                public IndexingService(
                    ParsingService parsingService,
                    IEmbeddingProvider embeddingProvider,
                    IVectorDatabaseClient vectorDatabaseClient)
                {
                    _parsingService = parsingService;
                    _embeddingProvider = embeddingProvider;
                    _vectorDatabaseClient = vectorDatabaseClient;
                }

                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName)
                {
                    // Placeholder: In a real scenario, you'd enumerate files in repositoryPath
                    // and process them.
                    var filePaths = new List<string> {
                        "path/to/file1.cs",
                        "path/to/file2.ts"
                    };

                    foreach (var filePath in filePaths)
                    {
                        var codeSnippets = await _parsingService.ParseCodeFileAsync(filePath);
                        if (codeSnippets.Any())
                        {
                            var embeddings = await _embeddingProvider.GenerateEmbeddingsAsync(codeSnippets);

                            var vectorsToUpsert = new List<VectorData>();
                            for (int i = 0; i < embeddings.Count; i++)
                            {
                                vectorsToUpsert.Add(new VectorData
                                {
                                    Id = $"{filePath}_{i}", // Unique ID for each snippet
                                    Vector = embeddings[i],
                                    Payload = new Dictionary<string, object> { { "filePath", filePath }, { "snippet", codeSnippets[i] } }
                                });
                            }
                            await _vectorDatabaseClient.UpsertAsync(collectionName, vectorsToUpsert);
                        }
                    }
                }
            }
        }
        ```
    -   **Imports**: `using System.Collections.Generic;`, `using System.Threading.Tasks;`, `using CodeContext.Core;`

### User Story 4: Register Services and Create Index Endpoint
**As Alisha, I want to** register all new services with the DI container and create an `/index` endpoint, **so that** the API can trigger the indexing process.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Register `QdrantClient`, `OllamaProvider`, `ParsingService`, and `IndexingService` with the DI container.
    -   **Implementation**:
        ```csharp
        using CodeContext.Core;
        using CodeContext.Core.Services;
        using CodeContext.Infrastructure.DatabaseClients;
        using CodeContext.Infrastructure.EmbeddingProviders;
        using System.Net.Http; // For HttpClient

        // ... existing builder.Services ...

        // Register HttpClient for OllamaProvider
        builder.Services.AddHttpClient<OllamaProvider>(); // Registers HttpClient and OllamaProvider

        // Register concrete client implementations
        // For QdrantClient, you might need configuration for host/port
        builder.Services.AddSingleton<IVectorDatabaseClient>(sp =>
        {
            // Read configuration for Qdrant host/port
            var configuration = sp.GetRequiredService<IConfiguration>();
            var qdrantHost = configuration["Qdrant:Host"] ?? "localhost";
            var qdrantPort = int.Parse(configuration["Qdrant:Port"] ?? "6334");
            return new QdrantClient(qdrantHost, qdrantPort);
        });

        builder.Services.AddSingleton<IEmbeddingProvider>(sp =>
        {
            // Read configuration for Ollama API URL and model name
            var configuration = sp.GetRequiredService<IConfiguration>();
            var ollamaApiUrl = configuration["Ollama:ApiUrl"] ?? "http://localhost:11434";
            var ollamaModel = configuration["Ollama:Model"] ?? "llama2"; // Default model
            var httpClient = sp.GetRequiredService<HttpClient>(); // Get HttpClient from DI
            return new OllamaProvider(httpClient, ollamaApiUrl, ollamaModel);
        });

        // Register services
        builder.Services.AddSingleton<ParsingService>();
        builder.Services.AddSingleton<IndexingService>();

        // ... existing app.MapGet("/health") ...
        ```
    -   **Imports**: `using CodeContext.Core;`, `using CodeContext.Core.Services;`, `using CodeContext.Infrastructure.DatabaseClients;`, `using CodeContext.Infrastructure.EmbeddingProviders;`, `using System.Net.Http;`, `using Microsoft.Extensions.Configuration;`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Create a `POST /index` endpoint that triggers the `IndexingService`.
    -   **Implementation**:
        ```csharp
        // ... existing app.MapGet("/health") ...

        app.MapPost("/index", async (IndexingService indexingService) =>
        {
            // In a real scenario, you'd get the repository path from the request or configuration
            // For now, use a placeholder or read from appsettings.json
            var repositoryPath = "/path/to/your/code/repository"; // Placeholder
            var collectionName = "code_context_collection"; // Placeholder

            await indexingService.IndexRepositoryAsync(repositoryPath, collectionName);
            return Results.Ok("Indexing started.");
        });

        app.Run();
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   `Qdrant.Client` NuGet package is added to `CodeContext.Infrastructure`.
-   `QdrantClient` class implements `IVectorDatabaseClient` and correctly handles `UpsertAsync` and `QueryAsync` (though `QueryAsync` is not explicitly tested in this sprint's AC).
-   `OllamaProvider` class implements `IEmbeddingProvider` and correctly makes HTTP requests to Ollama and parses responses.
-   `ParsingService` and `IndexingService` classes are created in `CodeContext.Core/Services`.
-   All new services (`QdrantClient`, `OllamaProvider`, `ParsingService`, `IndexingService`) are registered with the DI container in `Program.cs`.
-   A `POST /index` endpoint exists in the API that triggers the `IndexingService`.

**Testing Plan:**
-   **Test Case 1**: Build the C# solution (`dotnet build CodeContext.sln`). Ensure no compilation errors.
-   **Test Case 2**: Run the API project (`dotnet run --project CodeContext.Api`).
-   **Test Case 3**: Use a tool like Postman or `curl` to send a `POST` request to `http://localhost:<port>/index`. Verify a `200 OK` response and that the indexing process (even if placeholder) is initiated.
-   **Test Case 4**: (Requires local Qdrant and Ollama instances) Start local Qdrant and Ollama containers. Run the API and trigger the `/index` endpoint. Observe logs for successful communication with Qdrant and Ollama. Verify data is inserted into Qdrant (e.g., using Qdrant's API or UI).
-   **Test Case 5**: (Unit Tests) Write unit tests for `QdrantClient` and `OllamaProvider` using mocking frameworks (e.g., Moq) to ensure their methods behave as expected without requiring actual external services.
</file>

<file path="docs/todo/fe/backlog_sprint_6_end_to_end_indexing_query_ui.md">
### User Story 1: Real-time Indexing Progress Feedback
**As Devin, I want to** click the "Index Now" button and see a progress bar while my code is being indexed, **so that** I have clear feedback on the process.

**Actions to Undertake:**
1.  **Filepath**: `CodeContext.Core/Services/IndexingService.cs`
    -   **Action**: Implement a mechanism (e.g., `IProgress<T>`) to report progress updates during indexing.
    -   **Implementation**:
        ```csharp
        using System; // For Action
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core;

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                // ... (constructor and existing fields) ...

                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName, IProgress<int>? progress = null)
                {
                    // Simulate file discovery
                    var allFiles = new List<string> {
                        Path.Combine(repositoryPath, "src", "Program.cs"),
                        Path.Combine(repositoryPath, "src", "Utils.ts"),
                        Path.Combine(repositoryPath, "src", "AnotherFile.cs")
                    };
                    int totalFiles = allFiles.Count;
                    int processedFiles = 0;

                    foreach (var filePath in allFiles)
                    {
                        // ... (existing parsing, embedding, upserting logic) ...
                        processedFiles++;
                        int percentage = (int)((double)processedFiles / totalFiles * 100);
                        progress?.Report(percentage); // Report progress
                        await Task.Delay(100); // Simulate work
                    }
                }
            }
        }
        ```
    -   **Imports**: `using System;`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Create a Server-Sent Events (SSE) endpoint to stream progress updates from the backend to the UI.
    -   **Implementation**:
        ```csharp
        // ... existing imports ...
        using Microsoft.AspNetCore.Http; // For HttpContext
        using System.Threading.Channels; // For Channel

        // ... existing app.MapPost("/index") ...

        // Define a channel for broadcasting progress updates
        var progressChannel = Channel.CreateUnbounded<int>();

        app.MapPost("/index", async (IndexingService indexingService, HttpContext httpContext) =>
        {
            var repositoryPath = "/Users/bramburn/dev/bigcontext";
            var collectionName = "code_context_collection";

            // Create a progress reporter that pushes to the channel
            var progressReporter = new Progress<int>(percentage =>
            {
                progressChannel.Writer.TryWrite(percentage);
            });

            // Run indexing in a background task so the HTTP request can return quickly
            _ = Task.Run(async () =>
            {
                try
                {
                    await indexingService.IndexRepositoryAsync(repositoryPath, collectionName, progressReporter);
                    progressChannel.Writer.TryWrite(100); // Indicate completion
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Indexing error: {ex.Message}");
                    // Optionally send an error message through the channel or a separate mechanism
                }
            });

            return Results.Accepted(); // Return 202 Accepted
        });

        app.MapGet("/index-progress", async (HttpContext httpContext) =>
        {
            httpContext.Response.Headers.Add("Content-Type", "text/event-stream");
            httpContext.Response.Headers.Add("Cache-Control", "no-cache");
            httpContext.Response.Headers.Add("Connection", "keep-alive");

            await foreach (var percentage in progressChannel.Reader.ReadAllAsync(httpContext.RequestAborted))
            {
                await httpContext.Response.WriteAsync($"data: {percentage}\n\n");
                await httpContext.Response.Body.FlushAsync();
            }
        });

        app.Run();
        ```
    -   **Imports**: `using Microsoft.AspNetCore.Http;`, `using System.Threading.Channels;`
3.  **Filepath**: `webview/src/lib/components/IndexingView.svelte` (New File)
    -   **Action**: Create `IndexingView.svelte` with a progress bar and connect it to the SSE endpoint.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount, onDestroy } from 'svelte';
            import { postMessageToVsCode } from '../utils/vscode';
            import { currentView } from '../stores/viewStore';

            let progressPercentage: number = 0;
            let indexingStatus: string = 'Starting indexing...';
            let eventSource: EventSource | null = null;

            onMount(() => {
                // Start indexing process on mount (or when triggered by a button click)
                // For now, we'll assume it's triggered by the extension after config save.
                // In a real scenario, the "Save & Index" button in SetupView would trigger this.
                // postMessageToVsCode('startIndexing'); // Send message to extension to start backend indexing

                // Connect to SSE endpoint for progress updates
                eventSource = new EventSource('http://localhost:5000/index-progress'); // Adjust port if needed

                eventSource.onmessage = (event) => {
                    const percentage = parseInt(event.data, 10);
                    if (!isNaN(percentage)) {
                        progressPercentage = percentage;
                        indexingStatus = `Indexing progress: ${percentage}%`;
                        if (percentage >= 100) {
                            indexingStatus = 'Indexing complete!';
                            setTimeout(() => {
                                currentView.set('query'); // Transition to query view
                            }, 1000); // Give a moment for user to see 100%
                        }
                    }
                };

                eventSource.onerror = (error) => {
                    console.error('EventSource failed:', error);
                    indexingStatus = 'Indexing failed or disconnected.';
                    eventSource?.close();
                };
            });

            onDestroy(() => {
                eventSource?.close(); // Close the connection when component is destroyed
            });
        </script>

        <div class="indexing-container">
            <h1>Indexing Your Codebase</h1>
            <p>{indexingStatus}</p>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: {progressPercentage}%;"></div>
            </div>
            <p>{progressPercentage}%</p>
        </div>

        <style>
            .indexing-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            .progress-bar-container {
                width: 100%;
                background-color: var(--vscode-editorGroup-background);
                border: 1px solid var(--vscode-panel-border);
                border-radius: 5px;
                height: 20px;
                overflow: hidden;
            }
            .progress-bar {
                height: 100%;
                background-color: var(--vscode-progressBar-background);
                width: 0%;
                transition: width 0.3s ease-in-out;
            }
        </style>
        ```
    -   **Imports**: `import { onMount, onDestroy } from 'svelte';`, `import { postMessageToVsCode } from '../utils/vscode';`, `import { currentView } from '../stores/viewStore';`
4.  **Filepath**: `webview/src/App.svelte`
    -   **Action**: Update `App.svelte` to render `IndexingView` when indexing is in progress.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';
            import IndexingView from './lib/components/IndexingView.svelte'; // New import

            onMount(() => {
                window.addEventListener('message', event => {
                    const message = event.data;
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        case 'startIndexingUI': // Message from extension to show indexing view
                            currentView.set('indexing');
                            break;
                        // ... handle other messages
                    }
                });
            });
        </script>

        <main>
            {#if $currentView === 'setup'}
                <SetupView />
            {:else if $currentView === 'indexing'}
                <IndexingView />
            {:else if $currentView === 'query'}
                <QueryView />
            {/if}
        </main>
        ```
    -   **Imports**: `import IndexingView from './lib/components/IndexingView.svelte';`
5.  **Filepath**: `webview/src/lib/stores/viewStore.ts`
    -   **Action**: Update `currentView` store to include `'indexing'` state.
    -   **Implementation**:
        ```typescript
        import { writable } from 'svelte/store';

        export const currentView = writable<'setup' | 'indexing' | 'query'>('setup');
        ```
    -   **Imports**: None.

### User Story 2: Implement Core Query View
**As Devin, after indexing is complete, I want to** see a chat input box where I can type a question to find relevant code.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/QueryView.svelte`
    -   **Action**: Implement the `QueryView.svelte` component with a text input and a submit button, and a display area for results.
    -   **Implementation**:
        ```svelte
        <script lang="ts">
            import { postMessageToVsCode } from '../utils/vscode';

            let query: string = '';
            let searchResults: { filePath: string; snippet: string }[] = [];
            let isLoading: boolean = false;

            async function handleQuerySubmit() {
                if (!query.trim()) return;

                isLoading = true;
                searchResults = []; // Clear previous results

                // Send query to VS Code extension, which will forward to backend
                const response = await postMessageToVsCode('submitQuery', { query });

                // Assuming the extension sends back the results via a message
                // For now, we'll simulate or expect a direct return if possible (less ideal for async)
                // In a real scenario, the extension would send a message back to the webview
                // with the results, and this component would listen for it.
                // For this backlog, let's assume postMessageToVsCode can return a promise with results.
                // (This is a simplification for the backlog, actual implementation needs a message listener)
                if (response && response.type === 'queryResults') {
                    searchResults = response.results;
                } else {
                    // Simulate results for backlog purposes
                    searchResults = [
                        { filePath: "/path/to/file1.cs", snippet: "public class MyClass { /* ... */ }" },
                        { filePath: "/path/to/file2.ts", snippet: "function calculateSum(a: number, b: number) { /* ... */ }" }
                    ];
                }

                isLoading = false;
            }
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <div class="query-input-area">
                <input
                    type="text"
                    placeholder="Ask a question about your codebase..."
                    bind:value={query}
                    on:keydown={(e) => { if (e.key === 'Enter') handleQuerySubmit(); }}
                />
                <button on:click={handleQuerySubmit} disabled={isLoading}>
                    {#if isLoading}Searching...{:else}Search{/if}
                </button>
            </div>

            {#if searchResults.length > 0}
                <div class="search-results">
                    <h2>Results:</h2>
                    {#each searchResults as result}
                        <div class="result-item">
                            <h3>{result.filePath}</h3>
                            <pre><code>{result.snippet}</code></pre>
                        </div>
                    {/each}
                </div>
            {:else if !isLoading}
                <p>No results yet. Type a query above.</p>
            {/if}
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            .query-input-area {
                display: flex;
                margin-bottom: 20px;
            }
            .query-input-area input {
                flex-grow: 1;
                padding: 10px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border-radius: 4px;
                margin-right: 10px;
            }
            .query-input-area button {
                padding: 10px 15px;
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }
            button:hover:not(:disabled) {
                background-color: var(--vscode-button-hoverBackground);
            }
            button:disabled {
                opacity: 0.6;
                cursor: not-allowed;
            }
            .search-results {
                margin-top: 20px;
            }
            .result-item {
                background-color: var(--vscode-editorGroup-background);
                border: 1px solid var(--vscode-panel-border);
                padding: 15px;
                margin-bottom: 10px;
                border-radius: 5px;
            }
            .result-item h3 {
                margin-top: 0;
                color: var(--vscode-textLink-foreground);
            }
            .result-item pre {
                background-color: var(--vscode-editor-background);
                padding: 10px;
                border-radius: 3px;
                overflow-x: auto;
            }
        </style>
        ```
    -   **Imports**: `import { postMessageToVsCode } from '../utils/vscode';`
2.  **Filepath**: `CodeContext.Api/Program.cs`
    -   **Action**: Implement a `POST /query` endpoint that takes a query string, generates an embedding, performs a vector search, and returns relevant file paths.
    -   **Implementation**:
        ```csharp
        // ... existing imports ...
        using CodeContext.Core.Services; // For IndexingService (and now QueryService)

        // ... existing endpoints ...

        app.MapPost("/query", async (QueryRequest request, IndexingService indexingService, IEmbeddingProvider embeddingProvider, IVectorDatabaseClient vectorDatabaseClient) =>
        {
            if (string.IsNullOrWhiteSpace(request.QueryText))
            {
                return Results.BadRequest("Query text cannot be empty.");
            }

            var collectionName = "code_context_collection"; // Must match indexing collection

            try
            {
                // 1. Generate embedding for the query text
                var queryEmbedding = (await embeddingProvider.GenerateEmbeddingsAsync(new List<string> { request.QueryText })).FirstOrDefault();
                if (queryEmbedding == null)
                {
                    return Results.Problem("Failed to generate embedding for query.", statusCode: 500);
                }

                // 2. Perform vector search
                var searchResults = await vectorDatabaseClient.QueryAsync(collectionName, queryEmbedding, topK: 5); // Get top 5 results

                // 3. Format results for UI
                var formattedResults = searchResults.Select(r => new QueryResponseItem
                {
                    FilePath = r.Payload.ContainsKey("filePath") ? r.Payload["filePath"].ToString() : "Unknown Path",
                    Snippet = r.Payload.ContainsKey("snippet") ? r.Payload["snippet"].ToString() : "No snippet available"
                }).ToList();

                return Results.Ok(formattedResults);
            }
            catch (Exception ex)
            {
                return Results.Problem($"Query failed: {ex.Message}", statusCode: 500);
            }
        });

        app.Run();

        // Define request and response models for the query endpoint
        public record QueryRequest(string QueryText);
        public record QueryResponseItem(string FilePath, string Snippet);
        ```
    -   **Imports**: `using CodeContext.Core.Services;`
3.  **Filepath**: `extension.ts`
    -   **Action**: Handle `submitQuery` message from webview, forward to backend, and send results back to webview.
    -   **Implementation**:
        ```typescript
        // ... (inside activate function, in panel.webview.onDidReceiveMessage) ...
        case 'submitQuery':
            try {
                const queryText = message.query;
                const backendUrl = `http://localhost:${backendPort}/query`;
                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ queryText })
                });

                if (response.ok) {
                    const results = await response.json();
                    panel.webview.postMessage({ type: 'queryResults', results });
                } else {
                    const errorText = await response.text();
                    vscode.window.showErrorMessage(`Backend query failed: ${response.status} - ${errorText}`);
                    panel.webview.postMessage({ type: 'queryResults', results: [] }); // Send empty results on error
                }
            } catch (error: any) {
                vscode.window.showErrorMessage(`Error sending query to backend: ${error.message}`);
                panel.webview.postMessage({ type: 'queryResults', results: [] });
            }
            return;
        // ...
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   Clicking "Save & Index" (from SetupView) or a dedicated "Index Now" button (if added) triggers the indexing process in the backend.
-   The Svelte UI displays a progress bar that updates in real-time based on progress events streamed from the backend.
-   Upon successful completion of indexing (100% progress), the UI automatically transitions from `IndexingView` to `QueryView`.
-   The `QueryView` component features a text input field and a submit button.
-   Typing a query and submitting it sends a `POST` request to the C# backend's `/query` endpoint.
-   The backend successfully generates an embedding for the query, performs a vector search, and returns a list of relevant file paths and snippets.
-   The `QueryView` displays the returned search results in a clear, readable format.

**Testing Plan:**
-   **Test Case 1**: Start the extension with no `code-context.json`. Go through the setup, click "Save & Index". Verify `IndexingView` appears and the progress bar updates.
-   **Test Case 2**: Observe the console logs of the C# backend to confirm indexing progress is being reported.
-   **Test Case 3**: After indexing completes, verify the UI automatically transitions to `QueryView`.
-   **Test Case 4**: In `QueryView`, type a simple query (e.g., "how to calculate sum") and click "Search".
-   **Test Case 5**: Observe the C# backend logs to confirm the query was received, embedding generated, and search performed.
-   **Test Case 6**: Verify that the `QueryView` displays the returned file paths and snippets.
-   **Test Case 7**: (Edge Case) Test with an empty query or a query that yields no results.
</file>

<file path="docs/todo/fe/backlog_sub_sprint_1_database_configuration_component.md">
# Backlog: Sub-Sprint 1 - Database Configuration Component

**Objective:** To build the Svelte component for the database selection and management part of the setup view.

**Parent Sprint:** Sprint 1: Setup View Implementation

---

### User Story: Manage Database Configuration

**As a** new user (Devin), **I want to** select my vector database, start it if needed, and see its status, **so that** I can prepare my project for indexing.

**Workflow:**
1.  The `DatabaseSetup.svelte` component renders a dropdown for database selection and a button to start the local service.
2.  A status indicator shows the current state of the database (e.g., "Not Running", "Running").
3.  Clicking the "Start" button sends a message to the extension backend.
4.  The backend runs the necessary command and sends a status update back to the webview.

**File Changes:**
*   `webview/src/lib/components/DatabaseSetup.svelte` (New File)
*   `src/extension.ts` (Modification)
*   `webview/src/lib/stores/setupStore.ts` (Modification)

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte` (New File)
    *   **Action**: Build the UI with a Fluent UI `<Select>` component for database choice (initially just "Qdrant") and a `<Button>` to start the service.
    *   **Implementation**:
        ```html
        <script lang="ts">
          import { Button, Select } from '@svelte-fui/core';
          import { setupState } from '$lib/stores/setupStore';
          // ... message handling logic ...
        </script>
        <h2>Database Configuration</h2>
        <Select items={['Qdrant']} placeholder="Select a database" />
        <Button on:click={startDatabase}>Start Local Qdrant</Button>
        <span>Status: {$setupState.databaseReady ? 'Running' : 'Not Running'}</span>
        ```
    *   **Imports**: `@svelte-fui/core`, `../stores/setupStore`
2.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Implement the `startDatabase` function to send a `startDatabase` message via `postMessage`.
    *   **Implementation**: `const vscode = acquireVsCodeApi(); function startDatabase() { vscode.postMessage({ command: 'startDatabase' }); }`
    *   **Imports**: None.
3.  **Filepath**: `src/extension.ts`
    *   **Action**: Add a case for `startDatabase` in the `onDidReceiveMessage` listener. This should execute the `docker-compose up` command in a new terminal.
    *   **Implementation**: `case 'startDatabase': const terminal = vscode.window.createTerminal('Qdrant'); terminal.sendText('docker-compose up'); terminal.show(); break;`
    *   **Imports**: `vscode`
4.  **Filepath**: `src/extension.ts`
    *   **Action**: Implement a basic health check loop after starting the database. On success, `postMessage` to the webview with the updated status.
    *   **Implementation**: Use `setTimeout` and a fetch-like request to the Qdrant health endpoint. `panel.webview.postMessage({ command: 'databaseStatus', status: 'running' });`
    *   **Imports**: None.
5.  **Filepath**: `webview/src/lib/components/DatabaseSetup.svelte`
    *   **Action**: Add a listener for messages from the extension to update the `setupState` store.
    *   **Implementation**: `window.addEventListener('message', event => { const message = event.data; if (message.command === 'databaseStatus' && message.status === 'running') { setupState.update(s => ({ ...s, databaseReady: true })); } });`
    *   **Imports**: `setupState` from store.

**Acceptance Criteria:**
-   The dropdown displays "Qdrant" as an option.
-   Clicking the button successfully opens a terminal and runs `docker-compose up`.
-   The UI status correctly reflects the health status received from the backend, changing from "Not Running" to "Running".
-   The `databaseReady` state in the Svelte store is updated correctly.

**Dependencies:**
-   VS Code extension boilerplate must be complete.
-   A `docker-compose.yml` file must exist in the project root.
</file>

<file path="docs/todo/fe/backlog_sub_sprint_2_embedding_provider_workflow_logic.md">
# Backlog: Sub-Sprint 2 - Embedding Provider & Workflow Logic

**Objective:** To build the embedding provider selection component and the final workflow logic to enable indexing.

**Parent Sprint:** Sprint 1: Setup View Implementation

---

### User Story: Select Embedding Provider and Start Indexing

**As a** new user (Devin), **I want to** choose my embedding provider and trigger the indexing process, **so that** my code context can be generated.

**Workflow:**
1.  The `EmbeddingSetup.svelte` component renders a dropdown for selecting an embedding provider.
2.  The main `SetupView` component contains the "Index Now" button, which is disabled by default.
3.  The button's state is reactively bound to the `setupState` store. It becomes enabled only when the database is ready AND an embedding provider has been selected.
4.  Clicking the button sends the complete configuration to the extension backend to begin the indexing process.

**File Changes:**
*   `webview/src/lib/components/EmbeddingSetup.svelte` (New File)
*   `webview/src/lib/stores/setupStore.ts` (Modification)
*   `webview/src/routes/+page.svelte` (Modification)
*   `src/extension.ts` (Modification)

**Actions to Undertake:**
1.  **Filepath**: `webview/src/lib/components/EmbeddingSetup.svelte` (New File)
    *   **Action**: Build the UI with a Fluent UI `<Select>` component to choose between "Ollama" and "OpenAI".
    *   **Implementation**:
        ```html
        <script lang="ts">
          import { Select } from '@svelte-fui/core';
          import { setupState } from '$lib/stores/setupStore';
          const providers = ['Ollama', 'OpenAI'];
          function handleSelect(event) {
            setupState.update(s => ({ ...s, providerSelected: event.detail.value }));
          }
        </script>
        <h2>Embedding Provider</h2>
        <Select items={providers} placeholder="Select a provider" on:change={handleSelect} />
        ```
    *   **Imports**: `@svelte-fui/core`, `../stores/setupStore`
2.  **Filepath**: `webview/src/lib/stores/setupStore.ts`
    *   **Action**: Ensure the store can hold the selected provider's name.
    *   **Implementation**: The existing `providerSelected: string | null;` in the `SetupState` interface is sufficient.
    *   **Imports**: None.
3.  **Filepath**: `webview/src/routes/+page.svelte`
    *   **Action**: Add the "Index Now" button and bind its `disabled` property to a derived state from the store.
    *   **Implementation**:
        ```html
        <script lang="ts">
          import { setupState } from '$lib/stores/setupStore';
          import { Button } from '@svelte-fui/core';
          $: canStartIndex = $setupState.databaseReady && $setupState.providerSelected;
          function startIndexing() {
            vscode.postMessage({ command: 'startIndexing', config: $setupState });
          }
        </script>
        <Button variant="accent" disabled={!canStartIndex} on:click={startIndexing}>Index Now</Button>
        ```
    *   **Imports**: `setupState`, `Button`
4.  **Filepath**: `src/extension.ts`
    *   **Action**: Add a case for `startIndexing` in the `onDidReceiveMessage` listener.
    *   **Implementation**: `case 'startIndexing': const config = message.config; vscode.window.showInformationMessage(`Starting indexing with provider: ${config.providerSelected}`); // Future logic to save config and start backend process goes here. break;`
    *   **Imports**: `vscode`

**Acceptance Criteria:**
-   The dropdown displays "Ollama" and "OpenAI" as options.
-   Selecting a provider updates the `providerSelected` field in the Svelte store.
-   The "Index Now" button is disabled by default.
-   The button becomes enabled only after the database is running AND a provider is selected.
-   Clicking the button successfully sends the full configuration details to the extension backend.

**Dependencies:**
-   Sub-Sprint 1 must be complete.
</file>

<file path="docs/todo/fe/implementation_sprint_1_setup_view_implementation.md">
# Implementation Guidance: Sprint 1 - Setup View Implementation

**Objective:** To provide the technical guidance, code examples, and API information needed to build the onboarding and setup UI using SvelteKit, Fluent UI, and the VS Code Webview API.

---

### 1. Scaffolding the SvelteKit Project in `webview/`

Since the `webview` directory is empty, you will need to create a new SvelteKit project there. This will serve as the foundation for the entire UI.

**Command:**
```bash
# Navigate to the project root
cd /Users/bramburn/dev/bigcontext

# Create a new SvelteKit project inside the webview directory
npm create svelte@latest webview

# Follow the prompts:
# ? Which Svelte app template?  SvelteKit demo app
# ? Add type checking with TypeScript?  Yes, using TypeScript syntax
# ? Select additional options  ESLint, Prettier
```

After creation, `cd webview` and run `npm install`.

### 2. Configuring SvelteKit for VS Code Webviews

For a webview, the SvelteKit app must be exported as a static, single-page application (SPA).

**1. Install Static Adapter:**
```bash
cd /Users/bramburn/dev/bigcontext/webview
npm install -D @sveltejs/adapter-static@next
```

**2. Configure `svelte.config.js`:**
Modify `webview/svelte.config.js` to use the static adapter. This ensures all UI assets are bundled into a `build` directory with predictable paths.

```javascript
// webview/svelte.config.js
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/kit/vite';

/** @type {import('@sveltejs/kit').Config} */
const config = {
    preprocess: vitePreprocess(),
    kit: {
        adapter: adapter({
            pages: 'build',
            assets: 'build',
            fallback: 'index.html', // Important for SPA behavior
            precompress: false
        }),
        // This is crucial for resolving asset paths correctly inside the webview
        paths: {
            base: '{{vscode-resource-base}}' // A placeholder we will replace
        },
        appDir: 'app'
    }
};

export default config;
```

### 3. Integrating Fluent UI

We will use `svelte-fui`, a community-maintained library for Fluent UI components in Svelte.

**1. Install Dependencies:**
```bash
cd /Users/bramburn/dev/bigcontext/webview
npm install @svelte-fui/core @svelte-fui/tailwindcss
```

**2. Configure TailwindCSS:**
Create `webview/tailwind.config.js` and add the `svelte-fui` preset.
```javascript
// webview/tailwind.config.js
/** @type {import('tailwindcss').Config}*/
const config = {
  content: ['./src/**/*.{html,js,svelte,ts}'],
  presets: [require('@svelte-fui/tailwindcss').preset()],
  theme: {
    extend: {}
  },
  plugins: []
};

module.exports = config;
```
You will also need to set up Tailwind by creating `postcss.config.js` and `src/app.css` as per the SvelteKit Tailwind integration docs.

### 4. Webview Panel Creation and Communication (`src/extension.ts`)

This is the core logic for loading and interacting with the Svelte UI from the extension host.

**1. Loading the UI:**
The `createWebviewPanel` function loads the `index.html` from the SvelteKit `build` directory. We must replace the asset paths with special `vscode-resource` URIs.

```typescript
// src/extension.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

function createWebviewPanel(context: vscode.ExtensionContext) {
    const panel = vscode.window.createWebviewPanel(
        'setupView',
        'Code Context Setup',
        vscode.ViewColumn.One,
        {
            enableScripts: true,
            localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'webview', 'build')]
        }
    );

    const buildPath = vscode.Uri.joinPath(context.extensionUri, 'webview', 'build').fsPath;
    let html = fs.readFileSync(path.join(buildPath, 'index.html'), 'utf8');

    // Create the base URI for webview resources
    const baseUri = panel.webview.asWebviewUri(vscode.Uri.file(buildPath)).toString();
    // Replace our placeholder with the correct base URI
    html = html.replace('{{vscode-resource-base}}', baseUri);

    panel.webview.html = html;
    return panel;
}
```

**2. Bidirectional Messaging:**
Communication relies on `panel.webview.postMessage` and `panel.webview.onDidReceiveMessage`.

*   **From Extension to Webview:**
    ```typescript
    // src/extension.ts
    // Example: Sending database status to the UI
    panel.webview.postMessage({ command: 'databaseStatus', status: 'Running' });
    ```

*   **From Webview to Extension:**
    First, get the VS Code API instance in your Svelte component.
    ```html
    <!-- webview/src/lib/components/DatabaseSetup.svelte -->
    <script lang="ts">
        const vscode = acquireVsCodeApi();

        function startDatabase() {
            vscode.postMessage({
                command: 'startDatabase',
                payload: { type: 'qdrant' }
            });
        }
    </script>
    <Button on:click={startDatabase}>Start Local Qdrant</Button>
    ```
    Then, handle the message in `extension.ts`.
    ```typescript
    // src/extension.ts
    panel.webview.onDidReceiveMessage(message => {
        switch (message.command) {
            case 'startDatabase':
                const terminal = vscode.window.createTerminal(`Qdrant DB`);
                terminal.sendText('docker-compose up');
                terminal.show();
                // Here you would add logic to health-check the DB
                // and post a message back to the webview on success.
                return;
        }
    });
    ```

### 5. Running Commands in a Terminal

The `vscode.window.createTerminal` API is used to create and manage terminal instances from the extension.

**API Reference:** `vscode.window.createTerminal`
*   **`name`**: A string that is shown in the terminal's dropdown.
*   **`shellPath`**: (Optional) Path to a custom shell executable.
*   **`shellArgs`**: (Optional) Arguments for the shell.

**Example:**
```typescript
// src/extension.ts
// This creates a new terminal named "My Command" and runs "echo Hello"
const terminal = vscode.window.createTerminal("My Command");
terminal.sendText("echo Hello");
terminal.show(); // Makes the terminal visible to the user
```
For the PRD requirement, you will use `terminal.sendText('docker-compose up');`. You should also advise the user that this requires `docker-compose.yml` to be present in the workspace root and Docker to be running.
</file>

<file path="docs/todo/fe/implementation_sprint_1_web_api_boilerplate.md">
### How to Implement Sprint 1: C# Web API Boilerplate

This sprint focuses on setting up the foundational C# ASP.NET Core Web API project with a clean architecture.

**Key Technologies and Concepts:**

*   **ASP.NET Core Minimal APIs:** A simplified approach to building HTTP APIs in .NET 6 and later, reducing boilerplate code.
*   **.NET CLI:** Command-line interface for developing .NET applications.
*   **Dependency Injection (DI):** Built-in feature in ASP.NET Core for managing object dependencies, promoting loose coupling.
*   **Swagger/OpenAPI:** Tools for documenting and testing RESTful APIs.
*   **Clean Architecture:** Organizing code into layers (e.g., Core, Infrastructure, API) to separate concerns and improve maintainability.

**Detailed Implementation Steps and Code Examples:**

1.  **Create .NET Solution and Projects:**
    Use the `dotnet new` command to scaffold the solution and projects.
    *   **Command:**
        ```bash
        dotnet new sln -n CodeContext
        dotnet new webapi -n CodeContext.Api -o CodeContext.Api
        dotnet new classlib -n CodeContext.Core -o CodeContext.Core
        dotnet new classlib -n CodeContext.Infrastructure -o CodeContext.Infrastructure
        dotnet sln CodeContext.sln add CodeContext.Api/CodeContext.Api.csproj
        dotnet sln CodeContext.sln add CodeContext.Core/CodeContext.Core.csproj
        dotnet sln CodeContext.sln add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj
        ```
    *   **Guidance:** The `-o` flag creates the project in a new directory. `dotnet sln add` links the projects to the solution file.

2.  **Set Project References:**
    Edit the `CodeContext.Api.csproj` file to add references to the Core and Infrastructure projects. This allows the API layer to access types defined in the other layers.
    *   **File:** `CodeContext.Api/CodeContext.Api.csproj`
    *   **Code Example (add inside `<Project>` tag):**
        ```xml
        <ItemGroup>
            <ProjectReference Include="..\CodeContext.Core\CodeContext.Core.csproj" />
            <ProjectReference Include="..\CodeContext.Infrastructure\CodeContext.Infrastructure.csproj" />
        </ItemGroup>
        ```
    *   **Guidance:** Ensure the `Include` paths correctly point to the `.csproj` files of the Core and Infrastructure projects relative to the API project.

3.  **Implement Health Check Endpoint:**
    Modify `Program.cs` in the API project to add a simple `/health` endpoint. This is crucial for monitoring the API's availability.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add before `app.Run();`):**
        ```csharp
        // ... existing code ...

        app.MapGet("/health", () => Results.Ok());

        app.Run();
        ```
    *   **Guidance:** `Results.Ok()` is part of the `Microsoft.AspNetCore.Http.Results` class, which is implicitly available in minimal API contexts. This endpoint will return an HTTP 200 OK status.

4.  **Add Swagger/OpenAPI:**
    Integrate Swashbuckle to generate OpenAPI specifications and provide a Swagger UI for API documentation and testing.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add in `builder.Services` section):**
        ```csharp
        // ... existing code ...
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();

        var app = builder.Build();

        // Configure the HTTP request pipeline.
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }
        // ... existing code ...
        ```
    *   **Guidance:** `AddEndpointsApiExplorer()` is needed for minimal APIs to be discovered by Swagger. `AddSwaggerGen()` registers the Swagger generator. `UseSwagger()` and `UseSwaggerUI()` enable the middleware for serving the generated specification and the UI, respectively. These are typically enabled only in development environments.

5.  **Define Core Interfaces:**
    Create placeholder interfaces in the `CodeContext.Core` project. These interfaces will define the contracts for embedding providers and vector database clients, promoting a clean separation of concerns and extensibility.
    *   **File:** `CodeContext.Core/IEmbeddingProvider.cs`
    *   **Code Example:**
        ```csharp
        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                // Future methods for generating embeddings will go here, e.g.:
                // Task<float[]> GenerateEmbeddingAsync(string text);
            }
        }
        ```
    *   **File:** `CodeContext.Core/IVectorDatabaseClient.cs`
    *   **Code Example:**
        ```csharp
        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                // Future methods for interacting with vector databases will go here, e.g.:
                // Task UpsertAsync(string id, float[] vector, Dictionary<string, object> payload);
                // Task<List<QueryResult>> QueryAsync(float[] vector, int topK);
            }
        }
        ```
    *   **Guidance:** These interfaces are currently empty but establish the architectural placeholders.

6.  **Define Infrastructure Placeholders:**
    Create directories within the `CodeContext.Infrastructure` project to logically separate concrete implementations of database clients and embedding providers.
    *   **Action:** Manually create the following directories:
        *   `CodeContext.Infrastructure/DatabaseClients`
        *   `CodeContext.Infrastructure/EmbeddingProviders`
    *   **Guidance:** These folders will house the actual implementations (e.g., `QdrantClient.cs`, `OllamaProvider.cs`) in later sprints.

**Verification:**

After implementing these steps, build the solution (`dotnet build CodeContext.sln`) and run the API project (`dotnet run --project CodeContext.Api`). Verify that:
*   The API starts successfully.
*   You can access `http://localhost:<port>/health` and get a 200 OK response.
*   You can access `http://localhost:<port>/swagger` and see the Swagger UI.
</file>

<file path="docs/todo/fe/implementation_sprint_2_extensible_client_framework.md">
### How to Implement Sprint 2: Extensible Client Framework

This sprint focuses on designing the core interfaces for our external dependencies (embedding providers and vector databases) and setting up the dependency injection (DI) mechanism to manage their concrete implementations. This is crucial for building a flexible and testable architecture.

**Key Technologies and Concepts:**

*   **Interfaces (C#):** Define contracts for classes, enabling polymorphism and loose coupling.
*   **Dependency Injection (DI):** A software design pattern that allows for the inversion of control, where dependencies are provided to a class rather than the class creating them. ASP.NET Core has a built-in DI container.
*   **Strategy Pattern / Factory Pattern:** Design patterns that can be used to select and provide the correct implementation of an interface at runtime based on configuration or other criteria.
*   **`IServiceProvider` and `GetRequiredService<T>()`:** Core components of the .NET DI system for resolving registered services.

**Detailed Implementation Steps and Code Examples:**

1.  **Enhance `IEmbeddingProvider` Interface:**
    Define the `GenerateEmbeddingsAsync` method, which will be responsible for converting text into numerical vector representations.
    *   **File:** `CodeContext.Core/IEmbeddingProvider.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IEmbeddingProvider
            {
                /// <summary>
                /// Generates embeddings for a list of text inputs.
                /// </summary>
                /// <param name="texts">A list of strings to generate embeddings for.</param>
                /// <returns>A list of float arrays, where each array is an embedding for the corresponding text.</returns>
                Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts);
            }
        }
        ```
    *   **Guidance:** The `List<float[]>` return type is a common representation for embeddings. `Task` indicates an asynchronous operation, which is standard for I/O-bound tasks like API calls.

2.  **Enhance `IVectorDatabaseClient` Interface:**
    Define methods for `UpsertAsync` (inserting/updating vectors) and `QueryAsync` (searching for similar vectors). Also, define helper classes `VectorData` and `QueryResult` for structured data transfer.
    *   **File:** `CodeContext.Core/IVectorDatabaseClient.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Threading.Tasks;

        namespace CodeContext.Core
        {
            public interface IVectorDatabaseClient
            {
                /// <summary>
                /// Inserts or updates vectors in the specified collection.
                /// </summary>
                /// <param name="collectionName">The name of the vector collection.</param>
                /// <param name="vectors">A list of VectorData objects to upsert.</param>
                Task UpsertAsync(string collectionName, List<VectorData> vectors);

                /// <summary>
                /// Queries the vector database for similar vectors.
                /// </summary>
                /// <param name="collectionName">The name of the vector collection to query.</param>
                /// <param name="vector">The query vector.</param>
                /// <param name="topK">The number of top similar results to return.</param>
                /// <returns>A list of QueryResult objects.</returns>
                Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK);
            }

            /// <summary>
            /// Represents a single vector data point to be stored in the database.
            /// </summary>
            public class VectorData
            {
                public string Id { get; set; } // Unique identifier for the vector
                public float[] Vector { get; set; } // The embedding vector itself
                public Dictionary<string, object> Payload { get; set; } // Additional metadata
            }

            /// <summary>
            /// Represents a single query result from the vector database.
            /// </summary>
            public class QueryResult
            {
                public string Id { get; set; } // Identifier of the matched vector
                public double Score { get; set; } // Similarity score
                public Dictionary<string, object> Payload { get; set; } // Associated metadata
            }
        }
        ```
    *   **Guidance:** `Payload` is a `Dictionary<string, object>` to allow flexible metadata storage alongside vectors.

3.  **Create `ClientFactory` for Dynamic Resolution:**
    This factory will be responsible for providing the correct concrete implementation of `IEmbeddingProvider` or `IVectorDatabaseClient` based on a configuration string. This uses the Strategy/Factory pattern.
    *   **File:** `CodeContext.Core/ClientFactory.cs` (New File)
    *   **Code Example:**
        ```csharp
        using System;
        using Microsoft.Extensions.DependencyInjection; // Required for GetRequiredService

        namespace CodeContext.Core
        {
            public class ClientFactory
            {
                private readonly IServiceProvider _serviceProvider;

                public ClientFactory(IServiceProvider serviceProvider)
                {
                    _serviceProvider = serviceProvider;
                }

                public IEmbeddingProvider GetEmbeddingProvider(string providerType)
                {
                    // In a real application, you might use a more sophisticated lookup
                    // or configuration-driven approach. For now, a switch is sufficient.
                    return providerType.ToLowerInvariant() switch
                    {
                        "ollama" => _serviceProvider.GetRequiredService<OllamaProvider>(), // OllamaProvider will be registered in Program.cs
                        _ => throw new ArgumentException($"Unknown embedding provider type: {providerType}")
                    };
                }

                public IVectorDatabaseClient GetVectorDatabaseClient(string clientType)
                {
                    return clientType.ToLowerInvariant() switch
                    {
                        "qdrant" => _serviceProvider.GetRequiredService<QdrantClient>(), // QdrantClient will be registered in Program.cs
                        _ => throw new ArgumentException($"Unknown vector database client type: {clientType}")
                    };
                }
            }
        }
        ```
    *   **Guidance:** The `ClientFactory` takes `IServiceProvider` in its constructor, allowing it to resolve other services (our concrete client implementations) at runtime. Note that `OllamaProvider` and `QdrantClient` are concrete types that will be implemented and registered in later sprints.

4.  **Register `ClientFactory` with DI Container:**
    Add the `ClientFactory` as a singleton service in `Program.cs` so it can be injected wherever needed.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add in `builder.Services` section):**
        ```csharp
        using CodeContext.Core; // Add this import at the top

        // ... existing code ...
        builder.Services.AddSingleton<ClientFactory>();

        // In later sprints, you will register concrete implementations like this:
        // builder.Services.AddSingleton<OllamaProvider>();
        // builder.Services.AddSingleton<QdrantClient>();
        // builder.Services.AddSingleton<IEmbeddingProvider, OllamaProvider>(); // If you want to directly inject the interface
        // builder.Services.AddSingleton<IVectorDatabaseClient, QdrantClient>(); // If you want to directly inject the interface
        ```
    *   **Guidance:** `AddSingleton` ensures only one instance of `ClientFactory` is created and reused throughout the application's lifetime.

**Verification:**

*   Ensure the solution builds successfully after these changes.
*   While direct runtime testing of the factory's resolution capabilities is limited without concrete implementations, you can write unit tests in a separate test project (e.g., `CodeContext.Tests`) to verify the factory's logic.
    *   **Example Unit Test (Conceptual):**
        ```csharp
        // In CodeContext.Tests/ClientFactoryTests.cs
        using Xunit;
        using Microsoft.Extensions.DependencyInjection;
        using CodeContext.Core;
        using Moq; // For mocking interfaces

        public class ClientFactoryTests
        {
            [Fact]
            public void GetEmbeddingProvider_ReturnsOllamaProvider_WhenOllamaTypeIsRequested()
            {
                // Arrange
                var services = new ServiceCollection();
                var mockOllamaProvider = new Mock<IEmbeddingProvider>(); // Mock the concrete provider
                services.AddSingleton(mockOllamaProvider.Object); // Register the mock as the concrete type
                services.AddSingleton<ClientFactory>();
                var serviceProvider = services.BuildServiceProvider();
                var factory = serviceProvider.GetRequiredService<ClientFactory>();

                // Act
                var provider = factory.GetEmbeddingProvider("ollama");

                // Assert
                Assert.NotNull(provider);
                // You might assert the type if OllamaProvider was a concrete class,
                // but here we are just checking if a service was returned.
            }

            // Add similar tests for IVectorDatabaseClient
        }
        ```
    *   **Guidance:** This conceptual test demonstrates how you would set up a test environment using `ServiceCollection` and `Moq` (a mocking library) to verify the factory's behavior.
</file>

<file path="docs/todo/fe/implementation_sprint_3_backend_process_management.md">
### How to Implement Sprint 3: Backend Process Management

This sprint focuses on the critical integration between the VS Code extension (TypeScript) and the C# backend. The goal is to automate the lifecycle management of the backend process, ensuring it starts automatically, is monitored for health, and is properly terminated.

**Key Technologies and Concepts:**

*   **Node.js `child_process` module:** Provides the ability to spawn child processes, execute shell commands, and interact with their I/O streams. Specifically, `spawn` is preferred for long-running processes.
*   **VS Code Extension API:** `vscode.ExtensionContext` for managing disposables, `vscode.window.showInformationMessage` for user notifications.
*   **HTTP `fetch` API:** For making HTTP requests to the backend's health endpoint. In Node.js, you might need a polyfill like `node-fetch` or use `undici` for Node.js 18+.
*   **Process Management:** Handling `stdout`, `stderr`, `close`, and `error` events of the child process. Ensuring proper termination (`kill()`).

**Detailed Implementation Steps and Code Examples:**

1.  **Spawn C# Backend Executable:**
    In your extension's `activate` function, use `child_process.spawn` to launch the compiled C# executable. You'll need to determine the correct path to your executable after the C# project is built.
    *   **File:** `extension.ts` (main extension file)
    *   **Code Example:**
        ```typescript
        import * as vscode from 'vscode';
        import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
        import * as path from 'path';
        import fetch from 'node-fetch'; // Or 'undici' for Node.js 18+

        let backendProcess: ChildProcessWithoutNullStreams | null = null;
        const backendPort = 5000; // Define your backend's port

        export function activate(context: vscode.ExtensionContext) {
            console.log('Code Context extension is now active!');

            // IMPORTANT: Adjust this path based on your C# build output location.
            // This assumes the C# project builds to a 'bin' folder within the extension's root.
            const backendExecutablePath = path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api'); // Example for Windows/Linux
            // For macOS, it might be: path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api')
            // Or if it's a self-contained deployment: path.join(context.extensionPath, 'publish', 'CodeContext.Api')

            // Ensure the executable exists before trying to spawn
            if (!require('fs').existsSync(backendExecutablePath)) {
                vscode.window.showErrorMessage(`Code Context backend executable not found at: ${backendExecutablePath}`);
                return;
            }

            backendProcess = spawn(backendExecutablePath, [], {
                cwd: path.dirname(backendExecutablePath), // Run from the executable's directory
                stdio: ['ignore', 'pipe', 'pipe'] // Ignore stdin, pipe stdout/stderr
            });

            // Capture stdout for logging
            backendProcess.stdout.on('data', (data) => {
                console.log(`[Backend stdout]: ${data.toString()}`);
                // Consider using a dedicated VS Code OutputChannel for better logging
                // const outputChannel = vscode.window.createOutputChannel("Code Context Backend");
                // outputChannel.appendLine(`[Backend stdout]: ${data.toString()}`);
            });

            // Capture stderr for error logging
            backendProcess.stderr.on('data', (data) => {
                console.error(`[Backend stderr]: ${data.toString()}`);
                // outputChannel.appendLine(`[Backend stderr]: ${data.toString()}`);
            });

            // Handle process exit
            backendProcess.on('close', (code) => {
                console.log(`Backend process exited with code ${code}`);
                backendProcess = null;
                // Potentially notify user or attempt restart if unexpected exit
            });

            // Handle errors during spawning (e.g., executable not found, permissions)
            backendProcess.on('error', (err) => {
                console.error('Failed to start backend process:', err);
                vscode.window.showErrorMessage(`Failed to start Code Context backend: ${err.message}`);
                backendProcess = null;
            });

            // Ensure the process is killed when the extension deactivates
            context.subscriptions.push({
                dispose: () => {
                    if (backendProcess) {
                        console.log('Terminating backend process on extension deactivation...');
                        backendProcess.kill(); // Sends SIGTERM
                        backendProcess = null;
                    }
                }
            });

            // Start health check after a short delay to allow backend to start listening
            setTimeout(() => startHealthCheck(context), 2000);
        }

        export function deactivate() {
            if (backendProcess) {
                console.log('Deactivating extension, terminating backend process...');
                backendProcess.kill(); // Ensure process is killed
                backendProcess = null;
            }
        }
        ```
    *   **Guidance:**
        *   `cwd`: Set the current working directory for the spawned process to the directory containing the executable.
        *   `stdio`: `['ignore', 'pipe', 'pipe']` means stdin is ignored, stdout and stderr are piped to the parent process (your extension), allowing you to capture their output.
        *   **Executable Path:** The path `path.join(context.extensionPath, 'bin', 'CodeContext.Api', 'CodeContext.Api')` is a common pattern for .NET Core executables. For cross-platform compatibility, you might need to check `process.platform` or use a self-contained deployment.
        *   **Error Handling:** Implement robust error handling for `spawn` and `on('error')` events.

2.  **Implement Backend Health Monitoring:**
    Create a function to periodically check the backend's `/health` endpoint. If it fails repeatedly, attempt to restart the backend.
    *   **File:** `extension.ts`
    *   **Code Example (add as a new function):**
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        let healthCheckTimer: NodeJS.Timeout | null = null;
        let healthCheckAttempts = 0;
        const maxHealthCheckAttempts = 5; // Number of failed attempts before restart
        const healthCheckInterval = 5000; // Check every 5 seconds

        async function checkBackendHealth(context: vscode.ExtensionContext): Promise<boolean> {
            if (!backendProcess) {
                console.log('Backend process not running, health check skipped.');
                return false;
            }
            try {
                const response = await fetch(`http://localhost:${backendPort}/health`);
                if (response.ok) {
                    console.log('Backend is healthy.');
                    healthCheckAttempts = 0;
                    // You can send a message to your webview here to update UI status
                    // vscode.window.activeTextEditor?.document.uri.scheme === 'vscode-webview' &&
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'running' });
                    return true;
                } else {
                    console.warn(`Backend health check failed: HTTP ${response.status}`);
                    return false;
                }
            } catch (error) {
                console.error('Error during backend health check:', error);
                return false;
            }
        }

        function startHealthCheck(context: vscode.ExtensionContext) {
            if (healthCheckTimer) {
                clearInterval(healthCheckTimer);
            }
            healthCheckTimer = setInterval(async () => {
                const isHealthy = await checkBackendHealth(context);
                if (!isHealthy) {
                    healthCheckAttempts++;
                    // Update UI state to "Starting" or "Error"
                    // webviewPanel.webview.postMessage({ type: 'backendStatus', status: 'starting' });

                    if (healthCheckAttempts >= maxHealthCheckAttempts) {
                        console.error('Max health check attempts reached. Attempting to restart backend.');
                        clearInterval(healthCheckTimer!);
                        restartBackend(context);
                    }
                }
            }, healthCheckInterval);
        }

        function restartBackend(context: vscode.ExtensionContext) {
            if (backendProcess) {
                console.log('Killing existing backend process for restart...');
                backendProcess.kill(); // Send SIGTERM
                backendProcess = null;
            }
            healthCheckAttempts = 0; // Reset attempts for new process
            console.log('Attempting to restart backend process...');
            // Re-call activate to re-spawn and re-initialize everything
            // In a more complex app, you might have a dedicated `startBackend` function
            deactivate(); // Clean up existing disposables
            activate(context); // Re-activate the extension, which will spawn a new process
            vscode.window.showWarningMessage('Code Context Backend is restarting due to health check failures.');
        }
        ```
    *   **Guidance:**
        *   `setInterval`: Used for periodic checks.
        *   `fetch`: Make HTTP requests. Remember to install `node-fetch` (`npm install node-fetch`) or use Node.js's built-in `fetch` if on Node.js 18+.
        *   **Restart Logic:** The `restartBackend` function kills the current process and then re-calls `activate(context)`. This is a simple way to re-initialize the extension and spawn a new backend. For more fine-grained control, you might extract the spawning logic into a separate `startBackend` function.
        *   **UI Integration:** The comments show where you would send messages to a VS Code Webview to update the UI status.

**Verification:**

*   **Manual Testing:**
    1.  Open VS Code and activate the extension. Check your system's process list (Task Manager on Windows, Activity Monitor on macOS, `ps aux | grep CodeContext.Api` on Linux) to confirm the C# backend process is running.
    2.  Deactivate the extension (e.g., by closing the VS Code window or disabling the extension). Verify the C# backend process is no longer running.
    3.  While the extension is active, manually kill the C# backend process (e.g., using Task Manager). Observe if the extension detects the unhealthiness and attempts to restart the backend after a few intervals.
*   **Logging:** Monitor the VS Code Debug Console (for `console.log` messages) or a dedicated Output Channel (if implemented) for messages indicating process start/stop, health checks, and errors.
</file>

<file path="docs/todo/fe/implementation_sprint_4_onboarding_setup_ui.md">
### How to Implement Sprint 4: Onboarding & Setup UI

This sprint focuses on building the initial user interface within the VS Code extension, specifically for onboarding new users and allowing them to configure their database and embedding provider. This involves creating a VS Code Webview and integrating a Svelte frontend.

**Key Technologies and Concepts:**

*   **VS Code Webviews:** Allow you to create custom UI within VS Code using HTML, CSS, and JavaScript (or frameworks like Svelte, React, Vue).
*   **Svelte:** A reactive JavaScript framework for building user interfaces.
*   **`vscode.workspace.workspaceFolders`:** API to get information about open workspace folders.
*   **`fs` module (Node.js):** For file system operations like checking file existence.
*   **`vscode.window.createTerminal()`:** API to create and interact with VS Code integrated terminals.
*   **Message Passing (Extension <-> Webview):** Communication between the VS Code extension (Node.js/TypeScript) and the webview (Svelte/JavaScript) is done via `postMessage` and `onDidReceiveMessage`.

**Detailed Implementation Steps and Code Examples:**

1.  **Create and Manage VS Code Webview:**
    The `extension.ts` file will be responsible for creating the webview panel and loading your Svelte application into it. It will also handle communication between the extension and the webview.
    *   **File:** `extension.ts`
    *   **Code Example (within `activate` function):**
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';
        // ... (other imports like child_process, fetch) ...

        export function activate(context: vscode.ExtensionContext) {
            // ... (backend process management setup) ...

            // Create and show the webview panel
            const panel = vscode.window.createWebviewPanel(
                'codeContext', // Unique ID for the webview
                'Code Context', // Title shown in VS Code tab
                vscode.ViewColumn.One, // Where to open the panel (e.g., in the first editor column)
                {
                    enableScripts: true, // VERY IMPORTANT: Allows JavaScript to run in the webview
                    // Restrict the webview to only load resources from our extension's 'webview/dist' directory
                    localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                }
            );

            // Get the path to the SvelteKit build output (index.html)
            const svelteAppPath = path.join(context.extensionPath, 'webview', 'dist', 'index.html');
            if (!fs.existsSync(svelteAppPath)) {
                vscode.window.showErrorMessage('Svelte webview build not found. Please run `npm run build` in the webview directory.');
                return;
            }
            panel.webview.html = fs.readFileSync(svelteAppPath, 'utf8');

            // Check for existing configuration file
            const workspaceFolders = vscode.workspace.workspaceFolders;
            let configFilePath: string | undefined;
            if (workspaceFolders && workspaceFolders.length > 0) {
                // Assuming config file is in .vscode/code-context.json relative to workspace root
                configFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'code-context.json');
            }

            let initialView: 'setup' | 'query' = 'setup';
            if (configFilePath && fs.existsSync(configFilePath)) {
                initialView = 'query'; // If config exists, show query view
            }

            // Send initial view state to the Svelte webview
            panel.webview.postMessage({ type: 'initialView', view: initialView });

            // Handle messages received from the webview (e.g., user clicks a button)
            panel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showInformationMessage(message.text);
                            return;
                        case 'startDocker':
                            handleStartDockerCommand(message.service, context);
                            return;
                        case 'saveConfigAndIndex':
                            // Implement saving config and triggering indexing in a later sprint
                            vscode.window.showInformationMessage('Configuration saved (not yet implemented) and indexing will start!');
                            return;
                    }
                },
                undefined,
                context.subscriptions // Ensure the message listener is disposed
            );

            // Add the panel to the extension's disposables so it's cleaned up when the extension deactivates
            context.subscriptions.push(panel);
        }
        ```
    *   **Guidance:**
        *   `enableScripts: true` is crucial for your Svelte app to run.
        *   `localResourceRoots` is a security measure to prevent the webview from loading arbitrary content.
        *   `panel.webview.html = fs.readFileSync(...)` loads your Svelte app's `index.html`.
        *   `panel.webview.postMessage` sends data to the webview.
        *   `panel.webview.onDidReceiveMessage` listens for data from the webview.

2.  **Svelte App Structure and View Management:**
    Your Svelte application will have a main `App.svelte` component that conditionally renders `SetupView.svelte` or `QueryView.svelte` based on a Svelte store.
    *   **File:** `webview/src/lib/stores/viewStore.ts` (New File)
    *   **Code Example:**
        ```typescript
        import { writable } from 'svelte/store';

        // Defines the current view of the webview: 'setup' or 'query'
        export const currentView = writable<'setup' | 'query'>('setup');
        ```
    *   **File:** `webview/src/App.svelte` (Main Svelte component)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            import { onMount } from 'svelte';
            import { currentView } from './lib/stores/viewStore';
            import SetupView from './lib/components/SetupView.svelte';
            import QueryView from './lib/components/QueryView.svelte';

            onMount(() => {
                // Listen for messages from the VS Code extension
                window.addEventListener('message', event => {
                    const message = event.data; // The JSON data that the extension sent
                    switch (message.type) {
                        case 'initialView':
                            currentView.set(message.view);
                            break;
                        // Add cases for other messages from extension (e.g., backend status updates)
                    }
                });
            });
        </script>

        <main>
            {#if $currentView === 'setup'}
                <SetupView />
            {:else if $currentView === 'query'}
                <QueryView />
            {/if}
        </main>

        <style>
            /* Global styles for your Svelte app */
            body {
                margin: 0;
                padding: 0;
                background-color: var(--vscode-editor-background);
                color: var(--vscode-editor-foreground);
            }
            /* You can use VS Code CSS variables for theming */
        </style>
        ```
    *   **Guidance:** The `onMount` lifecycle hook is used to set up the message listener. The `{#if}` block conditionally renders components.

3.  **Implement `SetupView.svelte`:**
    This component will contain the UI elements for selecting database/embedding providers and the "Start Local" buttons.
    *   **File:** `webview/src/lib/components/SetupView.svelte` (New File)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            import { postMessageToVsCode } from '../utils/vscode'; // Utility to send messages to extension

            let selectedDatabase: string = 'qdrant'; // Default selection
            let selectedEmbeddingProvider: string = 'ollama'; // Default selection

            function handleStartLocalService(service: string) {
                // Send a message to the VS Code extension to execute the Docker command
                postMessageToVsCode('startDocker', { service });
            }

            function handleSaveAndIndex() {
                // Send configuration to extension to save and trigger indexing
                postMessageToVsCode('saveConfigAndIndex', {
                    database: selectedDatabase,
                    embeddingProvider: selectedEmbeddingProvider
                });
            }
        </script>

        <div class="setup-container">
            <h1>Code Context Setup</h1>

            <section>
                <h2>Database Configuration</h2>
                <label for="database-select">Select Database:</label>
                <select id="database-select" bind:value={selectedDatabase}>
                    <option value="qdrant">Qdrant (Local)</option>
                    <!-- Add more database options here as they are supported -->
                </select>
                <button on:click={() => handleStartLocalService('qdrant')}>Start Local Qdrant</button>
                <!-- Future: Add status indicator (e.g., "Running", "Stopped") -->
            </section>

            <section>
                <h2>Embedding Provider Configuration</h2>
                <label for="embedding-select">Select Embedding Provider:</label>
                <select id="embedding-select" bind:value={selectedEmbeddingProvider}>
                    <option value="ollama">Ollama (Local)</option>
                    <!-- Add more embedding provider options here -->
                </select>
                <button on:click={() => handleStartLocalService('ollama')}>Start Local Ollama</button>
                <!-- Future: Add status indicator -->
            </section>

            <button on:click={handleSaveAndIndex}>Save & Index</button>
        </div>

        <style>
            /* Basic styling for the setup view */
            .setup-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
            section {
                margin-bottom: 20px;
                border: 1px solid var(--vscode-panel-border);
                padding: 15px;
                border-radius: 5px;
                background-color: var(--vscode-editorGroup-background);
            }
            label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            select, button {
                margin-right: 10px;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                cursor: pointer;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
        </style>
        ```
    *   **Guidance:** `bind:value` creates two-way data binding for select elements. `postMessageToVsCode` is a custom utility.

4.  **Create `postMessageToVsCode` Utility:**
    This simple utility abstracts the `acquireVsCodeApi()` call, making it easier to send messages from Svelte to the extension.
    *   **File:** `webview/src/lib/utils/vscode.ts` (New File)
    *   **Code Example:**
        ```typescript
        // This function is provided by VS Code to webviews to communicate back to the extension.
        // It must be called exactly once per webview panel.
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        /**
         * Sends a message from the Svelte webview to the VS Code extension.
         * @param command The command string (e.g., 'startDocker', 'saveConfig').
         * @param data Any additional data to send with the command.
         */
        export function postMessageToVsCode(command: string, data: any) {
            vscode.postMessage({ command, ...data });
        }
        ```
    *   **Guidance:** `acquireVsCodeApi()` is a global function available in webview contexts.

5.  **Implement `handleStartDockerCommand` in Extension:**
    This function in `extension.ts` will receive messages from the webview and execute the appropriate Docker commands in a new VS Code terminal.
    *   **File:** `extension.ts`
    *   **Code Example (add as a new function):**
        ```typescript
        // ... (inside extension.ts, after activate/deactivate) ...

        function handleStartDockerCommand(service: string, context: vscode.ExtensionContext) {
            let command: string;
            let terminalName: string;
            let cwd: string | undefined; // Current working directory for the terminal

            // Assuming docker-compose files are in a 'docker' sub-directory of the extension
            const dockerComposeDir = path.join(context.extensionPath, 'docker');

            switch (service) {
                case 'qdrant':
                    command = 'docker-compose -f docker-compose.qdrant.yml up -d';
                    terminalName = 'Code Context: Qdrant';
                    cwd = dockerComposeDir; // Run docker-compose from its directory
                    break;
                case 'ollama':
                    // Example Ollama command to run it as a detached container
                    command = 'docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama';
                    terminalName = 'Code Context: Ollama';
                    // Ollama command can be run from any directory, no specific cwd needed
                    break;
                default:
                    vscode.window.showErrorMessage(`Unknown service to start: ${service}`);
                    return;
            }

            const terminal = vscode.window.createTerminal({
                name: terminalName,
                cwd: cwd // Set the working directory for the terminal
            });
            terminal.show(); // Show the terminal panel
            terminal.sendText(command); // Send the command to the terminal

            vscode.window.showInformationMessage(`Attempting to start ${service} via Docker. Check '${terminalName}' terminal for status.`);
            // In a real scenario, you'd also want to poll the health of these services
            // and update the UI status in SetupView.svelte.
        }
        ```
    *   **Guidance:**
        *   `vscode.window.createTerminal()` creates a new integrated terminal.
        *   `terminal.show()` brings the terminal into focus.
        *   `terminal.sendText()` sends the command to be executed in the terminal.
        *   Consider adding a `docker-compose.qdrant.yml` file in a `docker` directory within your extension for Qdrant.

6.  **Create Placeholder `QueryView.svelte`:**
    This component will be displayed when a `code-context.json` file is found, indicating the project is already set up.
    *   **File:** `webview/src/lib/components/QueryView.svelte` (New File)
    *   **Code Example:**
        ```svelte
        <script lang="ts">
            // This component will be developed in a later sprint for querying functionality.
        </script>

        <div class="query-container">
            <h1>Code Context Query</h1>
            <p>Your project is configured. Query functionality will be available here soon!</p>
            <!-- Future: Input box for queries, display area for results -->
        </div>

        <style>
            .query-container {
                padding: 20px;
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
            }
        </style>
        ```
    *   **Guidance:** This is a minimal placeholder for now.

**Verification:**

*   **Build Svelte App:** Before testing, navigate to your `webview` directory and run `npm install` and then `npm run build` to compile your Svelte app into the `dist` folder.
*   **VS Code Testing:**
    1.  Open VS Code with an empty folder (no `.vscode/code-context.json`). Activate your extension. Verify that the "Code Context" webview panel appears and displays the `SetupView` with dropdowns and buttons.
    2.  Create an empty file at `.vscode/code-context.json` in your workspace root. Reload the VS Code window (Ctrl+R or Cmd+R). Verify that the webview now displays the `QueryView` placeholder.
    3.  Go back to the `SetupView` (by deleting `.vscode/code-context.json` and reloading). Click the "Start Local Qdrant" button. Verify a new VS Code terminal opens and the `docker-compose` command is executed. Repeat for "Start Local Ollama".
</file>

<file path="docs/todo/fe/implementation_sprint_5_concrete_client_implementation.md">
### How to Implement Sprint 5: Concrete Client Implementation (C#)

This sprint is about bringing our abstract interfaces to life by implementing concrete clients for Qdrant (vector database) and Ollama (embedding provider). We will also introduce the core indexing logic that orchestrates the parsing, embedding, and storage of code context.

**Key Technologies and Concepts:**

*   **Qdrant.Client NuGet Package:** The official .NET client library for interacting with Qdrant.
*   **`HttpClient` (C#):** For making HTTP requests to the Ollama API.
*   **`System.Text.Json`:** For JSON serialization and deserialization when communicating with Ollama.
*   **Abstract Syntax Tree (AST) Parsing:** The process of analyzing source code to build a tree-like representation of its structure. For C#, `Microsoft.CodeAnalysis` (Roslyn) is the standard. For other languages, you'd use appropriate libraries.
*   **Dependency Injection (DI):** Continues to be crucial for injecting our new concrete clients and services.
*   **`IConfiguration`:** For reading settings like API URLs and model names from `appsettings.json`.

**Detailed Implementation Steps and Code Examples:**

1.  **Add Qdrant.Client NuGet Package:**
    Install the official Qdrant .NET client library into your `CodeContext.Infrastructure` project.
    *   **Command:**
        ```bash
        dotnet add CodeContext.Infrastructure/CodeContext.Infrastructure.csproj package Qdrant.Client
        ```
    *   **Guidance:** Always check NuGet.org for the latest stable version.

2.  **Implement `QdrantClient` Class:**
    Create a class that implements `IVectorDatabaseClient` and uses the `Qdrant.Client` library to perform upsert and query operations.
    *   **File:** `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IVectorDatabaseClient, VectorData, QueryResult
        using Qdrant.Client;
        using Qdrant.Client.Grpc; // For PointStruct, VectorParams, Distance, etc.

        namespace CodeContext.Infrastructure.DatabaseClients
        {
            public class QdrantClient : IVectorDatabaseClient
            {
                private readonly QdrantGrpcClient _client;
                private readonly string _collectionName; // Default collection name

                public QdrantClient(string host, int port, string collectionName = "code_context_collection")
                {
                    _client = new QdrantGrpcClient(host, port);
                    _collectionName = collectionName;
                }

                public async Task UpsertAsync(string collectionName, List<VectorData> vectors)
                {
                    if (!vectors.Any()) return;

                    // Ensure collection exists or create it.
                    // In a production app, you might check this once on startup or have a dedicated migration.
                    var collections = await _client.Collections.ListAsync();
                    if (!collections.Any(c => c.Name == collectionName))
                    {
                        // Assuming all vectors have the same dimension (size) and cosine distance
                        await _client.Collections.CreateAsync(
                            collectionName,
                            new VectorParams { Size = (ulong)vectors.First().Vector.Length, Distance = Distance.Cosine }
                        );
                    }

                    // Convert our generic VectorData to Qdrant's PointStruct
                    var points = vectors.Select(v => new PointStruct
                    {
                        Id = v.Id, // Qdrant uses string IDs
                        Vectors = v.Vector.ToList(), // Convert float[] to List<float>
                        Payload = v.Payload.ToDictionary(
                            p => p.Key,
                            p => Value.From(p.Value) // Convert generic object to Qdrant's Value type
                        )
                    }).ToList();

                    // Perform the upsert operation
                    await _client.Points.UpsertAsync(collectionName, points);
                }

                public async Task<List<QueryResult>> QueryAsync(string collectionName, float[] vector, int topK)
                {
                    var searchResult = await _client.Points.SearchAsync(
                        collectionName,
                        vector.ToList(), // Convert float[] to List<float>
                        limit: (ulong)topK
                    );

                    // Convert Qdrant's SearchPoint to our generic QueryResult
                    return searchResult.Select(s => new QueryResult
                    {
                        Id = s.Id,
                        Score = s.Score,
                        Payload = s.Payload.ToDictionary(
                            p => p.Key,
                            p => p.Value.ToValue() // Convert Qdrant's Value back to generic object
                        )
                    }).ToList();
                }
            }
        }
        ```
    *   **Guidance:**
        *   `QdrantGrpcClient`: The main client for gRPC communication with Qdrant.
        *   `Value.From(object)` and `Value.ToValue()`: Helper methods for converting between C# objects and Qdrant's internal `Value` type for payload data.
        *   Collection creation: The example includes logic to create the collection if it doesn't exist. In a real application, this might be handled during setup or migration.

3.  **Implement `OllamaProvider` Class:**
    Create a class that implements `IEmbeddingProvider` and makes HTTP POST requests to a local Ollama instance to generate embeddings.
    *   **File:** `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Net.Http;
        using System.Text;
        using System.Text.Json;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider

        namespace CodeContext.Infrastructure.EmbeddingProviders
        {
            public class OllamaProvider : IEmbeddingProvider
            {
                private readonly HttpClient _httpClient;
                private readonly string _ollamaApiUrl;
                private readonly string _modelName;

                public OllamaProvider(HttpClient httpClient, string ollamaApiUrl, string modelName)
                {
                    _httpClient = httpClient;
                    _ollamaApiUrl = ollamaApiUrl;
                    _modelName = modelName;
                }

                public async Task<List<float[]>> GenerateEmbeddingsAsync(List<string> texts)
                {
                    var embeddings = new List<float[]>();
                    foreach (var text in texts)
                    {
                        var requestBody = new
                        {
                            model = _modelName,
                            prompt = text,
                            // You might add options like "keep_alive" for performance
                            // options = new { temperature = 0.0 }
                        };

                        var json = JsonSerializer.Serialize(requestBody);
                        var content = new StringContent(json, Encoding.UTF8, "application/json");

                        var response = await _httpClient.PostAsync($"{_ollamaApiUrl}/api/embeddings", content);
                        response.EnsureSuccessStatusCode(); // Throws an exception for non-2xx status codes

                        var responseBody = await response.Content.ReadAsStringAsync();
                        using (JsonDocument jsonDoc = JsonDocument.Parse(responseBody))
                        {
                            var embeddingArray = jsonDoc.RootElement.GetProperty("embedding").EnumerateArray()
                                .Select(e => (float)e.GetDouble())
                                .ToArray();
                            embeddings.Add(embeddingArray);
                        }
                    }
                    return embeddings;
                }
            }
        }
        ```
    *   **Guidance:**
        *   `HttpClient`: Best practice is to use `IHttpClientFactory` for managing `HttpClient` instances in ASP.NET Core. This is handled by `builder.Services.AddHttpClient<OllamaProvider>();` in `Program.cs`.
        *   Ollama API: The `/api/embeddings` endpoint expects a JSON payload with `model` and `prompt`.
        *   `JsonSerializer`: Used for serializing C# objects to JSON and deserializing JSON responses.

4.  **Add AST Parsing Logic (Placeholder):**
    Create a `ParsingService` that will eventually use an AST library to extract meaningful code snippets. For C#, `Microsoft.CodeAnalysis` (Roslyn) is the go-to.
    *   **File:** `CodeContext.Core/Services/ParsingService.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.IO;
        using System.Threading.Tasks;

        namespace CodeContext.Core.Services
        {
            public class ParsingService
            {
                /// <summary>
                /// Parses a code file and extracts relevant text snippets for embedding.
                /// This is a placeholder; actual implementation would use an AST library.
                /// </summary>
                /// <param name="filePath">The path to the code file.</param>
                /// <returns>A list of text snippets extracted from the file.</returns>
                public async Task<List<string>> ParseCodeFileAsync(string filePath)
                {
                    if (!File.Exists(filePath))
                    {
                        return new List<string>();
                    }

                    // For now, just return the entire file content as a single snippet.
                    // In a real implementation:
                    // - Use Roslyn for C# files (Microsoft.CodeAnalysis.CSharp)
                    // - Use other parsers for TypeScript, Python, etc.
                    // - Break down code into functions, classes, comments, etc.
                    var content = await File.ReadAllTextAsync(filePath);
                    return new List<string> { content };
                }
            }
        }
        ```
    *   **Guidance:** For C# parsing, you would add `Microsoft.CodeAnalysis.CSharp` NuGet package and use its APIs to traverse the syntax tree.

5.  **Create `IndexingService`:**
    This service orchestrates the entire indexing workflow: reading files, parsing them, generating embeddings, and upserting to the vector database.
    *   **File:** `CodeContext.Core/Services/IndexingService.cs`
    *   **Code Example:**
        ```csharp
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using CodeContext.Core; // For IEmbeddingProvider, IVectorDatabaseClient, VectorData

        namespace CodeContext.Core.Services
        {
            public class IndexingService
            {
                private readonly ParsingService _parsingService;
                private readonly IEmbeddingProvider _embeddingProvider;
                private readonly IVectorDatabaseClient _vectorDatabaseClient;

                public IndexingService(
                    ParsingService parsingService,
                    IEmbeddingProvider embeddingProvider,
                    IVectorDatabaseClient vectorDatabaseClient)
                {
                    _parsingService = parsingService;
                    _embeddingProvider = embeddingProvider;
                    _vectorDatabaseClient = vectorDatabaseClient;
                }

                /// <summary>
                /// Indexes a given code repository by parsing files, generating embeddings,
                /// and storing them in the vector database.
                /// </summary>
                /// <param name="repositoryPath">The root path of the code repository.</param>
                /// <param name="collectionName">The name of the Qdrant collection to use.</param>
                public async Task IndexRepositoryAsync(string repositoryPath, string collectionName)
                {
                    // TODO: Implement actual file enumeration (e.g., using Directory.EnumerateFiles)
                    // and filtering (e.g., .gitignore, file extensions).
                    var dummyFilePaths = new List<string> { 
                        Path.Combine(repositoryPath, "src", "Program.cs"), 
                        Path.Combine(repositoryPath, "src", "Utils.ts") 
                    };

                    foreach (var filePath in dummyFilePaths)
                    {
                        Console.WriteLine($"Indexing file: {filePath}"); // For logging progress
                        var codeSnippets = await _parsingService.ParseCodeFileAsync(filePath);

                        if (codeSnippets.Any())
                        {
                            var embeddings = await _embeddingProvider.GenerateEmbeddingsAsync(codeSnippets);

                            var vectorsToUpsert = new List<VectorData>();
                            for (int i = 0; i < embeddings.Count; i++)
                            {
                                vectorsToUpsert.Add(new VectorData
                                {
                                    Id = $"{filePath.Replace("\", "/")}_{i}", // Create a unique ID, normalize path
                                    Vector = embeddings[i],
                                    Payload = new Dictionary<string, object>
                                    {
                                        { "filePath", filePath },
                                        { "snippet", codeSnippets[i] }
                                    }
                                });
                            }
                            await _vectorDatabaseClient.UpsertAsync(collectionName, vectorsToUpsert);
                            Console.WriteLine($"Indexed {embeddings.Count} snippets from {filePath}");
                        }
                    }
                    Console.WriteLine("Indexing complete.");
                }
            }
        }
        ```
    *   **Guidance:** This service takes dependencies on `ParsingService`, `IEmbeddingProvider`, and `IVectorDatabaseClient`, which will be injected by DI.

6.  **Register Services with DI Container:**
    Update `Program.cs` in the API project to register all the new concrete implementations and services.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (within `builder.Services` section):**
        ```csharp
        using CodeContext.Core;
        using CodeContext.Core.Services;
        using CodeContext.Infrastructure.DatabaseClients;
        using CodeContext.Infrastructure.EmbeddingProviders;
        using Microsoft.Extensions.Configuration; // For IConfiguration
        using System.Net.Http; // For HttpClient

        // ... existing services ...

        // Register HttpClient for OllamaProvider (best practice for HttpClient management)
        builder.Services.AddHttpClient(); // Registers a default HttpClient

        // Register concrete client implementations as singletons
        builder.Services.AddSingleton<IVectorDatabaseClient>(sp =>
        {
            var configuration = sp.GetRequiredService<IConfiguration>();
            var qdrantHost = configuration["Qdrant:Host"] ?? "localhost";
            var qdrantPort = int.Parse(configuration["Qdrant:Port"] ?? "6334");
            var collectionName = configuration["Qdrant:CollectionName"] ?? "code_context_collection";
            return new QdrantClient(qdrantHost, qdrantPort, collectionName);
        });

        builder.Services.AddSingleton<IEmbeddingProvider>(sp =>
        {
            var configuration = sp.GetRequiredService<IConfiguration>();
            var ollamaApiUrl = configuration["Ollama:ApiUrl"] ?? "http://localhost:11434";
            var ollamaModel = configuration["Ollama:Model"] ?? "llama2"; // Default model
            var httpClientFactory = sp.GetRequiredService<IHttpClientFactory>();
            var httpClient = httpClientFactory.CreateClient(); // Get a named client if needed, or default
            return new OllamaProvider(httpClient, ollamaApiUrl, ollamaModel);
        });

        // Register core services
        builder.Services.AddSingleton<ParsingService>();
        builder.Services.AddSingleton<IndexingService>();

        // ... existing app.MapGet("/health") ...
        ```
    *   **Guidance:**
        *   `AddHttpClient()`: Registers `IHttpClientFactory`, which is used to create `HttpClient` instances.
        *   `IConfiguration`: You'll need to add `appsettings.json` to your `CodeContext.Api` project to configure Qdrant and Ollama settings.
            ```json
            // appsettings.json
            {
              "Logging": {
                "LogLevel": {
                  "Default": "Information",
                  "Microsoft.AspNetCore": "Warning"
                }
              },
              "AllowedHosts": "*",
              "Qdrant": {
                "Host": "localhost",
                "Port": 6334,
                "CollectionName": "code_context_collection"
              },
              "Ollama": {
                "ApiUrl": "http://localhost:11434",
                "Model": "llama2"
              }
            }
            ```

7.  **Create `/index` Endpoint:**
    Add a new minimal API endpoint that triggers the `IndexingService`.
    *   **File:** `CodeContext.Api/Program.cs`
    *   **Code Example (add before `app.Run();`):**
        ```csharp
        // ... existing endpoints ...

        app.MapPost("/index", async (IndexingService indexingService) =>
        {
            // In a real application, the repository path would come from the request
            // or be managed by the extension. For now, use a hardcoded path or read from config.
            var repositoryPath = "/Users/bramburn/dev/bigcontext"; // Example: Use the current project root
            var collectionName = "code_context_collection"; // Should match Qdrant config

            try
            {
                await indexingService.IndexRepositoryAsync(repositoryPath, collectionName);
                return Results.Ok("Indexing process completed successfully.");
            }
            catch (Exception ex)
            {
                return Results.Problem($"Indexing failed: {ex.Message}", statusCode: 500);
            }
        });

        app.Run();
        ```
    *   **Guidance:** The `IndexingService` is automatically injected into the endpoint handler. Add error handling for robustness.

**Verification:**

*   **Prerequisites:** Ensure you have a local Qdrant instance running (e.g., via Docker) and Ollama installed with a model downloaded (e.g., `ollama run llama2`).
*   **Build and Run:** Build your C# solution (`dotnet build`) and run the API project (`dotnet run --project CodeContext.Api`).
*   **Test `/health`:** Confirm `http://localhost:<port>/health` returns 200 OK.
*   **Test `/index`:** Use a tool like Postman, Insomnia, or `curl` to send a `POST` request to `http://localhost:<port>/index`.
    *   `curl -X POST http://localhost:<port>/index`
*   **Observe Logs:** Check the console output of your running C# API for messages from `IndexingService` and any errors from Qdrant or Ollama communication.
*   **Verify Qdrant Data:** If successful, you should see new points (vectors) added to your Qdrant collection. You can use Qdrant's API or UI to verify this.
</file>

<file path="docs/todo/fe/implementation_sub_sprint_1_database_configuration_component.md">
# Implementation Guidance: Sub-Sprint 1 - Database Configuration Component

**Objective:** To provide detailed instructions for creating the `DatabaseSetup.svelte` component, handling user interaction, and communicating with the extension backend to manage the database service.

---

### 1. Component Structure (`DatabaseSetup.svelte`)

This component is responsible for the database section of the UI. It will contain a selector, a button, and a status indicator.

**File:** `webview/src/lib/components/DatabaseSetup.svelte`

```html
<script lang="ts">
  import { Button, Select } from '@svelte-fui/core';
  import { setupState } from '$lib/stores/setupStore';
  import { onMount } from 'svelte';

  // Acquire the vscode API only once
  const vscode = acquireVsCodeApi();

  function startDatabase() {
    // Disable button to prevent multiple clicks
    // You can add a 'loading' state here
    vscode.postMessage({ command: 'startDatabase' });
  }

  onMount(() => {
    const handleMessage = (event: MessageEvent) => {
      const message = event.data; // The JSON data from the extension
      if (message.command === 'databaseStatus') {
        console.log(`Received status: ${message.status}`);
        setupState.update(s => ({ ...s, databaseReady: message.status === 'running' }));
      }
    };

    window.addEventListener('message', handleMessage);

    // Cleanup listener when component is destroyed
    return () => {
      window.removeEventListener('message', handleMessage);
    };
  });
</script>

<div class="space-y-4 p-4 border rounded-md">
  <h3 class="text-lg font-semibold">Database Configuration</h3>
  <div class="flex items-center space-x-4">
    <Select items={['Qdrant']} placeholder="Select Database" class="flex-grow" />
    <Button variant="primary" on:click={startDatabase}>Start Local Qdrant</Button>
  </div>
  <div>
    <span>Status:</span>
    {#if $setupState.databaseReady}
      <span class="text-green-500"> Running</span>
    {:else}
      <span class="text-gray-500"> Not Running</span>
    {/if}
  </div>
</div>
```

### 2. Backend Logic (`src/extension.ts`)

The extension needs to listen for the `startDatabase` message and then perform two key actions:
1.  Run the Docker command.
2.  Poll a health check endpoint to verify the service is running.

```typescript
// src/extension.ts inside the onDidReceiveMessage handler

case 'startDatabase': {
    const terminal = vscode.window.createTerminal('Qdrant');
    // Assumes docker-compose.yml is in the root of the workspace
    terminal.sendText('docker-compose up');
    terminal.show();

    // Start polling for Qdrant health
    pollQdrantHealth(panel);
    return;
}

// ...

function pollQdrantHealth(panel: vscode.WebviewPanel) {
    let attempts = 0;
    const maxAttempts = 30; // Poll for 30 seconds (30 * 1000ms)
    const interval = 1000; // 1 second

    const intervalId = setInterval(async () => {
        if (attempts >= maxAttempts) {
            clearInterval(intervalId);
            vscode.window.showErrorMessage('Qdrant health check timed out.');
            // Optionally send a 'failed' status to the webview
            panel.webview.postMessage({ command: 'databaseStatus', status: 'failed' });
            return;
        }

        try {
            // Qdrant's default health check endpoint
            const response = await fetch('http://localhost:6333/healthz');
            if (response.ok) {
                clearInterval(intervalId);
                vscode.window.showInformationMessage('Qdrant is running!');
                panel.webview.postMessage({ command: 'databaseStatus', status: 'running' });
            }
        } catch (error) {
            // Ignore errors until timeout
            attempts++;
        }
    }, interval);
}
```

**Important Considerations:**
*   **Error Handling:** The `pollQdrantHealth` function should handle timeouts and fetch errors gracefully. It's crucial to inform the user if the database fails to start, perhaps with an error notification in VS Code.
*   **Hardcoded URL:** The URL `http://localhost:6333` is the default for Qdrant. For a more robust solution, this should be configurable.
*   **User Experience:** Provide feedback to the user that a health check is in progress (e.g., a "Checking..." status in the UI).

### 3. State Management (`setupStore.ts`)

The Svelte store remains simple for this sub-sprint. The `databaseReady` flag is the key piece of state managed here, which will be updated based on messages from the extension backend.

**File:** `webview/src/lib/stores/setupStore.ts`
```typescript
import { writable } from 'svelte/store';

export interface SetupState {
  databaseReady: boolean;
  providerSelected: string | null;
}

export const setupState = writable<SetupState>({
  databaseReady: false,
  providerSelected: null,
});
```
This typed store will help prevent errors and improve autocompletion in the Svelte components.
</file>

<file path="docs/todo/fe/implementation_sub_sprint_2_embedding_provider_workflow_logic.md">
# Implementation Guidance: Sub-Sprint 2 - Embedding Provider & Workflow Logic

**Objective:** To provide instructions for creating the `EmbeddingSetup.svelte` component and managing the application state to control the main indexing workflow.

---

### 1. Component Structure (`EmbeddingSetup.svelte`)

This component allows the user to select their preferred embedding provider. The selection will be stored in our central Svelte store.

**File:** `webview/src/lib/components/EmbeddingSetup.svelte`

```html
<script lang="ts">
  import { Select } from '@svelte-fui/core';
  import { setupState } from '$lib/stores/setupStore';

  const embeddingProviders = [
    { label: 'Ollama (Local)', value: 'ollama' },
    { label: 'OpenAI', value: 'openai' }
  ];

  // This function updates the central store when a selection is made.
  function handleProviderSelect(event: CustomEvent<{ value: string; label: string }>) {
    if (event.detail.value) {
      setupState.update(s => ({ ...s, providerSelected: event.detail.value }));
    }
  }
</script>

<div class="space-y-4 p-4 border rounded-md">
  <h3 class="text-lg font-semibold">Embedding Provider</h3>
  <Select
    items={embeddingProviders}
    placeholder="Select a provider"
    on:change={handleProviderSelect}
    class="w-full"
  />
  {#if $setupState.providerSelected}
    <p class="text-sm text-gray-600">You have selected: {$setupState.providerSelected}</p>
  {/if}
</div>
```

### 2. Finalizing the Workflow (`SetupView.svelte` / `+page.svelte`)

The main view component will now bring everything together. It will use a Svelte "derived store" (`$:` syntax) to automatically compute whether the "Index Now" button should be enabled.

**File:** `webview/src/routes/+page.svelte`

```html
<script lang="ts">
  import { Button } from '@svelte-fui/core';
  import { setupState } from '$lib/stores/setupStore';
  import DatabaseSetup from '$lib/components/DatabaseSetup.svelte';
  import EmbeddingSetup from '$lib/components/EmbeddingSetup.svelte';

  // Acquire the vscode API once at the top level
  const vscode = acquireVsCodeApi();

  // This is a "derived" variable. It will automatically update
  // whenever the values inside $setupState change.
  $: canStartIndex = $setupState.databaseReady && $setupState.providerSelected;

  function startIndexing() {
    if (!canStartIndex) return; // Safety check

    // Send the entire configuration state to the backend
    vscode.postMessage({
      command: 'startIndexing',
      config: $setupState
    });
  }
</script>

<div class="p-8 space-y-6">
  <h1 class="text-2xl font-bold">Code Context Setup</h1>

  <DatabaseSetup />
  <EmbeddingSetup />

  <div class="pt-6 text-center">
    <Button
      variant="accent"
      class="w-full max-w-xs"
      disabled={!canStartIndex}
      on:click={startIndexing}
    >
      Index Now
    </Button>
    {#if !canStartIndex}
      <p class="text-sm text-gray-500 mt-2">
        Please start the database and select an embedding provider to continue.
      </p>
    {/if}
  </div>
</div>
```

### 3. Backend Logic (`src/extension.ts`)

The final step is to handle the `startIndexing` message in the extension. For this sub-sprint, we will simply acknowledge the message and log the configuration. In a future sprint, this is where the logic to write the `code-context.json` file and trigger the backend indexing process would go.

```typescript
// src/extension.ts inside the onDidReceiveMessage handler

case 'startIndexing': {
    const config = message.config; // config is the SetupState object
    console.log('Received configuration:', config);

    // 1. Save the configuration to code-context.json
    // const workspaceFolders = vscode.workspace.workspaceFolders;
    // if (workspaceFolders) {
    //   const configPath = vscode.Uri.joinPath(workspaceFolders[0].uri, 'code-context.json');
    //   const configData = Buffer.from(JSON.stringify(config, null, 2));
    //   await vscode.workspace.fs.writeFile(configPath, configData);
    // }

    // 2. Show a confirmation to the user
    vscode.window.showInformationMessage(
        `Configuration saved! Starting indexing with ${config.providerSelected}.`
    );

    // 3. Close the webview panel
    panel.dispose();

    // 4. (Future) Trigger the actual indexing process in the C# backend.
    return;
}
```

This completes the frontend workflow for the setup view. The UI now captures all necessary user input and sends it to the extension backend when the user is ready to proceed.
</file>

<file path="docs/todo/fe/prd.md">
<prd>Here is the software engineering roadmap based on your detailed project description.

| # | Theme | Milestone & Description | Timeframe | Assigned Team | Status |
| :- | :--- | :--- | :--- | :--- | :--- |
| 1 | **Backend Architecture** | **Develop C# Web API Foundation:** Build the initial ASP.NET Core Web API project, establishing the core service for the extension to communicate with. | Q1 2026 | Backend (C#) | Planned |
| 2 | **Backend Architecture** | **Implement Extensible Client Framework:** Use dependency injection and strategy patterns in C# to create abstract interfaces for various database clients and embedding providers. | Q1 2026 | Backend (C#) | Planned |
| 3 | **Extension Integration** | **Establish Extension-to-Backend Communication:** Implement logic in the TypeScript extension to manage (start/monitor) the C# backend process and communicate via local HTTP requests. | Q2 2026 | Frontend (TS/Svelte) | Not Started |
| 4 | **Onboarding & UI** | **Build Initial Setup & Indexing UI:** Create the Svelte UI that detects an un-indexed repository and presents the setup screen for database and embedding provider selection. | Q2 2026 | Frontend (TS/Svelte) | Not Started |
| 5 | **Core Functionality** | **Implement Qdrant & Ollama Clients:** Build the first concrete client implementations for the database (Qdrant) and embedding provider (Ollama) within the C# backend. | Q3 2026 | Backend (C#) | Not Started |
| 6 | **Onboarding & UI** | **Integrate Docker Helper Commands:** Connect the UI buttons to open a VS Code terminal and execute the required Docker commands for spinning up local databases. | Q3 2026 | Frontend (TS/Svelte) | Not Started |
| 7 | **Core Functionality** | **Develop End-to-End Indexing Workflow:** Connect the UI "Index" button to the C# API to trigger the full AST parsing, embedding, and vector storage process, showing progress in the UI. | Q4 2026 | Full Team | Not Started |
| 8 | **Core Functionality** | **Implement Core Query View:** Create the post-indexing UI with a simple input box for users to submit natural language queries to the C# backend for a response. | Q4 2026 | Full Team | Not Started |
| 9 | **Feature Enhancement** | **Build Settings Management & Re-Indexing:** Implement the settings (cog) icon functionality and the logic to trigger a full re-index when a user saves configuration changes. | Q1 2027 | Full Team | Not Started |

Of course. Let's continue with the detailed PRDs for the C\# backend and the UI onboarding, following the established roadmap.

-----

### **New Document: PRD 2: Backend Foundation - C\# Web API & Extensible Clients**

**1. Title & Overview**

  * **Project:** Code Context Engine - C\# Backend Foundation
  * **Summary:** This phase covers the creation of a robust, standalone C\# ASP.NET Core Web API. This backend service will handle all heavy lifting, including code parsing, vectorization, and database communication. The architecture will be designed for extensibility from day one, using dependency injection and abstract client interfaces to easily support various databases and embedding providers in the future.
  * **Dependencies:** Requires the .NET SDK and a C\# development environment (like VS Code with the C\# Dev Kit or Visual Studio).

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Decouple the core processing logic from the VS Code extension frontend, allowing for more robust and scalable development.
      * Create a flexible architecture that can adapt to new technologies (databases, embedding models) without significant refactoring.
  * **Developer & System Success Metrics:**
      * The C\# Web API project is successfully created and can be run locally.
      * A basic `/health` endpoint returns a `200 OK` status.
      * The service architecture correctly implements the strategy or factory pattern for database and embedding clients.
      * The solution includes separate class library projects for core logic, infrastructure, and the API, promoting clean architecture.
      * Unit tests are in place for the client abstraction layer.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha is responsible for building and maintaining the core indexing engine. She needs a well-structured, testable, and maintainable codebase that follows best practices for C\# development, such as dependency injection and clear separation of concerns.
  * **Devin (Developer - End User):** While Devin doesn't interact with this backend directly, he will benefit from its stability and performance. A well-architected backend ensures the indexing process is fast, reliable, and less prone to crashing.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Backend** | **Sprint 1: C\# Web API Boilerplate** | As Alisha, I want to create a new ASP.NET Core Web API project so we have the foundational service for our backend logic. | 1. A new .NET solution is created containing a Web API project.\<br/\>2. The API is configured to use minimal API syntax for endpoints.\<br/\>3. A basic `/health` endpoint is implemented that returns a success status.\<br/\>4. The project includes Swagger/OpenAPI support for API documentation and testing. | **2 Weeks** |
| | | As Alisha, I want to establish a clean architecture with separate projects for Core, Infrastructure, and API so that our codebase is organized and maintainable. | 1. The solution is organized into `CodeContext.Api`, `CodeContext.Core` (for domain logic/interfaces), and `CodeContext.Infrastructure` (for external clients).\<br/\>2. Project references are set up correctly (e.g., API depends on Core and Infrastructure).\<br/\>3. Basic folders and classes are created in each project to establish the structure. | |
| **Phase 2: Backend** | **Sprint 2: Extensible Client Framework** | As Alisha, I want to define abstract interfaces for database clients and embedding providers so we can easily add new implementations in the future. | 1. An `IEmbeddingProvider` interface with a `GenerateEmbeddingsAsync` method is created in `CodeContext.Core`.\<br/\>2. An `IVectorDatabaseClient` interface with `UpsertAsync` and `QueryAsync` methods is created in `CodeContext.Core`.\<br/\>3. These interfaces are agnostic of any specific technology (e.g., they use generic data types). | **2 Weeks** |
| | | As Alisha, I want to use dependency injection to register and resolve these clients so that the application is loosely coupled and testable. | 1. .NET's built-in dependency injection container is configured in `Program.cs`.\<br/\>2. A "factory" or "strategy" service is created that can resolve the correct client implementation based on a configuration string (e.g., "qdrant", "ollama").\<br/\>3. Unit tests are written to verify that the correct client is returned for a given configuration. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** C\# Web API Boilerplate (2 Weeks)
  * **Sprint 2:** Extensible Client Framework (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The development team is proficient in C\# and the .NET ecosystem.
  * **Risk:** Over-engineering the client framework. The initial design for the abstractions might be too complex for the immediate need.
      * **Mitigation:** Start with a simple interface and concrete implementation first (e.g., for Qdrant). Refactor to a more abstract factory pattern only when adding the second client (e.g., ChromaDB), following the rule of three.
  * **Risk:** Communication between the TypeScript extension and a C\# process can be complex to manage (e.g., starting, stopping, and handling errors).
      * **Mitigation:** This risk is primarily addressed in PRD 3, but in this phase, ensure the C\# API is simple and stateless (standard HTTP requests) to minimize integration complexity.

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - C\# Web API Boilerplate

**Goal:** To establish the foundational C\# ASP.NET Core Web API project with a clean architecture.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Create .NET Solution & Projects:** Use the `dotnet new` CLI to create a solution file (`CodeContext.sln`) and three projects: `webapi`, `classlib` (for Core), and `classlib` (for Infrastructure). | `(Project Root)` |
| **1.2** |  To Do | **Set Project References:** Configure the `.csproj` files so that the API project references the Core and Infrastructure projects. | `CodeContext.Api/CodeContext.Api.csproj` |
| **1.3** |  To Do | **Implement Health Check Endpoint:** In the `Program.cs` of the API project, add a minimal API endpoint for `/health` that returns `Results.Ok()`. | `CodeContext.Api/Program.cs` |
| **1.4** |  To Do | **Add Swagger/OpenAPI:** Configure the API to use Swashbuckle for generating an OpenAPI specification and a Swagger UI. | `CodeContext.Api/Program.cs` |
| **1.5** |  To Do | **Define Core Interfaces:** In the Core project, create initial placeholder interfaces (`IEmbeddingProvider.cs`, `IVectorDatabaseClient.cs`). | `CodeContext.Core/` |
| **1.6** |  To Do | **Define Infrastructure Placeholders:** In the Infrastructure project, create initial placeholder folders for `DatabaseClients` and `EmbeddingProviders`. | `CodeContext.Infrastructure/` |
| **1.7** |  To Do | **Test API Launch:** Run the API project and ensure it starts correctly, and that you can access the `/health` endpoint and the `/swagger` UI in a browser. | `(Local Environment)` |

-----

### **New Document: PRD 3: VS Code Integration & UI Onboarding**

**1. Title & Overview**

  * **Project:** Code Context Engine - VS Code Integration & Onboarding
  * **Summary:** This phase focuses on the user's first experience. It involves building the Svelte UI for the initial setup and creating the TypeScript logic within the VS Code extension to manage the C\# backend process. This includes detecting when a repository hasn't been indexed, guiding the user through database and embedding model selection, and providing helper buttons to run Docker commands.
  * **Dependencies:** PRD 1 and PRD 2 must be complete. The C\# backend must be buildable and runnable from the command line.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Create a smooth and intuitive onboarding experience to maximize user activation.
      * Abstract away technical complexity (like running Docker) to make the tool accessible to a wider range of developers.
  * **Developer & System Success Metrics:**
      * The TypeScript extension can successfully spawn the C\# backend as a child process.
      * The extension can reliably check the health of the C\# backend by polling the `/health` endpoint.
      * The Svelte UI correctly displays the setup screen when no index configuration is found.
      * Clicking the "Start Database" button in the UI successfully opens a new VS Code terminal and runs the `docker-compose up` command.
      * The UI state updates correctly to show that the database is "running" after a successful health check.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: Integration & UI** | **Sprint 3: Backend Process Management** | As a developer, I want the VS Code extension to automatically start the C\# backend service when the extension is activated, so I don't have to run it manually. | 1. The extension uses Node.js's `child_process.spawn` to launch the compiled C\# executable.\<br/\>2. The extension correctly captures `stdout` and `stderr` from the C\# process for logging.\<br/\>3. The child process is automatically terminated when the extension is deactivated or VS Code is closed. | **2 Weeks** |
| | | As a developer, I want the extension to monitor the health of the C\# backend service so it can reliably send API requests. | 1. The extension periodically sends an HTTP GET request to the backend's `/health` endpoint.\<br/\>2. The UI state reflects whether the backend is "Starting", "Running", or "Error".\<br/\>3. If the health check fails multiple times, the process is restarted. | |
| **Phase 3: Integration & UI** | **Sprint 4: Onboarding & Setup UI** | As Devin, when I open a new project, I want the extension to check if it's been indexed and show me a setup screen if it hasn't. | 1. On activation, the extension looks for the `code-context.json` file in the `.vscode` directory.\<br/\>2. If the file is not found, the main webview panel displays the "Setup" component.\<br/\>3. If the file is found, the main webview panel displays the "Query" component (to be built later). | **2 Weeks** |
| | | As Devin, I want the setup screen to let me choose my database and embedding provider, with helper buttons to start any required local services. | 1. The UI presents dropdowns for selecting a database (Qdrant, etc.) and embedding provider (Ollama, etc.).\<br/\>2. A button next to the database selection ("Start Local Qdrant") is present.\<br/\>3. Clicking the button creates a new VS Code terminal and runs the appropriate `docker-compose` command.\<br/\>4. The UI shows a success indicator once the service is confirmed to be running via a health check. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 3:** Backend Process Management (2 Weeks)
  * **Sprint 4:** Onboarding & Setup UI (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The C\# backend executable can be reliably located and run from the TypeScript extension across different operating systems (Windows, macOS, Linux).
  * **Risk:** Managing the lifecycle of the child C\# process could be buggy, leading to orphaned processes that consume system resources.
      * **Mitigation:** Implement robust error handling and ensure the process is always killed in the `deactivate` function of the extension. Use libraries like `tree-kill` if necessary to ensure the entire process tree is terminated.
  * **Risk:** The user may not have Docker installed or running, causing the helper commands to fail.
      * **Mitigation:** Provide clear error messages in the UI and terminal. The UI should check for the `docker` command on the system's PATH and disable the button with a helpful tooltip if it's not found.

Of course. Here are the final PRDs and their associated task lists, completing the project roadmap.

-----

### **New Document: PRD 4: Core Functionality - End-to-End Indexing & Querying**

**1. Title & Overview**

  * **Project:** Code Context Engine - Core Functionality Implementation
  * **Summary:** This phase is about bringing the core user journey to life. It involves implementing the first concrete clients for Qdrant and Ollama within the C\# backend. We will then connect the UI to the backend to create a seamless, end-to-end indexing workflow. Finally, we will build the initial chat/query interface, allowing users to ask their first questions and receive contextually relevant answers from their indexed codebase.
  * **Dependencies:** PRD 3 must be complete. The extension must be able to manage the C\# backend process and display the initial setup UI.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Deliver the "Aha\!" moment for the user by providing the first tangible results from their indexed code.
      * Validate the end-to-end architecture, from UI interaction to backend processing and back.
  * **Developer & System Success Metrics:**
      * The C\# backend can successfully generate embeddings using a local Ollama instance and store them in a local Qdrant database.
      * The `IndexingService` in the C\# backend correctly orchestrates the full pipeline: AST parsing, embedding, and database upserting.
      * The UI's "Index Now" button successfully triggers the indexing process via an API call to the C\# backend.
      * The UI displays a real-time progress bar that accurately reflects the status sent from the backend.
      * A user can type a query into the main chat box, and the extension will return a list of relevant file paths based on a vector search.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin has just completed the initial setup. He now wants to see the extension in action. He needs a simple interface to start the indexing, see that it's working, and then ask a basic question to see if the tool can find relevant code for him.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 4: Core Functionality** | **Sprint 5: Concrete Client Implementation (C\#)** | As Alisha, I want to implement the concrete client for Qdrant so that the backend can communicate with the vector database. | 1. A `QdrantClient` class is created in the Infrastructure project that implements `IVectorDatabaseClient`.\<br/\>2. The client correctly connects to the Qdrant instance specified in the configuration.\<br/\>3. The `UpsertAsync` method successfully saves vectors and their payloads to the database. | **2 Weeks** |
| | | As Alisha, I want to implement the concrete client for Ollama so that the backend can generate embeddings. | 1. An `OllamaProvider` class is created that implements `IEmbeddingProvider`.\<br/\>2. The provider makes successful HTTP POST requests to a local Ollama `/api/embeddings` endpoint.\<br/\>3. The class correctly parses the response to extract the embedding vectors.\<br/\>4. The implementation is registered with the dependency injection container. | |
| **Phase 4: Core Functionality** | **Sprint 6: End-to-End Indexing & Query UI** | As Devin, I want to click the "Index Now" button and see a progress bar while my code is being indexed so I have clear feedback on the process. | 1. Clicking the "Index Now" button in the Svelte UI sends a `POST /index` request to the C\# backend.\<br/\>2. The backend streams progress updates (e.g., via Server-Sent Events or WebSockets) back to the UI.\<br/\>3. The Fluent UI progress bar in the Svelte component updates based on the events received from the backend.\<br/\>4. The UI transitions to the "Query" view upon receiving a "completed" event. | **2 Weeks** |
| | | As Devin, after indexing is complete, I want to see a chat input box where I can type a question to find relevant code. | 1. A new "Query" Svelte component is created, featuring a text input and a submit button.\<br/\>2. Typing a query and hitting Enter sends a `POST /query` request to the C\# backend with the query text.\<br/\>3. The backend performs a vector search using the query and returns a list of file paths.\<br/\>4. The UI displays the returned file paths as a simple list. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 5:** Concrete Client Implementation (C\#) (2 Weeks)
  * **Sprint 6:** End-to-End Indexing & Query UI (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The selected Ollama embedding model provides sufficiently accurate embeddings for code to yield relevant search results.
  * **Risk:** The real-time progress update mechanism (e.g., SSE or WebSockets) could be complex to implement between the C\# backend and the VS Code webview.
      * **Mitigation:** Start with a simpler polling mechanism if a streaming approach proves too difficult. The frontend can poll a `/index/status` endpoint on the backend every few seconds to get the progress.
  * **Risk:** The performance of the end-to-end indexing on a large repository might be slow, leading to a poor user experience.
      * **Mitigation:** Focus on optimizing the "hot path" in the C\# backendspecifically, batching requests to the embedding provider and the database client to improve throughput.

-----

### **New Document: tasklist\_sprint\_05.md**

# Task List: Sprint 5 - Concrete Client Implementation (C\#)

**Goal:** To build the first concrete implementations for the database and embedding provider clients in the C\# backend.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** |  To Do | **Add Qdrant.Client NuGet Package:** Install the official Qdrant .NET client library into the `CodeContext.Infrastructure` project. | `CodeContext.Infrastructure/CodeContext.Infrastructure.csproj` |
| **5.2** |  To Do | **Implement `QdrantClient` Class:** Create the class that implements `IVectorDatabaseClient`. Implement the `UpsertAsync` method using the NuGet package's API. | `CodeContext.Infrastructure/DatabaseClients/QdrantClient.cs` |
| **5.3** |  To Do | **Implement `OllamaProvider` Class:** Create the class that implements `IEmbeddingProvider`. Use `HttpClient` to send requests to the Ollama API. | `CodeContext.Infrastructure/EmbeddingProviders/OllamaProvider.cs` |
| **5.4** |  To Do | **Add AST Parsing Logic:** Integrate a C\# AST parsing library (e.g., Roslyn for C\#, a community library for others) into a new `ParsingService`. | `CodeContext.Core/Services/ParsingService.cs` |
| **5.5** |  To Do | **Create `IndexingService`:** Build the main service in `CodeContext.Core` that orchestrates the workflow: takes file paths, calls the `ParsingService`, the `IEmbeddingProvider`, and the `IVectorDatabaseClient`. | `CodeContext.Core/Services/IndexingService.cs` |
| **5.6** |  To Do | **Register Services with DI:** In the API project's `Program.cs`, register all new services and clients with the dependency injection container. | `CodeContext.Api/Program.cs` |
| **5.7** |  To Do | **Create `/index` Endpoint:** Create the initial API endpoint that will trigger the `IndexingService`. | `CodeContext.Api/Program.cs` |

-----

### **New Document: PRD 5: Feature Enhancement & Polish**

**1. Title & Overview**

  * **Project:** Code Context Engine - Settings & Release Readiness
  * **Summary:** This final phase focuses on polishing the user experience and preparing the extension for its first public release. It involves building the settings management UI, enabling users to change their configuration and trigger a re-index. It also includes creating essential user and contributor documentation and establishing a CI/CD pipeline to automate builds and deployments to the marketplace.
  * **Dependencies:** PRD 4 must be complete. The core indexing and querying loop must be functional.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Increase user trust and adoption through a professional and polished user experience.
      * Ensure the long-term maintainability and scalability of the project by automating the release process.
  * **Developer & System Success Metrics:**
      * The settings UI correctly reads from and writes to the extension's configuration.
      * Saving a new configuration (e.g., changing the embedding model) successfully triggers the re-indexing workflow.
      * A GitHub Actions workflow is in place that automatically builds and tests the extension on every pull request.
      * The extension is successfully published to the VS Code Marketplace via an automated pipeline.
      * The project's `README.md` provides clear instructions for installation and use.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 5: Polish** | **Sprint 7: Settings Management & Re-Indexing** | As Devin, I want a settings icon in the UI so I can go back and change my database or embedding provider at any time. | 1. A "cog" icon is added to the main UI panel.\<br/\>2. Clicking the icon navigates the webview to the "Setup" component, pre-filled with the current configuration.\<br/\>3. The current configuration is read from the `code-context.json` file. | **2 Weeks** |
| | | As Devin, when I save a change in the settings, I want the extension to automatically re-index my project so that my changes take effect. | 1. The "Save" button in the settings UI is relabeled "Save & Re-Index".\<br/\>2. Clicking the button first saves the new configuration to `code-context.json`.\<br/\>3. After saving, the extension automatically triggers the end-to-end indexing process.\<br/\>4. The UI displays the progress bar, and transitions back to the query view on completion. | |
| **Phase 5: Polish** | **Sprint 8: Documentation & Publishing** | As a project owner, I want a CI/CD pipeline to automate builds and testing so we can ensure code quality and release reliability. | 1. A GitHub Actions workflow is created to run on every pull request.\<br/\>2. The workflow includes steps to build the C\# backend and the SvelteKit frontend.\<br/\>3. The workflow runs all unit tests for both the backend and frontend.\<br/\>4. A separate, manually triggered "release" workflow is created to publish the extension. | **2 Weeks** |
| | | As Devin, I want clear documentation in the `README.md` file so I can easily understand how to install and use the extension. | 1. The `README.md` is updated with sections for "Features", "Installation", "Configuration", and a "Quick Start" guide.\<br/\>2. A short animated GIF is created to demonstrate the primary user workflow.\<br/\>3. A `CONTRIBUTING.md` file is added to guide potential contributors. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 7:** Settings Management & Re-Indexing (2 Weeks)
  * **Sprint 8:** Documentation & Publishing (2 Weeks)

-----

### **New Document: tasklist\_sprint\_06.md**

# Task List: Sprint 6 - End-to-End Indexing & Query UI

**Goal:** To connect the frontend and backend to create the core indexing and querying user workflows.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** |  To Do | **Implement Progress Reporting:** In the C\# `IndexingService`, implement a mechanism (e.g., a callback or event bus) to report progress updates. | `CodeContext.Core/Services/IndexingService.cs` |
| **6.2** |  To Do | **Create Progress Endpoint:** Expose progress updates via a WebSocket or Server-Sent Events (SSE) endpoint in the C\# API. | `CodeContext.Api/Program.cs` |
| **6.3** |  To Do | **Connect UI to Progress Endpoint:** In the SvelteKit UI, connect to the progress endpoint after triggering an index and update the progress bar component. | `webview/src/lib/components/IndexingView.svelte` |
| **6.4** |  To Do | **Create Query View Component:** Build the `QueryView.svelte` component with a text input for questions and an area to display results. | `webview/src/lib/components/QueryView.svelte` |
| **6.5** |  To Do | **Implement `/query` Endpoint in C\#:** Create the API endpoint that takes a query string, generates an embedding for it, and uses the `IVectorDatabaseClient` to perform a similarity search. | `CodeContext.Api/Program.cs` |
| **6.6** |  To Do | **Connect UI to `/query` Endpoint:** When the user submits a query in the UI, make a `POST` request to the `/query` endpoint and display the returned file paths. | `webview/src/lib/components/QueryView.svelte` |
| **6.7** |  To Do | **Implement UI State Transition:** Manage the application's state to correctly switch from the `IndexingView` to the `QueryView` upon successful completion. | `webview/src/lib/stores/viewStore.ts` |

This completes the full set of Product Requirements Documents and their associated task lists for your project. You now have a comprehensive, strategic plan that takes you from the initial architectural decisions all the way to a polished, publishable VS Code extension.

Of course. Let's continue with the remaining PRDs and task lists to complete the UI/UX development plan for your extension.

-----

### **New Document: PRD 2: UI/UX - Indexing Progress View**

**1. Title & Overview**

  * **Project:** Code Context Engine - Indexing Progress UI
  * **Summary:** This phase is dedicated to building the UI that provides users with clear, real-time feedback while their repository is being indexed. A well-executed progress view is crucial for user trust, as it communicates that the extension is working and prevents the perception of it being frozen or broken during a potentially long-running task.
  * **Dependencies:** PRD 1 (Onboarding & Setup UI) must be complete. The C\# backend must provide an endpoint (either WebSocket or SSE) that streams progress updates.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Improve user retention during the initial, critical indexing phase by providing a transparent and informative experience.
      * Reduce user friction and prevent premature cancellation of the indexing process.
  * **User Success Metrics:**
      * The progress bar accurately reflects the real-world progress of the indexing job with less than a 5% margin of error.
      * The status text updates clearly, informing the user of the current stage (e.g., "Parsing files", "Generating embeddings").
      * User-initiated cancellations of the indexing process are below 10%.

-----

**3. User Personas**

  * **Devin (Developer - End User):** After clicking "Index Now," Devin expects immediate feedback. He wants to see that the process has started and get a reasonable estimate of how long it might take. Clear progress indicators give him the confidence to let the extension run while he works on other things.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Progress UI** | **Sprint 2: Progress View Implementation** | As Devin, after starting the indexing, I want to see a dedicated view with a progress bar so I know that the process is running. | 1. After the "startIndexing" message is sent, the webview immediately transitions to the `IndexingProgressView` component.\<br/\>2. A Fluent UI `<ProgressBar>` is prominently displayed.\<br/\>3. A text label below the bar shows the current percentage and a status message (e.g., "0% - Initializing..."). | **2 Weeks** |
| | | As Devin, I want the progress bar and status text to update in real-time as the indexing proceeds through different stages. | 1. The SvelteKit frontend successfully establishes a connection to the backend's progress streaming endpoint.\<br/\>2. The progress bar's value is reactively bound to the percentage received from the backend.\<br/\>3. The status text updates to reflect the messages sent from the backend (e.g., file names, current stage).\<br/\>4. The UI gracefully handles a dropped connection and attempts to reconnect. | |
| | | As Devin, I want the view to automatically switch to the main query interface once the indexing is complete. | 1. Upon receiving a "completed" event from the backend, the progress bar fills to 100%.\<br/\>2. A "Complete" message is briefly displayed.\<br/\>3. After a short delay (e.g., 1-2 seconds), the application state changes, and the `QueryView` component is rendered. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 2:** Progress View Implementation (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The backend can provide reasonably accurate progress percentages. If the backend can only provide status messages, the progress bar might need to be an indeterminate one.
  * **Risk:** A WebSocket or SSE connection between the VS Code webview and a local C\# process might be blocked by local firewall or security software.
      * **Mitigation:** Provide a fallback mechanism where the UI polls a standard HTTP endpoint (`GET /index/status`) every few seconds. This is less efficient but more reliable.
  * **Risk:** The UI might become unresponsive if it receives a very high frequency of progress updates from the backend.
      * **Mitigation:** Implement throttling or debouncing on the frontend to ensure the UI only re-renders at a reasonable interval (e.g., every 100-200ms).

-----

### **New Document: Sub-Sprint 3: Backend Connection for Progress Updates**

**Objective:**
To establish the communication channel from the SvelteKit frontend to the C\# backend to receive real-time progress events.

**Parent Sprint:**
PRD 2, Sprint 2: Progress View Implementation

**Tasks:**

1.  **Choose Streaming Technology:** Decide on the technology for real-time updates (WebSockets are a good choice for this).
2.  **Implement WebSocket Client:** In the SvelteKit app, create a service that connects to the C\# backend's WebSocket endpoint when the indexing view is loaded.
3.  **Create Progress Store:** Implement a new Svelte store (`progressStore.ts`) to hold the current percentage and status message.
4.  **Update Store on Message:** The WebSocket client, upon receiving a message from the backend, will parse the data and update the `progressStore`.

**Acceptance Criteria:**

  * The frontend successfully connects to the backend's WebSocket server.
  * Messages sent from the backend are correctly received and logged in the frontend's developer console.
  * The `progressStore` is accurately updated with the received data.

**Dependencies:**

  * The C\# backend must have a WebSocket or SSE endpoint that broadcasts progress.

**Timeline:**

  * **Start Date:** 2026-01-19
  * **End Date:** 2026-01-23

-----

### **New Document: Sub-Sprint 4: Svelte Progress UI Component**

**Objective:**
To build the user-facing Svelte component that displays the indexing progress.

**Parent Sprint:**
PRD 2, Sprint 2: Progress View Implementation

**Tasks:**

1.  **Create `IndexingProgressView.svelte`:** Build the main component for this view.
2.  **Add Fluent UI ProgressBar:** Integrate and style the `<ProgressBar>` component.
3.  **Subscribe to Progress Store:** In the component's script, subscribe to the `progressStore` to get live updates.
4.  **Bind UI to Store:** Reactively bind the `value` of the progress bar and the content of the status text label to the data from the store.
5.  **Implement Completion Logic:** Use a reactive statement (`$:`) to watch for when the progress percentage reaches 100, then trigger a state change to navigate to the query view.

**Acceptance Criteria:**

  * The progress bar visually updates as the value in the store changes.
  * The status text correctly displays the message from the store.
  * When progress hits 100, the UI automatically transitions to the next view.

**Dependencies:**

  * Sub-Sprint 3 must be complete.

**Timeline:**

  * **Start Date:** 2026-01-26
  * **End Date:** 2026-01-30

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Progress View Implementation

**Goal:** To build the UI for displaying real-time indexing progress to the user.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Install WebSocket client library:** Add a library like `socket.io-client` or use the native browser `WebSocket` API. | `webview/package.json` |
| **2.2** |  To Do | **Create `progressStore.ts`:** Define a new Svelte store with `percentage` and `message` properties. | `webview/src/lib/stores/progressStore.ts` |
| **2.3** |  To Do | **Create `ProgressService.ts`:** Implement the client-side logic to connect to the backend WebSocket and update the `progressStore`. | `webview/src/lib/services/ProgressService.ts` |
| **2.4** |  To Do | **Build `IndexingProgressView.svelte` component:** Add the Fluent UI progress bar and text labels. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.5** |  To Do | **Connect Component to Store:** In the Svelte component, import and subscribe to the `progressStore`. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.6** |  To Do | **Implement UI Bindings:** Bind the `value` of the progress bar and the text content of the label to the store's reactive variables. | `webview/src/lib/views/IndexingProgressView.svelte` |
| **2.7** |  To Do | **Implement View Transition Logic:** In the main view manager, listen for the "completion" state and switch the visible component to the `QueryView`. | `webview/src/lib/ViewManager.svelte` |
| **2.8** |  To Do | **Test with Mock Backend:** Create a mock backend service that sends simulated progress updates to test the UI in isolation. | `webview/src/lib/mocks/mockProgressService.ts` |

-----

### **New Document: PRD 3: UI/UX - Main Query & Results View**

**1. Title & Overview**

  * **Project:** Code Context Engine - Main Query Interface
  * **Summary:** This phase covers the development of the primary user interface where developers will interact with the indexed codebase. The design will focus on simplicity and efficiency, providing a clean, chat-like experience for asking questions and receiving results. This view is the core of the product's day-to-day value.
  * **Dependencies:** The indexing process must be complete, and the C\# backend must expose a `/query` endpoint.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Drive daily active usage by providing a powerful and easy-to-use interface for code discovery.
      * Clearly demonstrate the value of the indexing process by providing fast, relevant search results.
  * **User Success Metrics:**
      * The time from submitting a query to seeing the first result is less than 2 seconds.
      * The UI for displaying results is clear and allows users to easily identify and navigate to the relevant files.
      * The settings icon is easily discoverable, allowing users to return to the configuration view when needed.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: Query UI** | **Sprint 3: Query & Results Implementation** | As Devin, after my project is indexed, I want to see a simple text box where I can type my question, so I can start searching immediately. | 1. The `QueryView` component is displayed after indexing is complete.\<br/\>2. A Fluent UI `<TextField>` is shown at the bottom of the view, styled like a chat input.\<br/\>3. A "Submit" button or icon is present, and pressing "Enter" also triggers a submission. | **2 Weeks** |
| | | As Devin, when I submit a query, I want to see the list of relevant files returned by the engine, so I can find the code I'm looking for. | 1. Submitting a query sends a `POST` request to the C\# backend's `/query` endpoint.\<br/\>2. While waiting for a response, a loading indicator is displayed.\<br/\>3. The returned list of file paths is displayed in a clean, scrollable list in the main view area.\<br/\>4. Each file path is a clickable link that opens the corresponding file in a new VS Code editor tab. | |
| | | As Devin, I want to be able to easily access the settings to re-configure my project, so I can change the embedding model or database later. | 1. A "cog" icon is displayed in the top-right corner of the view.\<br/\>2. Clicking the icon navigates the user back to the `SetupView` component.\<br/\>3. The `SetupView` is pre-populated with the project's current, saved configuration. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 3:** Query & Results Implementation (2 Weeks)

This completes the full set of Product Requirements Documents and associated task lists for the UI/UX of your extension. You now have a comprehensive plan covering the entire frontend user journey, from initial setup to actively querying the codebase.
</prd>
[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/setup/backlog_sprint_6_lsp_integration_devops.md">
### User Story 1: LSP Data Integration into Index

**As a** developer, **I want to** capture data from the Language Server Protocol (LSP) during indexing, **so that** the code context index includes rich relationship information (e.g., definitions, references).

**Actions to Undertake:**
1.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Modify the `IndexingService` to interact with the active LSP for supported languages.
    -   **Implementation**: (Add logic to query LSP for definitions and references for each code chunk)
        ```typescript
        // Inside IndexingService.startIndexing loop, after chunking:
        // For each chunk, query LSP for definitions/references
        const definitions = await vscode.commands.executeCommand(
            'vscode.executeDefinitionProvider',
            vscode.Uri.file(file),
            new vscode.Position(chunk.startLine, 0) // Adjust position as needed
        );
        // Process definitions and add to chunk metadata

        const references = await vscode.commands.executeCommand(
            'vscode.executeReferenceProvider',
            vscode.Uri.file(file),
            new vscode.Position(chunk.startLine, 0) // Adjust position as needed
        );
        // Process references and add to chunk metadata
        ```
    -   **Imports**: `import * as vscode from 'vscode';`
2.  **Filepath**: `src/db/qdrantService.ts`
    -   **Action**: Update the `QdrantService` to store the new LSP-derived relationship metadata alongside the vectors.
    -   **Implementation**: (Modify `upsertChunks` to accept and store additional payload fields for LSP data)
        ```typescript
        // In QdrantService.upsertChunks, modify payload:
        payload: {
            filePath: chunk.filePath,
            content: chunk.content,
            startLine: chunk.startLine,
            endLine: chunk.endLine,
            type: chunk.type,
            // New LSP metadata fields
            definitions: chunk.definitions, // Example
            references: chunk.references,   // Example
        },
        ```
    -   **Imports**: None.

### User Story 2: CI/CD Pipeline with GitHub Actions

**As a** developer, **I want to** set up a CI/CD pipeline using GitHub Actions, **so that** the build, test, and packaging process for the extension is automated.

**Actions to Undertake:**
1.  **Filepath**: `.github/workflows/ci.yml` (New File)
    -   **Action**: Create a new GitHub Actions workflow file.
    -   **Implementation**: (Initial workflow structure)
        ```yaml
        name: CI/CD

        on: [push, pull_request]

        jobs:
          build:
            runs-on: ubuntu-latest
            steps:
              - uses: actions/checkout@v3
              - name: Use Node.js
                uses: actions/setup-node@v3
                with:
                  node-version: '18'
              - name: Install dependencies
                run: npm install
              - name: Run lint
                run: npm run lint
              - name: Run tests
                run: npm test
              - name: Build VS Code Extension
                run: npm run vscode:prepublish
              - name: Upload artifact
                uses: actions/upload-artifact@v3
                with:
                  name: vsix-package
                  path: ./*.vsix
        ```
    -   **Imports**: None.
2.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Configure the workflow to be triggered on `push` and `pull_request` events.
    -   **Implementation**: (See `on` section in the YAML above)
    -   **Imports**: None.
3.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Add steps for installing dependencies, running linting, executing unit tests, and building the `.vsix` package.
    -   **Implementation**: (See `steps` section in the YAML above)
    -   **Imports**: None.

**Acceptance Criteria:**
-   The `IndexingService` successfully queries the LSP for definition and reference information for code chunks.
-   The `QdrantService` stores the LSP-derived metadata in Qdrant alongside the code chunk vectors.
-   A GitHub Actions workflow file (`.github/workflows/ci.yml`) is created and correctly configured.
-   Every push and pull request to the repository triggers the CI/CD workflow.
-   The workflow successfully installs dependencies, runs linting checks, executes unit tests, and builds the `.vsix` extension package.
-   The `.vsix` package is uploaded as a build artifact.

**Testing Plan:**
-   **Test Case 1**: Make a small code change that triggers the LSP (e.g., add a new function). Run the indexing process. Verify that the LSP data (definitions, references) is captured and stored in Qdrant (requires inspecting Qdrant data).
-   **Test Case 2**: Push a commit to a branch. Verify that a GitHub Actions workflow run is triggered.
-   **Test Case 3**: Create a pull request. Verify that a GitHub Actions workflow run is triggered for the pull request.
-   **Test Case 4**: Review the GitHub Actions workflow run logs to ensure all steps (install, lint, test, build) pass successfully.
-   **Test Case 5**: Verify that the `.vsix` package is available as a build artifact in the GitHub Actions run summary.
</file>

<file path="docs/todo/setup/backlog_sprint_7_documentation_publishing.md">
### User Story 1: Comprehensive User Documentation

**As a** user, **I want to** have clear and comprehensive documentation for the extension, **so that** I can easily install, configure, and use it.

**Actions to Undertake:**
1.  **Filepath**: `README.md`
    -   **Action**: Update the `README.md` file with a feature list, installation instructions, and a guide on configuring the settings.
    -   **Implementation**: (Write content for `README.md`)
        ```markdown
        # Code Context Engine VS Code Extension

        ## Features
        - Code indexing and semantic search
        - LSP integration for rich context
        - Customizable settings for embedding providers and database

        ## Installation
        1. Install from VS Code Marketplace (link to be added).
        2. Alternatively, clone this repository and run `vsce package` then `code --install-extension your-extension.vsix`.

        ## Configuration
        Access settings via `Ctrl+Shift+P` (Cmd+Shift+P) and search for "Code Context Engine: Open Settings".
        - **Embedding Provider**: Choose between Ollama, OpenAI, etc.
        - **Database Connection String**: Specify your Qdrant instance.

        ## Usage
        (Detailed steps on how to use the extension, e.g., how to trigger indexing, how to perform queries)
        ```
    -   **Imports**: None.
2.  **Filepath**: `assets/demo.gif` (New File)
    -   **Action**: Create an animated GIF demonstrating the core workflow of the extension.
    -   **Implementation**: (Use screen recording software to capture workflow and convert to optimized GIF)
        ```
        <!-- In README.md -->
        ![Demo GIF](assets/demo.gif)
        ```
    -   **Imports**: None.
3.  **Filepath**: `CONTRIBUTING.md` (New File)
    -   **Action**: Create a `CONTRIBUTING.md` file with guidelines for new developers.
    -   **Implementation**: (Write content for `CONTRIBUTING.md`)
        ```markdown
        # Contributing to Code Context Engine

        We welcome contributions! Here's how to get started:

        ## Setup
        1. Clone the repository.
        2. Run `npm install`.
        3. Open in VS Code.

        ## Running Tests
        `npm test`

        ## Submitting Changes
        - Fork the repository.
        - Create a new branch for your feature or bug fix.
        - Ensure your code adheres to our linting rules (`npm run lint`).
        - Write clear commit messages.
        - Open a pull request.
        ```
    -   **Imports**: None.

### User Story 2: Publish to VS Code Marketplace

**As a** project owner, **I want to** publish the extension to the VS Code Marketplace, **so that** it is easily discoverable and accessible to all users.

**Actions to Undertake:**
1.  **Filepath**: `(External)`
    -   **Action**: Create a publisher identity on the VS Code Marketplace.
    -   **Implementation**: (Follow instructions on VS Code Marketplace publisher creation)
    -   **Imports**: None.
2.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Update the GitHub Actions pipeline with a manual "release" trigger.
    -   **Implementation**: (Add `workflow_dispatch` to `on` section)
        ```yaml
        on:
          push:
            branches:
              - main
          pull_request:
            branches:
              - main
          workflow_dispatch: # Manual trigger
        ```
    -   **Imports**: None.
3.  **Filepath**: `.github/workflows/ci.yml`
    -   **Action**: Implement a job in the CI/CD pipeline that automatically packages and publishes the extension to the marketplace when triggered.
    -   **Implementation**: (Add a new job, potentially with `vsce publish` and secrets)
        ```yaml
        # ... existing build job ...

        release:
          needs: build # Ensure build job completes successfully first
          runs-on: ubuntu-latest
          if: github.event_name == 'workflow_dispatch' # Only run on manual trigger

          steps:
            - uses: actions/checkout@v3
            - name: Use Node.js
              uses: actions/setup-node@v3
              with:
                node-version: '18'
            - name: Install dependencies
              run: npm install
            - name: Download VSIX artifact
              uses: actions/download-artifact@v3
              with:
                name: vsix-package
            - name: Publish to VS Code Marketplace
              run: npx vsce publish -p ${{ secrets.VSCE_TOKEN }}
              env:
                VSCE_TOKEN: ${{ secrets.VSCE_TOKEN }}
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   The `README.md` file is updated with all required sections (features, installation, configuration, usage).
-   An animated GIF demonstrating the core workflow is present in the `assets` directory and linked in `README.md`.
-   A `CONTRIBUTING.md` file is created with clear guidelines for contributors.
-   A publisher identity is successfully created on the VS Code Marketplace.
-   The GitHub Actions workflow includes a manual trigger for publishing.
-   Triggering the release workflow successfully publishes the extension to the VS Code Marketplace.

**Testing Plan:**
-   **Test Case 1**: Review `README.md` and `CONTRIBUTING.md` for completeness, clarity, and accuracy.
-   **Test Case 2**: Verify the animated GIF plays correctly and effectively demonstrates the extension's functionality.
-   **Test Case 3**: Manually trigger the GitHub Actions release workflow. Monitor the workflow run for successful completion.
-   **Test Case 4**: After successful release, search for the extension on the VS Code Marketplace to confirm its presence and correct listing.
-   **Test Case 5**: Install the published extension in a fresh VS Code instance and verify its basic functionality.
</file>

<file path="docs/todo/setup/backlog_sub_sprint_1_vs_code_extension_boilerplate_setup.md">
### User Story 1: VS Code Extension Project Setup

**As a** developer, **I want to** set up a new VS Code extension project with a fundamental file structure and configuration, **so that** I have a clean and organized starting point for development.

**Actions to Undertake:**
1.  **Filepath**: `(Project Root)`
    -   **Action**: Generate a new TypeScript-based VS Code extension using `yo code`.
    -   **Implementation**: `npx yo code` (select "New Extension (TypeScript)")
    -   **Imports**: None.
2.  **Filepath**: `package.json`
    -   **Action**: Configure the extension's name, publisher, and activation events in `package.json`.
    -   **Implementation**: (Modify `name`, `publisher`, and `activationEvents` fields as per project requirements)
    -   **Imports**: None.
3.  **Filepath**: `(Project Root)`
    -   **Action**: Create separate directories for the `extension` (backend) and `webview` (frontend) source code.
    -   **Implementation**: `mkdir src/extension` and `mkdir src/webview` (or similar structure if `yo code` provides a different default)
    -   **Imports**: None.
4.  **Filepath**: `src/extension.ts`
    -   **Action**: Write the initial `extension.ts` file, including the `activate` and `deactivate` functions.
    -   **Implementation**: (Basic `activate` and `deactivate` functions with a sample command)
        ```typescript
        import * as vscode from 'vscode';

        export function activate(context: vscode.ExtensionContext) {
            console.log('Congratulations, your extension "your-extension-name" is now active!');

            let disposable = vscode.commands.registerCommand('your-extension-name.helloWorld', () => {
                vscode.window.showInformationMessage('Hello World from your-extension-name!');
            });

            context.subscriptions.push(disposable);
        }

        export function deactivate() {}
        ```
    -   **Imports**: `import * as vscode from 'vscode';`

**Acceptance Criteria:**
-   The extension can be launched in a VS Code development host.
-   A "Hello World" command from the extension can be successfully executed from the command palette.
-   The project structure is clean and logically separated, with distinct directories for backend and frontend concerns.

**Testing Plan:**
-   **Test Case 1**: Run the extension in a VS Code development host (`F5` in VS Code). Verify no errors occur on activation.
-   **Test Case 2**: Open the command palette (`Ctrl+Shift+P` or `Cmd+Shift+P`), search for "Hello World", and execute the command. Verify the "Hello World from your-extension-name!" information message appears.
-   **Test Case 3**: Inspect the project directory to confirm the presence of `src/extension` and `src/webview` (or equivalent) directories.
</file>

<file path="docs/todo/setup/backlog_sub_sprint_2_sveltekit_fluent_ui_integration.md">
### User Story 1: SvelteKit Webview Integration

**As a** developer, **I want to** integrate a SvelteKit application into a VS Code webview, **so that** I can build a rich and interactive user interface for the extension.

**Actions to Undertake:**
1.  **Filepath**: `webview/`
    -   **Action**: Initialize a new SvelteKit project within the `webview` directory.
    -   **Implementation**: `cd webview && npm create svelte@latest .` (select "Skeleton project", "TypeScript", "ESLint", "Prettier", "Vitest")
    -   **Imports**: None.
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Create the logic in `extension.ts` to render the SvelteKit app inside a VS Code webview panel.
    -   **Implementation**: (Add `createWebviewPanel` and `resolveWebviewView` logic, loading `index.html` from SvelteKit's build output)
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';

        export function activate(context: vscode.ExtensionContext) {
            // ... existing code ...

            let panel: vscode.WebviewPanel | undefined = undefined;

            context.subscriptions.push(
                vscode.commands.registerCommand('code-context-engine.openPanel', () => {
                    if (panel) {
                        panel.reveal(vscode.ViewColumn.One);
                    } else {
                        panel = vscode.window.createWebviewPanel(
                            'codeContextEngine',
                            'Code Context Engine',
                            vscode.ViewColumn.One,
                            {
                                enableScripts: true,
                                localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))]
                            }
                        );

                        const svelteAppPath = vscode.Uri.file(
                            path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                        );
                        panel.webview.html = fs.readFileSync(svelteAppPath.fsPath, 'utf8');

                        panel.onDidDispose(
                            () => {
                                panel = undefined;
                            },
                            null,
                            context.subscriptions
                        );
                    }
                })
            );
        }

        // ... deactivate function ...
        ```
    -   **Imports**: `import * as path from 'path';`, `import * as fs from 'fs';` (need to import `fs` for `readFileSync`)

### User Story 2: Fluent UI Integration

**As a** developer, **I want to** integrate Microsoft's Fluent UI library into the SvelteKit project, **so that** I can build a consistent and professional-looking UI quickly.

**Actions to Undertake:**
1.  **Filepath**: `webview/package.json`
    -   **Action**: Add the Fluent UI Svelte library as a dependency to the SvelteKit project.
    -   **Implementation**: `cd webview && npm install @fluentui/web-components @fluentui/web-components-react @fluentui/react-components` (Note: The PRD mentions `svelte-fluent-ui`, but the official Fluent UI for web components is `@fluentui/web-components`. I will use the official one. If `svelte-fluent-ui` is a specific Svelte wrapper, it should be installed instead. I will assume the user meant the official Fluent UI components.)
    -   **Imports**: None.
2.  **Filepath**: `webview/src/routes/index.svelte` (or a new component like `MainPanel.svelte`)
    -   **Action**: Create a Svelte component for the main panel that includes an "Index Now" button and a placeholder for a progress bar from the Fluent UI library.
    -   **Implementation**: (Example using Fluent UI Web Components)
        ```html
        <script lang="ts">
          import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";

          provideFluentDesignSystem().register(
            fluentButton(),
            fluentProgressRing()
          );

          function handleIndexNow() {
            console.log("Index Now clicked!");
            // Logic to trigger indexing
          }
        </script>

        <main>
          <h1>Code Context Engine</h1>
          <fluent-button appearance="accent" @click="{handleIndexNow}">Index Now</fluent-button>
          <fluent-progress-ring style="margin-top: 20px;"></fluent-progress-ring>
        </main>

        <style>
          /* Basic styling */
          main {
            padding: 20px;
            font-family: sans-serif;
          }
        </style>
        ```
    -   **Imports**: `import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";`
3.  **Filepath**: `webview/src/app.html` (or global CSS)
    -   **Action**: Ensure the UI components automatically adapt to VS Code's light and dark themes.
    -   **Implementation**: (Utilize VS Code CSS variables for theming)
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <link rel="icon" href="/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            %sveltekit.head%
            <style>
              /* Apply VS Code theme colors */
              body {
                background-color: var(--vscode-editor-background);
                color: var(--vscode-editor-foreground);
              }
              /* Example for Fluent UI components */
              fluent-button {
                --accent-fill-rest: var(--vscode-button-background);
                --accent-fill-hover: var(--vscode-button-hoverBackground);
                --accent-fill-active: var(--vscode-button-background);
                --accent-foreground-rest: var(--vscode-button-foreground);
              }
              fluent-progress-ring {
                --accent-fill-rest: var(--vscode-progressBar-background);
              }
            </style>
          </head>
          <body data-sveltekit-preload-data="hover">
            <div style="display: contents">%sveltekit.body%</div>
          </body>
        </html>
        ```
    -   **Imports**: None.

**Acceptance Criteria:**
-   The SvelteKit application renders correctly inside the VS Code extension panel when the command to open it is executed.
-   The "Index Now" button is visible and interactive (e.g., logs a message to the console when clicked).
-   UI components (button, progress bar) correctly reflect the active VS Code theme (light/dark) without manual intervention.

**Testing Plan:**
-   **Test Case 1**: Run the extension in a development host. Execute the command to open the webview panel. Verify the SvelteKit app loads and displays the "Index Now" button and progress bar.
-   **Test Case 2**: Click the "Index Now" button and check the VS Code developer console for the logged message.
-   **Test Case 3**: Change the VS Code theme (e.g., from Light to Dark) and observe if the Fluent UI components' styling (background, text color) adapts accordingly.
</file>

<file path="docs/todo/setup/backlog_sub_sprint_5_implement_context_query_api.md">
### User Story 1: Retrieve File Content via API

**As a** developer, **I want to** query the extension's backend to retrieve the content of a specific file, **so that** the frontend can display it to the user.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts` (New File)
    -   **Action**: Create a new `ContextService` class to encapsulate context retrieval logic.
    -   **Implementation**: 
        ```typescript
        import * as vscode from 'vscode';
        import { QdrantService } from '../db/qdrantService';
        import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
        import { OllamaProvider } from '../embeddings/ollamaProvider'; // Example provider

        export class ContextService {
            private qdrantService: QdrantService;
            private embeddingProvider: IEmbeddingProvider;

            constructor() {
                this.qdrantService = new QdrantService();
                this.embeddingProvider = new OllamaProvider(); // This will be configurable later
            }

            public async getFileContent(filePathQuery: string): Promise<string | null> {
                // Placeholder: In a real scenario, you'd use embedding and Qdrant search
                // to find the most relevant file path based on the query.
                // For now, assume filePathQuery is an exact path for demonstration.
                try {
                    const uri = vscode.Uri.file(filePathQuery);
                    const contentBuffer = await vscode.workspace.fs.readFile(uri);
                    return contentBuffer.toString();
                } catch (error) {
                    console.error(`Error reading file ${filePathQuery}:`, error);
                    return null;
                }
            }

            public async findRelatedFiles(conceptOrFilePath: string, limit: number = 5): Promise<string[]> {
                // Placeholder: Implement actual vector search using embeddingProvider and QdrantService
                console.log(`Finding related files for: ${conceptOrFilePath}`);
                // Example: return dummy data
                return ["/path/to/related/file1.ts", "/path/to/related/file2.ts"];
            }
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { QdrantService } from '../db/qdrantService';`, `import { IEmbeddingProvider } from '../embeddings/embeddingProvider';`, `import { OllamaProvider } from '../embeddings/ollamaProvider';`
2.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Implement the `getFileContent` method to read the content of a specified file from disk.
    -   **Implementation**: (See `getFileContent` in the `ContextService` implementation above)
    -   **Imports**: None.

### User Story 2: Find Related Files via API

**As a** developer, **I want to** query the extension's backend to find files related to a given concept or file path, **so that** the frontend can display relevant code context to the user.

**Actions to Undertake:**
1.  **Filepath**: `src/context/contextService.ts`
    -   **Action**: Implement the `findRelatedFiles` method to perform a vector similarity search in Qdrant and return a list of relevant file paths.
    -   **Implementation**: (See `findRelatedFiles` in the `ContextService` implementation above. This will require actual integration with `embeddingProvider` and `qdrantService`.)
    -   **Imports**: None.

### User Story 3: Expose Backend API via Webview Message Passing

**As a** developer, **I want to** expose the `ContextService` methods to the SvelteKit frontend using VS Code's webview message passing, **so that** the frontend can interact with the backend API.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    -   **Action**: Set up a message listener on the webview panel to handle incoming requests from the frontend.
    -   **Implementation**: (Add `panel.webview.onDidReceiveMessage` handler)
        ```typescript
        // Inside activate function, after panel creation:
        panel.webview.onDidReceiveMessage(
            async message => {
                const contextService = new ContextService(); // Or pass an instance if already created
                switch (message.command) {
                    case 'getFileContent':
                        const fileContent = await contextService.getFileContent(message.filePath);
                        panel.webview.postMessage({ command: 'fileContentResult', content: fileContent });
                        return;
                    case 'findRelatedFiles':
                        const relatedFiles = await contextService.findRelatedFiles(message.query);
                        panel.webview.postMessage({ command: 'relatedFilesResult', files: relatedFiles });
                        return;
                }
            },
            undefined,
            context.subscriptions
        );
        ```
    -   **Imports**: `import { ContextService } from './context/contextService';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Route incoming messages to the appropriate `ContextService` method and send results back to the frontend.
    -   **Implementation**: (See `switch` statement and `panel.webview.postMessage` in the `onDidReceiveMessage` handler above)
    -   **Imports**: None.
3.  **Filepath**: `webview/src/lib/vscodeApi.ts` (New File)
    -   **Action**: Create a wrapper service in the SvelteKit app to simplify posting and listening for messages from the extension backend.
    -   **Implementation**: 
        ```typescript
        // webview/src/lib/vscodeApi.ts
        declare const acquireVsCodeApi: any;
        const vscode = acquireVsCodeApi();

        export function postMessage(message: any) {
            vscode.postMessage(message);
        }

        export function onMessage(callback: (message: any) => void) {
            window.addEventListener('message', event => {
                callback(event.data);
            });
        }
        ```
    -   **Imports**: None.
4.  **Filepath**: `webview/src/routes/+page.svelte` (or relevant Svelte component)
    -   **Action**: Modify the frontend to send messages to the backend and handle responses.
    -   **Implementation**: 
        ```html
        <script lang="ts">
          import { postMessage, onMessage } from '../lib/vscodeApi';
          import { onMount } from 'svelte';

          let fileContent: string | null = null;
          let relatedFiles: string[] = [];

          onMount(() => {
            onMessage(message => {
              switch (message.command) {
                case 'fileContentResult':
                  fileContent = message.content;
                  break;
                case 'relatedFilesResult':
                  relatedFiles = message.files;
                  break;
              }
            });
          });

          function requestFileContent(filePath: string) {
            postMessage({ command: 'getFileContent', filePath });
          }

          function requestRelatedFiles(query: string) {
            postMessage({ command: 'findRelatedFiles', query });
          }
        </script>

        <button on:click={() => requestFileContent('/path/to/your/file.ts')}>Get File Content</button>
        {#if fileContent}
          <pre>{fileContent}</pre>
        {/if}

        <button on:click={() => requestRelatedFiles('authentication logic')}>Find Related Files</button>
        {#if relatedFiles.length > 0}
          <ul>
            {#each relatedFiles as file}
              <li>{file}</li>
            {/each}
          </ul>
        {/if}
        ```
    -   **Imports**: `import { postMessage, onMessage } from '../lib/vscodeApi';`, `import { onMount } from 'svelte';`

**Acceptance Criteria:**
-   When the frontend sends a `getFileContent` message with a valid file path, the backend responds with the correct file content.
-   When the frontend sends a `findRelatedFiles` message with a query, the backend responds with an array of relevant file paths.
-   The backend API gracefully handles cases where files are not found or no related files are identified, returning `null` or an empty array respectively.

**Testing Plan:**
-   **Test Case 1**: Manually trigger a `getFileContent` request from the frontend (e.g., via a button click). Verify that the correct file content is displayed in the webview.
-   **Test Case 2**: Manually trigger a `findRelatedFiles` request from the frontend. Verify that a list of related files is displayed.
-   **Test Case 3**: Test with a non-existent file path for `getFileContent` and verify the frontend handles the `null` response gracefully (e.g., displays an error message).
-   **Test Case 4**: Test with a query that yields no related files for `findRelatedFiles` and verify the frontend handles the empty array gracefully.
</file>

<file path="docs/todo/setup/backlog_sub_sprint_6_develop_settings_ui.md">
### User Story 1: Open Settings UI from Command Palette

**As a** user, **I want to** open the extension's settings UI from the VS Code Command Palette, **so that** I can easily access and configure the extension.

**Actions to Undertake:**
1.  **Filepath**: `package.json`
    -   **Action**: Define a new command in `package.json` to open the settings webview.
    -   **Implementation**: (Add to `contributes.commands` section)
        ```json
        {
            "command": "code-context-engine.openSettings",
            "title": "Code Context Engine: Open Settings"
        }
        ```
    -   **Imports**: None.
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Register the new command in `extension.ts` to create and show the settings webview panel.
    -   **Implementation**: (Add to `activate` function)
        ```typescript
        import * as vscode from 'vscode';
        import * as path from 'path';
        import * as fs from 'fs';

        // ... existing activate function content ...

        let settingsPanel: vscode.WebviewPanel | undefined = undefined;

        context.subscriptions.push(
            vscode.commands.registerCommand('code-context-engine.openSettings', () => {
                const columnToShowIn = vscode.window.activeTextEditor
                    ? vscode.window.activeTextEditor.viewColumn
                    : undefined;

                if (settingsPanel) {
                    settingsPanel.reveal(columnToShowIn);
                } else {
                    settingsPanel = vscode.window.createWebviewPanel(
                        'codeContextEngineSettings',
                        'Code Context Engine Settings',
                        columnToShowIn || vscode.ViewColumn.One,
                        {
                            enableScripts: true,
                            localResourceRoots: [
                                vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                            ]
                        }
                    );

                    const svelteAppPath = vscode.Uri.file(
                        path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                    );

                    let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');
                    htmlContent = htmlContent.replace(/\/\_app\//g, settingsPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                    settingsPanel.webview.html = htmlContent;

                    settingsPanel.onDidDispose(
                        () => {
                            settingsPanel = undefined;
                        },
                        null,
                        context.subscriptions
                    );
                }
            })
        );
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import * as path from 'path';`, `import * as fs from 'fs';`

### User Story 2: Display and Edit Settings in UI

**As a** user, **I want to** see and edit the extension's configuration settings (e.g., embedding provider, database connection string) in a dedicated UI, **so that** I can customize its behavior.

**Actions to Undertake:**
1.  **Filepath**: `webview/src/routes/settings.svelte` (New File)
    -   **Action**: Create a new Svelte component for the settings UI, using Fluent UI components for input fields (e.g., `<fluent-select>`, `<fluent-text-field>`).
    -   **Implementation**: 
        ```html
        <script lang="ts">
          import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";
          import { onMount } from 'svelte';
          import { postMessage, onMessage } from '../lib/vscodeApi';

          provideFluentDesignSystem().register(
            fluentSelect(),
            fluentOption(),
            fluentTextField(),
            fluentButton()
          );

          let embeddingProvider: string = 'Ollama'; // Default value
          let databaseConnectionString: string = '';

          onMount(() => {
            // Request current settings from extension backend on component mount
            postMessage({ command: 'getSettings' });

            onMessage(message => {
              if (message.command === 'settingsResult') {
                embeddingProvider = message.settings.embeddingProvider || 'Ollama';
                databaseConnectionString = message.settings.databaseConnectionString || '';
              }
            });
          });

          function saveSettings() {
            const settings = {
              embeddingProvider,
              databaseConnectionString,
            };
            postMessage({ command: 'saveSettings', settings });
          }
        </script>

        <main>
          <h1>Extension Settings</h1>

          <fluent-text-field
            appearance="outline"
            placeholder="Database Connection String"
            bind:value={databaseConnectionString}
            style="width: 100%; margin-bottom: 15px;"
          >
            Database Connection String
          </fluent-text-field>

          <fluent-select
            appearance="outline"
            bind:value={embeddingProvider}
            style="width: 100%; margin-bottom: 20px;"
          >
            <fluent-option value="Ollama">Ollama</fluent-option>
            <fluent-option value="OpenAI">OpenAI</fluent-option>
            <!-- Add more options as needed -->
          </fluent-select>

          <fluent-button appearance="accent" @click={saveSettings}>Save Settings</fluent-button>
        </main>

        <style>
          main {
            padding: 20px;
            font-family: var(--vscode-font-family);
            color: var(--vscode-editor-foreground);
          }
          /* Basic styling for Fluent UI components to match VS Code theme */
          fluent-text-field,
          fluent-select {
            --neutral-fill-rest: var(--vscode-input-background);
            --neutral-foreground-rest: var(--vscode-input-foreground);
            --neutral-stroke-rest: var(--vscode-input-border);
            --neutral-fill-stealth-rest: var(--vscode-input-background);
            --neutral-fill-stealth-hover: var(--vscode-input-background);
            --neutral-fill-stealth-active: var(--vscode-input-background);
            --neutral-foreground-hover: var(--vscode-input-foreground);
            --neutral-foreground-active: var(--vscode-input-foreground);
            --neutral-stroke-hover: var(--vscode-input-border);
            --neutral-stroke-active: var(--vscode-input-border);
          }
          fluent-button {
            --accent-fill-rest: var(--vscode-button-background);
            --accent-foreground-rest: var(--vscode-button-foreground);
            --accent-fill-hover: var(--vscode-button-hoverBackground);
          }
        </style>
        ```
    -   **Imports**: `import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";`, `import { onMount } from 'svelte';`, `import { postMessage, onMessage } from '../lib/vscodeApi';`
2.  **Filepath**: `src/extension.ts`
    -   **Action**: Implement a message handler in `extension.ts` to retrieve current settings from VS Code configuration and send them to the webview.
    -   **Implementation**: (Inside `onDidReceiveMessage` handler)
        ```typescript
        // ... existing message handling ...

        case 'getSettings':
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const currentSettings = {
                embeddingProvider: config.get('embeddingProvider'),
                databaseConnectionString: config.get('databaseConnectionString'),
            };
            settingsPanel?.webview.postMessage({ command: 'settingsResult', settings: currentSettings });
            return;
        ```
    -   **Imports**: None.

### User Story 3: Save Settings to VS Code Configuration

**As a** user, **I want to** save my changes to the extension's settings, **so that** my preferences are persisted across VS Code sessions.

**Actions to Undertake:**
1.  **Filepath**: `src/extension.ts`
    -   **Action**: Implement a message handler in `extension.ts` to receive updated settings from the webview and save them to VS Code workspace configuration.
    -   **Implementation**: (Inside `onDidReceiveMessage` handler)
        ```typescript
        // ... existing message handling ...

        case 'saveSettings':
            const newSettings = message.settings;
            const configToUpdate = vscode.workspace.getConfiguration('code-context-engine');
            await configToUpdate.update('embeddingProvider', newSettings.embeddingProvider, vscode.ConfigurationTarget.Global);
            await configToUpdate.update('databaseConnectionString', newSettings.databaseConnectionString, vscode.ConfigurationTarget.Global);
            vscode.window.showInformationMessage('Settings saved!');
            return;
        ```
    -   **Imports**: None.
2.  **Filepath**: `package.json`
    -   **Action**: Define the configuration schema in `package.json` under `contributes.configuration`.
    -   **Implementation**: (Add to `contributes` section)
        ```json
        "configuration": {
            "title": "Code Context Engine Configuration",
            "properties": {
                "code-context-engine.embeddingProvider": {
                    "type": "string",
                    "default": "Ollama",
                    "description": "Select the embedding provider to use (e.g., Ollama, OpenAI)."
                },
                "code-context-engine.databaseConnectionString": {
                    "type": "string",
                    "default": "http://localhost:6333",
                    "description": "Connection string for the Qdrant database."
                }
            }
        }
        ```
    -   **Imports**: None.

### User Story 4: Services Read from Configuration

**As a** developer, **I want to** ensure the extension's backend services (e.g., `IndexingService`, `QdrantService`) read their configuration from the VS Code workspace settings, **so that** user changes are applied correctly.

**Actions to Undertake:**
1.  **Filepath**: `src/indexing/indexingService.ts`
    -   **Action**: Update `IndexingService` to read the selected embedding provider from the VS Code configuration.
    -   **Implementation**: (Modify constructor or relevant method)
        ```typescript
        // In IndexingService constructor or a setup method
        const config = vscode.workspace.getConfiguration('code-context-engine');
        const providerName = config.get<string>('embeddingProvider', 'Ollama');
        if (providerName === 'OpenAI') {
            this.embeddingProvider = new OpenAIProvider();
        } else {
            this.embeddingProvider = new OllamaProvider();
        }
        ```
    -   **Imports**: `import * as vscode from 'vscode';`, `import { OpenAIProvider } from '../embeddings/openaiProvider';`, `import { OllamaProvider } from '../embeddings/ollamaProvider';`
2.  **Filepath**: `src/db/qdrantService.ts`
    -   **Action**: Update `QdrantService` to read the database connection string from the VS Code configuration.
    -   **Implementation**: (Modify constructor or client initialization)
        ```typescript
        // In QdrantService constructor
        const config = vscode.workspace.getConfiguration('code-context-engine');
        const connectionString = config.get<string>('databaseConnectionString', 'http://localhost:6333');
        this.client = new QdrantClient({ url: connectionString });
        ```
    -   **Imports**: `import * as vscode from 'vscode';`

**Acceptance Criteria:**
-   A new command "Code Context Engine: Open Settings" appears in the Command Palette.
-   Executing the command opens a new webview panel titled "Code Context Engine Settings".
-   The settings UI displays the default values for embedding provider and database connection string.
-   Changing values in the settings UI and clicking "Save Settings" updates the `settings.json` file (either user or workspace settings).
-   After saving, if the extension is reloaded or the relevant services are re-initialized, they pick up the new configuration values.

**Testing Plan:**
-   **Test Case 1**: Open the Command Palette, search for and execute "Code Context Engine: Open Settings". Verify the panel opens.
-   **Test Case 2**: Change the "Embedding Provider" to "OpenAI" and the "Database Connection String" to a custom value. Click "Save Settings". Close and reopen VS Code. Verify the settings persist.
-   **Test Case 3**: Verify that `IndexingService` and `QdrantService` instances (after re-initialization or extension reload) use the newly saved configuration values.
-   **Test Case 4**: Test with invalid connection strings or provider names to ensure graceful fallback to defaults or error handling.
</file>

<file path="docs/todo/setup/implementation_sprint_6_lsp_integration_devops.md">
### Implementation Guide: Sprint 6 - LSP Integration & DevOps

**Objective:** To enrich the index with LSP data and automate the build and test process.

#### **Analysis**

This sprint introduces two significant enhancements: integrating Language Server Protocol (LSP) data into the code context index and establishing a robust CI/CD pipeline using GitHub Actions. LSP integration will make the code context engine more intelligent by understanding semantic relationships within the code, going beyond mere syntactic parsing. The CI/CD pipeline will automate the build, test, and packaging process, ensuring code quality and a streamlined release workflow.

#### **Prerequisites and Setup**

1.  **Completed Indexing Pipeline:** Ensure the indexing, chunking, vectorization, and Qdrant storage (from Sprints 2 and 3) are fully functional.
2.  **GitHub Repository:** Your project must be hosted on GitHub to utilize GitHub Actions.

#### **Implementation Guide**

Here's a step-by-step guide to implementing LSP Integration and DevOps:

**1. LSP Data Integration into `IndexingService`**

To capture LSP data, you'll modify your `IndexingService` to programmatically query the active language server for information like definitions and references for each code chunk.

  *   **File:** `src/indexing/indexingService.ts`
  *   **API Information:**
      *   `vscode.commands.executeCommand()`: This is the key API to interact with VS Code's built-in commands, including those exposed by language servers.
      *   `vscode.executeDefinitionProvider`: Command to get definitions.
      *   `vscode.executeReferenceProvider`: Command to get references.
      *   `vscode.Position`: Represents a position in a text document.
      *   `vscode.Location`, `vscode.DefinitionLink`, `vscode.Reference`: Data structures returned by LSP commands.

  *   **Implementation Example (within `startIndexing` loop, after chunking):**
    ```typescript
    import * as vscode from 'vscode';
    // ... other imports

    export class IndexingService {
        // ... existing code ...

        private async processChunkWithLSP(fileUri: vscode.Uri, chunk: CodeChunk): Promise<void> {
            const position = new vscode.Position(chunk.startLine, 0); // Start of the chunk

            // Get Definitions
            try {
                const definitions = await vscode.commands.executeCommand<
                    vscode.Definition | vscode.DefinitionLink[]
                >('vscode.executeDefinitionProvider', fileUri, position);

                if (definitions) {
                    // Process definitions (e.g., extract URIs, ranges, etc.)
                    // Store relevant info in chunk.payload or a new property
                    // Example: chunk.lspDefinitions = definitions.map(d => ({ uri: d.uri.toString(), range: d.range }));
                }
            } catch (error) {
                console.warn(`LSP Definition Provider failed for ${fileUri.fsPath}:${chunk.startLine}:`, error);
            }

            // Get References
            try {
                const references = await vscode.commands.executeCommand<vscode.Reference[]>( 'vscode.executeReferenceProvider', fileUri, position);

                if (references) {
                    // Process references
                    // Example: chunk.lspReferences = references.map(r => ({ uri: r.uri.toString(), range: r.range }));
                }
            } catch (error) {
                console.warn(`LSP Reference Provider failed for ${fileUri.fsPath}:${chunk.startLine}:`, error);
            }
        }

        public async startIndexing(): Promise<void> {
            // ... existing file walking, parsing, chunking logic ...

            for (const file of files) {
                // ... existing parsing and chunking ...
                const fileUri = vscode.Uri.file(file);
                if (language) {
                    const tree = this.astParser.parse(language, content);
                    const chunks = this.chunker.chunk(file, tree, content);

                    for (const chunk of chunks) {
                        await this.processChunkWithLSP(fileUri, chunk); // Call LSP processing for each chunk
                        allChunks.push(chunk);
                    }
                }
            }
            // ... rest of indexing (embedding, Qdrant upsert) ...
        }
    }
    ```

**2. Extend Qdrant Metadata in `QdrantService`**

Modify your `QdrantService` to accept and store the new LSP-derived metadata as part of the payload when upserting chunks into Qdrant.

  *   **File:** `src/db/qdrantService.ts`
  *   **Key Concept:** Qdrant allows arbitrary JSON payloads to be stored alongside vectors. This is where you'll put your LSP data.

  *   **Implementation Example (modify `upsertChunks` method):**
    ```typescript
    import { QdrantClient } from '@qdrant/js-client-rest';
    import type { CodeChunk } from '../parsing/chunker';

    // Extend CodeChunk interface if not already done to include LSP data
    // declare module '../parsing/chunker' {
    //     interface CodeChunk {
    //         lspDefinitions?: { uri: string; range: any; }[];
    //         lspReferences?: { uri: string; range: any; }[];
    //     }
    // }

    export class QdrantService {
        // ... existing code ...

        public async upsertChunks(collectionName: string, chunks: CodeChunk[], vectors: number[][]): Promise<void> {
            const points = chunks.map((chunk, i) => ({
                id: `${chunk.filePath}:${chunk.startLine}-${chunk.endLine}`,
                vector: vectors[i],
                payload: {
                    filePath: chunk.filePath,
                    content: chunk.content,
                    startLine: chunk.startLine,
                    endLine: chunk.endLine,
                    type: chunk.type,
                    // Add LSP metadata to payload
                    lspDefinitions: chunk.lspDefinitions || [],
                    lspReferences: chunk.lspReferences || [],
                },
            }));

            await this.client.upsert(collectionName, {
                wait: true,
                points,
            });
        }
    }
    ```

**3. Create GitHub Actions Workflow**

Set up a new workflow file in your `.github/workflows/` directory. This file defines the automated steps for your CI/CD pipeline.

  *   **File:** `.github/workflows/ci.yml` (New File)
  *   **Key Concepts:**
      *   `on`: Defines when the workflow runs (e.g., `push`, `pull_request`).
      *   `jobs`: A workflow run is made up of one or more jobs.
      *   `runs-on`: The type of machine to run the job on.
      *   `steps`: A sequence of tasks to be executed.
      *   `actions/checkout`: Action to check out your repository.
      *   `actions/setup-node`: Action to set up Node.js environment.
      *   `npm install`, `npm run lint`, `npm test`, `npm run vscode:prepublish`: Standard commands for VS Code extension development.
      *   `actions/upload-artifact`: To save build artifacts.

  *   **Implementation Example:**
    ```yaml
    name: CI/CD

    on:
      push:
        branches:
          - main
      pull_request:
        branches:
          - main

    jobs:
      build:
        runs-on: ubuntu-latest

        steps:
          - name: Checkout repository
            uses: actions/checkout@v3

          - name: Set up Node.js
            uses: actions/setup-node@v3
            with:
              node-version: '18' # Or your project's Node.js version

          - name: Install dependencies
            run: npm install

          - name: Run lint
            run: npm run lint

          - name: Run tests
            run: npm test

          - name: Build VS Code Extension
            run: npm run vscode:prepublish # This command typically builds the .vsix

          - name: Upload VSIX artifact
            uses: actions/upload-artifact@v3
            with:
              name: vsix-package
              path: '*.vsix' # Adjust if your .vsix is in a different location
    ```

**4. Configure Linting, Testing, and Build Steps**

Ensure your `package.json` has the necessary scripts for linting, testing, and building, which the GitHub Actions workflow will then call.

  *   **File:** `package.json`
  *   **Key Concepts:**
      *   `"lint"`: Script for running your linter (e.g., ESLint).
      *   `"test"`: Script for running your unit tests (e.g., Vitest, Mocha).
      *   `"vscode:prepublish"`: Standard script for preparing your extension for publishing, which typically includes compiling TypeScript and packaging.

  *   **Example `scripts` section in `package.json`:**
    ```json
    "scripts": {
        "vscode:prepublish": "npm run compile",
        "compile": "tsc -p ./",
        "watch": "tsc -watch -p ./",
        "pretest": "npm run compile",
        "test": "node ./out/test/runTest.js",
        "lint": "eslint src --ext ts"
    },
    ```
    *Note: Adjust these scripts based on your actual project setup (e.g., if you use `vitest` directly, your `test` script would be `vitest`).*

This completes the implementation guide for Sprint 6. You now have a more intelligent indexing process leveraging LSP data and an automated CI/CD pipeline to ensure continuous quality and efficient development.
</file>

<file path="docs/todo/setup/implementation_sprint_7_documentation_publishing.md">
### Implementation Guide: Sprint 7 - Documentation & Publishing

**Objective:** To create high-quality documentation and publish the extension to the marketplace.

#### **Analysis**

This final sprint focuses on the crucial aspects of product delivery: comprehensive documentation and marketplace publishing. Effective documentation (README, contributing guide) is vital for user adoption and community engagement. Publishing to the VS Code Marketplace makes the extension discoverable and easily installable. Automating the publishing process via GitHub Actions ensures consistency and reduces manual errors.

#### **Prerequisites and Setup**

1.  **Completed Extension:** The extension should be fully functional and tested from previous sprints.
2.  **GitHub Repository:** Your project must be hosted on GitHub.
3.  **VS Code Extension Publisher Account:** You will need to create one on the Azure DevOps organization for VS Code publishers.
4.  **`vsce` (Visual Studio Code Extension Manager):** This tool is used for packaging and publishing VS Code extensions.
    ```bash
    npm install -g vsce
    ```

#### **Implementation Guide**

Here's a step-by-step guide to creating documentation and publishing your extension:

**1. Write `README.md` Content**

The `README.md` is the first thing users see. It should clearly explain what your extension does, how to install it, configure it, and use it.

  *   **File:** `README.md`
  *   **Key Sections to Include:**
      *   **Title and Overview:** A clear, concise description of the extension.
      *   **Features:** A bulleted list of key functionalities.
      *   **Installation:** Step-by-step instructions for installing from the Marketplace or manually.
      *   **Configuration:** How to access and change settings, with examples.
      *   **Usage:** A guide on how to use the extension's core features.
      *   **Screenshots/GIFs:** Visual aids are highly recommended.
      *   **Contributing (Optional):** Link to `CONTRIBUTING.md`.
      *   **License:** Information about the extension's license.

  *   **Example Structure:**
    ```markdown
    # Code Context Engine VS Code Extension

    ![Demo GIF](assets/demo.gif) <!-- Link to your demo GIF -->

    A powerful VS Code extension that helps developers understand their codebase by providing contextual information through semantic search and LSP integration.

    ## Features
    - Intelligent code indexing using AST parsing and LSP data.
    - Semantic search for related files and code snippets.
    - Customizable embedding providers (Ollama, OpenAI).
    - Local Qdrant vector database integration.
    - Intuitive settings UI for easy configuration.

    ## Installation
    1.  **From VS Code Marketplace:** Search for "Code Context Engine" in the Extensions view (`Ctrl+Shift+X` or `Cmd+Shift+X`) and click "Install".
    2.  **Manual Installation:**
        a.  Clone this repository: `git clone https://github.com/your-username/code-context-engine.git`
        b.  Navigate to the project root: `cd code-context-engine`
        c.  Package the extension: `vsce package`
        d.  Install the `.vsix` file: Open VS Code, go to Extensions view, click `...` (More Actions) -> `Install from VSIX...` and select the generated `.vsix` file.

    ## Configuration
    To configure the extension, open the Command Palette (`Ctrl+Shift+P` or `Cmd+Shift+P`) and search for "Code Context Engine: Open Settings".

    -   **Embedding Provider:** Select your preferred embedding model (e.g., Ollama for local models, OpenAI for cloud-based).
    -   **Database Connection String:** Specify the URL for your Qdrant instance (e.g., `http://localhost:6333`).

    ## Usage
    1.  **Index Your Repository:** Open the Code Context Engine panel (View -> Open View -> Code Context Engine) and click "Index Now".
    2.  **Query Context:** Use the search bar in the panel to ask questions about your codebase (e.g., "Show me authentication logic", "Find files related to user profiles").

    ## Contributing
    We welcome contributions! Please see our [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

    ## License
    [Your License Here]
    ```

**2. Create Demo GIF**

A short, animated GIF demonstrating the core functionality of your extension can significantly improve user understanding and engagement.

  *   **Tool:** Use screen recording software (e.g., OBS Studio, ShareX, macOS built-in recorder) to capture your workflow. Then, use a GIF converter (e.g., online tools, FFmpeg) to create an optimized GIF.
  *   **File:** `assets/demo.gif` (or similar path, referenced in `README.md`)
  *   **Tips:**
      *   Keep it short and focused (10-30 seconds).
      *   Highlight the most impactful features.
      *   Ensure good resolution and clear text.
      *   Optimize file size for faster loading.

**3. Write `CONTRIBUTING.md`**

This file provides guidelines for potential contributors, making it easier for others to get involved with your project.

  *   **File:** `CONTRIBUTING.md`
  *   **Key Sections to Include:**
      *   **How to Contribute:** General overview.
      *   **Local Development Setup:** Instructions for cloning, installing dependencies, and running the project locally.
      *   **Running Tests:** How to execute unit and integration tests.
      *   **Code Style and Linting:** Any specific coding conventions or tools.
      *   **Submitting Changes:** Guidelines for pull requests (e.g., branch naming, commit message format).
      *   **Reporting Bugs/Suggesting Features:** How to open issues.

  *   **Example Structure:**
    ```markdown
    # Contributing to Code Context Engine

    We welcome and appreciate contributions to the Code Context Engine VS Code extension! By contributing, you help us make this tool better for everyone.

    ## How to Get Started

    1.  **Fork the Repository:** Start by forking the `code-context-engine` repository on GitHub.
    2.  **Clone Your Fork:** `git clone https://github.com/your-username/code-context-engine.git`
    3.  **Install Dependencies:** Navigate to the project root and install all necessary dependencies:
        ```bash
        npm install
        ```
    4.  **Open in VS Code:** Open the cloned project in Visual Studio Code.

    ## Local Development

    -   **Run Extension:** Press `F5` in VS Code to launch a new Extension Development Host window with your extension loaded.
    -   **Build Webview:** If you make changes to the SvelteKit webview, navigate to the `webview` directory and run `npm run build` to compile the changes.

    ## Running Tests

    To run the project's tests:

    ```bash
    npm test
    ```

    ## Code Style and Linting

    We use ESLint and Prettier to maintain code quality and consistency. Please ensure your code passes linting checks before submitting a pull request:

    ```bash
    npm run lint
    ```

    ## Submitting Changes (Pull Requests)

    1.  **Create a Branch:** Create a new branch for your feature or bug fix:
        `git checkout -b feature/your-feature-name` or `git checkout -b bugfix/issue-number`
    2.  **Make Your Changes:** Implement your feature or fix the bug.
    3.  **Write Tests:** Ensure your changes are covered by appropriate unit or integration tests.
    4.  **Commit Your Changes:** Write clear, concise commit messages that explain *what* and *why*.
    5.  **Push to Your Fork:** `git push origin your-branch-name`
    6.  **Open a Pull Request:** Go to the original `code-context-engine` repository on GitHub and open a new pull request from your branch.

    ## Reporting Issues / Suggesting Features

    If you find a bug or have a feature request, please open an issue on our [GitHub Issues page](https://github.com/your-username/code-context-engine/issues).
    ```

**4. Create Marketplace Publisher Identity**

To publish your extension, you need a publisher ID. This is done through Azure DevOps.

  *   **Action:** Follow the official VS Code documentation to create a publisher. This typically involves:
      1.  Going to the Azure DevOps organization for VS Code publishers.
      2.  Creating a new organization if you don't have one.
      3.  Creating a Personal Access Token (PAT) with `Marketplace (Publish)` scope.
  *   **Reference:** [Publishing Extensions - Visual Studio Code](https://code.visualstudio.com/api/references/publishing-extensions)

**5. Update GitHub Actions for Manual Release Trigger**

Modify your `ci.yml` workflow to include a `workflow_dispatch` event, allowing you to manually trigger the release job from the GitHub Actions UI.

  *   **File:** `.github/workflows/ci.yml`
  *   **Key Concept:** `workflow_dispatch` enables manual triggering of workflows.

  *   **Implementation Example (add to `on` section):**
    ```yaml
    on:
      push:
        branches:
          - main
      pull_request:
        branches:
          - main
      workflow_dispatch: # This enables manual triggering
    ```

**6. Implement Publishing Step in CI/CD Pipeline**

Add a new job to your `ci.yml` that will execute the `vsce publish` command. This job should depend on the `build` job and use a GitHub Secret to store your `vsce` Personal Access Token (PAT).

  *   **File:** `.github/workflows/ci.yml`
  *   **Key Concepts:**
      *   `needs`: Specifies that a job depends on the successful completion of another job.
      *   `if`: Conditional execution of a job.
      *   `secrets`: Securely store sensitive information like API keys.
      *   `vsce publish -p <token>`: Command to publish the extension.

  *   **Implementation Example (add a new job after `build` job):**
    ```yaml
    # ... (existing build job)

    release:
      needs: build # This job depends on the 'build' job completing successfully
      runs-on: ubuntu-latest
      if: github.event_name == 'workflow_dispatch' # Only run this job when manually triggered

      steps:
        - name: Checkout repository
          uses: actions/checkout@v3

        - name: Set up Node.js
          uses: actions/setup-node@v3
          with:
            node-version: '18' # Or your project's Node.js version

        - name: Install vsce
          run: npm install -g vsce

        - name: Download VSIX artifact
          uses: actions/download-artifact@v3
          with:
            name: vsix-package
            path: .

        - name: Publish to VS Code Marketplace
          run: vsce publish -p ${{ secrets.VSCE_TOKEN }}
          env:
            VSCE_TOKEN: ${{ secrets.VSCE_TOKEN }} # Pass the token as an environment variable
    ```
    *   **Important:** You must add `VSCE_TOKEN` as a repository secret in your GitHub repository settings (Settings -> Secrets and variables -> Actions -> New repository secret).

**7. Test the Release Process**

After setting up the workflow, perform a test release to ensure everything works as expected.

  *   **Action:**
      1.  Go to your GitHub repository -> Actions tab.
      2.  Select your `CI/CD` workflow.
      3.  Click `Run workflow` button (usually on the right side).
      4.  Select the `main` branch and click `Run workflow`.
      5.  Monitor the workflow run for success.
      6.  Check the VS Code Marketplace for your published extension.

This completes the implementation guide for Sprint 7. You now have a well-documented extension and an automated process for publishing it to the VS Code Marketplace, making it accessible to a wider audience.
</file>

<file path="docs/todo/setup/implementation_sub_sprint_1_vs_code_extension_boilerplate_setup.md">
### Implementation Guide: Sub-Sprint 1 - VS Code Extension Boilerplate Setup

**Objective:** To create the fundamental file structure and configuration for a new VS Code extension using TypeScript.

#### **Analysis**

Since a `repomix-roocode.xml` or similar comprehensive code structure file was not provided for this specific sub-sprint, the analysis is based on the general requirements for a VS Code extension and best practices for project setup. The goal is to establish a clean, maintainable, and standard TypeScript-based extension project.

#### **Prerequisites and Setup**

Before starting, ensure you have the following installed:

1.  **Node.js and npm/yarn:** Essential for JavaScript/TypeScript development.
2.  **VS Code Extension Generator (`yo code`):** This Yeoman generator scaffolds new VS Code extension projects.
    ```bash
    npm install -g yo generator-code
    ```

#### **Implementation Guide**

Here's a step-by-step guide to setting up the VS Code extension boilerplate:

**1. Generate the VS Code Extension Project**

Use the `yo code` generator to create the initial project structure. This command will prompt you with several questions to configure your extension.

  *   **Command:**
    ```bash
    npx yo code
    ```
  *   **Prompts to select:**
      *   `? What type of extension do you want to create?` -> `New Extension (TypeScript)`
      *   `? What is the name of your extension?` -> `CodeContextEngine` (or a suitable name)
      *   `? What is the identifier of your extension?` -> `code-context-engine`
      *   `? What is the description of your extension?` -> (Provide a brief description)
      *   `? Enable TypeScript checking and linting?` -> `Yes`
      *   `? Initialize a git repository?` -> `Yes` (Recommended)
      *   `? Do you want to open the new folder with VS Code?` -> `Yes`

  *   **API Information:** The `yo code` generator uses the VS Code Extension API internally to set up the `package.json`, `src/extension.ts`, and other configuration files.

**2. Configure `package.json`**

The `package.json` file is crucial for defining your extension's metadata, commands, and activation events. Review and adjust the generated file.

  *   **File:** `package.json`
  *   **Key fields to review/modify:**
      *   `name`: The unique identifier for your extension.
      *   `displayName`: The name displayed in the VS Code Marketplace.
      *   `description`: A brief summary of your extension.
      *   `publisher`: Your VS Code Marketplace publisher ID.
      *   `activationEvents`: Defines when your extension is activated (e.g., `onCommand:your-extension.helloWorld`).
      *   `main`: The entry point of your extension (usually `out/extension.js`).
      *   `contributes`: This section is where you declare commands, views, keybindings, etc.

  *   **Example `activationEvents` (if not already present):**
    ```json
    "activationEvents": [
        "onCommand:code-context-engine.helloWorld"
    ],
    ```

**3. Establish Project Structure**

The `yo code` generator provides a basic structure. For a SvelteKit frontend, it's good practice to separate the backend (extension) and frontend (webview) code. You'll typically have a `src` directory for your main extension code and a separate directory for your SvelteKit project.

  *   **Action:** Create a `webview` directory at the root level (or within `src` if preferred) to house your SvelteKit application.
  *   **Command:**
    ```bash
    mkdir webview
    ```
  *   **Resulting structure (example):**
    ```
    your-extension-name/
     .vscode/
     src/
        extension.ts
     webview/  <-- New directory for SvelteKit
     package.json
     tsconfig.json
     .gitignore
     ...
    ```

**4. Initial Backend Logic (`extension.ts`)**

The `extension.ts` file is the main entry point for your VS Code extension. It contains the `activate` function, which is called when your extension is activated, and the `deactivate` function, called when your extension is deactivated.

  *   **File:** `src/extension.ts`
  *   **Key concepts:**
      *   `activate(context: vscode.ExtensionContext)`: This is where you register commands, create webviews, and set up event listeners.
      *   `deactivate()`: Used for cleanup, like disposing of resources.
      *   `vscode.commands.registerCommand()`: Registers a command that can be invoked by the user (e.g., from the Command Palette).
      *   `vscode.window.showInformationMessage()`: Displays a message to the user.
      *   `context.subscriptions.push()`: Adds disposables (objects with a `dispose` method) to the extension's context, ensuring they are cleaned up when the extension is deactivated.

  *   **Example `src/extension.ts` (as generated by `yo code` and slightly modified for clarity):**
    ```typescript
    import * as vscode from 'vscode';

    /**
     * This method is called when your extension is activated.
     * The extension is activated the very first time the command is executed.
     */
    export function activate(context: vscode.ExtensionContext) {

        // Use the console to output diagnostic information (console.log) and errors (console.error)
        // This line of code will only be executed once when your extension is activated
        console.log('Congratulations, your extension "code-context-engine" is now active!');

        // The command has been defined in the package.json file
        // Now provide the implementation of the command with registerCommand
        // The commandId parameter must match the command field in package.json
        let disposable = vscode.commands.registerCommand('code-context-engine.helloWorld', () => {
            // The code you place here will be executed every time your command is executed
            // Display a message box to the user
            vscode.window.showInformationMessage('Hello World from Code Context Engine!');
        });

        context.subscriptions.push(disposable);
    }

    /**
     * This method is called when your extension is deactivated
     */
    export function deactivate() {}
    ```

This completes the foundational setup for your VS Code extension. You now have a runnable project with a basic command, ready for further development in subsequent sprints.
</file>

<file path="docs/todo/setup/implementation_sub_sprint_2_sveltekit_fluent_ui_integration.md">
### Implementation Guide: Sub-Sprint 2 - SvelteKit and Fluent UI Integration

**Objective:** To set up the SvelteKit frontend and integrate the Fluent UI component library, creating the initial user interface.

#### **Analysis**

This sub-sprint focuses on the frontend development of the VS Code extension. The core idea is to leverage SvelteKit for building a modern, reactive UI within a VS Code webview. Fluent UI is chosen for its consistency with Microsoft's design language, ensuring a native feel within VS Code. The integration requires careful handling of webview communication and theme adaptation.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 1 Completion:** Ensure the basic VS Code extension boilerplate is set up as per Sub-Sprint 1's guide.
2.  **Node.js and npm/yarn:** Already installed from previous steps.

#### **Implementation Guide**

Here's a step-by-step guide to integrating SvelteKit and Fluent UI:

**1. Initialize SvelteKit Project within `webview` Directory**

Navigate into the `webview` directory you created in Sub-Sprint 1 and initialize a new SvelteKit project. Choose the "Skeleton project" and enable TypeScript, ESLint, Prettier, and Vitest for a robust development environment.

  *   **Command:**
    ```bash
    cd webview
    npm create svelte@latest .
    ```
  *   **Prompts to select:**
      *   `? Which Svelte project template?` -> `Skeleton project`
      *   `? Add TypeScript?` -> `Yes, using TypeScript syntax`
      *   `? Add ESLint for code linting?` -> `Yes`
      *   `? Add Prettier for code formatting?` -> `Yes`
      *   `? Add Playwright for browser testing?` -> `No` (or Yes, if desired for e2e)
      *   `? Add Vitest for unit testing?` -> `Yes`

  *   **Install dependencies:**
    ```bash
    npm install
    ```

**2. Configure Webview in `extension.ts` to Load SvelteKit App**

Your `extension.ts` needs to create a `WebviewPanel` and load the compiled SvelteKit application's `index.html` into it. SvelteKit builds to a `dist` folder by default.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.window.createWebviewPanel()`: Creates and shows a new webview panel.
      *   `panel.webview.html`: Sets the HTML content of the webview.
      *   `panel.webview.options.localResourceRoots`: Allows the webview to load local resources (like CSS/JS from your SvelteKit build).
      *   `vscode.Uri.file()` and `path.join()`: Used to construct absolute paths to your SvelteKit build assets.
      *   `fs.readFileSync()`: Node.js file system module to read the `index.html` file. You might need to add `import * as fs from 'fs';` at the top of `extension.ts`.

  *   **Implementation Example:**
    ```typescript
    import * as vscode from 'vscode';
    import * as path from 'path';
    import * as fs from 'fs'; // Add this import

    export function activate(context: vscode.ExtensionContext) {
        console.log('Congratulations, your extension "code-context-engine" is now active!');

        let currentPanel: vscode.WebviewPanel | undefined = undefined;

        context.subscriptions.push(
            vscode.commands.registerCommand('code-context-engine.openSveltePanel', () => {
                const columnToShowIn = vscode.window.activeTextEditor
                    ? vscode.window.activeTextEditor.viewColumn
                    : undefined;

                if (currentPanel) {
                    currentPanel.reveal(columnToShowIn);
                } else {
                    currentPanel = vscode.window.createWebviewPanel(
                        'codeContextEngine',
                        'Code Context Engine',
                        columnToShowIn || vscode.ViewColumn.One,
                        {
                            enableScripts: true,
                            localResourceRoots: [
                                vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                            ]
                        }
                    );

                    const svelteAppPath = vscode.Uri.file(
                        path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                    );

                    // Read the SvelteKit index.html and set it as the webview content
                    let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');

                    // Important: Replace relative paths with webview-specific URIs
                    // This ensures that SvelteKit's JS/CSS assets are loaded correctly
                    htmlContent = htmlContent.replace(/\/\_app\//g, currentPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                    currentPanel.webview.html = htmlContent;

                    currentPanel.onDidDispose(
                        () => {
                            currentPanel = undefined;
                        },
                        null,
                        context.subscriptions
                    );
                }
            })
        );
    }

    export function deactivate() {}
    ```
    *   **Note on `htmlContent.replace`**: SvelteKit generates paths like `/_app/`. You need to convert these to `webview-uri`s so the webview can load them. The regex ` /\/_app\//g` targets these paths.

**3. Install Fluent UI Svelte Library**

While the PRD mentioned `svelte-fluent-ui`, the official Fluent UI components are often used as web components or React components. For Svelte, you can use the `@fluentui/web-components` directly or a community-maintained Svelte wrapper if available and preferred. For this guide, I will use the official web components as they are framework-agnostic.

  *   **Command (from `webview` directory):**
    ```bash
    cd webview
    npm install @fluentui/web-components
    ```

**4. Implement UI with Fluent UI Components**

Create your main Svelte component (e.g., `src/routes/+page.svelte` or a new component like `src/lib/MainPanel.svelte`) and use Fluent UI components.

  *   **File:** `webview/src/routes/+page.svelte` (or `webview/src/lib/MainPanel.svelte`)
  *   **API Information:**
      *   `provideFluentDesignSystem().register(...)`: Registers the Fluent UI web components for use.
      *   `<fluent-button>`: Fluent UI button component.
      *   `<fluent-progress-ring>`: Fluent UI progress indicator.

  *   **Implementation Example (`webview/src/routes/+page.svelte`):**
    ```html
    <script lang="ts">
      import { provideFluentDesignSystem, fluentButton, fluentProgressRing } from "@fluentui/web-components";

      // Register Fluent UI components
      provideFluentDesignSystem().register(
        fluentButton(),
        fluentProgressRing()
      );

      function handleIndexNow() {
        console.log("Index Now button clicked!");
        // In a real scenario, this would trigger the backend indexing process
      }
    </script>

    <main>
      <h1>Code Context Engine</h1>
      <p>Click the button to start indexing your repository.</p>
      <fluent-button appearance="accent" @click="{handleIndexNow}">Index Now</fluent-button>
      <div style="margin-top: 20px;">
        <p>Indexing Progress:</p>
        <fluent-progress-ring></fluent-progress-ring>
      </div>
    </main>

    <style>
      /* Basic styling for the page */
      main {
        padding: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        line-height: 1.5;
      }

      h1 {
        color: var(--vscode-editor-foreground);
      }

      p {
        color: var(--vscode-editor-foreground);
      }

      /* Ensure Fluent UI components inherit VS Code theme colors */
      fluent-button {
        --accent-fill-rest: var(--vscode-button-background);
        --accent-fill-hover: var(--vscode-button-hoverBackground);
        --accent-fill-active: var(--vscode-button-background);
        --accent-foreground-rest: var(--vscode-button-foreground);
        --neutral-fill-rest: var(--vscode-button-background);
        --neutral-fill-hover: var(--vscode-button-hoverBackground);
        --neutral-fill-active: var(--vscode-button-background);
        --neutral-foreground-rest: var(--vscode-button-foreground);
      }

      fluent-progress-ring {
        --accent-fill-rest: var(--vscode-progressBar-background);
      }
    </style>
    ```

**5. Theme Integration**

VS Code exposes its theme colors as CSS variables. You can use these variables in your SvelteKit application's global CSS or directly within components to ensure your UI adapts to the user's chosen theme.

  *   **File:** `webview/src/app.css` (or directly in your Svelte components' `<style>` tags)
  *   **API Information:** VS Code CSS Variables (e.g., `--vscode-editor-background`, `--vscode-editor-foreground`, `--vscode-button-background`).

  *   **Implementation Example (`webview/src/app.css`):**
    ```css
    /* Global styles for the webview */
    body {
      background-color: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
    }

    /* Example of applying VS Code theme colors to Fluent UI components */
    fluent-button {
      --accent-fill-rest: var(--vscode-button-background);
      --accent-fill-hover: var(--vscode-button-hoverBackground);
      --accent-fill-active: var(--vscode-button-background);
      --accent-foreground-rest: var(--vscode-button-foreground);
    }

    fluent-progress-ring {
      --accent-fill-rest: var(--vscode-progressBar-background);
    }
    ```

**Build the SvelteKit App:**

Before running the extension, you need to build your SvelteKit application so that `extension.ts` can load the `index.html` and other assets from the `dist` folder.

  *   **Command (from `webview` directory):**
    ```bash
    cd webview
    npm run build
    ```

This completes the integration of SvelteKit and Fluent UI into your VS Code extension. You now have a visually consistent and interactive frontend ready to communicate with your extension's backend.
</file>

<file path="docs/todo/setup/implementation_sub_sprint_5_implement_context_query_api.md">
### Implementation Guide: Sub-Sprint 5 - Implement Context Query API

**Objective:** To build the internal backend API that will allow the frontend to query the indexed codebase.

#### **Analysis**

This sub-sprint is critical for enabling the core functionality of the extension: allowing users to query their codebase for contextual information. It involves creating a backend service (`ContextService`) that orchestrates interactions with the Qdrant vector database and an embedding provider. Communication between the SvelteKit frontend and this backend service will occur via VS Code's webview message passing API. The design emphasizes modularity, with clear separation of concerns between file system operations, embedding generation, and vector database interactions.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 3 Completion:** Ensure that the Qdrant service and embedding providers (Ollama/OpenAI) are set up and functional, as this sprint relies heavily on them.
2.  **VS Code Extension Project:** A working VS Code extension project with a SvelteKit webview integrated (from previous sprints).

#### **Implementation Guide**

Here's a step-by-step guide to implementing the Context Query API:

**1. Create `ContextService`**

This service will act as the orchestrator for all context-related queries. It will depend on the `QdrantService` (for database interactions) and an `IEmbeddingProvider` (for generating embeddings).

  *   **File:** `src/context/contextService.ts` (New File)
  *   **Key Concepts:**
      *   **Dependency Injection (Basic):** The `ContextService` will instantiate `QdrantService` and an `IEmbeddingProvider`. In a more complex application, these might be passed in via a dependency injection framework.
      *   **Orchestration:** This service will coordinate calls to the embedding provider and Qdrant to fulfill queries.

  *   **Implementation Example:**
    ```typescript
    import * as vscode from 'vscode';
    import { QdrantService } from '../db/qdrantService';
    import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
    import { OllamaProvider } from '../embeddings/ollamaProvider'; // Default or configurable provider
    import { CodeChunk } from '../parsing/chunker'; // Assuming CodeChunk interface is available

    export class ContextService {
        private qdrantService: QdrantService;
        private embeddingProvider: IEmbeddingProvider;
        private collectionName: string; // Qdrant collection name, typically workspace-specific

        constructor(workspaceRoot: string) {
            this.qdrantService = new QdrantService();
            this.embeddingProvider = new OllamaProvider(); // TODO: Make this configurable via settings
            this.collectionName = vscode.workspace.name || 'default_collection'; // Use workspace name as collection
        }

        /**
         * Retrieves the content of a specific file based on a query.
         * In a real scenario, this would involve vector search to find the most relevant file.
         * For now, it directly reads the file if the path is exact.
         */
        public async getFileContent(filePath: string): Promise<string | null> {
            try {
                const uri = vscode.Uri.file(filePath);
                const contentBuffer = await vscode.workspace.fs.readFile(uri);
                return contentBuffer.toString();
            } catch (error) {
                vscode.window.showErrorMessage(`Error reading file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
                console.error(`Error reading file ${filePath}:`, error);
                return null;
            }
        }

        /**
         * Finds files related to a given concept or file path using vector similarity search.
         */
        public async findRelatedFiles(query: string, limit: number = 5): Promise<string[]> {
            try {
                // 1. Generate embedding for the query
                const queryEmbedding = (await this.embeddingProvider.generateEmbeddings([query]))[0];
                if (!queryEmbedding) {
                    vscode.window.showWarningMessage("Could not generate embedding for the query.");
                    return [];
                }

                // 2. Perform similarity search in Qdrant
                const searchResult = await this.qdrantService.search(this.collectionName, queryEmbedding, limit);

                // 3. Extract unique file paths from the search results
                const relatedFilePaths = new Set<string>();
                for (const hit of searchResult) {
                    if (hit.payload && hit.payload.filePath) {
                        relatedFilePaths.add(hit.payload.filePath as string);
                    }
                }
                return Array.from(relatedFilePaths);

            } catch (error) {
                vscode.window.showErrorMessage(`Error finding related files: ${error instanceof Error ? error.message : String(error)}`);
                console.error("Error in findRelatedFiles:", error);
                return [];
            }
        }
    }
    ```

**2. Implement `getFileContent` and `findRelatedFiles`**

These methods are the core of your context API. `getFileContent` will directly read from the file system (or eventually use vector search to resolve a path), while `findRelatedFiles` will leverage your embedding provider and Qdrant.

  *   **File:** `src/context/contextService.ts`
  *   **API Information:**
      *   `vscode.workspace.fs.readFile()`: VS Code API for reading file content.
      *   `this.embeddingProvider.generateEmbeddings()`: Your custom method from Sub-Sprint 3 to get vector representations of text.
      *   `this.qdrantService.search()`: Your custom method from Sub-Sprint 3 to query the Qdrant database.

  *   **Implementation:** (See `ContextService` example above. Ensure `QdrantService` has a `search` method and `IEmbeddingProvider` has `generateEmbeddings`.)

**3. Expose via Message Passing in `extension.ts`**

Your `extension.ts` will act as the bridge between the webview (frontend) and your backend `ContextService`. It will listen for messages from the webview, call the appropriate `ContextService` method, and send the results back.

  *   **File:** `src/extension.ts`
  *   **Key Concepts:**
      *   `panel.webview.onDidReceiveMessage()`: Event listener for messages from the webview.
      *   `panel.webview.postMessage()`: Sends messages back to the webview.
      *   **Message Structure:** Define a clear message structure (e.g., `{ command: string, payload: any }`) for both incoming and outgoing messages.

  *   **Implementation Example (within `activate` function, after `panel` creation):**
    ```typescript
    // Assuming `currentPanel` is your WebviewPanel instance
    const contextService = new ContextService(vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '');

    currentPanel.webview.onDidReceiveMessage(
        async message => {
            switch (message.command) {
                case 'getFileContent':
                    const fileContent = await contextService.getFileContent(message.filePath);
                    currentPanel?.webview.postMessage({ command: 'fileContentResult', content: fileContent });
                    return;
                case 'findRelatedFiles':
                    const relatedFiles = await contextService.findRelatedFiles(message.query);
                    currentPanel?.webview.postMessage({ command: 'relatedFilesResult', files: relatedFiles });
                    return;
                // Add other commands as needed
            }
        },
        undefined,
        context.subscriptions
    );
    ```

**4. Create Frontend API Client (`webview/src/lib/vscodeApi.ts`)**

To simplify communication from the SvelteKit frontend, create a small wrapper that abstracts the `acquireVsCodeApi()` and message posting/listening.

  *   **File:** `webview/src/lib/vscodeApi.ts` (New File)
  *   **Key Concepts:**
      *   `acquireVsCodeApi()`: Global function provided by VS Code to webviews to get a reference to the VS Code API.
      *   `vscode.postMessage()`: Sends a message from the webview to the extension.
      *   `window.addEventListener('message', ...)`: Listens for messages sent from the extension to the webview.

  *   **Implementation Example:**
    ```typescript
    // webview/src/lib/vscodeApi.ts
    declare const acquireVsCodeApi: any; // Declare to avoid TypeScript errors
    const vscode = acquireVsCodeApi();

    /**
     * Sends a message from the webview to the VS Code extension backend.
     * @param message The message payload.
     */
    export function postMessage(message: any) {
        vscode.postMessage(message);
    }

    /**
     * Registers a callback to listen for messages from the VS Code extension backend.
     * @param callback The function to call when a message is received.
     */
    export function onMessage(callback: (message: any) => void) {
        window.addEventListener('message', event => {
            callback(event.data);
        });
    }
    ```

**5. Integrate Frontend with API Client**

Modify your Svelte components to use the `vscodeApi.ts` client to send requests and handle responses.

  *   **File:** `webview/src/routes/+page.svelte` (or other relevant Svelte components)
  *   **Key Concepts:**
      *   `onMount`: Svelte lifecycle hook to run code when the component is first mounted.
      *   Reactive variables: Svelte's way of updating the UI when data changes.

  *   **Implementation Example (simplified):**
    ```html
    <script lang="ts">
      import { onMount } from 'svelte';
      import { postMessage, onMessage } from '../lib/vscodeApi';

      let fileContent: string | null = null;
      let relatedFiles: string[] = [];
      let queryInput: string = '';
      let filePathInput: string = '';

      onMount(() => {
        onMessage(message => {
          switch (message.command) {
            case 'fileContentResult':
              fileContent = message.content;
              if (fileContent === null) {
                alert("File not found or could not be read.");
              }
              break;
            case 'relatedFilesResult':
              relatedFiles = message.files;
              if (relatedFiles.length === 0) {
                alert("No related files found.");
              }
              break;
            // Handle other message types
          }
        });
      });

      function handleGetFileContent() {
        if (filePathInput) {
          postMessage({ command: 'getFileContent', filePath: filePathInput });
        }
      }

      function handleFindRelatedFiles() {
        if (queryInput) {
          postMessage({ command: 'findRelatedFiles', query: queryInput });
        }
      }
    </script>

    <main>
      <h1>Context Query API Demo</h1>

      <h2>Get File Content</h2>
      <input type="text" bind:value={filePathInput} placeholder="Enter file path (e.g., /src/extension.ts)" style="width: 300px;" />
      <button on:click={handleGetFileContent}>Get Content</button>
      {#if fileContent !== null}
        <h3>File Content:</h3>
        <pre style="white-space: pre-wrap; word-break: break-all; max-height: 300px; overflow-y: auto; background-color: var(--vscode-editor-background); color: var(--vscode-editor-foreground); padding: 10px; border: 1px solid var(--vscode-editorWidget-border);">{fileContent}</pre>
      {/if}

      <h2>Find Related Files</h2>
      <input type="text" bind:value={queryInput} placeholder="Enter concept or file path (e.g., authentication logic)" style="width: 300px;" />
      <button on:click={handleFindRelatedFiles}>Find Related</button>
      {#if relatedFiles.length > 0}
        <h3>Related Files:</h3>
        <ul>
          {#each relatedFiles as file}
            <li>{file}</li>
          {/each}
        </ul>
      {/if}
    </main>

    <style>
      /* Add basic styling for inputs and buttons to match VS Code theme */
      input[type="text"] {
        background-color: var(--vscode-input-background);
        color: var(--vscode-input-foreground);
        border: 1px solid var(--vscode-input-border);
        padding: 5px;
        margin-right: 10px;
      }
      button {
        background-color: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
        border: none;
        padding: 8px 12px;
        cursor: pointer;
      }
      button:hover {
        background-color: var(--vscode-button-hoverBackground);
      }
    </style>
    ```

This completes the implementation guide for Sub-Sprint 5. You now have a functional backend API for querying code context and a frontend capable of interacting with it.
</file>

<file path="docs/todo/setup/implementation_sub_sprint_6_develop_settings_ui.md">
### Implementation Guide: Sub-Sprint 6 - Develop Settings UI

**Objective:** To create the user-facing settings panel where users can configure the extension's behavior.

#### **Analysis**

This sub-sprint focuses on providing a user-friendly interface for configuring the extension. It involves extending the `package.json` to declare new configuration properties and a command to open the settings UI. The settings UI itself will be a SvelteKit webview, leveraging Fluent UI components for a consistent look and feel. Crucially, the UI will interact with the VS Code configuration API to read and write settings, ensuring persistence and proper application of user preferences across the extension's backend services.

#### **Prerequisites and Setup**

1.  **Sub-Sprint 2 Completion:** A working SvelteKit webview integrated into the VS Code extension.
2.  **Sub-Sprint 5 Completion:** The backend services are in place, which will eventually consume these settings.
3.  **Fluent UI Web Components:** Ensure `@fluentui/web-components` is installed in your `webview` project.

#### **Implementation Guide**

Here's a step-by-step guide to developing the Settings UI:

**1. Register Settings Command in `package.json`**

First, define a new command that users can execute from the VS Code Command Palette to open your settings UI.

  *   **File:** `package.json`
  *   **Key Concept:** The `contributes.commands` section in `package.json` is used to declare commands that your extension provides.

  *   **Implementation Example (add to `contributes.commands` array):**
    ```json
    {
        "command": "code-context-engine.openSettings",
        "title": "Code Context Engine: Open Settings",
        "category": "Code Context Engine"
    }
    ```

**2. Create and Show Settings Webview in `extension.ts`**

Implement the logic in your main extension file (`extension.ts`) to handle the `openSettings` command. This will involve creating a new `WebviewPanel` specifically for your settings UI.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.commands.registerCommand()`: To link your declared command to a function.
      *   `vscode.window.createWebviewPanel()`: To create the webview instance.
      *   `panel.webview.html`: To load the SvelteKit app into the webview.
      *   `path.join()` and `vscode.Uri.file()`: For constructing correct paths to your SvelteKit build output.

  *   **Implementation Example (within `activate` function):**
    ```typescript
    import * as vscode from 'vscode';
    import * as path from 'path';
    import * as fs from 'fs';

    // ... (existing code for main panel, if any)

    let settingsPanel: vscode.WebviewPanel | undefined; // Declare a variable to hold the settings panel instance

    context.subscriptions.push(
        vscode.commands.registerCommand('code-context-engine.openSettings', () => {
            const columnToShowIn = vscode.window.activeTextEditor
                ? vscode.window.activeTextEditor.viewColumn
                : undefined;

            if (settingsPanel) {
                settingsPanel.reveal(columnToShowIn); // If panel already exists, just reveal it
            } else {
                // Create a new webview panel
                settingsPanel = vscode.window.createWebviewPanel(
                    'codeContextEngineSettings', // Unique ID
                    'Code Context Engine Settings', // Title
                    columnToShowIn || vscode.ViewColumn.One, // Column to show in
                    {
                        enableScripts: true,
                        localResourceRoots: [
                            vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                        ]
                    }
                );

                // Get path to SvelteKit's built index.html
                const svelteAppPath = vscode.Uri.file(
                    path.join(context.extensionPath, 'webview', 'dist', 'index.html')
                );

                // Read and set the HTML content
                let htmlContent = fs.readFileSync(svelteAppPath.fsPath, 'utf8');
                // Important: Adjust paths for webview to load SvelteKit assets correctly
                htmlContent = htmlContent.replace(/\/\_app\//g, settingsPanel.webview.asWebviewUri(vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist', '_app'))).toString() + '/');

                settingsPanel.webview.html = htmlContent;

                // Handle panel disposal (e.g., when user closes it)
                settingsPanel.onDidDispose(
                    () => {
                        settingsPanel = undefined;
                    },
                    null,
                    context.subscriptions
                );
            }
        })
    );
    ```

**3. Build Svelte UI for Settings**

Create a new Svelte component (e.g., `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte`) that will serve as your settings page. Use Fluent UI components for input fields.

  *   **File:** `webview/src/routes/settings/+page.svelte` (or similar)
  *   **API Information:**
      *   `@fluentui/web-components`: Provides `<fluent-select>`, `<fluent-option>`, `<fluent-text-field>`, `<fluent-button>`.
      *   `bind:value`: Svelte directive for two-way data binding with input elements.
      *   `onMount`: Svelte lifecycle hook to run code after the component is first rendered.
      *   `postMessage`, `onMessage` (from `vscodeApi.ts`): For communication with the extension backend.

  *   **Implementation Example:**
    ```html
    <script lang="ts">
      import { provideFluentDesignSystem, fluentSelect, fluentOption, fluentTextField, fluentButton } from "@fluentui/web-components";
      import { onMount } from 'svelte';
      import { postMessage, onMessage } from '../../lib/vscodeApi'; // Adjust path as needed

      // Register Fluent UI components
      provideFluentDesignSystem().register(
        fluentSelect(),
        fluentOption(),
        fluentTextField(),
        fluentButton()
      );

      let embeddingProvider: string = 'Ollama'; // Default value, will be overwritten by loaded settings
      let databaseConnectionString: string = '';

      onMount(() => {
        // Request current settings from extension backend on component mount
        postMessage({ command: 'getSettings' });

        // Listen for settings data from the extension backend
        onMessage(message => {
          if (message.command === 'settingsResult') {
            embeddingProvider = message.settings.embeddingProvider || 'Ollama';
            databaseConnectionString = message.settings.databaseConnectionString || '';
          }
        });
      });

      function saveSettings() {
        const settings = {
          embeddingProvider,
          databaseConnectionString,
        };
        // Send updated settings to the extension backend to be saved
        postMessage({ command: 'saveSettings', settings });
      }
    </script>

    <main>
      <h1>Extension Settings</h1>

      <fluent-text-field
        appearance="outline"
        placeholder="Database Connection String"
        bind:value={databaseConnectionString}
        style="width: 100%; margin-bottom: 15px;"
      >
        Database Connection String
      </fluent-text-field>

      <fluent-select
        appearance="outline"
        bind:value={embeddingProvider}
        style="width: 100%; margin-bottom: 20px;"
      >
        <fluent-option value="Ollama">Ollama</fluent-option>
        <fluent-option value="OpenAI">OpenAI</fluent-option>
        <!-- Add more options as needed -->
      </fluent-select>

      <fluent-button appearance="accent" @click={saveSettings}>Save Settings</fluent-button>
    </main>

    <style>
      /* Basic styling for the page and Fluent UI components to match VS Code theme */
      main {
        padding: 20px;
        font-family: var(--vscode-font-family);
        color: var(--vscode-editor-foreground);
      }
      h1 {
        color: var(--vscode-editor-foreground);
      }
      fluent-text-field,
      fluent-select {
        --neutral-fill-rest: var(--vscode-input-background);
        --neutral-foreground-rest: var(--vscode-input-foreground);
        --neutral-stroke-rest: var(--vscode-input-border);
        --neutral-fill-stealth-rest: var(--vscode-input-background);
        --neutral-fill-stealth-hover: var(--vscode-input-background);
        --neutral-fill-stealth-active: var(--vscode-input-background);
        --neutral-foreground-hover: var(--vscode-input-foreground);
        --neutral-foreground-active: var(--vscode-input-foreground);
        --neutral-stroke-hover: var(--vscode-input-border);
        --neutral-stroke-active: var(--vscode-input-border);
      }
      fluent-button {
        --accent-fill-rest: var(--vscode-button-background);
        --accent-foreground-rest: var(--vscode-button-foreground);
        --accent-fill-hover: var(--vscode-button-hoverBackground);
      }
    </style>
    ```

**4. Implement State Management and VS Code Configuration Interaction**

This is the core of saving and loading settings. You'll use VS Code's `workspace.getConfiguration()` API.

  *   **File:** `src/extension.ts`
  *   **API Information:**
      *   `vscode.workspace.getConfiguration('your-extension-id')`: Gets a configuration object for your extension.
      *   `config.get<T>(key, defaultValue)`: Reads a setting.
      *   `config.update(key, value, target)`: Writes a setting. `target` can be `vscode.ConfigurationTarget.Global`, `Workspace`, or `WorkspaceFolder`.
      *   `panel.webview.postMessage()` and `panel.webview.onDidReceiveMessage()`: For communication between extension and webview.

  *   **Implementation Example (within `extension.ts` `onDidReceiveMessage` handler for `settingsPanel`):**
    ```typescript
    // ... (inside settingsPanel.webview.onDidReceiveMessage)
    switch (message.command) {
        case 'getSettings':
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const currentSettings = {
                embeddingProvider: config.get<string>('embeddingProvider', 'Ollama'),
                databaseConnectionString: config.get<string>('databaseConnectionString', 'http://localhost:6333'),
            };
            settingsPanel?.webview.postMessage({ command: 'settingsResult', settings: currentSettings });
            return;

        case 'saveSettings':
            const newSettings = message.settings;
            const configToUpdate = vscode.workspace.getConfiguration('code-context-engine');
            
            // Update settings. Use Global target for user-level settings, or Workspace for workspace-specific
            await configToUpdate.update('embeddingProvider', newSettings.embeddingProvider, vscode.ConfigurationTarget.Global);
            await configToUpdate.update('databaseConnectionString', newSettings.databaseConnectionString, vscode.ConfigurationTarget.Global);
            
            vscode.window.showInformationMessage('Code Context Engine settings saved!');
            return;
    }
    ```

**5. Define Configuration Schema in `package.json`**

To make your settings discoverable and provide type-checking and descriptions in VS Code's built-in settings UI, you must define them in `package.json`.

  *   **File:** `package.json`
  *   **Key Concept:** The `contributes.configuration` section defines the properties for your extension's settings.

  *   **Implementation Example (add to `contributes` section):**
    ```json
    "configuration": {
        "title": "Code Context Engine Configuration",
        "properties": {
            "code-context-engine.embeddingProvider": {
                "type": "string",
                "enum": ["Ollama", "OpenAI"],
                "default": "Ollama",
                "description": "Select the embedding provider to use for generating code embeddings."
            },
            "code-context-engine.databaseConnectionString": {
                "type": "string",
                "default": "http://localhost:6333",
                "description": "The connection string for the Qdrant vector database."
            }
        }
    }
    ```

**6. Refactor Services to Use Configuration**

Finally, ensure your `IndexingService` and `QdrantService` (and any other services that need configuration) read their values from the VS Code configuration instead of hardcoded defaults.

  *   **File:** `src/indexing/indexingService.ts`, `src/db/qdrantService.ts`
  *   **API Information:** `vscode.workspace.getConfiguration('your-extension-id').get<T>(key, defaultValue)`.

  *   **Implementation Example (`src/indexing/indexingService.ts` constructor):**
    ```typescript
    import * as vscode from 'vscode';
    // ... other imports

    export class IndexingService {
        // ... other properties
        private embeddingProvider: IEmbeddingProvider;

        constructor(private workspaceRoot: string) {
            // ...
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const providerName = config.get<string>('embeddingProvider', 'Ollama');

            if (providerName === 'OpenAI') {
                this.embeddingProvider = new OpenAIProvider(); // Assuming OpenAIProvider exists
            } else {
                this.embeddingProvider = new OllamaProvider(); // Assuming OllamaProvider exists
            }
        }
        // ...
    }
    ```

  *   **Implementation Example (`src/db/qdrantService.ts` constructor):**
    ```typescript
    import { QdrantClient } from '@qdrant/js-client-rest';
    import * as vscode from 'vscode';

    export class QdrantService {
        private client: QdrantClient;

        constructor() {
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const connectionString = config.get<string>('databaseConnectionString', 'http://localhost:6333');
            this.client = new QdrantClient({ url: connectionString });
        }
        // ...
    }
    ```

This completes the implementation guide for Sub-Sprint 6. You now have a fully functional settings UI that allows users to configure your extension, with those settings being correctly consumed by your backend services.
</file>

<file path="docs/todo/setup/prd.md">
<prd>Of course. I've analyzed the roadmap and will now generate the detailed Product Requirements Documents (PRDs) for each phase of the VS Code extension project.

Here is the first PRD, which covers the foundational setup of the extension.

-----

### **New Document: PRD 1: Foundational - Extension Boilerplate & UI Setup**

**1. Title & Overview**

  * **Project:** Code Context Engine - VS Code Extension
  * **Summary:** This phase establishes the core technical foundation for the VS Code extension. It includes setting up the project with the chosen technology stack (SvelteKit and TypeScript), creating the basic user interface using Microsoft's Fluent UI, and ensuring the basic extension can be loaded and run within a VS Code development environment.
  * **Dependencies:** Requires Node.js, npm/yarn, and the VS Code Extension Development Kit.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Rapidly create a tangible, runnable prototype to validate the chosen technology stack.
      * Establish a solid foundation for the user interface that can be easily extended in future phases.
  * **Developer & System Success Metrics:**
      * The VS Code extension can be successfully compiled, loaded, and activated in a development host.
      * The main SvelteKit-based UI panel renders correctly within VS Code.
      * Core UI components (buttons, progress bars) from the Fluent UI library are successfully integrated and functional.
      * The project structure is well-organized, with clear separation between the extension's backend (TypeScript) and frontend (SvelteKit) concerns.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin works on large, complex codebases and needs a tool to help him quickly understand code context. He expects a clean, intuitive, and responsive user interface that feels native to the VS Code environment.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Foundation** | **Sprint 1: Boilerplate & UI Scaffolding** | As a developer, I want a VS Code extension project set up with SvelteKit for the UI and TypeScript for the backend logic, so we have a standard, modern technology stack. | 1. A new VS Code extension project is generated using the official templates.\<br\>2. SvelteKit is successfully integrated as the webview provider for the extension's UI.\<br\>3. TypeScript is configured for both the extension's main process (backend) and the SvelteKit frontend.\<br\>4. The project can be compiled and run without errors. | **2 Weeks** |
| | | As Devin, I want to see a main panel for the extension with a clear "Index Now" button, so I know how to start the core process. | 1. The extension contributes a new view/panel to the VS Code UI.\<br\>2. This panel renders a SvelteKit component.\<br\>3. The component displays a prominent button with the text "Index Now" using a Fluent UI `Button` component.\<br\>4. A placeholder for a progress bar is visible on the UI. | |
| | | As a developer, I want to integrate Microsoft's Fluent UI library into the SvelteKit project, so we can build a consistent and professional-looking UI quickly. | 1. The Fluent UI Svelte library is added as a project dependency.\<br\>2. A sample Fluent UI component (e.g., a button or card) is successfully rendered within the extension's webview.\<br\>3. The styling of the Fluent UI components matches the user's current VS Code theme (light/dark). | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 1:** Boilerplate & UI Scaffolding (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** SvelteKit can be integrated smoothly as a webview UI for a VS Code extension without significant compatibility issues.
  * **Risk:** Integrating Fluent UI with SvelteKit might have unforeseen styling conflicts or component incompatibilities.
      * **Mitigation:** Dedicate early time in the sprint to create a small proof-of-concept integrating a few key Fluent UI components to identify and resolve any issues.
  * **Risk:** The initial project setup and build configuration for a hybrid TypeScript/SvelteKit extension might be more complex than anticipated.
      * **Mitigation:** Allocate sufficient time for research and follow best practices from official documentation and community examples.

-----

### **New Document: Sub-Sprint 1: VS Code Extension Boilerplate Setup**

**Objective:**
To create the fundamental file structure and configuration for a new VS Code extension using TypeScript.

**Parent Sprint:**
PRD 1, Sprint 1: Boilerplate & UI Scaffolding

**Tasks:**

1.  **Generate Extension:** Use `yo code` to generate a new TypeScript-based VS Code extension.
2.  **Configure `package.json`:** Define the extension's name, publisher, and activation events.
3.  **Establish Project Structure:** Create separate directories for the `extension` (backend) and `webview` (frontend) source code.
4.  **Initial Backend Logic:** Write the initial `extension.ts` file, including the `activate` and `deactivate` functions.

**Acceptance Criteria:**

  * The extension can be launched in a VS Code development host.
  * A "Hello World" command from the extension can be successfully executed from the command palette.
  * The project structure is clean and logically separated.

**Dependencies:**

  * Node.js and `yo code` generator installed.

**Timeline:**

  * **Start Date:** 2025-10-27
  * **End Date:** 2025-10-31

-----

### **New Document: Sub-Sprint 2: SvelteKit and Fluent UI Integration**

**Objective:**
To set up the SvelteKit frontend and integrate the Fluent UI component library, creating the initial user interface.

**Parent Sprint:**
PRD 1, Sprint 1: Boilerplate & UI Scaffolding

**Tasks:**

1.  **Initialize SvelteKit:** Set up a new SvelteKit project within the `webview` directory.
2.  **Configure Webview:** In `extension.ts`, create the logic to render the SvelteKit app inside a VS Code webview panel.
3.  **Install Fluent UI:** Add the Fluent UI Svelte library as a dependency to the SvelteKit project.
4.  **Implement UI:** Create a Svelte component for the main panel that includes an "Index Now" button and a progress bar from the Fluent UI library.
5.  **Theme Integration:** Ensure the UI components automatically adapt to VS Code's light and dark themes.

**Acceptance Criteria:**

  * The SvelteKit application renders correctly inside the VS Code extension panel.
  * The "Index Now" button is visible and interactive.
  * UI components correctly reflect the active VS Code theme.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2025-11-03
  * **End Date:** 2025-11-07

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Boilerplate & UI Scaffolding

**Goal:** To establish the project's foundation by setting up the VS Code extension with a SvelteKit frontend and Fluent UI.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Generate VS Code Extension:** Run `npx yo code` and select "New Extension (TypeScript)". | `(Project Root)` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** In a new `webview` directory, run `npm create svelte@latest .` and configure it for a single-page app. | `webview/` |
| **1.3** |  To Do | **Install Dependencies:** Add `svelte-fluent-ui` to the `webview`'s `package.json` and install. | `webview/package.json` |
| **1.4** |  To Do | **Create Webview Panel Logic:** In `extension.ts`, write the TypeScript code to create and manage a `WebviewPanel`. | `src/extension.ts` |
| **1.5** |  To Do | **Load Svelte App in Webview:** Configure the webview to load the compiled `index.html` from the SvelteKit `build` directory. | `src/extension.ts` |
| **1.6** |  To Do | **Build Main UI Component:** Create a `MainPanel.svelte` component displaying a `<Button>` and `<ProgressBar>` from Fluent UI. | `webview/src/lib/MainPanel.svelte` |
| **1.7** |  To Do | **Implement Theme Handling:** Use VS Code theme CSS variables to ensure Fluent UI components adapt to light/dark modes. | `webview/src/app.html` |
| **1.8** |  To Do | **Test Extension:** Run the extension in a development host to verify the UI panel opens and displays the SvelteKit app correctly. | `(Launch Configuration)` |

Of course. Here are the final PRDs and task lists to complete the project plan for your VS Code extension.

-----

### **New Document: PRD 3: Context Engine API & Feature Enhancement**

**1. Title & Overview**

  * **Project:** Code Context Engine - API & Settings
  * **Summary:** This phase focuses on exposing the indexed data through an internal API and building the user-facing settings UI. This will enable the core functionality of the extensionquerying the codebase for contextand allow users to configure the extension to their specific needs, such as changing the database connection or selecting a different embedding provider.
  * **Dependencies:** PRD 2 must be complete. The codebase must be successfully indexed and stored in a Qdrant instance.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Deliver the primary value proposition of the extension by allowing users to query their code contextually.
      * Increase user retention and satisfaction by providing customization options.
  * **Developer & System Success Metrics:**
      * The internal API successfully handles queries like "list files related to X" and "get content of Y" by performing a vector search.
      * API response times for typical queries are under 500ms.
      * The settings UI correctly reads from and writes to the VS Code workspace configuration.
      * Changing a setting (e.g., the embedding provider) is correctly reflected in the indexing service on the next run.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin wants to ask his codebase questions in plain English. He needs to be able to ask for the content of a specific file or find other files related to the one he's working on to speed up his development workflow. He also wants to easily configure the extension to use his preferred embedding model.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 3: API & Settings** | **Sprint 4: Context Query API** | As Devin, I want to be able to ask the extension to retrieve the content of a specific file so I can view it without having to manually search for it. | 1. An internal API endpoint is created to handle "get file content" requests.\<br/\>2. The API performs a search in the vector index to find the most likely file matching the query.\<br/\>3. The full, up-to-date content of the identified file is returned. | **2 Weeks** |
| | | As Devin, I want to ask for a list of files related to a specific file or concept so I can understand the connections within my codebase. | 1. An internal API endpoint is created for "find related files" requests.\<br/\>2. The API vectorizes the input query and performs a similarity search in Qdrant.\<br/\>3. A ranked list of the top 5 most relevant file paths is returned based on the search results. | |
| **Phase 3: API & Settings** | **Sprint 5: Settings UI & Configuration** | As Devin, I want a dedicated settings page for the extension so I can configure the database and embedding provider for each of my projects. | 1. A new webview panel is created for the extension's settings.\<br/\>2. The UI includes a dropdown to select an embedding provider (Ollama, OpenAI, etc.).\<br/\>3. The UI includes a text input for the database connection string.\<br/\>4. The settings are saved to the workspace's `settings.json` file under a unique extension-specific key. | **2 Weeks** |
| | | As a developer, I want the extension's backend services to read their configuration from the workspace settings so that user changes are applied correctly. | 1. The `IndexingService` reads the selected embedding provider from the VS Code workspace configuration.\<br/\>2. The `QdrantService` reads the database connection string from the configuration.\<br/\>3. The extension gracefully handles missing or invalid configuration values by falling back to sensible defaults. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 4:** Context Query API (2 Weeks)
  * **Sprint 5:** Settings UI & Configuration (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** Simple vector similarity search will be sufficient to find "related" files accurately for the initial version.
  * **Risk:** The quality of search results might be poor if the user's query is ambiguous, leading to user frustration.
      * **Mitigation:** For the initial version, focus on clear query patterns. In a future phase, introduce an LLM to refine user queries before they are sent to the vector search.
  * **Risk:** Securely storing and handling user-provided secrets (like an OpenAI API key) is critical.
      * **Mitigation:** Use VS Code's official `SecretStorage` API for any sensitive information instead of storing it in plain text in the settings file.

-----

### **New Document: Sub-Sprint 5: Implement Context Query API**

**Objective:**
To build the internal backend API that will allow the frontend to query the indexed codebase.

**Parent Sprint:**
PRD 3, Sprint 4: Context Query API

**Tasks:**

1.  **Create `ContextService`:** Develop a new service in the TypeScript backend to orchestrate context retrieval.
2.  **Implement `getFileContent`:** Create a method that takes a file path query, uses the embedding provider and Qdrant client to find the best match, and then reads the file content from the disk.
3.  **Implement `findRelatedFiles`:** Create a method that takes a concept or file path, generates an embedding for it, and performs a vector similarity search in Qdrant to find the top N most similar file chunks.
4.  **Expose via Message Passing:** Use the standard VS Code webview message passing interface to allow the SvelteKit frontend to call these backend service methods.

**Acceptance Criteria:**

  * Sending a "getFileContent" message from the webview returns the correct file's content.
  * Sending a "findRelatedFiles" message returns an array of relevant file paths.
  * The API handles cases where no relevant files are found gracefully.

**Dependencies:**

  * PRD 2 must be complete.

**Timeline:**

  * **Start Date:** 2025-11-24
  * **End Date:** 2025-11-28

-----

### **New Document: Sub-Sprint 6: Develop Settings UI**

**Objective:**
To create the user-facing settings panel where users can configure the extension's behavior.

**Parent Sprint:**
PRD 3, Sprint 5: Settings UI & Configuration

**Tasks:**

1.  **Register Settings Command:** Add a new command to `package.json` that will open the settings webview.
2.  **Create Settings Webview:** Develop the TypeScript logic in `extension.ts` to create and show a new webview panel for settings.
3.  **Build Svelte UI:** Create a `Settings.svelte` component using Fluent UI components (`<Select>`, `<TextField>`) for the provider and database configuration.
4.  **Implement State Management:** The Svelte component should read the current configuration from VS Code settings on load and use message passing to send updated values back to the extension backend to be saved.

**Acceptance Criteria:**

  * A new command in the command palette successfully opens the settings UI.
  * The UI correctly displays the currently saved settings.
  * Changing a value in the UI and clicking "Save" correctly updates the workspace `settings.json` file.

**Dependencies:**

  * Sub-Sprint 5 must be complete.

**Timeline:**

  * **Start Date:** 2025-12-01
  * **End Date:** 2025-12-05

-----

### **New Document: tasklist\_sprint\_04.md**

# Task List: Sprint 4 - Context Query API

**Goal:** To build and expose the internal API for querying the indexed code context.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `ContextService`:** In the backend, create a new `contextService.ts` file to house the query logic. | `src/context/contextService.ts` |
| **4.2** |  To Do | **Implement `getFileContent` method:** Add logic to perform a vector search for the file path and then read the content from disk using `vscode.workspace.fs`. | `src/context/contextService.ts` |
| **4.3** |  To Do | **Implement `findRelatedFiles` method:** Add logic to perform a similarity search in Qdrant and return a list of unique file paths from the results. | `src/context/contextService.ts` |
| **4.4** |  To Do | **Set up Webview Message Handling:** In `extension.ts`, add a `message` listener to the webview panel to handle incoming requests from the frontend. | `src/extension.ts` |
| **4.5** |  To Do | **Route API Calls:** In the message handler, create a `switch` statement to route requests (e.g., `'getFileContent'`) to the appropriate method in `ContextService`. | `src/extension.ts` |
| **4.6** |  To Do | **Send Results to Frontend:** Use the `webview.postMessage` method to send the results from the service back to the SvelteKit UI. | `src/extension.ts` |
| **4.7** |  To Do | **Create Frontend API Client:** In the SvelteKit app, create a wrapper service (`vscodeApi.ts`) that simplifies posting and listening for messages from the extension backend. | `webview/src/lib/vscodeApi.ts` |

-----

### **New Document: tasklist\_sprint\_05.md**

# Task List: Sprint 5 - Settings UI & Configuration

**Goal:** To build the settings UI and connect it to the VS Code configuration system.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** |  To Do | **Define Configuration Schema:** In `package.json`, under the `contributes.configuration` section, define the properties for the settings (e.g., `code-context.embeddingProvider`). | `package.json` |
| **5.2** |  To Do | **Register `openSettings` command:** In `package.json`, add a new command to the `contributes.commands` section. | `package.json` |
| **5.3** |  To Do | **Implement command in `extension.ts`:** Register the command to create and show the settings webview panel. | `src/extension.ts` |
| **5.4** |  To Do | **Create `Settings.svelte` component:** Build the UI with a `<Select>` for providers and a `<TextField>` for the database URI. | `webview/src/routes/settings.svelte` |
| **5.5** |  To Do | **Load Initial Settings:** In the Svelte component, use the `vscodeApi` service to request the current configuration when the component mounts. | `webview/src/routes/settings.svelte` |
| **5.6** |  To Do | **Save Settings:** On button click, send a message with the updated settings object to the extension backend. | `webview/src/routes/settings.svelte` |
| **5.7** |  To Do | **Implement `saveConfiguration` handler:** In the backend message listener, handle the "saveSettings" message by calling `vscode.workspace.getConfiguration().update()`. | `src/extension.ts` |
| **5.8** |  To Do | **Refactor Services to Use Config:** Update `IndexingService` and `QdrantService` to read their settings from `vscode.workspace.getConfiguration()` instead of hardcoded values. | `src/indexing/indexingService.ts`, `src/db/qdrantService.ts` |

-----

### **New Document: PRD 4: Advanced Features & Polish**

**1. Title & Overview**

  * **Project:** Code Context Engine - Advanced Indexing & Publishing
  * **Summary:** This final phase focuses on enhancing the quality of the index by integrating data from the Language Server Protocol (LSP), establishing a professional release process with a CI/CD pipeline, and creating comprehensive documentation to support users and future contributors.
  * **Dependencies:** PRD 3 must be complete.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Gain a competitive advantage by creating a more intelligent and contextually-aware index than simple AST parsing can provide.
      * Ensure long-term project health and user trust through a reliable release process and clear documentation.
  * **Developer & System Success Metrics:**
      * The indexing process can successfully capture and store LSP data like "go to definition" and "find all references" links between code chunks.
      * A GitHub Actions workflow is created that automatically builds, lints, tests, and packages the extension on every push to the `main` branch.
      * The extension is successfully published to the Visual Studio Code Marketplace.
      * A `README.md` and contributing guide are created that meet open-source community standards.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 4: Polish** | **Sprint 6: LSP Integration & DevOps** | As Alisha, I want to enhance the index by capturing data from the Language Server Protocol (LSP) so that we can understand relationships between code. | 1. The extension can programmatically access the active LSP for supported languages.\<br/\>2. During indexing, the system queries the LSP for information like definitions and references for each code chunk.\<br/\>3. This relationship data is stored as metadata alongside the vectors in Qdrant. | **2 Weeks** |
| | | As Alisha, I want to create a CI/CD pipeline using GitHub Actions so that we can automate the build, test, and release process. | 1. A new GitHub Actions workflow file is created.\<br/\>2. The workflow is triggered on pushes and pull requests.\<br/\>3. The workflow includes stages for installing dependencies, linting, running unit tests, and building the extension package (`.vsix`). | |
| **Phase 4: Polish** | **Sprint 7: Documentation & Publishing** | As Devin, I want clear, comprehensive documentation for the extension so that I know how to install, configure, and use it effectively. | 1. The `README.md` file is updated with a feature list, installation instructions, and a guide on configuring the settings.\<br/\>2. An animated GIF is included in the README to demonstrate the core workflow.\<br/\>3. A `CONTRIBUTING.md` file is created with guidelines for new developers. | **2 Weeks** |
| | | As a project owner, I want to publish the extension to the VS Code Marketplace so that it is easily discoverable and accessible to all users. | 1. A publisher identity is created on the VS Code Marketplace.\<br/\>2. The GitHub Actions pipeline is updated with a manual "release" trigger.\<br/\>3. When triggered, the pipeline automatically packages and publishes the latest version of the extension to the marketplace. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 6:** LSP Integration & DevOps (2 Weeks)
  * **Sprint 7:** Documentation & Publishing (2 Weeks)

-----

### **New Document: tasklist\_sprint\_06.md**

# Task List: Sprint 6 - LSP Integration & DevOps

**Goal:** To enrich the index with LSP data and automate the build and test process.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** |  To Do | **Research LSP Interaction:** Investigate how to programmatically interact with a language server using the `vscode.lsp` API. | `(Documentation)` |
| **6.2** |  To Do | **Update `IndexingService` for LSP:** Modify the service to, for each chunk, invoke LSP commands like `vscode.executeDefinitionProvider` to find related symbols. | `src/indexing/indexingService.ts` |
| **6.3** |  To Do | **Extend Qdrant Metadata:** Update the `QdrantService` to store the new relationship metadata (e.g., `definesSymbol`, `referencesSymbol`) along with the vector. | `src/db/qdrantService.ts` |
| **6.4** |  To Do | **Create GitHub Actions Workflow:** Create a `.github/workflows/ci.yml` file. | `.github/workflows/ci.yml` |
| **6.5** |  To Do | **Add Linting and Testing Steps:** Add jobs to the workflow for running `eslint` and `vitest`. | `.github/workflows/ci.yml` |
| **6.6** |  To Do | **Add Build Step:** Add a job that runs `vsce package` to create the `.vsix` extension file and uploads it as a build artifact. | `.github/workflows/ci.yml` |

-----

### **New Document: tasklist\_sprint\_07.md**

# Task List: Sprint 7 - Documentation & Publishing

**Goal:** To create high-quality documentation and publish the extension to the marketplace.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **7.1** |  To Do | **Write `README.md` Content:** Draft the main sections: Features, Requirements, Installation, and Configuration. | `README.md` |
| **7.2** |  To Do | **Create Demo GIF:** Use screen recording software to capture the indexing and querying workflow and save it as an optimized GIF. | `assets/demo.gif` |
| **7.3** |  To Do | **Write `CONTRIBUTING.md`:** Create a guide for developers on how to set up the project, run tests, and submit pull requests. | `CONTRIBUTING.md` |
| **7.4** |  To Do | **Create Marketplace Publisher:** Register a new publisher ID in the Microsoft Partner Center. | `(External)` |
| **7.5** |  To Do | **Add Release Workflow:** Update the `ci.yml` file to include a manually triggered `release` job. | `.github/workflows/ci.yml` |
| **7.6** |  To Do | **Implement Publishing Step:** The `release` job should use `vsce publish` with a personal access token (stored as a GitHub secret) to upload the extension. | `.github/workflows/ci.yml` |
| **7.7** |  To Do | **Test the Release:** Manually trigger the release workflow for a `v1.0.0` tag and verify that the extension appears on the VS Code Marketplace. | `(External)` |

This completes the full set of PRDs and task lists for the Code Context Engine project. You now have a comprehensive, phased plan to guide you from the initial boilerplate to a published and feature-rich VS Code extension.

Of course. Here is a comprehensive guide to implementing Sprint 2: "AST Parser & Code Chunking" for your VS Code extension. This guide includes analysis, code examples, and API information based on the PRD and my research.

### **Analysis of `repomix-roocode.xml`**

The provided `repomix-roocode.xml` file confirms that the project is a standard SvelteKit application using TypeScript and Vitest for testing. The presence of `setup.ts` with JSDOM mocks indicates a robust testing environment. The project structure appears to be conventional, which makes integrating the new services straightforward. The key takeaway is that the new backend services should be written in TypeScript and can be unit-tested using the existing Vitest setup.

-----

### **Prerequisites and Setup**

Before you start coding, you'll need to add a few dependencies to your project for file parsing and AST manipulation.

**1. Install `tree-sitter` and Language Grammars:**

`tree-sitter` is a powerful parser generator tool. You'll need the core library and the specific grammar for each language you want to support.

```bash
npm install tree-sitter tree-sitter-typescript tree-sitter-python tree-sitter-c-sharp
```

**2. Install Helper Libraries:**

You'll also need a library to handle `.gitignore` files and another for efficient file system traversal.

```bash
npm install glob ignore
```

-----

### **Implementation Guide**

Here's a step-by-step guide to building the services outlined in `tasklist_sprint_02.md`.

#### **1. The `FileWalker` Service**

This service is responsible for finding all the files in the workspace that need to be indexed, while respecting the rules in `.gitignore`.

**API Information:**

  * **`vscode.workspace.fs`:** The official VS Code API for reading files and directories. It's asynchronous and designed to work with virtual file systems.
  * **`glob` package:** A library for matching files using patterns.
  * **`ignore` package:** A high-performance library for parsing `.gitignore` files.

**Code Example (`src/indexing/fileWalker.ts`):**

```typescript
import * as vscode from 'vscode';
import { glob } from 'glob';
import { promises as fs } from 'fs';
import path from 'path';
import ignore from 'ignore';

export class FileWalker {
    private ig = ignore();

    constructor(private workspaceRoot: string) {}

    private async loadGitignore(): Promise<void> {
        try {
            const gitignorePath = path.join(this.workspaceRoot, '.gitignore');
            const gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');
            this.ig.add(gitignoreContent);
        } catch (error) {
            console.log("No .gitignore file found or could not be read.");
        }
    }

    public async findAllFiles(): Promise<string[]> {
        await this.loadGitignore();
        const files = await glob('**/*.{ts,js,py,cs}', {
            cwd: this.workspaceRoot,
            nodir: true,
            absolute: true,
        });

        return files.filter(file => !this.ig.ignores(path.relative(this.workspaceRoot, file)));
    }
}
```

#### **2. The `AstParser` Service**

This service takes a file and its content, and using `tree-sitter`, parses it into an Abstract Syntax Tree (AST).

**API Information:**

  * **`tree-sitter` package:** The core library for parsing.
  * **Language-specific `tree-sitter` packages:** (e.g., `tree-sitter-typescript`) provide the grammars.

**Code Example (`src/parsing/astParser.ts`):**

```typescript
import Parser from 'tree-sitter';
import TypeScript from 'tree-sitter-typescript';
import Python from 'tree-sitter-python';
import CSharp from 'tree-sitter-c-sharp';

export class AstParser {
    private parser = new Parser();

    public parse(language: 'typescript' | 'python' | 'csharp', code: string): Parser.Tree {
        switch (language) {
            case 'typescript':
                this.parser.setLanguage(TypeScript.typescript);
                break;
            case 'python':
                this.parser.setLanguage(Python);
                break;
            case 'csharp':
                this.parser.setLanguage(CSharp);
                break;
        }
        return this.parser.parse(code);
    }
}
```

#### **3. The `Chunker` Service**

This service takes an AST and chunks the code into meaningful segments (e.g., functions, classes).

**API Information:**

  * **`tree-sitter` `Query` API:** This allows you to find specific nodes in the AST using a LISP-like query language.

**Code Example (`src/parsing/chunker.ts`):**

```typescript
import Parser from 'tree-sitter';

export interface CodeChunk {
    filePath: string;
    content: string;
    startLine: number;
    endLine: number;
    type: string;
}

export class Chunker {
    public chunk(filePath: string, tree: Parser.Tree, code: string): CodeChunk[] {
        const query = new Parser.Query(tree.getLanguage(), `
            (function_declaration) @function
            (class_declaration) @class
            (method_declaration) @method
        `);

        const matches = query.matches(tree.rootNode);
        const chunks: CodeChunk[] = [];

        for (const match of matches) {
            for (const capture of match.captures) {
                const node = capture.node;
                chunks.push({
                    filePath,
                    content: node.text,
                    startLine: node.startPosition.row,
                    endLine: node.endPosition.row,
                    type: capture.name,
                });
            }
        }
        return chunks;
    }
}
```

#### **4. The `IndexingService` (Orchestrator)**

This service brings everything together. It uses the `FileWalker` to get the files, the `AstParser` to parse them, and the `Chunker` to create the final code chunks.

**API Information:**

  * **`vscode.window.withProgress`:** A VS Code API for showing progress notifications to the user.

**Code Example (`src/indexing/indexingService.ts`):**

```typescript
import * as vscode from 'vscode';
import { FileWalker } from './fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker, CodeChunk } from '../parsing/chunker';

export class IndexingService {
    private fileWalker: FileWalker;
    private astParser = new AstParser();
    private chunker = new Chunker();

    constructor(private workspaceRoot: string) {
        this.fileWalker = new FileWalker(workspaceRoot);
    }

    public async startIndexing(): Promise<CodeChunk[]> {
        return vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Indexing Repository",
            cancellable: true
        }, async (progress, token) => {
            if (token.isCancellationRequested) {
                return [];
            }

            progress.report({ message: "Discovering files..." });
            const files = await this.fileWalker.findAllFiles();
            const totalFiles = files.length;
            let indexedFiles = 0;
            const allChunks: CodeChunk[] = [];

            for (const file of files) {
                if (token.isCancellationRequested) {
                    break;
                }

                indexedFiles++;
                progress.report({
                    message: `Parsing ${file}`,
                    increment: (1 / totalFiles) * 100
                });

                const content = await vscode.workspace.fs.readFile(vscode.Uri.file(file)).then(buffer => buffer.toString());
                const language = this.getLanguage(file);
                if (language) {
                    const tree = this.astParser.parse(language, content);
                    const chunks = this.chunker.chunk(file, tree, content);
                    allChunks.push(...chunks);
                }
            }

            return allChunks;
        });
    }

    private getLanguage(filePath: string): 'typescript' | 'python' | 'csharp' | null {
        if (filePath.endsWith('.ts') || filePath.endsWith('.js')) {
            return 'typescript';
        }
        if (filePath.endsWith('.py')) {
            return 'python';
        }
        if (filePath.endsWith('.cs')) {
            return 'csharp';
        }
        return null;
    }
}
```

### **Putting It All Together**

You would trigger the `IndexingService` from your main `extension.ts` file, likely when the user clicks the "Index Now" button you created in Sprint 1.

**Code Example (`src/extension.ts`):**

```typescript
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';

export function activate(context: vscode.ExtensionContext) {
    // ... other activation code

    let disposable = vscode.commands.registerCommand('your-extension.startIndexing', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            const workspaceRoot = workspaceFolders[0].uri.fsPath;
            const indexingService = new IndexingService(workspaceRoot);
            const chunks = await indexingService.startIndexing();
            console.log(`Indexing complete. Found ${chunks.length} chunks.`);
            // Here you would proceed to Sprint 3: Vectorization & DB Integration
        } else {
            vscode.window.showErrorMessage("Please open a folder or workspace to index.");
        }
    });

    context.subscriptions.push(disposable);
}
```

This guide provides the core implementation for Sprint 2. You now have a robust system for walking the file tree, parsing code with `tree-sitter`, and chunking it into meaningful segments. The next step will be to take these chunks and vectorize them for storage in Qdrant, as outlined in Sprint 3.

Of course. Here is the implementation guide for Sprint 3, which focuses on vectorizing the code chunks and storing them in the Qdrant database.

### **Analysis of `repomix-roocode.xml`**

The `repomix-roocode.xml` file shows a standard SvelteKit project setup. The key takeaway is that the project is well-structured, uses TypeScript, and has a testing framework in place. This means that the new services for vectorization and database interaction can be seamlessly integrated and tested within the existing architecture. The presence of a `setup.ts` file for tests also indicates that we can easily mock external services like Ollama, OpenAI, and the Qdrant client for robust unit testing.

-----

### **Prerequisites and Setup**

Before you begin, you need to set up the necessary tools and dependencies for this sprint.

**1. Install Docker:**

If you don't already have it, install **Docker Desktop** on your development machine. This is required to run the Qdrant vector database locally.

**2. Install Dependencies:**

You'll need the official Qdrant client and a library for making HTTP requests to Ollama or other embedding providers.

```bash
npm install @qdrant/js-client-rest axios
```

**3. Set up a `.env` file (Optional but Recommended):**

Create a `.env` file in the root of your project to store API keys and other secrets. Make sure to add `.env` to your `.gitignore` file.

```
OPENAI_API_KEY="your-openai-api-key"
```

-----

### **Implementation Guide**

Here's a step-by-step guide to building the services outlined in `tasklist_sprint_03.md`.

#### **1. Docker Compose for Qdrant**

Create a `docker-compose.yml` file in the root of your project. This will allow you to easily start and stop the Qdrant database.

**Code Example (`docker-compose.yml`):**

```yaml
version: '3.8'
services:
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - ./qdrant_storage:/qdrant/storage
```

You can now start Qdrant by running `docker-compose up` in your terminal.

#### **2. The `QdrantService`**

This service will handle all communication with the Qdrant database, including creating collections and upserting data.

**API Information:**

  * **`@qdrant/js-client-rest` package:** The official JavaScript/TypeScript client for Qdrant.
  * **Key methods:**
      * `QdrantClient`: The main class for interacting with the Qdrant API.
      * `client.getCollections()`: Lists all available collections.
      * `client.createCollection()`: Creates a new collection with a specified schema.
      * `client.upsert()`: Inserts or updates points (vectors and their payloads) in a collection.

**Code Example (`src/db/qdrantService.ts`):**

```typescript
import { QdrantClient } from '@qdrant/js-client-rest';
import type { CodeChunk } from '../parsing/chunker';

export class QdrantService {
    private client = new QdrantClient({ url: 'http://localhost:6333' });

    public async createCollectionIfNotExists(collectionName: string): Promise<void> {
        const collections = await this.client.getCollections();
        if (!collections.collections.find(c => c.name === collectionName)) {
            await this.client.createCollection(collectionName, {
                vectors: { size: 768, distance: 'Cosine' }, // Adjust size based on your embedding model
            });
        }
    }

    public async upsertChunks(collectionName: string, chunks: CodeChunk[], vectors: number[][]): Promise<void> {
        const points = chunks.map((chunk, i) => ({
            id: `${chunk.filePath}:${chunk.startLine}-${chunk.endLine}`,
            vector: vectors[i],
            payload: {
                filePath: chunk.filePath,
                content: chunk.content,
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                type: chunk.type,
            },
        }));

        await this.client.upsert(collectionName, {
            wait: true,
            points,
        });
    }
}
```

#### **3. The Embedding Provider Interface and Implementations**

To keep the code clean and extensible, you'll create an interface for embedding providers and then implement it for Ollama and OpenAI.

**Code Example (`src/embeddings/embeddingProvider.ts`):**

```typescript
export interface IEmbeddingProvider {
    generateEmbeddings(chunks: string[]): Promise<number[][]>;
}
```

**Code Example (`src/embeddings/ollamaProvider.ts`):**

```typescript
import axios from 'axios';
import { IEmbeddingProvider } from './embeddingProvider';

export class OllamaProvider implements IEmbeddingProvider {
    public async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        const embeddings: number[][] = [];
        for (const chunk of chunks) {
            const response = await axios.post('http://localhost:11434/api/embeddings', {
                model: 'nomic-embed-text', // Or your preferred model
                prompt: chunk,
            });
            embeddings.push(response.data.embedding);
        }
        return embeddings;
    }
}
```

**Code Example (`src/embeddings/openaiProvider.ts`):**

```typescript
import axios from 'axios';
import { IEmbeddingProvider } from './embeddingProvider';
import * as vscode from 'vscode';


export class OpenAIProvider implements IEmbeddingProvider {
    private apiKey: string | undefined;

    constructor() {
        this.apiKey = vscode.workspace.getConfiguration('your-extension').get('openaiApiKey');
    }

    public async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        if (!this.apiKey) {
            vscode.window.showErrorMessage("OpenAI API key not found. Please set it in the extension settings.");
            return [];
        }

        const response = await axios.post('https://api.openai.com/v1/embeddings', {
            model: 'text-embedding-ada-002',
            input: chunks,
        }, {
            headers: {
                'Authorization': `Bearer ${this.apiKey}`,
            },
        });

        return response.data.data.map((item: any) => item.embedding);
    }
}
```

#### **4. Updating the `IndexingService`**

Finally, you'll update the `IndexingService` to use the new `QdrantService` and an embedding provider to complete the indexing process.

**Code Example (`src/indexing/indexingService.ts`):**

```typescript
import * as vscode from 'vscode';
import { FileWalker } from './fileWalker';
import { AstParser } from '../parsing/astParser';
import { Chunker, CodeChunk } from '../parsing/chunker';
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { OllamaProvider } from '../embeddings/ollamaProvider'; // Default provider

export class IndexingService {
    private fileWalker: FileWalker;
    private astParser = new AstParser();
    private chunker = new Chunker();
    private qdrantService = new QdrantService();
    private embeddingProvider: IEmbeddingProvider;

    constructor(private workspaceRoot: string) {
        this.fileWalker = new FileWalker(workspaceRoot);
        // This will be updated in a later sprint to be configurable
        this.embeddingProvider = new OllamaProvider();
    }

    public async startIndexing(): Promise<void> {
        return vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Indexing Repository",
            cancellable: true
        }, async (progress, token) => {
            // ... (file walking, parsing, and chunking logic from Sprint 2)

            const allChunks: CodeChunk[] = []; // Assume this is populated

            progress.report({ message: "Generating embeddings..." });
            const contents = allChunks.map(chunk => chunk.content);
            const vectors = await this.embeddingProvider.generateEmbeddings(contents);

            progress.report({ message: "Storing in vector database..." });
            const collectionName = path.basename(this.workspaceRoot);
            await this.qdrantService.createCollectionIfNotExists(collectionName);
            await this.qdrantService.upsertChunks(collectionName, allChunks, vectors);

            vscode.window.showInformationMessage("Indexing complete!");
        });
    }

    // ... (getLanguage method from Sprint 2)
}
```

This completes the implementation guide for Sprint 3. You now have a complete pipeline for finding, parsing, chunking, vectorizing, and storing your code. The next logical step is to build the API and UI to actually *use* this indexed data, as outlined in the subsequent PRDs.
</prd>


[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/setup/tasklist_sprint_01.md">
# Task List: Sprint 1 - Boilerplate & UI Scaffolding

**Goal:** To establish the project's foundation by setting up the VS Code extension with a SvelteKit frontend and Fluent UI.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Generate VS Code Extension:** Run `npx yo code` in your project's root directory. When prompted, select "New Extension (TypeScript)", provide a suitable name (e.g., "Code Context Engine"), and accept default configurations for linting and Git initialization. | `(Project Root)` |
| **1.2** |  To Do | **Initialize SvelteKit Project:** Navigate into the newly created `webview` directory (e.g., `cd webview`). Run `npm create svelte@latest .` and select "Skeleton project", "TypeScript", "ESLint", "Prettier", and "Vitest" when prompted. | `webview/` |
| **1.3** |  To Do | **Install SvelteKit Dependencies:** After initializing SvelteKit, run `npm install` inside the `webview` directory to install its dependencies. | `webview/package.json` |
| **1.4** |  To Do | **Install Fluent UI Dependencies:** While still in the `webview` directory, install the Fluent UI web components: `npm install @fluentui/web-components`. | `webview/package.json` |
| **1.5** |  To Do | **Create Webview Panel Logic:** Open `src/extension.ts`. Add TypeScript code within the `activate` function to create and manage a `WebviewPanel` that will host the SvelteKit application. This involves using `vscode.window.createWebviewPanel` and setting `enableScripts: true`. | `src/extension.ts` |
| **1.6** |  To Do | **Load Svelte App in Webview:** In `src/extension.ts`, configure the webview to load the compiled `index.html` from the SvelteKit `dist` directory. Ensure you use `vscode.Uri.file` and `path.join` to construct the correct absolute path, and handle relative paths for SvelteKit assets (e.g., `/_app/`) by converting them to `webview.asWebviewUri`. | `src/extension.ts` |
| **1.7** |  To Do | **Build SvelteKit App:** Navigate to the `webview` directory (`cd webview`) and run `npm run build` to compile the SvelteKit application into the `dist` folder. This step must be completed before the extension can load the webview. | `webview/` |
| **1.8** |  To Do | **Build Main UI Component:** Create a new Svelte component (e.g., `webview/src/routes/+page.svelte` or `webview/src/lib/MainPanel.svelte`). Implement a basic UI displaying a `<fluent-button>` with the text "Index Now" and a `<fluent-progress-ring>` from the Fluent UI library. Register the Fluent UI components using `provideFluentDesignSystem().register()`. | `webview/src/routes/+page.svelte` or `webview/src/lib/MainPanel.svelte` |
| **1.9** |  To Do | **Implement Theme Handling:** In `webview/src/app.css` (or within your Svelte component's `<style>` tags), use VS Code theme CSS variables (e.g., `--vscode-editor-background`, `--vscode-button-background`) to ensure Fluent UI components automatically adapt to light/dark modes. Apply these to the `body` and relevant Fluent UI custom properties. | `webview/src/app.css` or `webview/src/routes/+page.svelte` |
| **1.10** |  To Do | **Test Extension:** Press `F5` in VS Code to run the extension in a development host. Execute the command to open your extension's UI panel. Verify that the SvelteKit app loads correctly, the "Index Now" button and progress bar are visible, and the UI adapts to theme changes. | `(Launch Configuration)` |
</file>

<file path="docs/todo/setup/tasklist_sprint_02.md">
# Task List: Sprint 2 - AST Parser & Code Chunking

**Goal:** To implement the core logic for parsing code into Abstract Syntax Trees (ASTs) and chunking them into meaningful segments.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Install Tree-sitter and Language Grammars:** In your project's root directory, run `npm install tree-sitter tree-sitter-typescript tree-sitter-python tree-sitter-c-sharp` to install the core parser and necessary language grammars. | `package.json` |
| **2.2** |  To Do | **Install File System Helper Libraries:** In your project's root directory, run `npm install glob ignore` to install libraries for file matching and `.gitignore` parsing. | `package.json` |
| **2.3** |  To Do | **Create `FileWalker` Service File:** Create a new TypeScript file at `src/indexing/fileWalker.ts`. | `src/indexing/fileWalker.ts` |
| **2.4** |  To Do | **Implement `FileWalker` Constructor:** In `src/indexing/fileWalker.ts`, add a constructor that takes `workspaceRoot: string` and initializes an `ignore` instance. | `src/indexing/fileWalker.ts` |
| **2.5** |  To Do | **Implement `FileWalker.loadGitignore` Method:** In `src/indexing/fileWalker.ts`, add an asynchronous private method `loadGitignore` that reads the `.gitignore` file from `workspaceRoot` and adds its patterns to the `ignore` instance. Handle cases where `.gitignore` is not found. | `src/indexing/fileWalker.ts` |
| **2.6** |  To Do | **Implement `FileWalker.findAllFiles` Method:** In `src/indexing/fileWalker.ts`, add an asynchronous public method `findAllFiles` that first calls `loadGitignore`, then uses `glob` to find all relevant code files (e.g., `**/*.{ts,js,py,cs}`), and finally filters them using the `ignore` instance. | `src/indexing/fileWalker.ts` |
| **2.7** |  To Do | **Create `AstParser` Service File:** Create a new TypeScript file at `src/parsing/astParser.ts`. | `src/parsing/astParser.ts` |
| **2.8** |  To Do | **Implement `AstParser` Constructor:** In `src/parsing/astParser.ts`, add a constructor that initializes a `tree-sitter` `Parser` instance. | `src/parsing/astParser.ts` |
| **2.9** |  To Do | **Implement `AstParser.parse` Method:** In `src/parsing/astParser.ts`, add a public method `parse` that takes `language: 'typescript' | 'python' | 'csharp'` and `code: string`. Use a `switch` statement to set the correct `tree-sitter` language grammar and then parse the provided `code` into an AST, returning the `Parser.Tree`. | `src/parsing/astParser.ts` |
| **2.10** |  To Do | **Create `Chunker` Service File:** Create a new TypeScript file at `src/parsing/chunker.ts`. Define the `CodeChunk` interface within this file, including `filePath`, `content`, `startLine`, `endLine`, and `type`. | `src/parsing/chunker.ts` |
| **2.11** |  To Do | **Implement `Chunker.chunk` Method:** In `src/parsing/chunker.ts`, add a public method `chunk` that takes `filePath: string`, `tree: Parser.Tree`, and `code: string`. Use `tree-sitter`'s `Query` API to find specific nodes (e.g., function declarations, class declarations) in the AST. Iterate through matches and create `CodeChunk` objects, populating their properties from the AST nodes. | `src/parsing/chunker.ts` |
| **2.12** |  To Do | **Update `IndexingService` File:** Open `src/indexing/indexingService.ts`. If it doesn't exist, create it. This file will orchestrate the `FileWalker`, `AstParser`, and `Chunker`. | `src/indexing/indexingService.ts` |
| **2.13** |  To Do | **Implement `IndexingService` Constructor:** In `src/indexing/indexingService.ts`, add a constructor that takes `workspaceRoot: string` and initializes instances of `FileWalker`, `AstParser`, and `Chunker`. | `src/indexing/indexingService.ts` |
| **2.14** |  To Do | **Implement `IndexingService.startIndexing` Method:** In `src/indexing/indexingService.ts`, add an asynchronous public method `startIndexing`. This method should use `vscode.window.withProgress` to show a progress notification. Inside, call `fileWalker.findAllFiles()`. For each file, read its content using `vscode.workspace.fs.readFile`, determine its language, parse it with `astParser.parse()`, and then chunk it with `chunker.chunk()`. Collect all generated `CodeChunk` objects. | `src/indexing/indexingService.ts` |
| **2.15** |  To Do | **Implement `IndexingService.getLanguage` Method:** In `src/indexing/indexingService.ts`, add a private helper method `getLanguage` that takes a `filePath` and returns the corresponding language (e.g., 'typescript', 'python', 'csharp') or `null` based on the file extension. | `src/indexing/indexingService.ts` |
| **2.16** |  To Do | **Integrate `IndexingService` into `extension.ts`:** In `src/extension.ts`, modify the `activate` function to instantiate `IndexingService` and call `startIndexing` when a specific command (e.g., "Index Now") is executed. Ensure proper error handling and user feedback (e.g., `vscode.window.showInformationMessage`). | `src/extension.ts` |
</file>

<file path="docs/todo/setup/tasklist_sprint_03.md">
# Task List: Sprint 3 - Vectorization & DB Integration

**Goal:** To vectorize the code chunks and store them in the Qdrant database.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Install Qdrant Client and Axios:** In your project's root directory, run `npm install @qdrant/js-client-rest axios` to install the Qdrant JavaScript client and an HTTP client for embedding providers. | `package.json` |
| **3.2** |  To Do | **Create Docker Compose File for Qdrant:** In your project's root directory, create a new file named `docker-compose.yml`. | `docker-compose.yml` |
| **3.3** |  To Do | **Add Qdrant Service Definition to Docker Compose:** In `docker-compose.yml`, define the Qdrant service, specifying the `qdrant/qdrant:latest` image, port mappings (`6333:6333`, `6334:6334`), and a volume for persistent storage (`./qdrant_storage:/qdrant/storage`). | `docker-compose.yml` |
| **3.4** |  To Do | **Start Qdrant Container:** From your project's root directory, run `docker-compose up -d` to start the Qdrant database in the background. | `(Terminal Command)` |
| **3.5** |  To Do | **Create `QdrantService` File:** Create a new TypeScript file at `src/db/qdrantService.ts`. | `src/db/qdrantService.ts` |
| **3.6** |  To Do | **Implement `QdrantService` Constructor:** In `src/db/qdrantService.ts`, add a constructor that initializes a `QdrantClient` instance, connecting to the local Qdrant instance (e.g., `http://localhost:6333`). | `src/db/qdrantService.ts` |
| **3.7** |  To Do | **Implement `QdrantService.createCollectionIfNotExists` Method:** In `src/db/qdrantService.ts`, add an asynchronous public method `createCollectionIfNotExists` that takes `collectionName: string`. This method should check if the collection already exists using `client.getCollections()` and, if not, create it using `client.createCollection()` with appropriate vector size and distance (e.g., `size: 768, distance: 'Cosine'`). | `src/db/qdrantService.ts` |
| **3.8** |  To Do | **Implement `QdrantService.upsertChunks` Method:** In `src/db/qdrantService.ts`, add an asynchronous public method `upsertChunks` that takes `collectionName: string`, `chunks: CodeChunk[]`, and `vectors: number[][]`. This method should map `CodeChunk` and `vector` data into `PointStruct` objects and then use `client.upsert()` to insert or update them in the specified collection. | `src/db/qdrantService.ts` |
| **3.9** |  To Do | **Create `IEmbeddingProvider` Interface File:** Create a new TypeScript file at `src/embeddings/embeddingProvider.ts`. Define the `IEmbeddingProvider` interface with a `generateEmbeddings(chunks: string[]): Promise<number[][]>` method. | `src/embeddings/embeddingProvider.ts` |
| **3.10** |  To Do | **Create `OllamaProvider` File:** Create a new TypeScript file at `src/embeddings/ollamaProvider.ts`. | `src/embeddings/ollamaProvider.ts` |
| **3.11** |  To Do | **Implement `OllamaProvider`:** In `src/embeddings/ollamaProvider.ts`, implement the `IEmbeddingProvider` interface. The `generateEmbeddings` method should make HTTP POST requests to the local Ollama API (`http://localhost:11434/api/embeddings`) for each chunk, using a specified model (e.g., `nomic-embed-text`), and return the generated embeddings. | `src/embeddings/ollamaProvider.ts` |
| **3.12** |  To Do | **Create `OpenAIProvider` File:** Create a new TypeScript file at `src/embeddings/openaiProvider.ts`. | `src/embeddings/openaiProvider.ts` |
| **3.13** |  To Do | **Implement `OpenAIProvider`:** In `src/embeddings/openaiProvider.ts`, implement the `IEmbeddingProvider` interface. The `generateEmbeddings` method should make HTTP POST requests to the OpenAI embeddings API (`https://api.openai.com/v1/embeddings`), using a specified model (e.g., `text-embedding-ada-002`), and include the API key from VS Code settings in the authorization header. Handle cases where the API key is missing. | `src/embeddings/openaiProvider.ts` |
| **3.14** |  To Do | **Update `IndexingService` to Use Embedding Provider and Qdrant:** Open `src/indexing/indexingService.ts`. Modify the `IndexingService` to include instances of `QdrantService` and `IEmbeddingProvider`. | `src/indexing/indexingService.ts` |
| **3.15** |  To Do | **Modify `IndexingService.startIndexing` Method:** In `src/indexing/indexingService.ts`, after chunking is complete, add steps to: 1) Extract content from all chunks, 2) Call `embeddingProvider.generateEmbeddings()` to get vectors, 3) Determine a collection name (e.g., based on workspace root), 4) Call `qdrantService.createCollectionIfNotExists()`, and 5) Call `qdrantService.upsertChunks()` to store the chunks and vectors in Qdrant. | `src/indexing/indexingService.ts` |
| **3.16** |  To Do | **Add Progress Reporting for Embedding and Storage:** In `IndexingService.startIndexing`, update `vscode.window.withProgress` to report progress messages for "Generating embeddings..." and "Storing in vector database...". | `src/indexing/indexingService.ts` |
| **3.17** |  To Do | **Add Completion Message:** In `IndexingService.startIndexing`, after successful storage, display a completion message using `vscode.window.showInformationMessage("Indexing complete!")`. | `src/indexing/indexingService.Service` |
</file>

<file path="docs/todo/setup/tasklist_sprint_04.md">
# Task List: Sprint 4 - Context Query API

**Goal:** To build and expose the internal API for querying the indexed code context.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `ContextService`:** In the backend, create a new `contextService.ts` file at `src/context/contextService.ts` to house the query logic. | `src/context/contextService.ts` |
| **4.2** |  To Do | **Implement `getFileContent` method:** In `src/context/contextService.ts`, add logic to perform a vector search for the file path (using embedding provider and Qdrant) and then read the content from disk using `vscode.workspace.fs.readFile`. | `src/context/contextService.ts` |
| **4.3** |  To Do | **Implement `findRelatedFiles` method:** In `src/context/contextService.ts`, add logic to perform a similarity search in Qdrant (using embedding provider) and return a list of unique file paths from the results. | `src/context/contextService.ts` |
| **4.4** |  To Do | **Set up Webview Message Handling:** In `src/extension.ts`, add a `panel.webview.onDidReceiveMessage` listener to the webview panel to handle incoming requests from the frontend. | `src/extension.ts` |
| **4.5** |  To Do | **Route API Calls:** In the message handler within `src/extension.ts`, create a `switch` statement to route requests (e.g., `'getFileContent'`, `'findRelatedFiles'`) to the appropriate method in `ContextService`. | `src/extension.ts` |
| **4.6** |  To Do | **Send Results to Frontend:** In `src/extension.ts`, use the `webview.postMessage` method to send the results from the `ContextService` back to the SvelteKit UI. | `src/extension.ts` |
| **4.7** |  To Do | **Create Frontend API Client:** In the SvelteKit app, create a wrapper service (`webview/src/lib/vscodeApi.ts`) that simplifies posting and listening for messages from the extension backend using `acquireVsCodeApi()`. | `webview/src/lib/vscodeApi.ts` |
| **4.8** |  To Do | **Integrate Frontend with API Client:** In your Svelte components (e.g., `webview/src/routes/+page.svelte`), use the `vscodeApi.ts` client to send requests (e.g., for file content or related files) and handle the responses received from the extension backend. | `webview/src/routes/+page.svelte` |
</file>

<file path="docs/todo/setup/tasklist_sprint_05.md">
# Task List: Sprint 5 - Settings UI & Configuration

**Goal:** To build the settings UI and connect it to the VS Code configuration system.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **5.1** |  To Do | **Define Configuration Schema:** In `package.json`, under the `contributes.configuration` section, define the properties for the settings (e.g., `code-context.embeddingProvider`, `code-context.databaseConnectionString`), including their types, defaults, and descriptions. | `package.json` |
| **5.2** |  To Do | **Register `openSettings` command:** In `package.json`, add a new command to the `contributes.commands` section (e.g., `code-context-engine.openSettings`) that will be used to open the settings UI. | `package.json` |
| **5.3** |  To Do | **Implement command in `extension.ts`:** In `src/extension.ts`, register the `openSettings` command. The command handler should create and show a new `WebviewPanel` specifically for the settings UI, loading the SvelteKit app into it. | `src/extension.ts` |
| **5.4** |  To Do | **Create `Settings.svelte` component:** Create a new Svelte component (e.g., `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte`). Build the UI using Fluent UI components like `<fluent-select>` for embedding providers and `<fluent-text-field>` for the database URI. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.5** |  To Do | **Load Initial Settings:** In the `Settings.svelte` component, use the `onMount` lifecycle hook to send a message to the extension backend (via `vscodeApi.ts`) requesting the current configuration values. Listen for the response and populate the UI fields with the loaded settings. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.6** |  To Do | **Implement `getSettings` handler in `extension.ts`:** In `src/extension.ts`, add a message handler for the `getSettings` command. This handler should read the current configuration values from `vscode.workspace.getConfiguration('code-context-engine')` and send them back to the webview. | `src/extension.ts` |
| **5.7** |  To Do | **Save Settings from UI:** In the `Settings.svelte` component, add a button (e.g., "Save Settings"). On click, gather the current values from the UI fields and send them as a message (e.g., `saveSettings`) to the extension backend. | `webview/src/routes/settings/+page.svelte` or `webview/src/lib/Settings.svelte` |
| **5.8** |  To Do | **Implement `saveConfiguration` handler in `extension.ts`:** In `src/extension.ts`, add a message handler for the `saveSettings` command. This handler should receive the updated settings from the webview and use `vscode.workspace.getConfiguration().update()` to persist them to the VS Code configuration (e.g., `vscode.ConfigurationTarget.Global`). | `src/extension.ts` |
| **5.9** |  To Do | **Refactor Services to Use Config:** Update `src/indexing/indexingService.ts` and `src/db/qdrantService.ts` (and any other relevant services) to read their configuration (e.g., embedding provider, database connection string) from `vscode.workspace.getConfiguration('code-context-engine')` instead of hardcoded values. | `src/indexing/indexingService.ts`, `src/db/qdrantService.ts` |
</file>

<file path="docs/todo/setup/tasklist_sprint_06.md">
# Task List: Sprint 6 - LSP Integration & DevOps

**Goal:** To enrich the index with LSP data and automate the build and test process.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **6.1** |  To Do | **Research LSP Interaction:** Investigate how to programmatically interact with a language server using the `vscode.commands.executeCommand` API for LSP-related commands (e.g., `vscode.executeDefinitionProvider`, `vscode.executeReferenceProvider`). Understand the expected input parameters (URI, Position) and output formats. | `(Documentation)` |
| **6.2** |  To Do | **Update `IndexingService` for LSP:** In `src/indexing/indexingService.ts`, modify the `startIndexing` method (or create a helper method like `processChunkWithLSP`). For each code chunk, call the relevant `vscode.commands.executeCommand` for LSP data (definitions, references) using the chunk's file URI and start position. | `src/indexing/indexingService.ts` |
| **6.3** |  To Do | **Process LSP Results:** Within `IndexingService`, parse the results from the LSP commands. Extract relevant information (e.g., target URIs, ranges, symbol names) and structure it into a suitable format to be stored as metadata. | `src/indexing/indexingService.ts` |
| **6.4** |  To Do | **Extend `CodeChunk` Interface:** If not already done, update the `CodeChunk` interface (e.g., in `src/parsing/chunker.ts`) to include new properties for LSP-derived metadata (e.g., `lspDefinitions`, `lspReferences`). | `src/parsing/chunker.ts` |
| **6.5** |  To Do | **Extend Qdrant Metadata:** In `src/db/qdrantService.ts`, modify the `upsertChunks` method. Ensure that the `payload` object sent to Qdrant includes the newly added LSP metadata from the `CodeChunk` objects. | `src/db/qdrantService.ts` |
| **6.6** |  To Do | **Create GitHub Actions Workflow File:** In your project's root directory, create a new directory `.github/workflows/` if it doesn't exist. Inside this directory, create a new YAML file named `ci.yml`. | `.github/workflows/ci.yml` |
| **6.7** |  To Do | **Configure Workflow Triggers:** In `.github/workflows/ci.yml`, set the `on` section to trigger the workflow on `push` events to the `main` branch and on `pull_request` events targeting the `main` branch. | `.github/workflows/ci.yml` |
| **6.8** |  To Do | **Define Build Job:** In `.github/workflows/ci.yml`, define a `build` job that runs on `ubuntu-latest`. | `.github/workflows/ci.yml` |
| **6.9** |  To Do | **Add Checkout Step:** In the `build` job, add a step to `uses: actions/checkout@v3` to check out the repository code. | `.github/workflows/ci.yml` |
| **6.10** |  To Do | **Add Node.js Setup Step:** In the `build` job, add a step to `uses: actions/setup-node@v3` to set up the Node.js environment (specify your project's Node.js version, e.g., `node-version: '18'`). | `.github/workflows/ci.yml` |
| **6.11** |  To Do | **Add Install Dependencies Step:** In the `build` job, add a step to run `npm install` to install all project dependencies. | `.github/workflows/ci.yml` |
| **6.12** |  To Do | **Add Linting Step:** In the `build` job, add a step to run your project's linting command (e.g., `npm run lint`). | `.github/workflows/ci.yml` |
| **6.13** |  To Do | **Add Testing Step:** In the `build` job, add a step to run your project's test command (e.g., `npm test`). | `.github/workflows/ci.yml` |
| **6.14** |  To Do | **Add Build Extension Step:** In the `build` job, add a step to run the command that builds your VS Code extension package (e.g., `npm run vscode:prepublish` or `vsce package`). | `.github/workflows/ci.yml` |
| **6.15** |  To Do | **Add Upload Artifact Step:** In the `build` job, add a step to `uses: actions/upload-artifact@v3` to upload the generated `.vsix` file as a build artifact (e.g., `name: vsix-package`, `path: '*.vsix'`). | `.github/workflows/ci.yml` |
</file>

<file path="docs/todo/setup/tasklist_sprint_07.md">
# Task List: Sprint 7 - Documentation & Publishing

**Goal:** To create high-quality documentation and publish the extension to the marketplace.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **7.1** |  To Do | **Write `README.md` Content:** Open `README.md` in the project root. Draft the main sections: Features, Requirements, Installation, Configuration, and Usage. Ensure clear and concise language. | `README.md` |
| **7.2** |  To Do | **Create Demo GIF:** Use screen recording software to capture the core indexing and querying workflow of the extension. Optimize the recording and convert it into an animated GIF (e.g., `assets/demo.gif`). | `assets/demo.gif` |
| **7.3** |  To Do | **Embed GIF in `README.md`:** In `README.md`, add markdown syntax to display the `demo.gif` at an appropriate location (e.g., `![Demo GIF](assets/demo.gif)`). | `README.md` |
| **7.4** |  To Do | **Write `CONTRIBUTING.md`:** Create a new file named `CONTRIBUTING.md` in the project root. Write a guide for developers on how to set up the project, run tests, adhere to code style, and submit pull requests. | `CONTRIBUTING.md` |
| **7.5** |  To Do | **Create Marketplace Publisher:** Follow the official VS Code documentation to create a publisher identity on the Visual Studio Code Marketplace. This involves setting up an Azure DevOps organization and generating a Personal Access Token (PAT) with `Marketplace (Publish)` scope. | `(External - VS Code Marketplace)` |
| **7.6** |  To Do | **Add `VSCE_TOKEN` as GitHub Secret:** In your GitHub repository settings, navigate to `Settings` -> `Secrets and variables` -> `Actions`. Add a new repository secret named `VSCE_TOKEN` and paste the PAT generated in the previous step as its value. | `(GitHub Repository Settings)` |
| **7.7** |  To Do | **Add Manual Release Trigger to CI Workflow:** Open `.github/workflows/ci.yml`. In the `on` section, add `workflow_dispatch:` to enable manual triggering of the workflow from the GitHub Actions UI. | `.github/workflows/ci.yml` |
| **7.8** |  To Do | **Define Release Job in CI Workflow:** In `.github/workflows/ci.yml`, add a new job named `release` after the `build` job. This job should `needs: build` and run conditionally `if: github.event_name == 'workflow_dispatch'`. | `.github/workflows/ci.yml` |
| **7.9** |  To Do | **Add Steps to Release Job:** In the `release` job, add steps to: checkout the repository, set up Node.js, install `vsce` globally (`npm install -g vsce`), download the `.vsix` artifact from the `build` job, and finally run `vsce publish -p ${{ secrets.VSCE_TOKEN }}` to publish the extension. | `.github/workflows/ci.yml` |
| **7.10** |  To Do | **Test the Release Process:** Go to your GitHub repository's `Actions` tab. Select the `CI/CD` workflow and click `Run workflow`. Choose the `main` branch and click `Run workflow`. Monitor the job execution to ensure it completes successfully. | `(GitHub Actions UI)` |
| **7.11** |  To Do | **Verify Publication:** After the release workflow completes, search for your extension on the Visual Studio Code Marketplace to confirm it has been successfully published and is publicly accessible. | `(External - VS Code Marketplace)` |
</file>

<file path="docs/todo/svelte-continue/prd.md">
<prd>Of course. You've correctly identified a significant architectural issue. Hardcoding the entire frontend within HTML strings in `extension.ts` is not scalable or maintainable.

My analysis of the `repomix-output.xml` file confirms your assessment. The functions `getWebviewContent`, `getSettingsWebviewContent`, and `getSetupWebviewContent` in `src/extension.ts` contain large blocks of HTML and inline JavaScript. The current `webview` directory has a basic webpack setup but isn't a proper SvelteKit application.

To address this technical debt, I've created a foundational PRD focused on migrating this inline HTML into a dedicated and properly structured SvelteKit application. This will establish a clean separation between the extension's backend logic and its frontend UI.

-----

### **New Document: PRD 1: Foundational - SvelteKit Webview Migration**

**1. Title & Overview**

  * **Project:** Code Context Engine - SvelteKit Webview Migration
  * **Summary:** This phase focuses on refactoring the entire frontend from inline HTML strings within `extension.ts` into a dedicated SvelteKit application in the `webview/` directory. This will create a clean, modern, and maintainable frontend architecture, enabling faster development and better organization of UI components and logic.
  * **Dependencies:** The existing `extension.ts` file serves as the functional specification for the UI.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Significantly improve developer velocity and maintainability for all future frontend work.
      * Establish a professional and scalable frontend architecture that separates UI from backend logic.
  * **Developer & System Success Metrics:**
      * All UI-related HTML and inline JavaScript is removed from `src/extension.ts`.
      * The `webview/` directory contains a fully functional SvelteKit application.
      * The SvelteKit application is built into a static `dist` or `build` directory.
      * The `extension.ts` file now only loads the `index.html` from the SvelteKit build output.
      * All previous UI functionality (buttons, inputs, status updates) is replicated in the new SvelteKit application and communicates with `extension.ts` via a standardized message-passing API.

-----

**3. User Personas**

  * **Frank (Frontend Developer):** Frank is currently unable to work efficiently because all UI code is tangled inside a TypeScript file. He needs a proper frontend development environment with Svelte components, state management, and a standard build process to create and iterate on the UI effectively.
  * **Alisha (Backend Developer):** Alisha wants to focus on the extension's core logic without having to modify large HTML strings in `extension.ts`. A clean separation allows her to work on the backend without impacting the UI, and vice-versa.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Migration** | **Sprint 1: SvelteKit Scaffolding & UI Components** | As Frank, I want to set up a new SvelteKit project in the `webview/` directory configured with a static adapter, so I have a proper foundation for the UI. | 1. The `webview/` directory is replaced with a new SvelteKit skeleton project.\<br/\>2. The project is configured to use `@sveltejs/adapter-static`.\<br/\>3. Fluent UI web components are installed as a dependency.\<br/\>4. The project can be successfully built using `npm run build`. | **2 Weeks** |
| | | As Frank, I want to recreate the three main UI views (Setup, Indexing, Query) as separate Svelte components based on the existing HTML in `extension.ts`. | 1. A `SetupView.svelte` component is created, replicating the database and provider selection UI.\<br/\>2. An `IndexingView.svelte` component is created with a progress bar and status text.\<br/\>3. A `QueryView.svelte` component is created with the search input and results area.\<br/\>4. A main `+page.svelte` or `ViewManager.svelte` component is created to conditionally render the correct view based on application state. | |
| **Phase 1: Migration** | **Sprint 2: Extension Integration & Communication** | As Alisha, I want to refactor `extension.ts` to load the SvelteKit application instead of generating inline HTML, so that the UI is fully decoupled. | 1. The `getWebviewContent` and similar functions in `extension.ts` are removed.\<br/\>2. A new, simpler function reads the `index.html` from the SvelteKit build directory.\<br/\>3. The function correctly rewrites asset paths (`/_app/...`) using `webview.asWebviewUri` to ensure JS and CSS load.\<br/\>4. The extension successfully loads and renders the SvelteKit application in the webview panel. | **2 Weeks** |
| | | As Frank, I want a standardized API client (`vscodeApi.ts`) in the SvelteKit app for communicating with the extension, so I don't have to use the global `acquireVsCodeApi` in every component. | 1. A `vscodeApi.ts` module is created that wraps `acquireVsCodeApi`.\<br/\>2. It provides simple `postMessage` and `onMessage` functions.\<br/\>3. The client handles request-response pairing using a unique `requestId` for asynchronous operations.\<br/\>4. All Svelte components use this new module for communication instead of the raw API. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 1:** SvelteKit Scaffolding & UI Components (2 Weeks)
  * **Sprint 2:** Extension Integration & Communication (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The existing UI functionality described in the `extension.ts` HTML is the complete and desired feature set for the initial version.
  * **Risk:** The path rewriting logic to load SvelteKit's static assets (`/_app/...`) in a webview can be tricky and may require adjustments based on the SvelteKit version.
      * **Mitigation:** Dedicate a specific task to creating a robust path-rewriting function and test it thoroughly across different asset types (JS, CSS, fonts).
  * **Risk:** Migrating the inline JavaScript logic to a proper Svelte state management and message-passing system might reveal inconsistencies in the original implementation.
      * **Mitigation:** Create a clear mapping of all existing `postMessage` calls and event listeners before starting the Svelte implementation. Use a Svelte store for managing shared UI state.

-----

### **New Document: Sub-Sprint 1: SvelteKit Project Scaffolding**

**Objective:**
To replace the existing `webview/` content with a new, properly configured SvelteKit project and add the Fluent UI component library.

**Parent Sprint:**
PRD 1, Sprint 1: SvelteKit Scaffolding & UI Components

**Tasks:**

1.  **Clear Existing `webview/`:** Remove the current webpack-based content from the `webview/` directory.
2.  **Initialize SvelteKit:** Run `npm create svelte@latest webview` to scaffold a new SvelteKit "Skeleton project" with TypeScript support.
3.  **Install Static Adapter:** Add `@sveltejs/adapter-static` as a dev dependency.
4.  **Configure `svelte.config.js`:** Update the config file to use the static adapter, setting the output directory to `build` and the fallback to `index.html`.
5.  **Install Fluent UI:** Add `@fluentui/web-components` as a dependency.

**Acceptance Criteria:**

  * The `webview/` directory contains a clean SvelteKit project.
  * Running `npm run build` inside `webview/` successfully generates a static site in `webview/build/`.
  * Fluent UI is listed as a dependency.

**Dependencies:**

  * Node.js and npm installed.

**Timeline:**

  * **Start Date:** 2025-08-25
  * **End Date:** 2025-08-29

-----

### **New Document: Sub-Sprint 2: Recreate UI as Svelte Components**

**Objective:**
To build the three primary UI views as distinct Svelte components, replicating the functionality and layout from the original inline HTML.

**Parent Sprint:**
PRD 1, Sprint 1: SvelteKit Scaffolding & UI Components

**Tasks:**

1.  **Create View Components:** Create `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte` inside `webview/src/lib/components/`.
2.  **Translate HTML to Svelte:** For each component, translate the corresponding HTML structure from `extension.ts` into Svelte syntax, replacing standard HTML elements with Fluent UI components (e.g., `<fluent-button>`, `<fluent-progress-bar>`).
3.  **Create State Store:** Create a `viewStore.ts` to manage the current visible view (e.g., `'setup' | 'indexing' | 'query'`).
4.  **Create View Manager:** Build a main component (`+page.svelte`) that imports the three views and uses the state store to conditionally render the active one.

**Acceptance Criteria:**

  * The three core view components exist and contain the correct UI elements.
  * The application renders one of the three views based on the value in a central store.
  * The UI layout and elements closely match the original design specified in `extension.ts`.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2025-09-01
  * **End Date:** 2025-09-05

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - SvelteKit Scaffolding & UI Components

**Goal:** To establish the new SvelteKit frontend project and recreate the existing UI with modular components.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Clear and Re-initialize Project:** Delete the contents of `webview/` and run `npm create svelte@latest webview` to create a new SvelteKit project with TypeScript. | `webview/` |
| **1.2** |  To Do | **Install Static Adapter:** In the `webview/` directory, run `npm install -D @sveltejs/adapter-static`. | `webview/package.json` |
| **1.3** |  To Do | **Configure Static Build:** Modify `webview/svelte.config.js` to import and use `adapter-static`, setting the output to a `build` directory. | `webview/svelte.config.js` |
| **1.4** |  To Do | **Install Fluent UI:** In the `webview/` directory, run `npm install @fluentui/web-components`. | `webview/package.json` |
| **1.5** |  To Do | **Create State Store:** Create a new file `webview/src/lib/stores/viewStore.ts` and use Svelte's `writable` to manage the current view state. | `webview/src/lib/stores/viewStore.ts` |
| **1.6** |  To Do | **Create View Components:** Create the files `SetupView.svelte`, `IndexingView.svelte`, and `QueryView.svelte` in `webview/src/lib/components/`. | `webview/src/lib/components/` |
| **1.7** |  To Do | **Implement `SetupView` UI:** Replicate the setup form from `getSetupWebviewContent` in `extension.ts` using Fluent UI components. | `webview/src/lib/components/SetupView.svelte` |
| **1.8** |  To Do | **Implement `IndexingView` UI:** Replicate the progress bar UI from `getWebviewContent` in `extension.ts`. | `webview/src/lib/components/IndexingView.svelte` |
| **1.9** |  To Do | **Implement `QueryView` UI:** Replicate the search input and results area from `getWebviewContent` in `extension.ts`. | `webview/src/lib/components/QueryView.svelte` |
| **1.10**|  To Do | **Create Main Page:** In `webview/src/routes/+page.svelte`, import the view components and the store, and use an `{#if}` block to render the correct view based on the store's value. | `webview/src/routes/+page.svelte` |

-----

### **New Document: tasklist\_sprint\_02.md**

# Task List: Sprint 2 - Extension Integration & Communication

**Goal:** To connect the new SvelteKit application to the extension backend and re-establish all communication logic.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **2.1** |  To Do | **Refactor `getWebviewContent`:** Remove the large HTML string from `getWebviewContent` in `extension.ts`. | `src/extension.ts` |
| **2.2** |  To Do | **Implement Static HTML Loading:** The new `getWebviewContent` should read `webview/build/index.html` using `fs.readFileSync`. | `src/extension.ts` |
| **2.3** |  To Do | **Implement Asset Path Rewriting:** In `getWebviewContent`, use a regular expression to find all `/_app/...` asset paths and replace them with the correct `webview.asWebviewUri` version. | `src/extension.ts` |
| **2.4** |  To Do | **Test Webview Loading:** Run the extension and confirm the SvelteKit application loads correctly, including all CSS and JavaScript assets. | `(Manual Test)` |
| **2.5** |  To Do | **Create `vscodeApi.ts`:** Create a new file `webview/src/lib/vscodeApi.ts` to wrap the `acquireVsCodeApi()` call. | `webview/src/lib/vscodeApi.ts` |
| **2.6** |  To Do | **Implement `postMessage` Wrapper:** In `vscodeApi.ts`, create a simple function that calls `vscode.postMessage(message)`. | `webview/src/lib/vscodeApi.ts` |
| **2.7** |  To Do | **Implement `onMessage` Wrapper:** In `vscodeApi.ts`, create a function that adds a listener to `window.addEventListener('message', ...)`. | `webview/src/lib/vscodeApi.ts` |
| **2.8** |  To Do | **Refactor Components to Use `vscodeApi`:** Update all Svelte components to import from `vscodeApi.ts` for all communication. | `webview/src/lib/components/*.svelte` |
| **2.9** |  To Do | **Re-implement "Start Database" Action:** Connect the button's `on:click` event in `SetupView.svelte` to send a `startDatabase` message using `vscodeApi.postMessage`. | `webview/src/lib/components/SetupView.svelte` |
| **2.10**|  To Do | **Re-implement `databaseStatus` Listener:** In `SetupView.svelte`, use `vscodeApi.onMessage` to listen for `databaseStatus` messages and update the UI accordingly. | `webview/src/lib/components/SetupView.svelte` |
| **2.11**|  To Do | **Verify End-to-End Communication:** Manually test that clicking the "Start Database" button in the Svelte UI correctly triggers the terminal command in the extension backend. | `(Manual Test)` |


Of course. Here is the final PRD to complete the technical debt and refactoring initiative.

-----

### **New Document: PRD 2: Advanced Refactoring - Webview & Communication**

**1. Title & Overview**

  * **Project:** Code Context Engine - Webview & Communication Refactoring
  * **Summary:** This phase completes the decoupling of `extension.ts` by creating dedicated managers for webview lifecycle and message routing. A `WebviewManager` will centralize the logic for creating, showing, and disposing of all webview panels. A `MessageRouter` will handle all communication between the webview and the extension's backend services, creating a clean and robust communication layer.
  * **Dependencies:** PRD 1 (Backend Decoupling & Refactoring) must be complete. The `ExtensionManager` and `CommandManager` should be in place.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Finalize the architectural refactoring to create a fully modular, scalable, and maintainable codebase.
      * Improve the reliability of the UI and its communication with the backend, leading to a better user experience.
  * **Developer & System Success Metrics:**
      * `extension.ts` is purely an activator and contains no direct webview or message handling logic.
      * All webview panel creation and management logic is consolidated within the `WebviewManager`.
      * The large `switch` statement for message handling is replaced by the `MessageRouter`, which cleanly delegates tasks to the appropriate services.
      * Adding a new webview or a new message command is a simple, low-risk operation that requires changes in only one or two focused files.

-----

**3. User Personas**

  * **Alisha (Backend Developer):** Alisha can now add new commands and backend logic without ever needing to touch the UI or communication layers. Her work is isolated to the services she owns.
  * **Frank (Frontend Developer):** Frank works on the SvelteKit UI. He now has a single, predictable `MessageRouter` to interact with. He doesn't need to know which backend service implements a feature; he just sends a command, and the router handles the rest.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 2: Refactoring** | **Sprint 3: Webview Management** | As a developer, I want to create a `WebviewManager` to handle the lifecycle of all webview panels so that UI creation logic is centralized and reusable. | 1. A new `WebviewManager` class is created. \<br/\> 2. All `vscode.window.createWebviewPanel` logic is moved from `extension.ts` (or `CommandManager`) into the `WebviewManager`. \<br/\> 3. The manager handles showing the main panel and the settings panel, ensuring only one of each can exist at a time. \<br/\> 4. The manager is responsible for panel disposal and is properly disposed of by the `ExtensionManager`. | **2 Weeks** |
| | | As Frank, I want the `WebviewManager` to be responsible for providing the correct HTML content so that the webview loading process is standardized. | 1. The logic for reading the `index.html` file from the `webview/dist` directory is moved into a private method in `WebviewManager`. \<br/\> 2. The method correctly replaces asset paths with `webview.asWebviewUri` to ensure CSS and JS files load correctly. \<br/\> 3. The `showMainPanel` and `showSettingsPanel` methods use this helper to set the panel's HTML. | |
| **Phase 2: Refactoring** | **Sprint 4: Communication & State Mgmt** | As a developer, I want to create a `MessageRouter` to handle all incoming messages from the webview so that communication logic is decoupled and clean. | 1. A new `MessageRouter` class is created. \<br/\> 2. The `onDidReceiveMessage` listener for each webview is set up to delegate to an instance of the `MessageRouter`. \<br/\> 3. The `MessageRouter`'s `routeMessage` method contains the `switch` statement that calls the appropriate service based on the message command. \<br/\> 4. The router sends results back to the webview with a consistent response format (e.g., `{ command, requestId, result, error }`). | **2 Weeks** |
| | | As Alisha, I want to introduce a basic `StateManager` to track the global state of the extension so that services don't need to communicate directly with each other for status updates. | 1. A new `StateManager` class is created to hold simple boolean flags (e.g., `isIndexing`, `isBackendHealthy`). \<br/\> 2. Services can update the state via the manager (e.g., `stateManager.setIndexing(true)`). \<br/\> 3. The `MessageRouter` can query the state to prevent conflicting actions (e.g., don't start a new index if `isIndexing` is true). | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 4 Weeks
  * **Sprint 3:** Webview Management (2 Weeks)
  * **Sprint 4:** Communication & State Management (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** The message-passing API between the webview and the extension is stable and performant enough for all communication needs.
  * **Risk:** Incorrectly managing panel/webview lifecycles in the `WebviewManager` could lead to memory leaks or "ghost" panels that are not properly disposed of.
      * **Mitigation:** Ensure that the `onDidDispose` event for every created panel is correctly handled and that all disposables are added to the extension's context subscriptions.
  * **Risk:** The `StateManager` could become a complex bottleneck if too much logic is added to it.
      * **Mitigation:** Keep the initial `StateManager` extremely simple, holding only essential, global boolean flags. Avoid putting business logic into the state manager itself; its only job is to store and retrieve state.

-----

### **New Document: Sub-Sprint 3: Centralized Webview Management**

**Objective:**
To create the `WebviewManager` class and move all webview panel creation and lifecycle logic into it, cleaning up the command handlers and `extension.ts`.

**Parent Sprint:**
PRD 2, Sprint 3: Webview Management

**Tasks:**

1.  **Create `WebviewManager.ts`:** Develop the new class with a constructor that accepts the `vscode.ExtensionContext`.
2.  **Implement `showMainPanel`:** Create a method that contains the logic for creating and showing the main webview panel. It should ensure only one instance of the main panel can exist.
3.  **Implement `showSettingsPanel`:** Create a method that contains the logic for creating and showing the settings webview panel.
4.  **Implement `getWebviewContent`:** Create a private helper method that reads the `index.html`, prepares it with the correct URIs for webview assets, and returns the HTML string.
5.  **Refactor `CommandManager`:** Update the callbacks for the `openMainPanel` and `openSettings` commands to simply call the appropriate methods on the `WebviewManager` instance.

**Acceptance Criteria:**

  * All `vscode.window.createWebviewPanel` calls are located exclusively within `WebviewManager.ts`.
  * The `openMainPanel` and `openSettings` commands correctly open their respective UIs.
  * Attempting to open a panel that is already open simply brings the existing panel into focus.

**Dependencies:**

  * `CommandManager` from PRD 1 must be implemented.

**Timeline:**

  * **Start Date:** 2025-09-22
  * **End Date:** 2025-10-03

-----

### **New Document: Sub-Sprint 4: Message Routing & State**

**Objective:**
To create the `MessageRouter` and `StateManager` classes to formalize the communication layer and centralize the extension's global state.

**Parent Sprint:**
PRD 2, Sprint 4: Communication & State Mgmt

**Tasks:**

1.  **Create `StateManager.ts`:** Develop a simple class with private properties (e.g., `_isIndexing = false`) and public getter/setter methods.
2.  **Create `MessageRouter.ts`:** Develop the class with a constructor that accepts the `ExtensionManager` (to access all services and managers) and the `vscode.Webview`. The constructor will set up the `onDidReceiveMessage` listener.
3.  **Implement `routeMessage` method:** Move the message-handling `switch` statement from `extension.ts` into this private method within the `MessageRouter`.
4.  **Integrate `StateManager`:** In the `MessageRouter`, check the state before delegating actions. For example: `if (this.stateManager.isIndexing) { /* return error */ }`.
5.  **Update Services:** Modify services like `IndexingService` to update the central state (e.g., `this.stateManager.setIndexing(true)` at the start and `false` at the end).
6.  **Integrate `MessageRouter`:** In `WebviewManager`, when a panel is created, instantiate a `MessageRouter` for it, passing in the necessary dependencies.

**Acceptance Criteria:**

  * The `onDidReceiveMessage` listener in `WebviewManager` is a single line that instantiates and uses the `MessageRouter`.
  * The `MessageRouter` correctly routes commands to the appropriate services.
  * Attempting to start a new indexing job while one is already running is gracefully rejected with an error message sent back to the UI.

**Dependencies:**

  * Sub-Sprint 3 must be complete.

**Timeline:**

  * **Start Date:** 2025-10-06
  * **End Date:** 2025-10-17

-----

### **New Document: tasklist\_sprint\_03.md**

# Task List: Sprint 3 - Webview Management

**Goal:** To centralize all webview creation and lifecycle logic into a dedicated `WebviewManager` class.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **3.1** |  To Do | **Create `WebviewManager.ts`:** Create the new file and the `WebviewManager` class structure with a constructor and a `dispose` method. | `src/webviewManager.ts` (New) |
| **3.2** |  To Do | **Implement `getWebviewContent`:** Create a private helper method that takes a webview instance, reads `webview/dist/index.html`, replaces asset paths using `webview.asWebviewUri`, and returns the final HTML string. | `src/webviewManager.ts` |
| **3.3** |  To Do | **Implement `showMainPanel`:** Create a public method that checks if a main panel instance already exists. If not, it calls `vscode.window.createWebviewPanel`, sets its HTML using the helper, and stores the instance. If it exists, it calls `.reveal()`. | `src/webviewManager.ts` |
| **3.4** |  To Do | **Implement `showSettingsPanel`:** Create a public method with the same logic as `showMainPanel`, but for the settings UI, using a different panel ID and title. | `src/webviewManager.ts` |
| **3.5** |  To Do | **Handle Panel Disposal:** In the `show...` methods, add the `onDidDispose` listener to the created panel to nullify the stored instance variable (e.g., `this.mainPanel = undefined`). | `src/webviewManager.ts` |
| **3.6** |  To Do | **Update `ExtensionManager`:** Instantiate the `WebviewManager` in the `ExtensionManager`'s constructor. | `src/extensionManager.ts` |
| **3.7** |  To Do | **Refactor `CommandManager`:** Change the `openMainPanel` and `openSettings` command callbacks to call `extensionManager.webviewManager.showMainPanel()` and `showSettingsPanel()` respectively. | `src/commandManager.ts` |

-----

### **New Document: tasklist\_sprint\_04.md**

# Task List: Sprint 4 - Communication & State Mgmt

**Goal:** To formalize the webview communication layer with a `MessageRouter` and centralize global state with a `StateManager`.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **4.1** |  To Do | **Create `StateManager.ts`:** Create the new file and a simple `StateManager` class. Add a private boolean `_isIndexing` and public `isIndexing()` getter and `setIndexing(state: boolean)` setter. | `src/stateManager.ts` (New) |
| **4.2** |  To Do | **Create `MessageRouter.ts`:** Create the new file and the `MessageRouter` class. Its constructor will accept the `ExtensionManager` and `vscode.Webview`. | `src/messageRouter.ts` (New) |
| **4.3** |  To Do | **Implement `routeMessage`:** Move the message handling `switch` statement into a private `async routeMessage` method in `MessageRouter`. | `src/messageRouter.ts` |
| **4.4** |  To Do | **Integrate State Check:** In `routeMessage`, before the `startIndexing` case, add a check: `if (this.extensionManager.stateManager.isIndexing()) { ... post error message ... }`. | `src/messageRouter.ts` |
| **4.5** |  To Do | **Update `IndexingService`:** Inject the `StateManager` instance into the `IndexingService`. Call `this.stateManager.setIndexing(true)` at the beginning of `startIndexing` and `false` in a `finally` block at the end. | `src/indexing/indexingService.ts` |
| **4.6** |  To Do | **Instantiate `MessageRouter`:** In `WebviewManager`, when a panel is created, remove the old `onDidReceiveMessage` logic and replace it with `new MessageRouter(this.extensionManager, this.mainPanel.webview)`. | `src/webviewManager.ts` |
| **4.7** |  To Do | **Instantiate `StateManager`:** In `ExtensionManager`, create a public instance of the `StateManager` so it can be accessed by other services. | `src/extensionManager.ts` |
| **4.8** |  To Do | **Update Service Constructors:** Update the constructors of services (like `IndexingService`) that now need the `StateManager`, and update the instantiation logic in `ExtensionManager`. | `src/extensionManager.ts`, `src/indexing/indexingService.ts` |

This completes the full set of PRDs for the refactoring initiative. You now have a comprehensive plan to transform your extension's architecture into a more robust, maintainable, and scalable system.</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/ux/prd.md">
<prd>Of course. Here are the detailed PRDs focusing specifically on the frontend UI/UX development for your VS Code extension, broken down by each user-facing view.

-----

### **New Document: PRD 1: Foundational - Onboarding & Setup UI**

**1. Title & Overview**

  * **Project:** Code Context Engine - Onboarding UI/UX
  * **Summary:** This phase focuses on building the user's first interaction with the extension: the onboarding and setup view. This UI is critical for user activation and must clearly guide the user through configuring the necessary database and embedding providers for a new, un-indexed repository.
  * **Dependencies:** Requires the foundational SvelteKit and Fluent UI boilerplate (from the previous UI/UX roadmap) to be in place. The VS Code extension must be able to detect whether a repository has an existing configuration.

-----

**2. Goals & Success Metrics**

  * **Business Objectives:**
      * Maximize the rate of successful user onboarding (i.e., users who complete the setup and start indexing).
      * Minimize user confusion and support requests by making the setup process intuitive and self-explanatory.
  * **User Success Metrics:**
      * A new user can successfully configure and start the indexing process in under 2 minutes.
      * The UI provides clear feedback and status indicators (e.g., "database is running") to build user confidence.
      * The setup completion rate (users who click "Index Now") is above 85% for first-time users.

-----

**3. User Personas**

  * **Devin (Developer - End User):** Devin has just installed the extension and opened a project. He needs a simple, step-by-step process to get started. He doesn't want to read lengthy documentation; the UI should guide him through the necessary choices and actions.

-----

**4. Requirements Breakdown**

| Phase | Sprint | User Story | Acceptance Criteria | Duration |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1: Onboarding** | **Sprint 1: Setup View Implementation** | As Devin, when I open an un-indexed project, I want to see a clear setup screen so I know what I need to do to get started. | 1. The extension correctly identifies when no `code-context.json` file is present and displays the `SetupView` component.\<br/\>2. The view contains distinct sections for "Database Configuration" and "Embedding Provider".\<br/\>3. The primary call-to-action button ("Index Now") is initially disabled. | **2 Weeks** |
| | | As Devin, I want to select my desired vector database and get help starting it if it's not running. | 1. A dropdown allows selecting "Qdrant".\<br/\>2. A button labeled "Start Local Qdrant" is visible.\<br/\>3. Clicking the button opens a new VS Code terminal and executes the `docker-compose up` command.\<br/\>4. A status icon next to the dropdown changes from "Not Running" to "Running" after a successful health check to the backend service. | |
| | | As Devin, I want to choose which embedding model to use for indexing my code. | 1. A dropdown allows selecting an embedding provider (e.g., "Ollama", "OpenAI").\<br/\>2. The "Index Now" button becomes enabled only after both the database is confirmed running and an embedding provider has been selected.\<br/\>3. The chosen configuration is saved to a state management store. | |

-----

**5. Timeline & Sprints**

  * **Total Estimated Time:** 2 Weeks
  * **Sprint 1:** Setup View Implementation (2 Weeks)

-----

**6. Risks & Assumptions**

  * **Assumption:** Users will have Docker installed and running on their machine for local database setup.
  * **Risk:** The logic for detecting if a local service (like Qdrant) is running could be unreliable across different user machine setups.
      * **Mitigation:** Rely on the C\# backend to perform the health check and pass a simple boolean status to the frontend. This centralizes the logic and makes the UI's job simpler.
  * **Risk:** The user might be confused about what to do if the Docker command fails.
      * **Mitigation:** The TypeScript extension should monitor the terminal process it creates. If the process exits with a non-zero code, display a VS Code error notification with a link to a troubleshooting guide in the `README`.

-----

### **New Document: Sub-Sprint 1: Database Configuration Component**

**Objective:**
To build the Svelte component for the database selection and management part of the setup view.

**Parent Sprint:**
PRD 1, Sprint 1: Setup View Implementation

**Tasks:**

1.  **Create `DatabaseSetup.svelte` component:** Build the UI with a Fluent UI `<Select>` component for the database choice.
2.  **Implement "Start" button:** Add a Fluent UI `<Button>` that, when clicked, sends a message to the TypeScript extension backend to execute the Docker command.
3.  **Display Status Indicator:** Add a small status icon and text (e.g., " Not Running" / " Running") that is bound to a reactive variable from a Svelte store.
4.  **Backend Message Handling:** The TypeScript extension will listen for the "startDatabase" message, create a new VS Code `Terminal`, and run the command.

**Acceptance Criteria:**

  * The dropdown displays "Qdrant" as an option.
  * Clicking the button successfully opens a terminal and runs `docker-compose up`.
  * The UI status correctly reflects the health status received from the backend.

**Dependencies:**

  * VS Code extension boilerplate must be complete.
  * A `docker-compose.yml` file must exist in the project root.

**Timeline:**

  * **Start Date:** 2026-01-05
  * **End Date:** 2026-01-09

-----

### **New Document: Sub-Sprint 2: Embedding Provider & Workflow Logic**

**Objective:**
To build the embedding provider selection component and the final workflow logic to enable indexing.

**Parent Sprint:**
PRD 1, Sprint 1: Setup View Implementation

**Tasks:**

1.  **Create `EmbeddingSetup.svelte` component:** Build the UI with a Fluent UI `<Select>` to choose between "Ollama" and "OpenAI".
2.  **Implement Main "Index Now" Button:** Create the primary call-to-action button for the setup view.
3.  **Create Svelte Store for State:** Implement a Svelte writable store to manage the overall setup state (e.g., `databaseReady`, `providerSelected`).
4.  **Conditional Button Logic:** The "Index Now" button's `disabled` attribute should be reactively bound to the store's state, enabling only when all conditions are met.
5.  **Trigger Indexing:** When clicked, the button sends a "startIndexing" message to the backend with the selected configuration.

**Acceptance Criteria:**

  * The dropdown displays "Ollama" and "OpenAI" as options.
  * The "Index Now" button is disabled by default.
  * The button becomes enabled after the database is running AND a provider is selected.
  * Clicking the button successfully sends the configuration details to the extension backend.

**Dependencies:**

  * Sub-Sprint 1 must be complete.

**Timeline:**

  * **Start Date:** 2026-01-12
  * **End Date:** 2026-01-16

-----

### **New Document: tasklist\_sprint\_01.md**

# Task List: Sprint 1 - Setup View Implementation

**Goal:** To build the complete user onboarding and setup UI within the VS Code extension's webview.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Create `SetupView.svelte` main component:** This component will act as the container for the setup process. | `webview/src/lib/views/SetupView.svelte` |
| **1.2** |  To Do | **Implement `DatabaseSetup.svelte` component:** Build the UI for database selection, the "Start" button, and status indicator. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.3** |  To Do | **Implement `EmbeddingSetup.svelte` component:** Build the UI for embedding provider selection. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.4** |  To Do | **Create `setupStore.ts`:** Define a Svelte store to manage the configuration state (`database`, `provider`, `isDbRunning`). | `webview/src/lib/stores/setupStore.ts` |
| **1.5** |  To Do | **Add `runCommandInTerminal` to extension backend:** In `extension.ts`, create a handler that receives a command string from the webview and executes it in a new VS Code terminal. | `src/extension.ts` |
| **1.6** |  To Do | **Implement state logic:** Connect the components to the store so that selecting options updates the state. | `webview/src/lib/views/SetupView.svelte` |
| **1.7** |  To Do | **Bind "Index Now" button's disabled state:** Use a reactive statement in Svelte (`$:`) to derive the button's state from the store. | `webview/src/lib/views/SetupView.svelte` |
| **1.8** |  To Do | **Test full UI flow:** Manually test the entire onboarding process: start database, select provider, and ensure the "Index Now" button enables correctly. | `(Manual Test)` |

</prd>

[backlog template]

```
<prompt>
  <purpose>
    You are an expert AI Project Manager and Senior Software Architect. Your primary role is to analyze user requirements, Product Requirement Documents (PRDs), and an existing codebase to generate a comprehensive, step-by-step implementation plan. You will break down features into a detailed backlog, including user stories, atomic actions, file references, and testing criteria, following a structured and iterative process.
  </purpose>
  <instructions>
    <instruction>
      **Phase 1: Analysis and Objective Setting**
      1.  Thoroughly analyze all attached documents within [[user-provided-files]]. Pay special attention to:
          - A file named `repomix-output-all.md` or similar, which contains the entire application's code structure.
          - A Product Requirement Document (PRD) or a requirements file.
      2.  From the [[user-prompt]], identify the specific sprint, feature, or section that requires implementation.
      3.  Define the high-level objective for implementing this feature based on the PRD and user prompt.
    </instruction>
    <instruction>
      **Phase 2: Iterative Backlog Generation**
      For each distinct requirement or user story within the specified sprint/feature, you will perform the following loop:
      1.  **Draft User Story**: Write a clear user story with a role, goal, and outcome.
      2.  **Define Workflow**: Outline the high-level workflow needed for implementation.
      3.  **Codebase Review**: Search the `repomix` file to identify existing code, components, or files that can be reused or need to be modified.
      4.  **Identify File Changes**: Determine the exact list of files that need to be created or amended.
      5.  **Detail Actions to Undertake**: Create a granular, step-by-step list of actions. Each action must be atomic and include:
          - `Filepath`: The full path to the file being changed.
          - `Action`: A description of the change (e.g., "Add new method `calculateTotal` to class `Billing`").
          - `Implementation`: The precise code snippet to be added or modified.
          - `Imports`: Any new import statements required for the change.
      6.  **Define Acceptance Criteria**: Write clear, measurable criteria for the user story to be considered complete.
      7.  **Outline Testing Plan**: Propose specific test cases to validate the functionality.
      8.  **Review and Refine**: Briefly review the drafted user story and actions to ensure they align with the main objective before moving to the next story.
    </instruction>
    <instruction>
      **Phase 3: Final Output Compilation**
      1.  Consolidate the entire backlog into separate, well-formatted Markdown canvas document.
      2.  Use clear headings and subheadings as demonstrated in the examples.
      3.  Ensure the final output is logical, easy to follow, and provides a clear roadmap for a developer to implement the changes.
        Note: please ensure each backlog is in a separate canvas document.
    </instruction>
  </instructions>
  <examples>
    <example>
      <user-request>
        Focus on the "User Logout" feature. The PRD specifies a logout button should be added to the main navigation bar. The `repomix` file shows a React component called `Navbar.js`.
      </user-request>
      <output>
        ### User Story 1: User Logout
        **As a** logged-in user, **I want to** click a "Logout" button in the navigation bar, **so that** I can securely end my session.

        **Actions to Undertake:**
        1.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Add a logout button element.
            -   **Implementation**: `<button onClick={handleLogout}>Logout</button>`
            -   **Imports**: `import { useAuth } from '../contexts/AuthContext';`
        2.  **Filepath**: `src/components/Navbar.js`
            -   **Action**: Implement the `handleLogout` function.
            -   **Implementation**: `const { logout } = useAuth(); const handleLogout = () => { logout(); };`
            -   **Imports**: None.
        3.  **Filepath**: `src/contexts/AuthContext.js`
            -   **Action**: Ensure a `logout` function exists that clears the user's session.
            -   **Implementation**: `const logout = () => { setUser(null); localStorage.removeItem('authToken'); };`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   A "Logout" button is visible in the Navbar.
        -   Clicking the button clears the user's session and redirects to the login page.

        **Testing Plan:**
        -   **Test Case 1**: Log in and verify the "Logout" button appears.
        -   **Test Case 2**: Click the "Logout" button and confirm the user is redirected and the session is cleared.
      </output>
    </example>
    <example>
      <user-request>
        Implement the "Character Counter" for the new post input field as per the PRD. The `repomix` file shows a component at `src/features/posts/NewPost.js`.
      </user-request>
      <output>
        ### User Story 2: Post Character Counter
        **As a** user writing a new post, **I want to** see a character counter below the text input, **so that** I know how close I am to the character limit (280).

        **Actions to Undertake:**
        1.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a state variable to track the input text.
            -   **Implementation**: `const [content, setContent] = useState('');`
            -   **Imports**: `import { useState } from 'react';`
        2.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Update the `textarea` to use the new state.
            -   **Implementation**: `<textarea value={content} onChange={(e) => setContent(e.target.value)} maxLength="280" />`
            -   **Imports**: None.
        3.  **Filepath**: `src/features/posts/NewPost.js`
            -   **Action**: Add a character counter display element.
            -   **Implementation**: `<p>{content.length} / 280</p>`
            -   **Imports**: None.

        **Acceptance Criteria:**
        -   As the user types in the textarea, a counter below it updates in real-time.
        -   The counter format is "current_length / 280".
        -   The user cannot type more than 280 characters.

        **Testing Plan:**
        -   **Test Case 1**: Type 50 characters and verify the counter shows "50 / 280".
        -   **Test Case 2**: Clear the text and verify the counter shows "0 / 280".
        -   **Test Case 3**: Try to paste 300 characters and verify only 280 are accepted.
      </output>
    </example>
    <example>
      <user-request>
        Create a new "Settings" page that is currently just a placeholder. The PRD states it should be accessible from the main app router.
      </user-request>
      <output>
        ### User Story 3: Create Settings Page
        **As a** user, **I want to** navigate to a "Settings" page, **so that** I can manage my account preferences in the future.

        **List of Files to be Created:**
        -   `src/pages/Settings.js`

        **Actions to Undertake:**
        1.  **Filepath**: `src/pages/Settings.js` (New File)
            -   **Action**: Create a placeholder React component for the Settings page.
            -   **Implementation**: `import React from 'react';

const Settings = () => {
  return <h1>Settings Page</h1>;
};

export default Settings;`
            -   **Imports**: `import React from 'react';`
        2.  **Filepath**: `src/App.js`
            -   **Action**: Add a new route for the Settings page.
            -   **Implementation**: `<Route path="/settings" element={<Settings />} />`
            -   **Imports**: `import Settings from './pages/Settings';`

        **Acceptance Criteria:**
        -   Navigating to the `/settings` URL renders the "Settings Page" heading.
        -   The application does not crash.

        **Testing Plan:**
        -   **Test Case 1**: Manually navigate to `/settings` in the browser and verify the page loads with the correct heading.
      </output>
    </example>
  </examples>
  <sections>
    <user-provided-files>
       see attached markdown files. Usually we would include the repomix file usually named 'repomix-output-all.xml' or .md or similar filename which would contain the concatenated source code and structure of the application.
	   I would also provide the prd, or high level detail of the requirement.
    </user-provided-files>
    <user-prompt>
        Following the PRD: ` ` you now have to generate backlogs for each sprint item in that PRD. ensure you undertake a detail review, web search (to add relevant api information, and implementation) before you produce each backlog. Ensure we have one new canvas for each backlog sprint item. Ensure you review and markdown or xml repomix files attached to get an understanding of the existing context.
        Create new canvas doc for sprint X and X backlog
    </user-prompt>
  </sections>
</prompt>
```

[implementation guidance template]

```
how do i implement the sprints x to x , undertake a full websearch, determine which content is suitable and then, provide code example, api information and further guidance on using external api/packages to complete the task. Review 'prd', (if available) the existing code inin your analysis. Ensure each guide is produced in their own individual canvas document
```

<instructions>

<instruction>
Step 1: Initial Repository Context Analysis.
Begin by thoroughly analyzing the entire codebase in the repository. Perform a static analysis to understand the project structure, common patterns, and key architectural components. Identify the main folders, file naming conventions, and the purpose of the primary modules. This initial, broad review is crucial for contextual understanding before focusing on specific items.
</instruction>
<instruction>
Step 2: Deconstruct the Product Requirements Document (PRD).
Review the entire PRD and identify each distinct feature, task, or user story. Create a list of these individual "sprint items". This list will serve as your master checklist for the documents you need to create.
</instruction>
<instruction>
Step 3: Begin Processing the First Sprint Item.
Select the first sprint item from the list you created in Step 2. All subsequent steps until the final instruction will be performed for this single item.
</instruction>
<instruction>
Step 4: Conduct a Detailed Review of the Sprint Item.
Focus exclusively on the selected sprint item. Read its description, acceptance criteria, and any associated notes in the PRD. Clearly define the scope and objectives of this specific item.
</instruction>
<instruction>
Step 5: Perform Targeted Web and Repository Searches.
Based on the sprint item's requirements, conduct a web search to find relevant API documentation, libraries, best practices, or potential implementation examples. Simultaneously, search within the existing codebase for any files, functions, or modules that are related to the item. This connects external research with internal context.
</instruction>
<instruction>
Step 6: Create the Backlog Markdown File.
Locate the file named [backlog template]. Create a new markdown file for the sprint item. Name it appropriately (e.g., backlog_sprint_item_name.md). Populate this new file by filling out the template using the information gathered from the PRD review (Step 4) and your research (Step 5).
</instruction>
<instruction>
Step 7: Create the Implementation Guidance Markdown File.
Locate the file named [implementation guidance template]. Create another new markdown file. Name it to correspond with the backlog item (e.g., implementation_sprint_item_name.md). Populate this file by filling out the template, focusing on the technical details, code-level suggestions, relevant API endpoints, and file paths you discovered during your searches (Step 5).
</instruction>
<instruction>
Step 8: Save the New Files.
Ensure both newly created markdown files (the backlog and the implementation guidance) are saved in the same folder where this prompt file is located.
</instruction>
<instruction>
Step 9: Repeat for All Remaining Sprint Items.
If there are more sprint items on your list from Step 2, return to Step 3 and repeat the entire process (Steps 3 through 8) for the next item. Continue this loop until a backlog and an implementation guidance file have been created for every single item on your list.
</instruction>
<instruction>
Step 10: Final Verification.
Once all sprint items have been processed, perform a final check. Verify that for every item identified in the PRD, there are exactly two corresponding markdown files (one backlog, one implementation guidance) located in the correct folder.
</instruction>

</instructions>

<notes>
<note>
Note 1: Template Adherence.
You must strictly use the provided [backlog template] and [implementation guidance template] for all generated files. Do not deviate from their structure.
</note>
<note>
Note 2: One-to-One File-to-Item Ratio.
For every single sprint item identified in the PRD, you must produce exactly one backlog markdown file and one implementation guidance markdown file.
</note>
<note>
Note 3: Naming Conventions.
All new files must follow a consistent naming convention that clearly links them to the sprint item, for example: backlog_sprint_item_name.md and implementation_sprint_item_name.md.
</note>
<note>
Note 4: File Location.
All generated markdown files must be created and saved in the exact same folder as the prompt file.
</note>
<note>
Note 5: Atomic Processing.
Each sprint item must be processed individually and completely (from detailed review to file creation) before moving to the next item. Do not batch-process steps.
</note>
<note>
Note 6: Foundational Analysis.
The initial repository context analysis (Step 1) is mandatory and must be completed before processing any sprint items. This step is critical for providing relevant and accurate guidance.
</note>
</notes>
</file>

<file path="docs/todo/ux/tasklist_sprint_01.md">
# Task List: Sprint 1 - Onboarding & Setup UI

**Goal:** To build the complete user onboarding and setup UI, from initializing the SvelteKit project to enabling the final "Index Now" button based on user configuration.

| Task ID | Status | Task Description (Sequential & Atomic Steps) | File(s) To Modify |
| :--- | :--- | :--- | :--- |
| **1.1** |  To Do | **Project Setup:** In the `webview` directory, initialize a new SvelteKit project with TypeScript support. | `webview/` |
| **1.2** |  To Do | **Project Setup:** Run `npm install` within the new `webview` directory. | `webview/` |
| **1.3** |  To Do | **Configuration:** Install `@sveltejs/adapter-static`. | `webview/package.json` |
| **1.4** |  To Do | **Configuration:** Configure `svelte.config.js` to use `adapter-static` and set the `fallback` page to `index.html`. | `webview/svelte.config.js` |
| **1.5** |  To Do | **UI Framework:** Install Fluent UI dependencies: `@svelte-fui/core` and `@svelte-fui/tailwindcss`. | `webview/package.json` |
| **1.6** |  To Do | **UI Framework:** Configure `tailwind.config.js` to use the `svelte-fui` preset. | `webview/tailwind.config.js` |
| **1.7** |  To Do | **State Management:** Create the Svelte store file `setupStore.ts` with `databaseReady` and `providerSelected` properties. | `webview/src/lib/stores/setupStore.ts` |
| **1.8** |  To Do | **TDD:** Write a basic test for the store to ensure its default state is correct. | `webview/src/lib/stores/setupStore.test.ts` |
| **1.9** |  To Do | **Component:** Create the `DatabaseSetup.svelte` component file. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.10**|  To Do | **TDD:** Write a failing test to check that `DatabaseSetup.svelte` renders a select, a button, and a status indicator. | `webview/src/lib/components/DatabaseSetup.test.ts` |
| **1.11**|  To Do | **Component:** Implement the UI for `DatabaseSetup.svelte` using Fluent UI components. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.12**|  To Do | **Component:** In `DatabaseSetup.svelte`, bind the status indicator to the `databaseReady` property of the store. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.13**|  To Do | **Component:** In `DatabaseSetup.svelte`, implement the `on:click` handler for the "Start" button to send a `startDatabase` message to the extension. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.14**|  To Do | **Component:** In `DatabaseSetup.svelte`, add a message listener to handle `databaseStatus` messages from the extension and update the store. | `webview/src/lib/components/DatabaseSetup.svelte` |
| **1.15**|  To Do | **TDD:** Pass the rendering test for `DatabaseSetup.svelte`. | `webview/src/lib/components/DatabaseSetup.test.ts` |
| **1.16**|  To Do | **Component:** Create the `EmbeddingSetup.svelte` component file. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.17**|  To Do | **TDD:** Write a failing test to check that `EmbeddingSetup.svelte` renders a select component. | `webview/src/lib/components/EmbeddingSetup.test.ts` |
| **1.18**|  To Do | **Component:** Implement the UI for `EmbeddingSetup.svelte` with "Ollama" and "OpenAI" options. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.19**|  To Do | **Component:** In `EmbeddingSetup.svelte`, implement the `on:change` handler to update the `providerSelected` property in the store. | `webview/src/lib/components/EmbeddingSetup.svelte` |
| **1.20**|  To Do | **TDD:** Pass the rendering test for `EmbeddingSetup.svelte`. | `webview/src/lib/components/EmbeddingSetup.test.ts` |
| **1.21**|  To Do | **Main View:** Create the main view file `+page.svelte` and import the `DatabaseSetup` and `EmbeddingSetup` components. | `webview/src/routes/+page.svelte` |
| **1.22**|  To Do | **Main View:** In `+page.svelte`, add the "Index Now" button. | `webview/src/routes/+page.svelte` |
| **1.23**|  To Do | **Main View:** In `+page.svelte`, create the derived state `$: canStartIndex` based on the store. | `webview/src/routes/+page.svelte` |
| **1.24**|  To Do | **Main View:** Bind the "Index Now" button's `disabled` state to the `canStartIndex` derived property. | `webview/src/routes/+page.svelte` |
| **1.25**|  To Do | **Main View:** Implement the `startIndexing` click handler to send the configuration from the store to the extension. | `webview/src/routes/+page.svelte` |
| **1.26**|  To Do | **Extension:** In `extension.ts`, add the command `code-context.setup` to create and load the webview panel. | `src/extension.ts` |
| **1.27**|  To Do | **Extension:** In `extension.ts`, implement the message listener to handle `startDatabase` and `startIndexing` commands. | `src/extension.ts` |
| **1.28**|  To Do | **Extension:** In the `startDatabase` handler, implement the logic to create a terminal and run `docker-compose up`. | `src/extension.ts` |
| **1.29**|  To Do | **Extension:** Implement the `pollQdrantHealth` function and call it after starting the database. | `src/extension.ts` |
| **1.30**|  To Do | **Extension:** On successful health check, send the `databaseStatus` message back to the webview. | `src/extension.ts` |
| **1.31**|  To Do | **Integration Test:** Manually test the complete end-to-end flow as described in the PRD's acceptance criteria. | `(Manual Test)` |
</file>

<file path="docs/sprint3-usage.md">
# Sprint 3: Vectorization & DB Integration - Usage Guide

## Overview

Sprint 3 adds AI-powered semantic search capabilities to the Code Context Engine. Your code is now vectorized using embedding models and stored in a Qdrant vector database for intelligent similarity search.

## Prerequisites

### 1. Start Qdrant Database

```bash
# Start Qdrant using Docker Compose
docker-compose up -d

# Verify Qdrant is running
curl http://localhost:6333/health
```

### 2. Choose Embedding Provider

#### Option A: Ollama (Local, Free)
```bash
# Install Ollama
curl -fsSL https://ollama.ai/install.sh | sh

# Pull the embedding model
ollama pull nomic-embed-text

# Verify Ollama is running
curl http://localhost:11434/api/tags
```

#### Option B: OpenAI (Cloud, Requires API Key)
1. Get an API key from [OpenAI](https://platform.openai.com/api-keys)
2. Set it in VS Code settings: `code-context-engine.openaiApiKey`
3. Set provider to "openai": `code-context-engine.embeddingProvider`

## Configuration

Open VS Code settings and configure:

```json
{
  "code-context-engine.embeddingProvider": "ollama", // or "openai"
  "code-context-engine.databaseConnectionString": "http://localhost:6333",
  "code-context-engine.openaiApiKey": "your-api-key-here" // Only for OpenAI
}
```

## Usage

### 1. Index Your Repository

1. Open your project in VS Code
2. Run command: `Code Context Engine: Open Main Panel`
3. Click "Index Repository"
4. Watch the progress through phases:
   - **Discovering**: Finding code files
   - **Parsing**: Creating ASTs with tree-sitter
   - **Chunking**: Breaking code into segments
   - **Embedding**: Generating vector embeddings
   - **Storing**: Saving to Qdrant database

### 2. Search Your Code

1. In the Code Context Engine panel, enter a search query
2. Examples:
   - "function that handles user authentication"
   - "error handling for API requests"
   - "database connection setup"
   - "React component for user profile"

3. Results show:
   - **File path** and **line numbers**
   - **Code snippet** with context
   - **Similarity score** (higher = more relevant)
   - **Code type** (function, class, method, etc.)

## How It Works

### Indexing Pipeline

1. **File Discovery**: Finds all code files, respects .gitignore
2. **AST Parsing**: Uses tree-sitter to parse code structure
3. **Code Chunking**: Breaks code into meaningful segments:
   - Functions and methods
   - Classes and interfaces
   - Modules and namespaces
   - Important code blocks

4. **Vectorization**: Converts code chunks to embeddings:
   - **Ollama**: Uses local `nomic-embed-text` model (768 dimensions)
   - **OpenAI**: Uses `text-embedding-ada-002` (1536 dimensions)

5. **Storage**: Saves vectors and metadata to Qdrant:
   - Collection name: `code_context_{workspace_name}`
   - Includes file path, line numbers, code type, content
   - Optimized for similarity search

### Search Process

1. **Query Embedding**: Your search query is converted to a vector
2. **Similarity Search**: Qdrant finds most similar code chunks
3. **Ranking**: Results ranked by cosine similarity score
4. **Formatting**: Results formatted for VS Code display

## Supported Languages

- **TypeScript** (.ts, .tsx)
- **JavaScript** (.js, .jsx)
- **Python** (.py)
- **C#** (.cs)

## Troubleshooting

### Qdrant Issues
```bash
# Check if Qdrant is running
docker ps | grep qdrant

# View Qdrant logs
docker-compose logs qdrant

# Restart Qdrant
docker-compose restart qdrant
```

### Ollama Issues
```bash
# Check if Ollama is running
curl http://localhost:11434/api/tags

# Pull embedding model
ollama pull nomic-embed-text

# List available models
ollama list
```

### OpenAI Issues
- Verify API key is correct in VS Code settings
- Check API quota and billing status
- Ensure internet connectivity

### Search Returns No Results
1. Verify indexing completed successfully
2. Check Qdrant collection exists: `curl http://localhost:6333/collections`
3. Try broader search terms
4. Re-index if collection is empty

## Performance Tips

- **Large repositories**: Indexing may take several minutes
- **Batch processing**: Embeddings are processed in batches for efficiency
- **Memory usage**: Large codebases require more RAM for vector storage
- **Search speed**: First search may be slower due to model loading

## Next Steps

Sprint 4 will add:
- Advanced query capabilities
- File content retrieval
- Related files discovery
- Context-aware suggestions
</file>

<file path="docs/sprint4-usage.md">
# Sprint 4: Context Query API - Usage Guide

## Overview

Sprint 4 adds advanced context query capabilities to the Code Context Engine. You can now retrieve file content, discover related files, and perform sophisticated queries with filtering and metadata.

## New Features

### 1. Enhanced Search Interface

The search interface now provides:
- **Similarity scores** for each result (percentage match)
- **Code type indicators** (function, class, method, etc.)
- **Language badges** for each code chunk
- **Direct file opening** from search results
- **Related files discovery** automatically shown with search results

### 2. Service Status Monitoring

Real-time status display showing:
- **Database Connection**: Qdrant connectivity status
- **Embedding Provider**: Current provider (Ollama/OpenAI) status
- **Collection Status**: Whether your workspace is indexed

### 3. File Content Viewer

Click "Open" on any search result to:
- View complete file content in a modal
- See file metadata (size, last modified, language)
- Navigate to specific line numbers
- View related code chunks from the same file

### 4. Related Files Discovery

For each search, the system automatically finds:
- Files with similar code patterns
- Related functionality across your codebase
- Similarity scores and reasoning for each suggestion
- Chunk counts showing how much related code exists

## API Capabilities

### File Content Retrieval

```typescript
// Get file content with related chunks
const content = await vscodeApi.getFileContent('src/utils/helper.ts', true);

// Result includes:
// - Full file content
// - File metadata (size, modified date, language)
// - Related code chunks from the same file
```

### Related Files Discovery

```typescript
// Find files related to a query
const relatedFiles = await vscodeApi.findRelatedFiles(
    'authentication logic',
    'src/auth/login.ts',  // exclude current file
    10,                   // max results
    0.6                   // minimum similarity threshold
);

// Results include:
// - File paths with similarity scores
// - Reasoning for why files are related
// - Chunk counts and language information
```

### Advanced Context Queries

```typescript
// Perform sophisticated queries with filtering
const result = await vscodeApi.queryContext({
    query: 'error handling patterns',
    includeRelated: true,
    maxResults: 20,
    minSimilarity: 0.7,
    fileTypes: ['typescript', 'javascript']  // filter by language
});

// Results include:
// - Matching code chunks with metadata
// - Related files automatically discovered
// - Processing time and total result counts
```

### Service Status Monitoring

```typescript
// Check service health and configuration
const status = await vscodeApi.getServiceStatus();

// Returns:
// - Qdrant database connectivity
// - Embedding provider status
// - Collection existence and info
```

## Enhanced UI Features

### Search Results

Each search result now displays:
- **File path** with clickable "Open" button
- **Code snippet** with syntax highlighting
- **Similarity percentage** as a badge
- **Code type and name** (e.g., "function: authenticateUser")
- **Line number and language** information

### Related Files Panel

Automatically populated with each search:
- **File paths** with similarity scores
- **Reasoning** explaining why files are related
- **Chunk counts** showing amount of related code
- **Language indicators** for each file

### Service Status Bar

Always visible status indicators:
- **Database**: Connected/Disconnected status
- **Embeddings**: Current provider (ollama:nomic-embed-text, openai:text-embedding-ada-002)
- **Collection**: Ready/Not indexed status

### File Content Modal

Click any "Open" button to see:
- **Complete file content** with syntax highlighting
- **File metadata** (size, modification date, language)
- **Related chunks** from the same file (if requested)
- **Easy navigation** with scroll and search

## Message-Based Architecture

The new API uses a robust message-passing system:

### Request/Response Pattern
- **Unique request IDs** for tracking
- **Timeout handling** (30 seconds default)
- **Error propagation** with detailed messages
- **Type-safe interfaces** for all operations

### Event Handling
- **Real-time updates** for indexing progress
- **Service status changes** automatically reflected
- **Search result streaming** for large result sets

## Performance Optimizations

### Batch Processing
- **Related files** discovered in parallel with search
- **File content** loaded on-demand
- **Service status** cached and updated periodically

### Smart Caching
- **Request deduplication** for identical queries
- **Status caching** to reduce API calls
- **Result pagination** for large datasets

## Error Handling

Comprehensive error handling for:
- **Network timeouts** with retry logic
- **Service unavailability** with graceful degradation
- **Invalid queries** with helpful error messages
- **File access errors** with fallback options

## Integration Points

### VS Code Integration
- **Command palette** access to all features
- **Settings synchronization** with VS Code preferences
- **Theme integration** for consistent appearance
- **Keyboard shortcuts** for common operations

### Extension API
- **Message routing** for all webview communication
- **Context service** handling all business logic
- **Type safety** throughout the request/response cycle
- **Extensible architecture** for future enhancements

## Next Steps

Sprint 5 will add:
- **Settings UI** for configuring providers and preferences
- **Advanced filtering** options in the interface
- **Workspace-specific** configurations
- **Performance tuning** controls

The Context Query API provides a solid foundation for intelligent code exploration and discovery!
</file>

<file path="src/lsp/lspService.ts">
/**
 * Language Server Protocol (LSP) Service
 * 
 * This service provides integration with VS Code's language servers to enrich
 * code chunks with semantic information like definitions, references, symbols,
 * and type information. It leverages the existing language servers that VS Code
 * uses for features like Go to Definition, Find References, etc.
 */

import * as vscode from 'vscode';
import { SupportedLanguage } from '../parsing/astParser';

/**
 * Represents a symbol definition from the LSP
 */
export interface LSPDefinition {
    /** The URI of the file containing the definition */
    uri: string;
    /** The range of the definition in the file */
    range: vscode.Range;
    /** The name of the symbol */
    name: string;
    /** The kind of symbol (function, class, variable, etc.) */
    kind: vscode.SymbolKind;
    /** Additional detail about the symbol */
    detail?: string;
}

/**
 * Represents a reference to a symbol from the LSP
 */
export interface LSPReference {
    /** The URI of the file containing the reference */
    uri: string;
    /** The range of the reference in the file */
    range: vscode.Range;
    /** Whether this is a definition or just a reference */
    isDefinition: boolean;
}

/**
 * Represents a symbol from the LSP
 */
export interface LSPSymbol {
    /** The name of the symbol */
    name: string;
    /** The kind of symbol */
    kind: vscode.SymbolKind;
    /** The range of the symbol */
    range: vscode.Range;
    /** The selection range (typically the name) */
    selectionRange: vscode.Range;
    /** Additional detail about the symbol */
    detail?: string;
    /** Child symbols (for classes, namespaces, etc.) */
    children?: LSPSymbol[];
}

/**
 * Represents hover information from the LSP
 */
export interface LSPHoverInfo {
    /** The hover content as markdown */
    contents: vscode.MarkdownString[];
    /** The range the hover applies to */
    range?: vscode.Range;
}

/**
 * LSP metadata that can be attached to code chunks
 */
export interface LSPMetadata {
    /** Symbols defined in this chunk */
    definitions: LSPDefinition[];
    /** References to other symbols from this chunk */
    references: LSPReference[];
    /** All symbols in this chunk */
    symbols: LSPSymbol[];
    /** Hover information for key symbols */
    hoverInfo: Record<string, LSPHoverInfo>;
    /** The language this metadata applies to */
    language: SupportedLanguage;
    /** Whether LSP data was successfully retrieved */
    hasLSPData: boolean;
}

/**
 * Service for interacting with VS Code's Language Server Protocol
 */
export class LSPService {
    private workspaceRoot: string;

    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
    }

    /**
     * Get LSP metadata for a code chunk
     * 
     * @param filePath - The path to the file
     * @param content - The content of the code chunk
     * @param startLine - The starting line of the chunk
     * @param endLine - The ending line of the chunk
     * @param language - The programming language
     * @returns Promise resolving to LSP metadata
     */
    async getMetadataForChunk(
        filePath: string,
        content: string,
        startLine: number,
        endLine: number,
        language: SupportedLanguage
    ): Promise<LSPMetadata> {
        try {
            const uri = vscode.Uri.file(filePath);
            const document = await vscode.workspace.openTextDocument(uri);
            
            // Create range for the chunk
            const range = new vscode.Range(
                new vscode.Position(startLine, 0),
                new vscode.Position(endLine, Number.MAX_SAFE_INTEGER)
            );

            // Get symbols in the document
            const symbols = await this.getDocumentSymbols(document);
            const chunkSymbols = this.filterSymbolsInRange(symbols, range);

            // Get definitions and references for symbols in the chunk
            const definitions: LSPDefinition[] = [];
            const references: LSPReference[] = [];
            const hoverInfo: Record<string, LSPHoverInfo> = {};

            for (const symbol of chunkSymbols) {
                // Get definition information
                const symbolDefinitions = await this.getDefinitions(document, symbol.selectionRange.start);
                definitions.push(...symbolDefinitions);

                // Get references
                const symbolReferences = await this.getReferences(document, symbol.selectionRange.start);
                references.push(...symbolReferences);

                // Get hover information
                const hover = await this.getHoverInfo(document, symbol.selectionRange.start);
                if (hover) {
                    hoverInfo[symbol.name] = hover;
                }
            }

            return {
                definitions,
                references,
                symbols: chunkSymbols,
                hoverInfo,
                language,
                hasLSPData: true
            };
        } catch (error) {
            console.warn(`Failed to get LSP metadata for ${filePath}:`, error);
            return {
                definitions: [],
                references: [],
                symbols: [],
                hoverInfo: {},
                language,
                hasLSPData: false
            };
        }
    }

    /**
     * Get document symbols from the LSP
     */
    private async getDocumentSymbols(document: vscode.TextDocument): Promise<LSPSymbol[]> {
        try {
            const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
                'vscode.executeDocumentSymbolProvider',
                document.uri
            );

            return symbols ? this.convertDocumentSymbols(symbols) : [];
        } catch (error) {
            console.warn('Failed to get document symbols:', error);
            return [];
        }
    }

    /**
     * Convert VS Code DocumentSymbol to our LSPSymbol format
     */
    private convertDocumentSymbols(symbols: vscode.DocumentSymbol[]): LSPSymbol[] {
        return symbols.map(symbol => ({
            name: symbol.name,
            kind: symbol.kind,
            range: symbol.range,
            selectionRange: symbol.selectionRange,
            detail: symbol.detail,
            children: symbol.children ? this.convertDocumentSymbols(symbol.children) : undefined
        }));
    }

    /**
     * Filter symbols that are within the specified range
     */
    private filterSymbolsInRange(symbols: LSPSymbol[], range: vscode.Range): LSPSymbol[] {
        const result: LSPSymbol[] = [];

        for (const symbol of symbols) {
            if (range.intersection(symbol.range)) {
                const filteredSymbol: LSPSymbol = {
                    ...symbol,
                    children: symbol.children ? this.filterSymbolsInRange(symbol.children, range) : undefined
                };
                result.push(filteredSymbol);
            }
        }

        return result;
    }

    /**
     * Get definitions for a symbol at a specific position
     */
    private async getDefinitions(document: vscode.TextDocument, position: vscode.Position): Promise<LSPDefinition[]> {
        try {
            const locations = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeDefinitionProvider',
                document.uri,
                position
            );

            if (!locations) return [];

            return locations.map(location => ({
                uri: location.uri.toString(),
                range: location.range,
                name: '', // Will be filled by caller
                kind: vscode.SymbolKind.Null, // Will be determined by caller
                detail: undefined
            }));
        } catch (error) {
            console.warn('Failed to get definitions:', error);
            return [];
        }
    }

    /**
     * Get references for a symbol at a specific position
     */
    private async getReferences(document: vscode.TextDocument, position: vscode.Position): Promise<LSPReference[]> {
        try {
            const locations = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeReferenceProvider',
                document.uri,
                position
            );

            if (!locations) return [];

            return locations.map(location => ({
                uri: location.uri.toString(),
                range: location.range,
                isDefinition: false // This would need more sophisticated logic to determine
            }));
        } catch (error) {
            console.warn('Failed to get references:', error);
            return [];
        }
    }

    /**
     * Get hover information for a symbol at a specific position
     */
    private async getHoverInfo(document: vscode.TextDocument, position: vscode.Position): Promise<LSPHoverInfo | null> {
        try {
            const hover = await vscode.commands.executeCommand<vscode.Hover>(
                'vscode.executeHoverProvider',
                document.uri,
                position
            );

            if (!hover) return null;

            return {
                contents: hover.contents as vscode.MarkdownString[],
                range: hover.range
            };
        } catch (error) {
            console.warn('Failed to get hover info:', error);
            return null;
        }
    }

    /**
     * Check if LSP is available for a given language
     */
    async isLSPAvailable(language: SupportedLanguage): Promise<boolean> {
        try {
            // Create a temporary document to test LSP availability
            const tempContent = this.getTestContent(language);
            const tempDoc = await vscode.workspace.openTextDocument({
                content: tempContent,
                language: this.getVSCodeLanguageId(language)
            });

            // Try to get symbols - if this works, LSP is available
            const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
                'vscode.executeDocumentSymbolProvider',
                tempDoc.uri
            );

            return symbols !== undefined;
        } catch (error) {
            console.warn(`LSP not available for ${language}:`, error);
            return false;
        }
    }

    /**
     * Get test content for checking LSP availability
     */
    private getTestContent(language: SupportedLanguage): string {
        switch (language) {
            case 'typescript':
                return 'function test() { return "hello"; }';
            case 'javascript':
                return 'function test() { return "hello"; }';
            case 'python':
                return 'def test():\n    return "hello"';
            case 'csharp':
                return 'public class Test { public string Method() { return "hello"; } }';
            default:
                return '';
        }
    }

    /**
     * Convert our language enum to VS Code language identifiers
     */
    private getVSCodeLanguageId(language: SupportedLanguage): string {
        switch (language) {
            case 'typescript':
                return 'typescript';
            case 'javascript':
                return 'javascript';
            case 'python':
                return 'python';
            case 'csharp':
                return 'csharp';
            default:
                return 'plaintext';
        }
    }
}
</file>

<file path="src/test/suite/configService.test.ts">
import * as assert from 'assert';
import * as vscode from 'vscode';
import { ConfigService } from '../../configService';

/**
 * Test suite for ConfigService
 *
 * These tests verify that the ConfigService correctly reads and provides
 * configuration values from VS Code settings.
 */
suite('ConfigService Tests', () => {
    let configService: ConfigService;

    setup(() => {
        configService = new ConfigService();
    });

    test('should provide default Qdrant connection string', () => {
        const connectionString = configService.getQdrantConnectionString();
        assert.strictEqual(typeof connectionString, 'string');
        assert.ok(connectionString.length > 0);
    });

    test('should provide database configuration', () => {
        const dbConfig = configService.getDatabaseConfig();
        assert.strictEqual(dbConfig.type, 'qdrant');
        assert.strictEqual(typeof dbConfig.connectionString, 'string');
    });

    test('should provide embedding provider type', () => {
        const provider = configService.getEmbeddingProvider();
        assert.ok(provider === 'ollama' || provider === 'openai');
    });

    test('should provide Ollama configuration', () => {
        const ollamaConfig = configService.getOllamaConfig();
        assert.strictEqual(typeof ollamaConfig.apiUrl, 'string');
        assert.strictEqual(typeof ollamaConfig.model, 'string');
        assert.strictEqual(typeof ollamaConfig.timeout, 'number');
        assert.strictEqual(typeof ollamaConfig.maxBatchSize, 'number');
    });

    test('should provide OpenAI configuration', () => {
        const openaiConfig = configService.getOpenAIConfig();
        assert.strictEqual(typeof openaiConfig.apiKey, 'string');
        assert.strictEqual(typeof openaiConfig.model, 'string');
        assert.strictEqual(typeof openaiConfig.timeout, 'number');
        assert.strictEqual(typeof openaiConfig.maxBatchSize, 'number');
    });

    test('should provide indexing configuration', () => {
        const indexingConfig = configService.getIndexingConfig();
        assert.ok(Array.isArray(indexingConfig.excludePatterns));
        assert.ok(Array.isArray(indexingConfig.supportedLanguages));
        assert.strictEqual(typeof indexingConfig.maxFileSize, 'number');
        assert.strictEqual(typeof indexingConfig.chunkSize, 'number');
        assert.strictEqual(typeof indexingConfig.chunkOverlap, 'number');
    });

    test('should provide full configuration', () => {
        const fullConfig = configService.getFullConfig();
        assert.ok(fullConfig.database);
        assert.ok(fullConfig.embeddingProvider);
        assert.ok(fullConfig.ollama);
        assert.ok(fullConfig.openai);
        assert.ok(fullConfig.indexing);
    });

    test('should check provider configuration status', () => {
        const ollamaConfigured = configService.isProviderConfigured('ollama');
        const openaiConfigured = configService.isProviderConfigured('openai');
        
        assert.strictEqual(typeof ollamaConfigured, 'boolean');
        assert.strictEqual(typeof openaiConfigured, 'boolean');
    });

    test('should get current provider configuration', () => {
        const currentConfig = configService.getCurrentProviderConfig();
        assert.ok(currentConfig);
        
        // Should have either Ollama or OpenAI properties
        const hasOllamaProps = 'apiUrl' in currentConfig;
        const hasOpenAIProps = 'apiKey' in currentConfig;
        assert.ok(hasOllamaProps || hasOpenAIProps);
    });

    test('should refresh configuration', () => {
        // This test verifies that refresh doesn't throw an error
        assert.doesNotThrow(() => {
            configService.refresh();
        });
    });
});
</file>

<file path="src/test/suite/dependencyInjection.test.ts">
import * as assert from 'assert';
import { ConfigService } from '../../configService';
import { QdrantService } from '../../db/qdrantService';
import { ContextService } from '../../context/contextService';
import { IndexingService } from '../../indexing/indexingService';
import {
    MockQdrantService,
    MockEmbeddingProvider,
    MockFileWalker,
    MockAstParser,
    MockChunker,
    MockLspService
} from '../mocks';

/**
 * Test suite for Dependency Injection
 * 
 * These tests verify that our services can be properly instantiated with
 * injected dependencies and that they work correctly in isolation.
 */
suite('Dependency Injection Tests', () => {
    let configService: ConfigService;
    let mockQdrantService: MockQdrantService;
    let mockEmbeddingProvider: MockEmbeddingProvider;

    setup(() => {
        configService = new ConfigService();
        mockQdrantService = new MockQdrantService();
        mockEmbeddingProvider = new MockEmbeddingProvider();
    });

    test('should create QdrantService with injected connection string', () => {
        const connectionString = 'http://test:6333';
        const qdrantService = new QdrantService(connectionString);
        
        assert.ok(qdrantService);
        // QdrantService should be created without throwing
    });

    test('should create ContextService with injected dependencies', () => {
        const workspaceRoot = '/test/workspace';
        const mockFileWalker = new MockFileWalker(workspaceRoot);
        const mockAstParser = new MockAstParser();
        const mockChunker = new MockChunker();
        const mockLspService = new MockLspService(workspaceRoot);
        
        const mockIndexingService = new IndexingService(
            workspaceRoot,
            mockFileWalker as any,
            mockAstParser as any,
            mockChunker as any,
            mockQdrantService as any,
            mockEmbeddingProvider,
            mockLspService as any
        );

        const contextService = new ContextService(
            workspaceRoot,
            mockQdrantService as any,
            mockEmbeddingProvider,
            mockIndexingService
        );

        assert.ok(contextService);
        // ContextService should be created without throwing
    });

    test('should create IndexingService with all injected dependencies', () => {
        const workspaceRoot = '/test/workspace';
        const mockFileWalker = new MockFileWalker(workspaceRoot);
        const mockAstParser = new MockAstParser();
        const mockChunker = new MockChunker();
        const mockLspService = new MockLspService(workspaceRoot);

        const indexingService = new IndexingService(
            workspaceRoot,
            mockFileWalker as any,
            mockAstParser as any,
            mockChunker as any,
            mockQdrantService as any,
            mockEmbeddingProvider,
            mockLspService as any
        );

        assert.ok(indexingService);
        // IndexingService should be created without throwing
    });

    test('should allow mocking of QdrantService behavior', async () => {
        // Test that we can control mock behavior
        mockQdrantService.setHealthy(false);
        const isHealthy = await mockQdrantService.healthCheck();
        assert.strictEqual(isHealthy, false);

        mockQdrantService.setHealthy(true);
        const isHealthyNow = await mockQdrantService.healthCheck();
        assert.strictEqual(isHealthyNow, true);
    });

    test('should allow mocking of EmbeddingProvider behavior', async () => {
        // Test that we can control mock behavior
        mockEmbeddingProvider.setAvailable(false);
        const isAvailable = await mockEmbeddingProvider.isAvailable();
        assert.strictEqual(isAvailable, false);

        mockEmbeddingProvider.setAvailable(true);
        const isAvailableNow = await mockEmbeddingProvider.isAvailable();
        assert.strictEqual(isAvailableNow, true);
    });

    test('should generate mock embeddings', async () => {
        const chunks = ['test chunk 1', 'test chunk 2'];
        const embeddings = await mockEmbeddingProvider.generateEmbeddings(chunks);
        
        assert.strictEqual(embeddings.length, 2);
        assert.strictEqual(embeddings[0].length, mockEmbeddingProvider.getDimensions());
        assert.strictEqual(embeddings[1].length, mockEmbeddingProvider.getDimensions());
    });

    test('should allow configuration of mock dimensions', () => {
        const newDimensions = 1024;
        mockEmbeddingProvider.setDimensions(newDimensions);
        assert.strictEqual(mockEmbeddingProvider.getDimensions(), newDimensions);
    });

    test('should allow configuration of mock provider name', () => {
        const newName = 'test-provider';
        mockEmbeddingProvider.setProviderName(newName);
        assert.strictEqual(mockEmbeddingProvider.getProviderName(), newName);
    });

    test('should support mock file operations', async () => {
        const mockFileWalker = new MockFileWalker('/test');
        const testFiles = ['file1.ts', 'file2.js', 'file3.py'];
        
        mockFileWalker.setMockFiles(testFiles);
        const files = await mockFileWalker.getFiles();
        
        assert.deepStrictEqual(files, testFiles);
    });

    test('should support mock chunking operations', () => {
        const mockChunker = new MockChunker();
        const testContent = 'function test() { return "hello"; }';
        
        const chunks = mockChunker.chunkCode(testContent, 'test.ts', 'typescript');
        
        assert.ok(Array.isArray(chunks));
        assert.ok(chunks.length > 0);
        assert.strictEqual(chunks[0].filePath, 'test.ts');
        assert.strictEqual(chunks[0].language, 'typescript');
    });
});
</file>

<file path="src/test/suite/index.ts">
import * as path from 'path';
import { glob } from 'glob';

export function run(): Promise<void> {
    // Create the mocha test
    const Mocha = require('mocha');
    const mocha = new Mocha({
        ui: 'tdd',
        color: true
    });

    const testsRoot = path.resolve(__dirname, '..');

    return new Promise((c, e) => {
        glob('**/**.test.js', { cwd: testsRoot }, (err: Error | null, files: string[]) => {
            if (err) {
                return e(err);
            }

            // Add files to the test suite
            files.forEach((f: string) => mocha.addFile(path.resolve(testsRoot, f)));

            try {
                // Run the mocha test
                mocha.run((failures: number) => {
                    if (failures > 0) {
                        e(new Error(`${failures} tests failed.`));
                    } else {
                        c();
                    }
                });
            } catch (err) {
                console.error(err);
                e(err);
            }
        });
    });
}
</file>

<file path="src/test/mocks.ts">
/**
 * Mock implementations for testing services in isolation
 * 
 * This file contains mock classes that implement the same interfaces as the real services
 * but provide predictable, controllable behavior for unit testing.
 */

import { QdrantPoint, SearchResult } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { CodeChunk, ChunkType } from '../parsing/chunker';
import { SupportedLanguage } from '../parsing/astParser';

/**
 * Mock implementation of QdrantService for testing
 */
export class MockQdrantService {
    private collections: Set<string> = new Set();
    private points: Map<string, QdrantPoint[]> = new Map();
    private isHealthy = true;

    async healthCheck(): Promise<boolean> {
        return this.isHealthy;
    }

    async createCollectionIfNotExists(
        collectionName: string,
        vectorSize: number = 768,
        distance: 'Cosine' | 'Dot' | 'Euclid' = 'Cosine'
    ): Promise<boolean> {
        this.collections.add(collectionName);
        if (!this.points.has(collectionName)) {
            this.points.set(collectionName, []);
        }
        return true;
    }

    async deleteCollection(collectionName: string): Promise<boolean> {
        this.collections.delete(collectionName);
        this.points.delete(collectionName);
        return true;
    }

    async upsertPoints(collectionName: string, points: QdrantPoint[]): Promise<boolean> {
        if (!this.collections.has(collectionName)) {
            await this.createCollectionIfNotExists(collectionName);
        }
        
        const existingPoints = this.points.get(collectionName) || [];
        
        // Update or insert points
        for (const newPoint of points) {
            const existingIndex = existingPoints.findIndex(p => p.id === newPoint.id);
            if (existingIndex >= 0) {
                existingPoints[existingIndex] = newPoint;
            } else {
                existingPoints.push(newPoint);
            }
        }
        
        this.points.set(collectionName, existingPoints);
        return true;
    }

    async search(
        collectionName: string,
        queryVector: number[],
        limit: number = 10,
        filter?: any
    ): Promise<SearchResult[]> {
        const points = this.points.get(collectionName) || [];
        
        // Simple mock search - return first N points with random scores
        return points.slice(0, limit).map((point, index) => ({
            id: point.id,
            score: 0.9 - (index * 0.1), // Decreasing scores
            payload: point.payload
        }));
    }

    async getCollectionInfo(collectionName: string): Promise<any> {
        if (!this.collections.has(collectionName)) {
            throw new Error(`Collection ${collectionName} does not exist`);
        }
        
        const points = this.points.get(collectionName) || [];
        return {
            status: 'green',
            vectors_count: points.length,
            indexed_vectors_count: points.length,
            points_count: points.length
        };
    }

    // Test helper methods
    setHealthy(healthy: boolean): void {
        this.isHealthy = healthy;
    }

    getPointsCount(collectionName: string): number {
        return this.points.get(collectionName)?.length || 0;
    }

    clearAllData(): void {
        this.collections.clear();
        this.points.clear();
    }
}

/**
 * Mock implementation of IEmbeddingProvider for testing
 */
export class MockEmbeddingProvider implements IEmbeddingProvider {
    private isAvailableFlag = true;
    private dimensions = 768;
    private providerName = 'mock-provider';

    async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        // Generate mock embeddings - arrays of random numbers
        return chunks.map(() => 
            Array.from({ length: this.dimensions }, () => Math.random() - 0.5)
        );
    }

    getDimensions(): number {
        return this.dimensions;
    }

    getProviderName(): string {
        return this.providerName;
    }

    async isAvailable(): Promise<boolean> {
        return this.isAvailableFlag;
    }

    // Test helper methods
    setAvailable(available: boolean): void {
        this.isAvailableFlag = available;
    }

    setDimensions(dims: number): void {
        this.dimensions = dims;
    }

    setProviderName(name: string): void {
        this.providerName = name;
    }
}

/**
 * Mock implementation of FileWalker for testing
 */
export class MockFileWalker {
    private workspaceRoot: string;
    private ignoreInstance: any;
    private mockFiles: string[] = [];

    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
        this.ignoreInstance = { add: () => {}, ignores: () => false };
    }

    private async loadGitignore(): Promise<void> {
        // Mock implementation
    }

    public async findAllFiles(): Promise<string[]> {
        return this.mockFiles;
    }

    public async getFileStats(): Promise<{ totalFiles: number; filesByExtension: Record<string, number> }> {
        const filesByExtension: Record<string, number> = {};
        this.mockFiles.forEach(file => {
            const ext = file.substring(file.lastIndexOf('.'));
            filesByExtension[ext] = (filesByExtension[ext] || 0) + 1;
        });

        return {
            totalFiles: this.mockFiles.length,
            filesByExtension
        };
    }

    public isCodeFile(filePath: string): boolean {
        const codeExtensions = ['.ts', '.tsx', '.js', '.jsx', '.py', '.cs', '.java'];
        return codeExtensions.some(ext => filePath.endsWith(ext));
    }

    async getFiles(
        extensions: string[] = [],
        excludePatterns: string[] = []
    ): Promise<string[]> {
        return this.mockFiles.filter(file => {
            if (extensions.length > 0) {
                return extensions.some(ext => file.endsWith(ext));
            }
            return true;
        });
    }

    // Test helper methods
    setMockFiles(files: string[]): void {
        this.mockFiles = files;
    }

    addMockFile(file: string): void {
        this.mockFiles.push(file);
    }

    clearMockFiles(): void {
        this.mockFiles = [];
    }
}

/**
 * Mock implementation of AstParser for testing
 */
export class MockAstParser {
    private mockParseResult: any = null;

    async parseFile(filePath: string, language: SupportedLanguage): Promise<any> {
        return this.mockParseResult || {
            functions: [],
            classes: [],
            imports: [],
            exports: []
        };
    }

    // Test helper methods
    setMockParseResult(result: any): void {
        this.mockParseResult = result;
    }
}

/**
 * Mock implementation of Chunker for testing
 */
export class MockChunker {
    private mockChunks: CodeChunk[] = [];

    chunkCode(
        content: string,
        filePath: string,
        language: SupportedLanguage,
        astResult?: any
    ): CodeChunk[] {
        if (this.mockChunks.length > 0) {
            return this.mockChunks;
        }

        // Default mock chunks
        return [
            {
                content: content.substring(0, Math.min(100, content.length)),
                filePath,
                startLine: 1,
                endLine: 10,
                type: ChunkType.FUNCTION,
                language,
                metadata: {}
            }
        ];
    }

    // Test helper methods
    setMockChunks(chunks: CodeChunk[]): void {
        this.mockChunks = chunks;
    }

    clearMockChunks(): void {
        this.mockChunks = [];
    }
}

/**
 * Mock implementation of LspService for testing
 */
export class MockLspService {
    private isInitialized = false;

    constructor(workspaceRoot: string) {
        // Mock constructor
    }

    async initialize(): Promise<void> {
        this.isInitialized = true;
    }

    async dispose(): Promise<void> {
        this.isInitialized = false;
    }

    isReady(): boolean {
        return this.isInitialized;
    }

    // Test helper methods
    setInitialized(initialized: boolean): void {
        this.isInitialized = initialized;
    }
}
</file>

<file path="src/test/runTest.ts">
import * as path from 'path';
import { runTests } from '@vscode/test-electron';

async function main() {
    try {
        // The folder containing the Extension Manifest package.json
        // Passed to `--extensionDevelopmentPath`
        const extensionDevelopmentPath = path.resolve(__dirname, '../../');

        // The path to test runner
        // Passed to --extensionTestsPath
        const extensionTestsPath = path.resolve(__dirname, './suite/index');

        // Download VS Code, unzip it and run the integration test
        await runTests({ extensionDevelopmentPath, extensionTestsPath });
    } catch (err) {
        console.error('Failed to run tests');
        process.exit(1);
    }
}

main();
</file>

<file path="src/types/tree-sitter-languages.d.ts">
declare module 'tree-sitter-typescript' {
    const typescript: any;
    const javascript: any;
    export { typescript, javascript };
}

declare module 'tree-sitter-python' {
    const python: any;
    export = python;
}

declare module 'tree-sitter-c-sharp' {
    const csharp: any;
    export = csharp;
}

declare module 'glob' {
    interface GlobOptions {
        cwd?: string;
        absolute?: boolean;
        nodir?: boolean;
        dot?: boolean;
    }

    function glob(pattern: string, options: GlobOptions, callback: (err: Error | null, matches: string[]) => void): void;

    export { glob, GlobOptions };
}
</file>

<file path="src/commandManager.ts">
import * as vscode from 'vscode';
import { IndexingService } from './indexing/indexingService';
import { WebviewManager } from './webviewManager';

/**
 * CommandManager class responsible for registering and managing all VS Code commands
 * for the Code Context Engine extension.
 * 
 * This class centralizes command registration and provides a clean separation between
 * command handling logic and the main extension activation. It handles:
 * - Registration of all extension commands
 * - Command callback implementations
 * - Integration with core services
 * - Proper disposal of command registrations
 */
export class CommandManager {
    private indexingService: IndexingService;
    private webviewManager: WebviewManager;

    /**
     * Creates a new CommandManager instance
     * @param indexingService - The IndexingService instance for handling indexing commands
     * @param webviewManager - The WebviewManager instance for handling webview operations
     */
    constructor(indexingService: IndexingService, webviewManager: WebviewManager) {
        this.indexingService = indexingService;
        this.webviewManager = webviewManager;
    }

    /**
     * Registers all extension commands and returns their disposables
     * @returns Array of disposables for the registered commands
     */
    registerCommands(): vscode.Disposable[] {
        const disposables: vscode.Disposable[] = [];

        // Register the main panel command
        const openMainPanelDisposable = vscode.commands.registerCommand(
            'code-context-engine.openMainPanel',
            this.handleOpenMainPanel.bind(this)
        );
        disposables.push(openMainPanelDisposable);

        // Register the start indexing command
        const startIndexingDisposable = vscode.commands.registerCommand(
            'code-context-engine.startIndexing',
            this.handleStartIndexing.bind(this)
        );
        disposables.push(startIndexingDisposable);

        // Register the open settings command
        const openSettingsDisposable = vscode.commands.registerCommand(
            'code-context-engine.openSettings',
            this.handleOpenSettings.bind(this)
        );
        disposables.push(openSettingsDisposable);

        // Register the setup project command
        const setupProjectDisposable = vscode.commands.registerCommand(
            'code-context-engine.setupProject',
            this.handleSetupProject.bind(this)
        );
        disposables.push(setupProjectDisposable);

        console.log('CommandManager: All commands registered successfully');
        return disposables;
    }

    /**
     * Handles the 'code-context-engine.openMainPanel' command
     * Opens the main Code Context Engine panel using WebviewManager
     */
    private async handleOpenMainPanel(): Promise<void> {
        try {
            console.log('CommandManager: Opening main panel...');

            this.webviewManager.showMainPanel();

            console.log('CommandManager: Main panel opened successfully');
        } catch (error) {
            console.error('CommandManager: Failed to open main panel:', error);
            vscode.window.showErrorMessage('Failed to open Code Context Engine panel');
        }
    }

    /**
     * Handles the 'code-context-engine.startIndexing' command
     * Starts the indexing process for the current workspace
     */
    private async handleStartIndexing(): Promise<void> {
        try {
            console.log('CommandManager: Starting indexing...');

            if (!this.indexingService) {
                throw new Error('IndexingService not available');
            }

            // Check if workspace is available
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                vscode.window.showWarningMessage('No workspace folder is open. Please open a folder to index.');
                return;
            }

            // Show progress notification
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Code Context Engine',
                cancellable: false
            }, async (progress) => {
                progress.report({ message: 'Starting indexing process...' });

                // Start the indexing process
                const result = await this.indexingService.startIndexing((progressInfo) => {
                    progress.report({ 
                        message: `${progressInfo.currentPhase}: ${progressInfo.currentFile}`,
                        increment: (progressInfo.processedFiles / progressInfo.totalFiles) * 100
                    });
                });

                if (result.success) {
                    progress.report({ message: 'Indexing completed successfully!' });
                    vscode.window.showInformationMessage(
                        `Indexing completed! Processed ${result.processedFiles} files with ${result.chunks.length} code chunks.`
                    );
                } else {
                    throw new Error(`Indexing failed with ${result.errors.length} errors`);
                }
            });

            console.log('CommandManager: Indexing completed successfully');
        } catch (error) {
            console.error('CommandManager: Failed to start indexing:', error);
            vscode.window.showErrorMessage(`Failed to start indexing: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Handles the 'code-context-engine.openSettings' command
     * Opens the extension settings panel using WebviewManager
     */
    private async handleOpenSettings(): Promise<void> {
        try {
            console.log('CommandManager: Opening settings...');

            this.webviewManager.showSettingsPanel();

            console.log('CommandManager: Settings opened successfully');
        } catch (error) {
            console.error('CommandManager: Failed to open settings:', error);
            vscode.window.showErrorMessage('Failed to open Code Context Engine settings');
        }
    }

    /**
     * Handles the 'code-context-engine.setupProject' command
     * Opens the project setup wizard
     */
    private async handleSetupProject(): Promise<void> {
        try {
            console.log('CommandManager: Starting project setup...');

            // Check if workspace is available
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                vscode.window.showWarningMessage('No workspace folder is open. Please open a folder to setup.');
                return;
            }

            // For now, show a simple setup dialog
            const setupChoice = await vscode.window.showInformationMessage(
                'Welcome to Code Context Engine! Would you like to start indexing your project?',
                'Start Indexing',
                'Configure Settings',
                'Cancel'
            );

            switch (setupChoice) {
                case 'Start Indexing':
                    await this.handleStartIndexing();
                    break;
                case 'Configure Settings':
                    await this.handleOpenSettings();
                    break;
                default:
                    console.log('CommandManager: Project setup cancelled');
                    break;
            }

            console.log('CommandManager: Project setup completed');
        } catch (error) {
            console.error('CommandManager: Failed to setup project:', error);
            vscode.window.showErrorMessage('Failed to setup Code Context Engine project');
        }
    }
}
</file>

<file path="src/configService.ts">
import * as vscode from 'vscode';

/**
 * Configuration interfaces for different providers
 */
export interface OllamaConfig {
    apiUrl: string;
    model: string;
    timeout?: number;
    maxBatchSize?: number;
}

export interface OpenAIConfig {
    apiKey: string;
    model: string;
    timeout?: number;
    maxBatchSize?: number;
}

export interface DatabaseConfig {
    type: 'qdrant';
    connectionString: string;
}

export interface IndexingConfig {
    excludePatterns: string[];
    supportedLanguages: string[];
    maxFileSize?: number;
    chunkSize?: number;
    chunkOverlap?: number;
}

/**
 * Main extension configuration interface
 */
export interface ExtensionConfig {
    database: DatabaseConfig;
    embeddingProvider: 'ollama' | 'openai';
    ollama: OllamaConfig;
    openai: OpenAIConfig;
    indexing: IndexingConfig;
}

/**
 * Centralized configuration service for the Code Context Engine extension.
 * 
 * This service encapsulates all extension settings, providing a single source of truth
 * and preventing direct vscode.workspace.getConfiguration() calls throughout the codebase.
 * It improves testability by centralizing configuration access and makes it easier to
 * manage configuration changes.
 */
export class ConfigService {
    private config: vscode.WorkspaceConfiguration;
    private readonly configSection = 'code-context-engine';

    constructor() {
        // Load the configuration once during instantiation
        this.config = vscode.workspace.getConfiguration(this.configSection);
    }

    /**
     * Refresh configuration from VS Code settings
     * Call this when configuration might have changed
     */
    public refresh(): void {
        this.config = vscode.workspace.getConfiguration(this.configSection);
    }

    /**
     * Get the Qdrant database connection string
     */
    public getQdrantConnectionString(): string {
        return this.config.get<string>('databaseConnectionString') || 'http://localhost:6333';
    }

    /**
     * Get the database configuration
     */
    public getDatabaseConfig(): DatabaseConfig {
        return {
            type: 'qdrant',
            connectionString: this.getQdrantConnectionString()
        };
    }

    /**
     * Get the current embedding provider type
     */
    public getEmbeddingProvider(): 'ollama' | 'openai' {
        return this.config.get<'ollama' | 'openai'>('embeddingProvider') || 'ollama';
    }

    /**
     * Get Ollama configuration
     */
    public getOllamaConfig(): OllamaConfig {
        return {
            apiUrl: this.config.get<string>('ollama.apiUrl') || 'http://localhost:11434',
            model: this.config.get<string>('ollama.model') || 'nomic-embed-text',
            timeout: this.config.get<number>('ollama.timeout') || 30000,
            maxBatchSize: this.config.get<number>('ollama.maxBatchSize') || 10
        };
    }

    /**
     * Get OpenAI configuration
     */
    public getOpenAIConfig(): OpenAIConfig {
        return {
            apiKey: this.config.get<string>('openai.apiKey') || '',
            model: this.config.get<string>('openai.model') || 'text-embedding-ada-002',
            timeout: this.config.get<number>('openai.timeout') || 30000,
            maxBatchSize: this.config.get<number>('openai.maxBatchSize') || 100
        };
    }

    /**
     * Get indexing configuration
     */
    public getIndexingConfig(): IndexingConfig {
        return {
            excludePatterns: this.config.get<string[]>('indexing.excludePatterns') || [
                '**/node_modules/**',
                '**/dist/**',
                '**/build/**',
                '**/.git/**',
                '**/coverage/**'
            ],
            supportedLanguages: this.config.get<string[]>('indexing.supportedLanguages') || [
                'typescript',
                'javascript',
                'python',
                'csharp',
                'java',
                'cpp',
                'rust'
            ],
            maxFileSize: this.config.get<number>('indexing.maxFileSize') || 1024 * 1024, // 1MB
            chunkSize: this.config.get<number>('indexing.chunkSize') || 1000,
            chunkOverlap: this.config.get<number>('indexing.chunkOverlap') || 200
        };
    }

    /**
     * Get the complete extension configuration
     */
    public getFullConfig(): ExtensionConfig {
        return {
            database: this.getDatabaseConfig(),
            embeddingProvider: this.getEmbeddingProvider(),
            ollama: this.getOllamaConfig(),
            openai: this.getOpenAIConfig(),
            indexing: this.getIndexingConfig()
        };
    }

    /**
     * Check if a specific provider is properly configured
     */
    public isProviderConfigured(provider: 'ollama' | 'openai'): boolean {
        switch (provider) {
            case 'ollama':
                const ollamaConfig = this.getOllamaConfig();
                return !!(ollamaConfig.apiUrl && ollamaConfig.model);
            case 'openai':
                const openaiConfig = this.getOpenAIConfig();
                return !!(openaiConfig.apiKey && openaiConfig.model);
            default:
                return false;
        }
    }

    /**
     * Get configuration for the currently selected embedding provider
     */
    public getCurrentProviderConfig(): OllamaConfig | OpenAIConfig {
        const provider = this.getEmbeddingProvider();
        return provider === 'ollama' ? this.getOllamaConfig() : this.getOpenAIConfig();
    }
}
</file>

<file path="src/configurationManager.ts">
import * as vscode from 'vscode';
import { ConfigService } from './configService';

/**
 * Configuration validation result
 */
export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings: string[];
}

/**
 * Configuration change event
 */
export interface ConfigurationChangeEvent {
    key: string;
    oldValue: any;
    newValue: any;
    timestamp: Date;
}

/**
 * Configuration preset for quick setup
 */
export interface ConfigurationPreset {
    name: string;
    description: string;
    settings: Record<string, any>;
}

/**
 * ConfigurationManager class responsible for advanced configuration management.
 * 
 * This class provides enhanced configuration capabilities including:
 * - Configuration validation and error checking
 * - Configuration presets and templates
 * - Change tracking and history
 * - Import/export functionality
 * - Real-time configuration updates
 */
export class ConfigurationManager {
    private configService: ConfigService;
    private changeListeners: ((event: ConfigurationChangeEvent) => void)[] = [];
    private configurationWatcher: vscode.Disposable | undefined;

    /**
     * Creates a new ConfigurationManager instance
     * @param configService - The ConfigService instance
     */
    constructor(configService: ConfigService) {
        this.configService = configService;
        this.setupConfigurationWatcher();
    }

    /**
     * Validates the current configuration
     * @returns Validation result with errors and warnings
     */
    async validateConfiguration(): Promise<ValidationResult> {
        const result: ValidationResult = {
            isValid: true,
            errors: [],
            warnings: []
        };

        try {
            // Validate database configuration
            const dbConfig = this.configService.getDatabaseConfig();
            if (!dbConfig.connectionString) {
                result.errors.push('Database connection string is required');
                result.isValid = false;
            } else {
                try {
                    new URL(dbConfig.connectionString);
                } catch {
                    result.errors.push('Invalid database connection string format');
                    result.isValid = false;
                }
            }

            // Validate embedding provider configuration
            const embeddingProvider = this.configService.getEmbeddingProvider();
            const isProviderConfigured = this.configService.isProviderConfigured(embeddingProvider);
            
            if (!isProviderConfigured) {
                if (embeddingProvider === 'openai') {
                    const openaiConfig = this.configService.getOpenAIConfig();
                    if (!openaiConfig.apiKey) {
                        result.errors.push('OpenAI API key is required when using OpenAI provider');
                        result.isValid = false;
                    }
                } else if (embeddingProvider === 'ollama') {
                    const ollamaConfig = this.configService.getOllamaConfig();
                    if (!ollamaConfig.apiUrl) {
                        result.errors.push('Ollama API URL is required when using Ollama provider');
                        result.isValid = false;
                    }
                }
            }

            // Validate indexing configuration
            const indexingConfig = this.configService.getIndexingConfig();
            if (indexingConfig.chunkSize !== undefined && indexingConfig.chunkSize <= 0) {
                result.errors.push('Chunk size must be greater than 0');
                result.isValid = false;
            }

            if (indexingConfig.chunkOverlap !== undefined && indexingConfig.chunkOverlap < 0) {
                result.errors.push('Chunk overlap cannot be negative');
                result.isValid = false;
            }

            if (indexingConfig.chunkOverlap !== undefined &&
                indexingConfig.chunkSize !== undefined &&
                indexingConfig.chunkOverlap >= indexingConfig.chunkSize) {
                result.warnings.push('Chunk overlap should be smaller than chunk size');
            }

            // Check for performance warnings
            if (indexingConfig.chunkSize !== undefined && indexingConfig.chunkSize > 2000) {
                result.warnings.push('Large chunk size may impact performance');
            }

            const openaiConfig = this.configService.getOpenAIConfig();
            if (openaiConfig.maxBatchSize !== undefined && openaiConfig.maxBatchSize > 100) {
                result.warnings.push('Large batch size may hit API rate limits');
            }

        } catch (error) {
            result.errors.push(`Configuration validation failed: ${error instanceof Error ? error.message : String(error)}`);
            result.isValid = false;
        }

        return result;
    }

    /**
     * Gets available configuration presets
     * @returns Array of configuration presets
     */
    getConfigurationPresets(): ConfigurationPreset[] {
        return [
            {
                name: 'Local Development',
                description: 'Optimized for local development with Ollama',
                settings: {
                    'code-context-engine.embeddingProvider': 'ollama',
                    'code-context-engine.ollama.apiUrl': 'http://localhost:11434',
                    'code-context-engine.ollama.model': 'nomic-embed-text',
                    'code-context-engine.databaseConnectionString': 'http://localhost:6333',
                    'code-context-engine.indexing.chunkSize': 1000,
                    'code-context-engine.indexing.chunkOverlap': 200
                }
            },
            {
                name: 'Cloud Production',
                description: 'Optimized for production use with OpenAI',
                settings: {
                    'code-context-engine.embeddingProvider': 'openai',
                    'code-context-engine.openai.model': 'text-embedding-ada-002',
                    'code-context-engine.openai.maxBatchSize': 50,
                    'code-context-engine.indexing.chunkSize': 1500,
                    'code-context-engine.indexing.chunkOverlap': 300
                }
            },
            {
                name: 'Performance Optimized',
                description: 'Optimized for large codebases',
                settings: {
                    'code-context-engine.indexing.chunkSize': 800,
                    'code-context-engine.indexing.chunkOverlap': 100,
                    'code-context-engine.indexing.maxFileSize': 2097152, // 2MB
                    'code-context-engine.ollama.maxBatchSize': 5,
                    'code-context-engine.openai.maxBatchSize': 20
                }
            },
            {
                name: 'Minimal Setup',
                description: 'Minimal configuration for quick testing',
                settings: {
                    'code-context-engine.embeddingProvider': 'ollama',
                    'code-context-engine.indexing.chunkSize': 500,
                    'code-context-engine.indexing.chunkOverlap': 50,
                    'code-context-engine.indexing.excludePatterns': [
                        '**/node_modules/**',
                        '**/dist/**',
                        '**/.git/**'
                    ]
                }
            }
        ];
    }

    /**
     * Applies a configuration preset
     * @param presetName - Name of the preset to apply
     * @returns Promise resolving when preset is applied
     */
    async applyPreset(presetName: string): Promise<void> {
        const preset = this.getConfigurationPresets().find(p => p.name === presetName);
        if (!preset) {
            throw new Error(`Configuration preset '${presetName}' not found`);
        }

        const config = vscode.workspace.getConfiguration();
        
        for (const [key, value] of Object.entries(preset.settings)) {
            await config.update(key, value, vscode.ConfigurationTarget.Workspace);
        }

        // Refresh the config service
        this.configService.refresh();

        console.log(`ConfigurationManager: Applied preset '${presetName}'`);
    }

    /**
     * Exports current configuration to a JSON object
     * @returns Configuration export object
     */
    exportConfiguration(): Record<string, any> {
        const fullConfig = this.configService.getFullConfig();
        
        return {
            exportedAt: new Date().toISOString(),
            version: '1.0',
            configuration: {
                database: fullConfig.database,
                embeddingProvider: fullConfig.embeddingProvider,
                ollama: fullConfig.ollama,
                openai: {
                    ...fullConfig.openai,
                    apiKey: fullConfig.openai.apiKey ? '[REDACTED]' : ''
                },
                indexing: fullConfig.indexing
            }
        };
    }

    /**
     * Imports configuration from a JSON object
     * @param configData - Configuration data to import
     * @returns Promise resolving when configuration is imported
     */
    async importConfiguration(configData: any): Promise<void> {
        if (!configData.configuration) {
            throw new Error('Invalid configuration format');
        }

        const config = vscode.workspace.getConfiguration();
        const settings = configData.configuration;

        // Import database settings
        if (settings.database?.connectionString) {
            await config.update(
                'code-context-engine.databaseConnectionString',
                settings.database.connectionString,
                vscode.ConfigurationTarget.Workspace
            );
        }

        // Import embedding provider settings
        if (settings.embeddingProvider) {
            await config.update(
                'code-context-engine.embeddingProvider',
                settings.embeddingProvider,
                vscode.ConfigurationTarget.Workspace
            );
        }

        // Import Ollama settings
        if (settings.ollama) {
            for (const [key, value] of Object.entries(settings.ollama)) {
                await config.update(
                    `code-context-engine.ollama.${key}`,
                    value,
                    vscode.ConfigurationTarget.Workspace
                );
            }
        }

        // Import OpenAI settings (excluding API key for security)
        if (settings.openai) {
            for (const [key, value] of Object.entries(settings.openai)) {
                if (key !== 'apiKey') {
                    await config.update(
                        `code-context-engine.openai.${key}`,
                        value,
                        vscode.ConfigurationTarget.Workspace
                    );
                }
            }
        }

        // Import indexing settings
        if (settings.indexing) {
            for (const [key, value] of Object.entries(settings.indexing)) {
                await config.update(
                    `code-context-engine.indexing.${key}`,
                    value,
                    vscode.ConfigurationTarget.Workspace
                );
            }
        }

        // Refresh the config service
        this.configService.refresh();

        console.log('ConfigurationManager: Configuration imported successfully');
    }

    /**
     * Resets configuration to defaults
     * @returns Promise resolving when configuration is reset
     */
    async resetToDefaults(): Promise<void> {
        const config = vscode.workspace.getConfiguration();
        const configKeys = [
            'code-context-engine.databaseConnectionString',
            'code-context-engine.embeddingProvider',
            'code-context-engine.ollama.apiUrl',
            'code-context-engine.ollama.model',
            'code-context-engine.ollama.timeout',
            'code-context-engine.ollama.maxBatchSize',
            'code-context-engine.openai.apiKey',
            'code-context-engine.openai.model',
            'code-context-engine.openai.timeout',
            'code-context-engine.openai.maxBatchSize',
            'code-context-engine.indexing.excludePatterns',
            'code-context-engine.indexing.supportedLanguages',
            'code-context-engine.indexing.maxFileSize',
            'code-context-engine.indexing.chunkSize',
            'code-context-engine.indexing.chunkOverlap'
        ];

        for (const key of configKeys) {
            await config.update(key, undefined, vscode.ConfigurationTarget.Workspace);
        }

        // Refresh the config service
        this.configService.refresh();

        console.log('ConfigurationManager: Configuration reset to defaults');
    }

    /**
     * Adds a configuration change listener
     * @param listener - Function to call when configuration changes
     */
    onConfigurationChange(listener: (event: ConfigurationChangeEvent) => void): void {
        this.changeListeners.push(listener);
    }

    /**
     * Sets up configuration watcher for real-time updates
     */
    private setupConfigurationWatcher(): void {
        this.configurationWatcher = vscode.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('code-context-engine')) {
                // Refresh the config service
                this.configService.refresh();

                // Notify listeners
                const changeEvent: ConfigurationChangeEvent = {
                    key: 'code-context-engine',
                    oldValue: null, // Would need to track previous values
                    newValue: this.configService.getFullConfig(),
                    timestamp: new Date()
                };

                this.changeListeners.forEach(listener => {
                    try {
                        listener(changeEvent);
                    } catch (error) {
                        console.error('ConfigurationManager: Error in change listener:', error);
                    }
                });

                console.log('ConfigurationManager: Configuration changed');
            }
        });
    }

    /**
     * Disposes of the ConfigurationManager and cleans up resources
     */
    dispose(): void {
        if (this.configurationWatcher) {
            this.configurationWatcher.dispose();
        }
        this.changeListeners = [];
        console.log('ConfigurationManager: Disposed');
    }
}
</file>

<file path="src/extensionManager.ts">
import * as vscode from 'vscode';
import { ConfigService } from './configService';
import { QdrantService } from './db/qdrantService';
import { EmbeddingProviderFactory, IEmbeddingProvider } from './embeddings/embeddingProvider';
import { ContextService } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { FileWalker } from './indexing/fileWalker';
import { AstParser } from './parsing/astParser';
import { Chunker } from './parsing/chunker';
import { LSPService } from './lsp/lspService';
import { CommandManager } from './commandManager';
import { WebviewManager } from './webviewManager';
import { SearchManager } from './searchManager';
import { ConfigurationManager } from './configurationManager';
import { PerformanceManager } from './performanceManager';

/**
 * ExtensionManager class responsible for managing the lifecycle of all core services
 * and coordinating the initialization and disposal of the extension.
 * 
 * This class serves as the main orchestrator for the extension, handling:
 * - Service initialization with dependency injection
 * - Command registration through CommandManager
 * - Resource cleanup and disposal
 * - Error handling during initialization
 */
export class ExtensionManager {
    private context: vscode.ExtensionContext;
    private disposables: vscode.Disposable[] = [];

    // Core services
    private configService!: ConfigService;
    private qdrantService!: QdrantService;
    private embeddingProvider!: IEmbeddingProvider;
    private contextService!: ContextService;
    private indexingService!: IndexingService;
    
    // Managers
    private commandManager!: CommandManager;
    private webviewManager!: WebviewManager;
    private searchManager!: SearchManager;
    private configurationManager!: ConfigurationManager;
    private performanceManager!: PerformanceManager;

    /**
     * Creates a new ExtensionManager instance
     * @param context - The VS Code extension context
     */
    constructor(context: vscode.ExtensionContext) {
        this.context = context;
    }

    /**
     * Initializes all core services and managers using dependency injection
     * This method sets up the entire extension architecture
     */
    async initialize(): Promise<void> {
        try {
            console.log('ExtensionManager: Starting service initialization...');

            // Step 1: Initialize ConfigService first (no dependencies)
            this.configService = new ConfigService();
            console.log('ExtensionManager: ConfigService initialized');

            // Step 2: Initialize QdrantService with configuration
            this.qdrantService = new QdrantService(this.configService.getQdrantConnectionString());
            console.log('ExtensionManager: QdrantService initialized');

            // Step 3: Initialize EmbeddingProvider using factory and configuration
            this.embeddingProvider = await EmbeddingProviderFactory.createProviderFromConfigService(this.configService);
            console.log('ExtensionManager: EmbeddingProvider initialized');

            // Step 4: Initialize workspace-dependent services
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (workspaceFolders && workspaceFolders.length > 0) {
                const workspaceRoot = workspaceFolders[0].uri.fsPath;

                // Create all dependencies for IndexingService
                const fileWalker = new FileWalker(workspaceRoot);
                const astParser = new AstParser();
                const chunker = new Chunker();
                const lspService = new LSPService(workspaceRoot);

                // Initialize IndexingService with all dependencies
                this.indexingService = new IndexingService(
                    workspaceRoot,
                    fileWalker,
                    astParser,
                    chunker,
                    this.qdrantService,
                    this.embeddingProvider,
                    lspService
                );
                console.log('ExtensionManager: IndexingService initialized');

                // Initialize ContextService with dependencies
                this.contextService = new ContextService(
                    workspaceRoot,
                    this.qdrantService,
                    this.embeddingProvider,
                    this.indexingService
                );
                console.log('ExtensionManager: ContextService initialized');
            } else {
                console.warn('ExtensionManager: No workspace folder found, some services not initialized');
            }

            // Step 5: Initialize PerformanceManager
            this.performanceManager = new PerformanceManager();
            console.log('ExtensionManager: PerformanceManager initialized');

            // Step 6: Initialize ConfigurationManager
            this.configurationManager = new ConfigurationManager(this.configService);
            console.log('ExtensionManager: ConfigurationManager initialized');

            // Step 7: Initialize SearchManager
            this.searchManager = new SearchManager(this.contextService);
            console.log('ExtensionManager: SearchManager initialized');

            // Step 8: Initialize WebviewManager
            this.webviewManager = new WebviewManager(this.context, this);
            console.log('ExtensionManager: WebviewManager initialized');

            // Step 9: Initialize CommandManager and register commands
            this.commandManager = new CommandManager(this.indexingService, this.webviewManager);
            const commandDisposables = this.commandManager.registerCommands();
            this.disposables.push(...commandDisposables);
            console.log('ExtensionManager: CommandManager initialized and commands registered');

            console.log('ExtensionManager: All services initialized successfully');

        } catch (error) {
            console.error('ExtensionManager: Failed to initialize services:', error);
            throw error;
        }
    }

    /**
     * Disposes of all resources and cleans up services
     * This method should be called when the extension is deactivated
     */
    dispose(): void {
        console.log('ExtensionManager: Starting disposal...');

        // Dispose of managers in reverse order
        if (this.webviewManager) {
            this.webviewManager.dispose();
        }

        if (this.searchManager) {
            this.searchManager.dispose();
        }

        if (this.configurationManager) {
            this.configurationManager.dispose();
        }

        if (this.performanceManager) {
            this.performanceManager.dispose();
        }

        // Dispose of all registered disposables
        this.disposables.forEach(disposable => {
            try {
                disposable.dispose();
            } catch (error) {
                console.error('ExtensionManager: Error disposing resource:', error);
            }
        });

        this.disposables = [];
        console.log('ExtensionManager: Disposal completed');
    }

    /**
     * Gets the ConfigService instance
     * @returns The ConfigService instance
     */
    getConfigService(): ConfigService {
        return this.configService;
    }

    /**
     * Gets the QdrantService instance
     * @returns The QdrantService instance
     */
    getQdrantService(): QdrantService {
        return this.qdrantService;
    }

    /**
     * Gets the EmbeddingProvider instance
     * @returns The EmbeddingProvider instance
     */
    getEmbeddingProvider(): IEmbeddingProvider {
        return this.embeddingProvider;
    }

    /**
     * Gets the ContextService instance
     * @returns The ContextService instance
     */
    getContextService(): ContextService {
        return this.contextService;
    }

    /**
     * Gets the IndexingService instance
     * @returns The IndexingService instance
     */
    getIndexingService(): IndexingService {
        return this.indexingService;
    }

    /**
     * Gets the CommandManager instance
     * @returns The CommandManager instance
     */
    getCommandManager(): CommandManager {
        return this.commandManager;
    }

    /**
     * Gets the WebviewManager instance
     * @returns The WebviewManager instance
     */
    getWebviewManager(): WebviewManager {
        return this.webviewManager;
    }

    /**
     * Gets the SearchManager instance
     * @returns The SearchManager instance
     */
    getSearchManager(): SearchManager {
        return this.searchManager;
    }

    /**
     * Gets the ConfigurationManager instance
     * @returns The ConfigurationManager instance
     */
    getConfigurationManager(): ConfigurationManager {
        return this.configurationManager;
    }

    /**
     * Gets the PerformanceManager instance
     * @returns The PerformanceManager instance
     */
    getPerformanceManager(): PerformanceManager {
        return this.performanceManager;
    }

    /**
     * Gets the VS Code extension context
     * @returns The extension context
     */
    getContext(): vscode.ExtensionContext {
        return this.context;
    }
}
</file>

<file path="src/messageRouter.ts">
import * as vscode from 'vscode';
import { ContextService, ContextQuery, FileContentResult, RelatedFile } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { SearchManager, SearchFilters } from './searchManager';
import { ConfigurationManager } from './configurationManager';
import { PerformanceManager } from './performanceManager';

/**
 * MessageRouter class responsible for routing and handling messages from webview panels.
 * 
 * This class centralizes all webview message handling logic, providing a clean separation
 * between webview communication and service logic. It handles:
 * - Message routing based on command types
 * - Service integration for handling requests
 * - Response formatting and error handling
 * - Type-safe message handling
 */
export class MessageRouter {
    private contextService: ContextService;
    private indexingService: IndexingService;
    private searchManager?: SearchManager;
    private configurationManager?: ConfigurationManager;
    private performanceManager?: PerformanceManager;

    /**
     * Creates a new MessageRouter instance
     * @param contextService - The ContextService instance for context operations
     * @param indexingService - The IndexingService instance for indexing operations
     */
    constructor(contextService: ContextService, indexingService: IndexingService) {
        this.contextService = contextService;
        this.indexingService = indexingService;
    }

    /**
     * Sets the advanced managers for enhanced functionality
     * @param searchManager - The SearchManager instance
     * @param configurationManager - The ConfigurationManager instance
     * @param performanceManager - The PerformanceManager instance
     */
    setAdvancedManagers(
        searchManager: SearchManager,
        configurationManager: ConfigurationManager,
        performanceManager: PerformanceManager
    ): void {
        this.searchManager = searchManager;
        this.configurationManager = configurationManager;
        this.performanceManager = performanceManager;
        console.log('MessageRouter: Advanced managers set');
    }

    /**
     * Routes and handles a message from a webview
     * @param message - The message object from the webview
     * @param webview - The webview that sent the message
     */
    async handleMessage(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling message:', message.command);

            switch (message.command) {
                case 'ping':
                    await this.handlePing(message, webview);
                    break;
                case 'getFileContent':
                    await this.handleGetFileContent(message, webview);
                    break;
                case 'findRelatedFiles':
                    await this.handleFindRelatedFiles(message, webview);
                    break;
                case 'queryContext':
                    await this.handleQueryContext(message, webview);
                    break;
                case 'getServiceStatus':
                    await this.handleGetServiceStatus(webview);
                    break;
                case 'startIndexing':
                    await this.handleStartIndexing(webview);
                    break;
                case 'advancedSearch':
                    await this.handleAdvancedSearch(message, webview);
                    break;
                case 'getSearchSuggestions':
                    await this.handleGetSearchSuggestions(message, webview);
                    break;
                case 'getSearchHistory':
                    await this.handleGetSearchHistory(webview);
                    break;
                case 'validateConfiguration':
                    await this.handleValidateConfiguration(webview);
                    break;
                case 'getConfigurationPresets':
                    await this.handleGetConfigurationPresets(webview);
                    break;
                case 'applyConfigurationPreset':
                    await this.handleApplyConfigurationPreset(message, webview);
                    break;
                case 'getPerformanceMetrics':
                    await this.handleGetPerformanceMetrics(webview);
                    break;
                case 'getFilePreview':
                    await this.handleGetFilePreview(message, webview);
                    break;
                default:
                    console.warn('MessageRouter: Unknown command:', message.command);
                    await this.sendErrorResponse(webview, `Unknown command: ${message.command}`);
                    break;
            }
        } catch (error) {
            console.error('MessageRouter: Error handling message:', error);
            await this.sendErrorResponse(webview, error instanceof Error ? error.message : String(error));
        }
    }

    /**
     * Handles the 'ping' message
     * Simple ping-pong test for communication verification
     */
    private async handlePing(message: any, webview: vscode.Webview): Promise<void> {
        console.log('MessageRouter: Received ping from webview', message.requestId);

        await webview.postMessage({
            command: 'pong',
            requestId: message.requestId,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Handles the 'getFileContent' message
     * Retrieves file content with optional related chunks
     */
    private async handleGetFileContent(message: any, webview: vscode.Webview): Promise<void> {
        const { filePath, includeRelatedChunks = false } = message;
        
        if (!filePath) {
            await this.sendErrorResponse(webview, 'File path is required');
            return;
        }

        const result = await this.contextService.getFileContent(filePath, includeRelatedChunks);
        
        await webview.postMessage({
            command: 'fileContentResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Handles the 'findRelatedFiles' message
     * Finds files related to a query
     */
    private async handleFindRelatedFiles(message: any, webview: vscode.Webview): Promise<void> {
        const { query, currentFilePath, maxResults = 10, minSimilarity = 0.5 } = message;
        
        if (!query) {
            await this.sendErrorResponse(webview, 'Query is required');
            return;
        }

        const result = await this.contextService.findRelatedFiles(
            query, 
            currentFilePath, 
            maxResults, 
            minSimilarity
        );
        
        await webview.postMessage({
            command: 'relatedFilesResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Handles the 'queryContext' message
     * Performs advanced context queries
     */
    private async handleQueryContext(message: any, webview: vscode.Webview): Promise<void> {
        const { contextQuery } = message;
        
        if (!contextQuery) {
            await this.sendErrorResponse(webview, 'Context query is required');
            return;
        }

        const result = await this.contextService.queryContext(contextQuery as ContextQuery);
        
        await webview.postMessage({
            command: 'contextQueryResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Handles the 'getServiceStatus' message
     * Retrieves the current status of all services
     */
    private async handleGetServiceStatus(webview: vscode.Webview): Promise<void> {
        const status = await this.contextService.getStatus();
        
        await webview.postMessage({
            command: 'serviceStatusResponse',
            data: status
        });
    }

    /**
     * Handles the 'startIndexing' message
     * Starts the indexing process with progress updates
     */
    private async handleStartIndexing(webview: vscode.Webview): Promise<void> {
        try {
            // Check if workspace is available
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                await this.sendErrorResponse(webview, 'No workspace folder is open');
                return;
            }

            // Send initial response
            await webview.postMessage({
                command: 'indexingStarted',
                message: 'Indexing process started'
            });

            // Start indexing with progress callback
            const result = await this.indexingService.startIndexing((progressInfo) => {
                webview.postMessage({
                    command: 'indexingProgress',
                    data: {
                        phase: progressInfo.currentPhase,
                        currentFile: progressInfo.currentFile,
                        processedFiles: progressInfo.processedFiles,
                        totalFiles: progressInfo.totalFiles,
                        percentage: Math.round((progressInfo.processedFiles / progressInfo.totalFiles) * 100)
                    }
                });
            });

            // Send completion response
            await webview.postMessage({
                command: 'indexingCompleted',
                data: {
                    success: result.success,
                    processedFiles: result.processedFiles,
                    chunksCreated: result.chunks.length,
                    errors: result.errors
                }
            });

        } catch (error) {
            await this.sendErrorResponse(webview, `Indexing failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Handles the 'advancedSearch' message
     * Performs advanced search with filters
     */
    private async handleAdvancedSearch(message: any, webview: vscode.Webview): Promise<void> {
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'Advanced search not available');
            return;
        }

        const { query, filters } = message;

        if (!query) {
            await this.sendErrorResponse(webview, 'Search query is required');
            return;
        }

        const results = await this.performanceManager?.measurePerformance('advancedSearch', async () => {
            return this.searchManager!.search(query, filters as SearchFilters);
        }) || await this.searchManager.search(query, filters as SearchFilters);

        await webview.postMessage({
            command: 'advancedSearchResponse',
            requestId: message.requestId,
            data: results
        });
    }

    /**
     * Handles the 'getSearchSuggestions' message
     * Gets search suggestions based on partial query
     */
    private async handleGetSearchSuggestions(message: any, webview: vscode.Webview): Promise<void> {
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'Search suggestions not available');
            return;
        }

        const { partialQuery } = message;
        const suggestions = this.searchManager.getSuggestions(partialQuery || '');

        await webview.postMessage({
            command: 'searchSuggestionsResponse',
            requestId: message.requestId,
            data: suggestions
        });
    }

    /**
     * Handles the 'getSearchHistory' message
     * Gets recent search history
     */
    private async handleGetSearchHistory(webview: vscode.Webview): Promise<void> {
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'Search history not available');
            return;
        }

        const history = this.searchManager.getSearchHistory();

        await webview.postMessage({
            command: 'searchHistoryResponse',
            data: history
        });
    }

    /**
     * Handles the 'validateConfiguration' message
     * Validates current configuration
     */
    private async handleValidateConfiguration(webview: vscode.Webview): Promise<void> {
        if (!this.configurationManager) {
            await this.sendErrorResponse(webview, 'Configuration validation not available');
            return;
        }

        const validation = await this.configurationManager.validateConfiguration();

        await webview.postMessage({
            command: 'configurationValidationResponse',
            data: validation
        });
    }

    /**
     * Handles the 'getConfigurationPresets' message
     * Gets available configuration presets
     */
    private async handleGetConfigurationPresets(webview: vscode.Webview): Promise<void> {
        if (!this.configurationManager) {
            await this.sendErrorResponse(webview, 'Configuration presets not available');
            return;
        }

        const presets = this.configurationManager.getConfigurationPresets();

        await webview.postMessage({
            command: 'configurationPresetsResponse',
            data: presets
        });
    }

    /**
     * Handles the 'applyConfigurationPreset' message
     * Applies a configuration preset
     */
    private async handleApplyConfigurationPreset(message: any, webview: vscode.Webview): Promise<void> {
        if (!this.configurationManager) {
            await this.sendErrorResponse(webview, 'Configuration presets not available');
            return;
        }

        const { presetName } = message;

        if (!presetName) {
            await this.sendErrorResponse(webview, 'Preset name is required');
            return;
        }

        try {
            await this.configurationManager.applyPreset(presetName);

            await webview.postMessage({
                command: 'configurationPresetAppliedResponse',
                requestId: message.requestId,
                data: { success: true, presetName }
            });
        } catch (error) {
            await this.sendErrorResponse(webview, `Failed to apply preset: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Handles the 'getPerformanceMetrics' message
     * Gets current performance metrics
     */
    private async handleGetPerformanceMetrics(webview: vscode.Webview): Promise<void> {
        if (!this.performanceManager) {
            await this.sendErrorResponse(webview, 'Performance metrics not available');
            return;
        }

        const metrics = this.performanceManager.getMetrics();

        await webview.postMessage({
            command: 'performanceMetricsResponse',
            data: metrics
        });
    }

    /**
     * Handles the 'getFilePreview' message
     * Gets file preview for a specific location
     */
    private async handleGetFilePreview(message: any, webview: vscode.Webview): Promise<void> {
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'File preview not available');
            return;
        }

        const { filePath, lineNumber, contextLines } = message;

        if (!filePath || !lineNumber) {
            await this.sendErrorResponse(webview, 'File path and line number are required');
            return;
        }

        try {
            const preview = await this.searchManager.getFilePreview(filePath, lineNumber, contextLines);

            await webview.postMessage({
                command: 'filePreviewResponse',
                requestId: message.requestId,
                data: { preview, filePath, lineNumber }
            });
        } catch (error) {
            await this.sendErrorResponse(webview, `Failed to get file preview: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Sends an error response to the webview
     * @param webview - The webview to send the error to
     * @param message - The error message
     */
    private async sendErrorResponse(webview: vscode.Webview, message: string): Promise<void> {
        await webview.postMessage({
            command: 'error',
            message: message
        });
    }

    /**
     * Updates the services used by the message router
     * This allows for dynamic service updates if needed
     * @param contextService - New ContextService instance
     * @param indexingService - New IndexingService instance
     */
    public updateServices(contextService: ContextService, indexingService: IndexingService): void {
        this.contextService = contextService;
        this.indexingService = indexingService;
        console.log('MessageRouter: Services updated');
    }
}
</file>

<file path="src/performanceManager.ts">
import * as vscode from 'vscode';

/**
 * Performance metrics for tracking system performance
 */
export interface PerformanceMetrics {
    searchLatency: number[];
    indexingTime: number;
    memoryUsage: number;
    cacheHitRate: number;
    activeConnections: number;
    lastUpdated: Date;
}

/**
 * Cache entry with expiration
 */
interface CacheEntry<T> {
    data: T;
    timestamp: number;
    ttl: number;
    accessCount: number;
}

/**
 * Performance optimization settings
 */
export interface OptimizationSettings {
    enableCaching: boolean;
    cacheSize: number;
    cacheTTL: number;
    enableCompression: boolean;
    batchSize: number;
    maxConcurrentOperations: number;
}

/**
 * PerformanceManager class responsible for performance optimization and monitoring.
 * 
 * This class provides performance enhancements including:
 * - Intelligent caching with LRU eviction
 * - Performance metrics collection and monitoring
 * - Memory usage optimization
 * - Request batching and throttling
 * - Background task scheduling
 */
export class PerformanceManager {
    private cache: Map<string, CacheEntry<any>> = new Map();
    private metrics: PerformanceMetrics;
    private settings: OptimizationSettings;
    private activeOperations: Set<string> = new Set();
    private operationQueue: Array<() => Promise<any>> = [];
    private isProcessingQueue = false;

    /**
     * Creates a new PerformanceManager instance
     */
    constructor() {
        this.metrics = {
            searchLatency: [],
            indexingTime: 0,
            memoryUsage: 0,
            cacheHitRate: 0,
            activeConnections: 0,
            lastUpdated: new Date()
        };

        this.settings = {
            enableCaching: true,
            cacheSize: 1000,
            cacheTTL: 5 * 60 * 1000, // 5 minutes
            enableCompression: false,
            batchSize: 10,
            maxConcurrentOperations: 5
        };

        this.startPerformanceMonitoring();
    }

    /**
     * Caches data with automatic expiration and LRU eviction
     * @param key - Cache key
     * @param data - Data to cache
     * @param ttl - Time to live in milliseconds (optional)
     */
    setCache<T>(key: string, data: T, ttl?: number): void {
        if (!this.settings.enableCaching) {
            return;
        }

        const entry: CacheEntry<T> = {
            data,
            timestamp: Date.now(),
            ttl: ttl || this.settings.cacheTTL,
            accessCount: 0
        };

        this.cache.set(key, entry);

        // Enforce cache size limit with LRU eviction
        if (this.cache.size > this.settings.cacheSize) {
            this.evictLRU();
        }
    }

    /**
     * Retrieves data from cache
     * @param key - Cache key
     * @returns Cached data or undefined if not found/expired
     */
    getCache<T>(key: string): T | undefined {
        if (!this.settings.enableCaching) {
            return undefined;
        }

        const entry = this.cache.get(key);
        if (!entry) {
            return undefined;
        }

        // Check if entry has expired
        if (Date.now() - entry.timestamp > entry.ttl) {
            this.cache.delete(key);
            return undefined;
        }

        // Update access count for LRU
        entry.accessCount++;
        entry.timestamp = Date.now();

        return entry.data as T;
    }

    /**
     * Clears cache entries
     * @param pattern - Optional pattern to match keys (supports wildcards)
     */
    clearCache(pattern?: string): void {
        if (!pattern) {
            this.cache.clear();
            return;
        }

        const regex = new RegExp(pattern.replace(/\*/g, '.*'));
        for (const key of this.cache.keys()) {
            if (regex.test(key)) {
                this.cache.delete(key);
            }
        }
    }

    /**
     * Measures and records operation performance
     * @param operationName - Name of the operation
     * @param operation - Function to execute and measure
     * @returns Result of the operation
     */
    async measurePerformance<T>(operationName: string, operation: () => Promise<T>): Promise<T> {
        const startTime = Date.now();
        const operationId = `${operationName}-${startTime}`;

        try {
            this.activeOperations.add(operationId);
            const result = await operation();
            
            const duration = Date.now() - startTime;
            this.recordMetric(operationName, duration);
            
            return result;
        } finally {
            this.activeOperations.delete(operationId);
        }
    }

    /**
     * Batches operations to improve performance
     * @param operations - Array of operations to batch
     * @returns Promise resolving to array of results
     */
    async batchOperations<T>(operations: Array<() => Promise<T>>): Promise<T[]> {
        const batches: Array<Array<() => Promise<T>>> = [];
        
        // Split operations into batches
        for (let i = 0; i < operations.length; i += this.settings.batchSize) {
            batches.push(operations.slice(i, i + this.settings.batchSize));
        }

        const results: T[] = [];

        // Process batches sequentially to avoid overwhelming the system
        for (const batch of batches) {
            const batchResults = await Promise.all(batch.map(op => op()));
            results.push(...batchResults);
        }

        return results;
    }

    /**
     * Queues operation for throttled execution
     * @param operation - Operation to queue
     * @returns Promise resolving to operation result
     */
    async queueOperation<T>(operation: () => Promise<T>): Promise<T> {
        return new Promise((resolve, reject) => {
            this.operationQueue.push(async () => {
                try {
                    const result = await operation();
                    resolve(result);
                    return result;
                } catch (error) {
                    reject(error);
                    throw error;
                }
            });

            this.processQueue();
        });
    }

    /**
     * Gets current performance metrics
     * @returns Current performance metrics
     */
    getMetrics(): PerformanceMetrics {
        this.updateMemoryUsage();
        this.updateCacheHitRate();
        this.metrics.activeConnections = this.activeOperations.size;
        this.metrics.lastUpdated = new Date();
        
        return { ...this.metrics };
    }

    /**
     * Updates optimization settings
     * @param newSettings - New optimization settings
     */
    updateSettings(newSettings: Partial<OptimizationSettings>): void {
        this.settings = { ...this.settings, ...newSettings };
        
        // Apply cache size limit if reduced
        if (newSettings.cacheSize && this.cache.size > newSettings.cacheSize) {
            while (this.cache.size > newSettings.cacheSize) {
                this.evictLRU();
            }
        }

        console.log('PerformanceManager: Settings updated', this.settings);
    }

    /**
     * Optimizes memory usage by cleaning up expired entries and running garbage collection
     */
    optimizeMemory(): void {
        // Clean expired cache entries
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (now - entry.timestamp > entry.ttl) {
                this.cache.delete(key);
            }
        }

        // Force garbage collection if available
        if (global.gc) {
            global.gc();
        }

        console.log('PerformanceManager: Memory optimization completed');
    }

    /**
     * Generates performance report
     * @returns Detailed performance report
     */
    generateReport(): string {
        const metrics = this.getMetrics();
        const avgSearchLatency = metrics.searchLatency.length > 0 
            ? metrics.searchLatency.reduce((a, b) => a + b, 0) / metrics.searchLatency.length 
            : 0;

        return `
Performance Report - ${metrics.lastUpdated.toISOString()}
========================================================

Search Performance:
- Average Latency: ${avgSearchLatency.toFixed(2)}ms
- Total Searches: ${metrics.searchLatency.length}

Indexing Performance:
- Last Indexing Time: ${metrics.indexingTime}ms

Memory Usage:
- Current Usage: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB

Cache Performance:
- Hit Rate: ${(metrics.cacheHitRate * 100).toFixed(1)}%
- Cache Size: ${this.cache.size} entries

System:
- Active Operations: ${metrics.activeConnections}
- Queue Length: ${this.operationQueue.length}

Settings:
- Caching Enabled: ${this.settings.enableCaching}
- Cache Size Limit: ${this.settings.cacheSize}
- Cache TTL: ${this.settings.cacheTTL}ms
- Batch Size: ${this.settings.batchSize}
- Max Concurrent Operations: ${this.settings.maxConcurrentOperations}
        `.trim();
    }

    /**
     * Evicts least recently used cache entry
     */
    private evictLRU(): void {
        let oldestKey: string | undefined;
        let oldestTime = Date.now();
        let lowestAccessCount = Infinity;

        for (const [key, entry] of this.cache.entries()) {
            if (entry.accessCount < lowestAccessCount || 
                (entry.accessCount === lowestAccessCount && entry.timestamp < oldestTime)) {
                oldestKey = key;
                oldestTime = entry.timestamp;
                lowestAccessCount = entry.accessCount;
            }
        }

        if (oldestKey) {
            this.cache.delete(oldestKey);
        }
    }

    /**
     * Records performance metric
     */
    private recordMetric(operationName: string, duration: number): void {
        if (operationName.includes('search')) {
            this.metrics.searchLatency.push(duration);
            
            // Keep only last 100 search latencies
            if (this.metrics.searchLatency.length > 100) {
                this.metrics.searchLatency = this.metrics.searchLatency.slice(-100);
            }
        } else if (operationName.includes('index')) {
            this.metrics.indexingTime = duration;
        }
    }

    /**
     * Updates memory usage metric
     */
    private updateMemoryUsage(): void {
        if (process.memoryUsage) {
            this.metrics.memoryUsage = process.memoryUsage().heapUsed;
        }
    }

    /**
     * Updates cache hit rate metric
     */
    private updateCacheHitRate(): void {
        // This would be calculated based on cache hits vs misses
        // For now, we'll estimate based on cache size
        this.metrics.cacheHitRate = Math.min(this.cache.size / this.settings.cacheSize, 1);
    }

    /**
     * Processes the operation queue with throttling
     */
    private async processQueue(): Promise<void> {
        if (this.isProcessingQueue || this.operationQueue.length === 0) {
            return;
        }

        this.isProcessingQueue = true;

        try {
            while (this.operationQueue.length > 0 && 
                   this.activeOperations.size < this.settings.maxConcurrentOperations) {
                
                const operation = this.operationQueue.shift();
                if (operation) {
                    // Execute operation without waiting
                    operation().catch(error => {
                        console.error('PerformanceManager: Queued operation failed:', error);
                    });
                }
            }
        } finally {
            this.isProcessingQueue = false;
            
            // Schedule next processing if queue is not empty
            if (this.operationQueue.length > 0) {
                setTimeout(() => this.processQueue(), 100);
            }
        }
    }

    /**
     * Starts background performance monitoring
     */
    private startPerformanceMonitoring(): void {
        // Update metrics every 30 seconds
        setInterval(() => {
            this.updateMemoryUsage();
            this.updateCacheHitRate();
        }, 30000);

        // Clean up expired cache entries every 5 minutes
        setInterval(() => {
            this.optimizeMemory();
        }, 5 * 60 * 1000);
    }

    /**
     * Disposes of the PerformanceManager and cleans up resources
     */
    dispose(): void {
        this.cache.clear();
        this.operationQueue = [];
        this.activeOperations.clear();
        console.log('PerformanceManager: Disposed');
    }
}
</file>

<file path="src/searchManager.ts">
import * as vscode from 'vscode';
import { ContextService, ContextQuery } from './context/contextService';

/**
 * Search filters and options for advanced search functionality
 */
export interface SearchFilters {
    fileTypes?: string[];
    languages?: string[];
    dateRange?: {
        from?: Date;
        to?: Date;
    };
    minSimilarity?: number;
    maxResults?: number;
    includeTests?: boolean;
    includeComments?: boolean;
}

/**
 * Enhanced search result with additional metadata
 */
export interface EnhancedSearchResult {
    id: string;
    title: string;
    description: string;
    filePath: string;
    language: string;
    lineNumber: number;
    similarity: number;
    context: string;
    preview: string;
    lastModified: Date;
    fileSize: number;
    chunkType: string;
}

/**
 * Search history entry for tracking user searches
 */
export interface SearchHistoryEntry {
    query: string;
    filters: SearchFilters;
    timestamp: Date;
    resultCount: number;
}

/**
 * SearchManager class responsible for advanced search functionality and result management.
 * 
 * This class provides enhanced search capabilities including:
 * - Advanced filtering and sorting options
 * - Search history and suggestions
 * - Result caching and performance optimization
 * - File preview and context extraction
 * - Search analytics and insights
 */
export class SearchManager {
    private contextService: ContextService;
    private searchHistory: SearchHistoryEntry[] = [];
    private resultCache: Map<string, EnhancedSearchResult[]> = new Map();
    private readonly maxHistoryEntries = 50;
    private readonly cacheTimeout = 5 * 60 * 1000; // 5 minutes

    /**
     * Creates a new SearchManager instance
     * @param contextService - The ContextService instance for performing searches
     */
    constructor(contextService: ContextService) {
        this.contextService = contextService;
        this.loadSearchHistory();
    }

    /**
     * Performs an advanced search with filters and options
     * @param query - The search query string
     * @param filters - Search filters and options
     * @returns Promise resolving to enhanced search results
     */
    async search(query: string, filters: SearchFilters = {}): Promise<EnhancedSearchResult[]> {
        try {
            console.log('SearchManager: Performing advanced search:', { query, filters });

            // Check cache first
            const cacheKey = this.generateCacheKey(query, filters);
            const cachedResults = this.resultCache.get(cacheKey);
            if (cachedResults) {
                console.log('SearchManager: Returning cached results');
                return cachedResults;
            }

            // Build context query from search parameters
            const contextQuery: ContextQuery = {
                query,
                maxResults: filters.maxResults || 20,
                minSimilarity: filters.minSimilarity || 0.5,
                fileTypes: filters.fileTypes
            };

            // Perform the search
            const contextResults = await this.contextService.queryContext(contextQuery);

            // Transform results to enhanced format
            const enhancedResults = await this.transformResults(contextResults.relatedFiles || []);

            // Apply additional filtering
            const filteredResults = this.applyAdvancedFilters(enhancedResults, filters);

            // Sort results by relevance and similarity
            const sortedResults = this.sortResults(filteredResults);

            // Cache the results
            this.cacheResults(cacheKey, sortedResults);

            // Add to search history
            this.addToHistory(query, filters, sortedResults.length);

            console.log(`SearchManager: Found ${sortedResults.length} results`);
            return sortedResults;

        } catch (error) {
            console.error('SearchManager: Search failed:', error);
            throw error;
        }
    }

    /**
     * Gets search suggestions based on query and history
     * @param partialQuery - Partial query string for suggestions
     * @returns Array of suggested search terms
     */
    getSuggestions(partialQuery: string): string[] {
        const suggestions = new Set<string>();

        // Add suggestions from search history
        this.searchHistory
            .filter(entry => entry.query.toLowerCase().includes(partialQuery.toLowerCase()))
            .slice(0, 5)
            .forEach(entry => suggestions.add(entry.query));

        // Add common programming terms if relevant
        const programmingTerms = [
            'function', 'class', 'interface', 'method', 'variable',
            'import', 'export', 'async', 'await', 'promise',
            'error', 'exception', 'test', 'mock', 'config'
        ];

        programmingTerms
            .filter(term => term.toLowerCase().includes(partialQuery.toLowerCase()))
            .slice(0, 3)
            .forEach(term => suggestions.add(term));

        return Array.from(suggestions).slice(0, 8);
    }

    /**
     * Gets recent search history
     * @param limit - Maximum number of history entries to return
     * @returns Array of recent search history entries
     */
    getSearchHistory(limit: number = 10): SearchHistoryEntry[] {
        return this.searchHistory
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }

    /**
     * Clears search history
     */
    clearSearchHistory(): void {
        this.searchHistory = [];
        this.saveSearchHistory();
        console.log('SearchManager: Search history cleared');
    }

    /**
     * Gets file preview for a search result
     * @param filePath - Path to the file
     * @param lineNumber - Line number to center the preview around
     * @param contextLines - Number of lines to include before and after
     * @returns File preview with syntax highlighting
     */
    async getFilePreview(filePath: string, lineNumber: number, contextLines: number = 5): Promise<string> {
        try {
            const fileContent = await this.contextService.getFileContent(filePath);
            if (!fileContent.content) {
                return 'File content not available';
            }

            const lines = fileContent.content.split('\n');
            const startLine = Math.max(0, lineNumber - contextLines - 1);
            const endLine = Math.min(lines.length, lineNumber + contextLines);

            const previewLines = lines.slice(startLine, endLine);
            
            return previewLines
                .map((line, index) => {
                    const actualLineNumber = startLine + index + 1;
                    const isTargetLine = actualLineNumber === lineNumber;
                    const prefix = isTargetLine ? ' ' : '  ';
                    return `${prefix}${actualLineNumber.toString().padStart(4)}: ${line}`;
                })
                .join('\n');

        } catch (error) {
            console.error('SearchManager: Failed to get file preview:', error);
            return 'Preview not available';
        }
    }

    /**
     * Transforms context service results to enhanced search results
     */
    private async transformResults(chunks: any[]): Promise<EnhancedSearchResult[]> {
        const results: EnhancedSearchResult[] = [];

        for (const chunk of chunks) {
            try {
                const result: EnhancedSearchResult = {
                    id: `${chunk.filePath}-${chunk.startLine}`,
                    title: this.extractTitle(chunk),
                    description: this.extractDescription(chunk),
                    filePath: chunk.filePath,
                    language: chunk.language || 'unknown',
                    lineNumber: chunk.startLine || 1,
                    similarity: chunk.similarity || 0,
                    context: chunk.content || '',
                    preview: chunk.content?.substring(0, 200) + '...' || '',
                    lastModified: new Date(), // Would be populated from file stats
                    fileSize: 0, // Would be populated from file stats
                    chunkType: chunk.type || 'unknown'
                };

                results.push(result);
            } catch (error) {
                console.error('SearchManager: Error transforming result:', error);
            }
        }

        return results;
    }

    /**
     * Applies advanced filters to search results
     */
    private applyAdvancedFilters(results: EnhancedSearchResult[], filters: SearchFilters): EnhancedSearchResult[] {
        let filtered = results;

        // Filter by file types
        if (filters.fileTypes && filters.fileTypes.length > 0) {
            filtered = filtered.filter(result => 
                filters.fileTypes!.some(type => result.filePath.endsWith(type))
            );
        }

        // Filter by languages
        if (filters.languages && filters.languages.length > 0) {
            filtered = filtered.filter(result => 
                filters.languages!.includes(result.language)
            );
        }

        // Filter by date range
        if (filters.dateRange) {
            if (filters.dateRange.from) {
                filtered = filtered.filter(result => 
                    result.lastModified >= filters.dateRange!.from!
                );
            }
            if (filters.dateRange.to) {
                filtered = filtered.filter(result => 
                    result.lastModified <= filters.dateRange!.to!
                );
            }
        }

        // Filter by minimum similarity
        if (filters.minSimilarity !== undefined) {
            filtered = filtered.filter(result => 
                result.similarity >= filters.minSimilarity!
            );
        }

        return filtered;
    }

    /**
     * Sorts search results by relevance and similarity
     */
    private sortResults(results: EnhancedSearchResult[]): EnhancedSearchResult[] {
        return results.sort((a, b) => {
            // Primary sort: similarity score
            if (a.similarity !== b.similarity) {
                return b.similarity - a.similarity;
            }

            // Secondary sort: file type preference (source files over tests)
            const aIsTest = a.filePath.includes('test') || a.filePath.includes('spec');
            const bIsTest = b.filePath.includes('test') || b.filePath.includes('spec');
            if (aIsTest !== bIsTest) {
                return aIsTest ? 1 : -1;
            }

            // Tertiary sort: last modified date
            return b.lastModified.getTime() - a.lastModified.getTime();
        });
    }

    /**
     * Generates cache key for search results
     */
    private generateCacheKey(query: string, filters: SearchFilters): string {
        return `${query}-${JSON.stringify(filters)}`;
    }

    /**
     * Caches search results with timeout
     */
    private cacheResults(key: string, results: EnhancedSearchResult[]): void {
        this.resultCache.set(key, results);
        
        // Set timeout to clear cache entry
        setTimeout(() => {
            this.resultCache.delete(key);
        }, this.cacheTimeout);
    }

    /**
     * Adds search to history
     */
    private addToHistory(query: string, filters: SearchFilters, resultCount: number): void {
        const entry: SearchHistoryEntry = {
            query,
            filters,
            timestamp: new Date(),
            resultCount
        };

        // Remove duplicate queries
        this.searchHistory = this.searchHistory.filter(h => h.query !== query);
        
        // Add new entry at the beginning
        this.searchHistory.unshift(entry);

        // Limit history size
        if (this.searchHistory.length > this.maxHistoryEntries) {
            this.searchHistory = this.searchHistory.slice(0, this.maxHistoryEntries);
        }

        this.saveSearchHistory();
    }

    /**
     * Extracts title from chunk content
     */
    private extractTitle(chunk: any): string {
        if (chunk.metadata?.functionName) {
            return `Function: ${chunk.metadata.functionName}`;
        }
        if (chunk.metadata?.className) {
            return `Class: ${chunk.metadata.className}`;
        }
        
        // Extract first meaningful line
        const lines = chunk.content?.split('\n') || [];
        const meaningfulLine = lines.find((line: string) =>
            line.trim() && !line.trim().startsWith('//') && !line.trim().startsWith('*')
        );
        
        return meaningfulLine?.trim().substring(0, 50) + '...' || 'Code snippet';
    }

    /**
     * Extracts description from chunk content
     */
    private extractDescription(chunk: any): string {
        const content = chunk.content || '';
        const lines = content.split('\n');
        
        // Look for comments that might describe the code
        const commentLine = lines.find((line: string) =>
            line.trim().startsWith('//') || line.trim().startsWith('*')
        );
        
        if (commentLine) {
            return commentLine.trim().replace(/^[\/\*\s]+/, '').substring(0, 100);
        }
        
        // Fallback to first few lines
        return lines.slice(0, 2).join(' ').trim().substring(0, 100) + '...';
    }

    /**
     * Loads search history from storage
     */
    private loadSearchHistory(): void {
        // In a real implementation, this would load from VS Code's global state
        // For now, we'll start with an empty history
        this.searchHistory = [];
    }

    /**
     * Saves search history to storage
     */
    private saveSearchHistory(): void {
        // In a real implementation, this would save to VS Code's global state
        console.log('SearchManager: Search history saved');
    }

    /**
     * Disposes of the SearchManager and cleans up resources
     */
    dispose(): void {
        this.resultCache.clear();
        console.log('SearchManager: Disposed');
    }
}
</file>

<file path="src/webviewManager.ts">
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { MessageRouter } from './messageRouter';

/**
 * WebviewManager class responsible for managing all webview panels and their lifecycle.
 * 
 * This class centralizes webview creation, content management, and message handling,
 * providing a clean separation between webview logic and command handlers.
 * It handles:
 * - Main panel and settings panel creation and lifecycle
 * - Webview content loading with proper resource URIs
 * - Panel state management (showing, hiding, disposing)
 * - Integration with ExtensionManager for service access
 */
export class WebviewManager {
    private context: vscode.ExtensionContext;
    private extensionManager: any; // Will be properly typed when we integrate
    private mainPanel: vscode.WebviewPanel | undefined;
    private settingsPanel: vscode.WebviewPanel | undefined;
    private messageRouter: MessageRouter | undefined;

    /**
     * Creates a new WebviewManager instance
     * @param context - The VS Code extension context
     * @param extensionManager - The ExtensionManager instance for service access
     */
    constructor(context: vscode.ExtensionContext, extensionManager: any) {
        this.context = context;
        this.extensionManager = extensionManager;
        this.initializeMessageRouter();
    }

    /**
     * Initializes the MessageRouter with services from ExtensionManager
     */
    private initializeMessageRouter(): void {
        try {
            if (this.extensionManager &&
                this.extensionManager.getContextService &&
                this.extensionManager.getIndexingService) {

                const contextService = this.extensionManager.getContextService();
                const indexingService = this.extensionManager.getIndexingService();

                if (contextService && indexingService) {
                    this.messageRouter = new MessageRouter(contextService, indexingService);

                    // Set advanced managers if available
                    if (this.extensionManager.getSearchManager &&
                        this.extensionManager.getConfigurationManager &&
                        this.extensionManager.getPerformanceManager) {

                        const searchManager = this.extensionManager.getSearchManager();
                        const configurationManager = this.extensionManager.getConfigurationManager();
                        const performanceManager = this.extensionManager.getPerformanceManager();

                        if (searchManager && configurationManager && performanceManager) {
                            this.messageRouter.setAdvancedManagers(
                                searchManager,
                                configurationManager,
                                performanceManager
                            );
                        }
                    }

                    console.log('WebviewManager: MessageRouter initialized');
                }
            }
        } catch (error) {
            console.error('WebviewManager: Failed to initialize MessageRouter:', error);
        }
    }

    /**
     * Shows the main Code Context Engine panel
     * Creates a new panel if one doesn't exist, or reveals the existing one
     */
    public showMainPanel(): void {
        // If panel already exists, just reveal it
        if (this.mainPanel) {
            this.mainPanel.reveal(vscode.ViewColumn.One);
            return;
        }

        // Create new main panel
        this.mainPanel = vscode.window.createWebviewPanel(
            'codeContextMain',
            'Code Context Engine',
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [
                    vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))
                ]
            }
        );

        // Set the webview content
        this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, 'main');

        // Handle panel disposal
        this.mainPanel.onDidDispose(() => {
            this.mainPanel = undefined;
        });

        // Set up message handling for the main panel
        this.setupMessageHandling(this.mainPanel.webview);

        console.log('WebviewManager: Main panel created and shown');
    }

    /**
     * Shows the settings panel
     * Creates a new panel if one doesn't exist, or reveals the existing one
     */
    public showSettingsPanel(): void {
        // If panel already exists, just reveal it
        if (this.settingsPanel) {
            this.settingsPanel.reveal(vscode.ViewColumn.Two);
            return;
        }

        // Create new settings panel
        this.settingsPanel = vscode.window.createWebviewPanel(
            'codeContextSettings',
            'Code Context Settings',
            vscode.ViewColumn.Two,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [
                    vscode.Uri.file(path.join(this.context.extensionPath, 'webview', 'dist'))
                ]
            }
        );

        // Set the webview content
        this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, 'settings');

        // Handle panel disposal
        this.settingsPanel.onDidDispose(() => {
            this.settingsPanel = undefined;
        });

        // Set up message handling for the settings panel
        this.setupMessageHandling(this.settingsPanel.webview);

        console.log('WebviewManager: Settings panel created and shown');
    }

    /**
     * Gets the HTML content for a webview panel
     * Reads the HTML template and replaces placeholders with proper webview URIs
     * @param webview - The webview instance
     * @param panelName - The name of the panel ('main' or 'settings')
     * @returns The HTML content with proper resource URIs
     */
    private getWebviewContent(webview: vscode.Webview, panelName: string): string {
        try {
            // Path to the webview HTML file
            const htmlPath = path.join(this.context.extensionPath, 'webview', 'dist', 'index.html');

            // Check if the HTML file exists
            if (!fs.existsSync(htmlPath)) {
                console.warn('WebviewManager: HTML file not found, using fallback content');
                return this.getFallbackContent(panelName);
            }

            // Read the HTML content
            let htmlContent = fs.readFileSync(htmlPath, 'utf8');

            // Replace relative paths with webview-specific URIs using regex
            // This handles webpack-generated assets like bundle.js, styles, etc.
            htmlContent = htmlContent.replace(
                /(<script[^>]+src="|<link[^>]+href="|src="|href=")(?!https?:\/\/)([^"]*\.(?:js|css|png|jpg|jpeg|gif|svg|ico))"/g,
                (_match, prefix, relativePath) => {
                    const resourcePath = path.join(this.context.extensionPath, 'webview', 'dist', relativePath);
                    const uri = webview.asWebviewUri(vscode.Uri.file(resourcePath));
                    return `${prefix}${uri}"`;
                }
            );

            return htmlContent;
        } catch (error) {
            console.error('WebviewManager: Error loading webview content:', error);
            return this.getFallbackContent(panelName);
        }
    }

    /**
     * Provides fallback HTML content when the main webview files are not available
     * @param panelName - The name of the panel
     * @returns Basic HTML content
     */
    private getFallbackContent(panelName: string): string {
        const title = panelName === 'main' ? 'Code Context Engine' : 'Code Context Settings';
        const content = panelName === 'main' 
            ? `
                <h1>Code Context Engine</h1>
                <p>Welcome to Code Context Engine!</p>
                <p>This is a placeholder interface. The full webview is being developed.</p>
                <button onclick="startIndexing()">Start Indexing</button>
                <script>
                    const vscode = acquireVsCodeApi();
                    function startIndexing() {
                        vscode.postMessage({ command: 'startIndexing' });
                    }
                </script>
            `
            : `
                <h1>Code Context Settings</h1>
                <p>Configure your Code Context Engine settings here.</p>
                <p>This is a placeholder interface. The full settings panel is being developed.</p>
            `;

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            padding: 20px;
        }
        h1 {
            color: var(--vscode-textLink-foreground);
        }
        button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }
    </style>
</head>
<body>
    ${content}
</body>
</html>`;
    }

    /**
     * Sets up message handling for a webview using MessageRouter
     * @param webview - The webview to set up message handling for
     */
    private setupMessageHandling(webview: vscode.Webview): void {
        webview.onDidReceiveMessage(async (message) => {
            try {
                console.log('WebviewManager: Received message:', message.command);

                if (this.messageRouter) {
                    // Use MessageRouter for centralized message handling
                    await this.messageRouter.handleMessage(message, webview);
                } else {
                    // Fallback for basic commands when MessageRouter is not available
                    console.warn('WebviewManager: MessageRouter not available, using fallback handling');

                    switch (message.command) {
                        case 'startIndexing':
                            // Delegate to command
                            await vscode.commands.executeCommand('code-context-engine.startIndexing');
                            break;
                        default:
                            console.log('WebviewManager: Unknown command:', message.command);
                            await webview.postMessage({
                                command: 'error',
                                message: `Command not supported: ${message.command}`
                            });
                            break;
                    }
                }
            } catch (error) {
                console.error('WebviewManager: Error handling message:', error);
                await webview.postMessage({
                    command: 'error',
                    message: error instanceof Error ? error.message : String(error)
                });
            }
        });
    }

    /**
     * Disposes of all webview panels and cleans up resources
     */
    public dispose(): void {
        console.log('WebviewManager: Starting disposal...');

        if (this.mainPanel) {
            this.mainPanel.dispose();
            this.mainPanel = undefined;
        }

        if (this.settingsPanel) {
            this.settingsPanel.dispose();
            this.settingsPanel = undefined;
        }

        console.log('WebviewManager: Disposal completed');
    }

    /**
     * Gets the current main panel instance
     * @returns The main panel or undefined if not created
     */
    public getMainPanel(): vscode.WebviewPanel | undefined {
        return this.mainPanel;
    }

    /**
     * Gets the current settings panel instance
     * @returns The settings panel or undefined if not created
     */
    public getSettingsPanel(): vscode.WebviewPanel | undefined {
        return this.settingsPanel;
    }
}
</file>

<file path="webview/src/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Context Engine</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .header {
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
        }
        .progress-section {
            display: none;
        }
        .progress-section.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Code Context Engine</h1>
            <p>AI-powered code context and search for your workspace</p>
        </div>

        <div class="section">
            <h2>Communication Test</h2>
            <p>Test the communication bridge between webview and extension.</p>
            <fluent-button id="ping-button" appearance="stealth">Send Ping to Extension</fluent-button>
            <div id="ping-result" style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;">
                <!-- Ping result will be displayed here -->
            </div>
        </div>

        <div class="section">
            <h2>Repository Indexing</h2>
            <p>Index your repository to enable AI-powered code search and context analysis.</p>
            <fluent-button id="index-button" appearance="accent">Index Repository</fluent-button>
            
            <div id="progress-section" class="progress-section">
                <h3>Indexing Progress</h3>
                <fluent-progress-ring id="progress-ring"></fluent-progress-ring>
                <p id="progress-text">Starting indexing process...</p>
            </div>
        </div>

        <div class="section">
            <h2>Search & Context</h2>
            <p>Search through your indexed code and get AI-powered context.</p>
            <fluent-text-field id="search-input" placeholder="Search your code..." style="width: 100%; margin-bottom: 10px;"></fluent-text-field>
            <fluent-button id="search-button">Search</fluent-button>
            
            <div id="search-results" style="margin-top: 20px;">
                <!-- Search results will be displayed here -->
            </div>
        </div>

        <div class="section">
            <h2>Settings</h2>
            <p>Configure your Code Context Engine preferences.</p>
            <fluent-button id="settings-button" appearance="stealth">Open Settings</fluent-button>
        </div>
    </div>
</body>
</html>
</file>

<file path="webview/src/index.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./styles.css");
const web_components_1 = require("@fluentui/web-components");
// Register Fluent UI components
(0, web_components_1.provideFluentDesignSystem)()
    .register((0, web_components_1.fluentButton)(), (0, web_components_1.fluentTextField)(), (0, web_components_1.fluentProgressRing)());
class CodeContextWebview {
    constructor() {
        this.vscode = acquireVsCodeApi();
        this.initializeElements();
        this.setupEventListeners();
        this.setupMessageListener();
    }
    initializeElements() {
        this.indexButton = document.getElementById('index-button');
        this.progressSection = document.getElementById('progress-section');
        this.progressRing = document.getElementById('progress-ring');
        this.progressText = document.getElementById('progress-text');
        this.searchButton = document.getElementById('search-button');
        this.searchInput = document.getElementById('search-input');
        this.searchResults = document.getElementById('search-results');
        this.settingsButton = document.getElementById('settings-button');
    }
    setupEventListeners() {
        this.indexButton?.addEventListener('click', () => {
            this.startIndexing();
        });
        this.searchButton?.addEventListener('click', () => {
            this.performSearch();
        });
        this.searchInput?.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                this.performSearch();
            }
        });
        this.settingsButton?.addEventListener('click', () => {
            this.openSettings();
        });
    }
    setupMessageListener() {
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'indexingProgress':
                    this.updateIndexingProgress(message.progress, message.message);
                    break;
                case 'indexingComplete':
                    this.indexingComplete();
                    break;
                case 'searchResults':
                    this.displaySearchResults(message.results);
                    break;
            }
        });
    }
    startIndexing() {
        this.vscode.postMessage({
            command: 'startIndexing'
        });
        // Show progress section
        this.progressSection?.classList.add('visible');
        if (this.indexButton) {
            this.indexButton.disabled = true;
        }
    }
    updateIndexingProgress(progress, message) {
        if (this.progressText) {
            this.progressText.textContent = message;
        }
        // Update progress ring if needed
    }
    indexingComplete() {
        if (this.progressText) {
            this.progressText.textContent = 'Indexing complete!';
        }
        if (this.indexButton) {
            this.indexButton.disabled = false;
        }
        // Hide progress section after a delay
        setTimeout(() => {
            this.progressSection?.classList.remove('visible');
        }, 2000);
    }
    performSearch() {
        const searchTerm = this.searchInput?.value;
        if (!searchTerm)
            return;
        this.vscode.postMessage({
            command: 'search',
            query: searchTerm
        });
        // Show loading state
        if (this.searchResults) {
            this.searchResults.innerHTML = '<p>Searching...</p>';
        }
    }
    displaySearchResults(results) {
        if (!this.searchResults)
            return;
        if (results.length === 0) {
            this.searchResults.innerHTML = '<p>No results found.</p>';
            return;
        }
        const resultsHtml = results.map(result => `
            <div style="margin-bottom: 15px; padding: 10px; border: 1px solid var(--vscode-panel-border); border-radius: 4px;">
                <h4>${result.file}</h4>
                <p>${result.snippet}</p>
                <small>Line ${result.line}</small>
            </div>
        `).join('');
        this.searchResults.innerHTML = resultsHtml;
    }
    openSettings() {
        this.vscode.postMessage({
            command: 'openSettings'
        });
    }
}
// Initialize the webview when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new CodeContextWebview();
});
//# sourceMappingURL=index.js.map
</file>

<file path="webview/src/index.js.map">
{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";;AAAA,wBAAsB;AACtB,6DAKkC;AAElC,gCAAgC;AAChC,IAAA,0CAAyB,GAAE;KACtB,QAAQ,CACL,IAAA,6BAAY,GAAE,EACd,IAAA,gCAAe,GAAE,EACjB,IAAA,mCAAkB,GAAE,CACvB,CAAC;AASN,MAAM,kBAAkB;IAWpB;QACI,IAAI,CAAC,MAAM,GAAG,gBAAgB,EAAE,CAAC;QACjC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAChC,CAAC;IAEO,kBAAkB;QACtB,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;QAC3D,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,cAAc,CAAC,kBAAkB,CAAC,CAAC;QACnE,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;QAC7D,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;QAC7D,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;QAC7D,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;QAC3D,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;QAC/D,IAAI,CAAC,cAAc,GAAG,QAAQ,CAAC,cAAc,CAAC,iBAAiB,CAAC,CAAC;IACrE,CAAC;IAEO,mBAAmB;QACvB,IAAI,CAAC,WAAW,EAAE,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE;YAC7C,IAAI,CAAC,aAAa,EAAE,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,YAAY,EAAE,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE;YAC9C,IAAI,CAAC,aAAa,EAAE,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,EAAE,gBAAgB,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,EAAE;YACrD,IAAK,KAAuB,CAAC,GAAG,KAAK,OAAO,EAAE;gBAC1C,IAAI,CAAC,aAAa,EAAE,CAAC;aACxB;QACL,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,cAAc,EAAE,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE;YAChD,IAAI,CAAC,YAAY,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,oBAAoB;QACxB,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,KAAK,CAAC,EAAE;YACvC,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC;YAC3B,QAAQ,OAAO,CAAC,OAAO,EAAE;gBACrB,KAAK,kBAAkB;oBACnB,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;oBAC/D,MAAM;gBACV,KAAK,kBAAkB;oBACnB,IAAI,CAAC,gBAAgB,EAAE,CAAC;oBACxB,MAAM;gBACV,KAAK,eAAe;oBAChB,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;oBAC3C,MAAM;aACb;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,aAAa;QACjB,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;YACpB,OAAO,EAAE,eAAe;SAC3B,CAAC,CAAC;QAEH,wBAAwB;QACxB,IAAI,CAAC,eAAe,EAAE,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAC/C,IAAI,IAAI,CAAC,WAAW,EAAE;YACjB,IAAI,CAAC,WAAmB,CAAC,QAAQ,GAAG,IAAI,CAAC;SAC7C;IACL,CAAC;IAEO,sBAAsB,CAAC,QAAgB,EAAE,OAAe;QAC5D,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAI,CAAC,YAAY,CAAC,WAAW,GAAG,OAAO,CAAC;SAC3C;QACD,iCAAiC;IACrC,CAAC;IAEO,gBAAgB;QACpB,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAI,CAAC,YAAY,CAAC,WAAW,GAAG,oBAAoB,CAAC;SACxD;QACD,IAAI,IAAI,CAAC,WAAW,EAAE;YACjB,IAAI,CAAC,WAAmB,CAAC,QAAQ,GAAG,KAAK,CAAC;SAC9C;QAED,sCAAsC;QACtC,UAAU,CAAC,GAAG,EAAE;YACZ,IAAI,CAAC,eAAe,EAAE,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QACtD,CAAC,EAAE,IAAI,CAAC,CAAC;IACb,CAAC;IAEO,aAAa;QACjB,MAAM,UAAU,GAAI,IAAI,CAAC,WAAmB,EAAE,KAAK,CAAC;QACpD,IAAI,CAAC,UAAU;YAAE,OAAO;QAExB,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;YACpB,OAAO,EAAE,QAAQ;YACjB,KAAK,EAAE,UAAU;SACpB,CAAC,CAAC;QAEH,qBAAqB;QACrB,IAAI,IAAI,CAAC,aAAa,EAAE;YACpB,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,qBAAqB,CAAC;SACxD;IACL,CAAC;IAEO,oBAAoB,CAAC,OAAc;QACvC,IAAI,CAAC,IAAI,CAAC,aAAa;YAAE,OAAO;QAEhC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,0BAA0B,CAAC;YAC1D,OAAO;SACV;QAED,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;;sBAE5B,MAAM,CAAC,IAAI;qBACZ,MAAM,CAAC,OAAO;8BACL,MAAM,CAAC,IAAI;;SAEhC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAEZ,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,WAAW,CAAC;IAC/C,CAAC;IAEO,YAAY;QAChB,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;YACpB,OAAO,EAAE,cAAc;SAC1B,CAAC,CAAC;IACP,CAAC;CACJ;AAED,4CAA4C;AAC5C,QAAQ,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,GAAG,EAAE;IAC/C,IAAI,kBAAkB,EAAE,CAAC;AAC7B,CAAC,CAAC,CAAC"}
</file>

<file path="webview/package.json">
{
  "name": "code-context-engine-webview",
  "version": "1.0.0",
  "description": "Webview for Code Context Engine VS Code Extension",
  "main": "dist/index.js",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack --mode development --watch",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "webpack": "^5.88.0",
    "webpack-cli": "^5.1.0",
    "ts-loader": "^9.4.0",
    "typescript": "^4.9.0",
    "css-loader": "^6.8.0",
    "style-loader": "^3.3.0",
    "html-webpack-plugin": "^5.5.0"
  },
  "dependencies": {
    "@fluentui/web-components": "^2.5.16"
  }
}
</file>

<file path="webview/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "DOM",
      "DOM.Iterable",
      "ES6"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": false,
    "strictPropertyInitialization": false,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": false,
    "declaration": true,
    "outDir": "./dist"
  },
  "include": [
    "src"
  ]
}
</file>

<file path="webview/webpack.config.js">
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.ts',
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html',
    }),
  ],
};
</file>

<file path=".eslintrc.json">
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 6,
        "sourceType": "module"
    },
    "plugins": [
        "@typescript-eslint"
    ],
    "rules": {
        "@typescript-eslint/naming-convention": [
            "warn",
            {
                "selector": "import",
                "format": [ "camelCase", "PascalCase" ]
            }
        ],
        "@typescript-eslint/semi": "warn",
        "curly": "warn",
        "eqeqeq": "warn",
        "no-throw-literal": "warn",
        "semi": "off"
    },
    "ignorePatterns": [
        "out",
        "dist",
        "**/*.d.ts"
    ]
}
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
</file>

<file path=".vscodeignore">
# Source files
src/**
webview/src/**
webview/node_modules/**

# Build artifacts
*.vsix
out/test/**

# Development files
.vscode/**
.vscode-test/**
.gitignore
.github/**
.eslintrc.json
tsconfig.json
vsc-extension-quickstart.md

# Documentation
docs/**
*.md
!README.md

# Node modules and dependencies
node_modules/**
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Test files
test/**
**/*.test.ts
**/*.spec.ts

# Configuration files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.idea/**
*.swp
*.swo
*~

# OS files
.DS_Store
Thumbs.db

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Repomix output
repomix-output.xml
repomix.config.json

# Docker files
docker-compose.yml
Dockerfile*

# Development scripts
scripts/**
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  qdrant:
    image: qdrant/qdrant:latest
    container_name: code-context-qdrant
    ports:
      - "6333:6333"  # REST API port
      - "6334:6334"  # gRPC port
    volumes:
      - ./qdrant_storage:/qdrant/storage
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
      - QDRANT__SERVICE__GRPC_PORT=6334
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Optional: Ollama service for local embeddings
  # Uncomment if you want to run Ollama locally
  # ollama:
  #   image: ollama/ollama:latest
  #   container_name: code-context-ollama
  #   ports:
  #     - "11434:11434"
  #   volumes:
  #     - ./ollama_data:/root/.ollama
  #   restart: unless-stopped
  #   environment:
  #     - OLLAMA_HOST=0.0.0.0
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="src/db/qdrantService.ts">
import { QdrantClient } from '@qdrant/js-client-rest';
import { CodeChunk } from '../parsing/chunker';

export interface QdrantPoint {
    id: string | number;
    vector: number[];
    payload: {
        filePath: string;
        content: string;
        startLine: number;
        endLine: number;
        type: string;
        name?: string;
        signature?: string;
        docstring?: string;
        language: string;
        metadata?: Record<string, any>;
    };
}

export interface SearchResult {
    id: string | number;
    score: number;
    payload: QdrantPoint['payload'];
}

export class QdrantService {
    private client: QdrantClient;
    private connectionString: string;

    /**
     * Constructor now accepts connectionString as a required parameter
     * This enables dependency injection and removes direct VS Code configuration access
     */
    constructor(connectionString: string) {
        this.connectionString = connectionString;
        this.client = new QdrantClient({
            host: this.extractHost(connectionString),
            port: this.extractPort(connectionString)
        });
    }

    private extractHost(connectionString: string): string {
        try {
            const url = new URL(connectionString);
            return url.hostname;
        } catch {
            return 'localhost';
        }
    }

    private extractPort(connectionString: string): number {
        try {
            const url = new URL(connectionString);
            return parseInt(url.port) || 6333;
        } catch {
            return 6333;
        }
    }

    /**
     * Check if Qdrant service is accessible
     */
    async healthCheck(): Promise<boolean> {
        try {
            await this.client.getCollections();
            return true;
        } catch (error) {
            console.error('Qdrant health check failed:', error);
            return false;
        }
    }

    /**
     * Create a collection if it doesn't exist
     */
    async createCollectionIfNotExists(
        collectionName: string, 
        vectorSize: number = 768, 
        distance: 'Cosine' | 'Dot' | 'Euclid' = 'Cosine'
    ): Promise<boolean> {
        try {
            // Check if collection exists
            const collections = await this.client.getCollections();
            const existingCollection = collections.collections?.find(
                col => col.name === collectionName
            );

            if (existingCollection) {
                console.log(`Collection '${collectionName}' already exists`);
                return true;
            }

            // Create new collection
            await this.client.createCollection(collectionName, {
                vectors: {
                    size: vectorSize,
                    distance: distance
                }
            });

            console.log(`Collection '${collectionName}' created successfully`);
            return true;
        } catch (error) {
            console.error(`Failed to create collection '${collectionName}':`, error);
            return false;
        }
    }

    /**
     * Convert CodeChunk to QdrantPoint format
     */
    private chunkToPoint(chunk: CodeChunk, vector: number[], index: number): QdrantPoint {
        return {
            id: `${chunk.filePath}:${chunk.startLine}-${chunk.endLine}:${index}`,
            vector: vector,
            payload: {
                filePath: chunk.filePath,
                content: chunk.content,
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                type: chunk.type,
                name: chunk.name,
                signature: chunk.signature,
                docstring: chunk.docstring,
                language: chunk.language,
                metadata: chunk.metadata
            }
        };
    }

    /**
     * Upsert chunks with their vectors into the collection
     */
    async upsertChunks(
        collectionName: string, 
        chunks: CodeChunk[], 
        vectors: number[][]
    ): Promise<boolean> {
        try {
            if (chunks.length !== vectors.length) {
                throw new Error(`Chunks count (${chunks.length}) doesn't match vectors count (${vectors.length})`);
            }

            // Convert chunks to points
            const points = chunks.map((chunk, index) => 
                this.chunkToPoint(chunk, vectors[index], index)
            );

            // Upsert points in batches to avoid memory issues
            const batchSize = 100;
            for (let i = 0; i < points.length; i += batchSize) {
                const batch = points.slice(i, i + batchSize);
                
                await this.client.upsert(collectionName, {
                    wait: true,
                    points: batch
                });

                console.log(`Upserted batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(points.length / batchSize)} (${batch.length} points)`);
            }

            console.log(`Successfully upserted ${points.length} chunks to collection '${collectionName}'`);
            return true;
        } catch (error) {
            console.error(`Failed to upsert chunks to collection '${collectionName}':`, error);
            return false;
        }
    }

    /**
     * Search for similar vectors in the collection
     */
    async search(
        collectionName: string, 
        queryVector: number[], 
        limit: number = 10,
        filter?: any
    ): Promise<SearchResult[]> {
        try {
            const searchResult = await this.client.search(collectionName, {
                vector: queryVector,
                limit: limit,
                with_payload: true,
                filter: filter
            });

            return searchResult.map(point => ({
                id: point.id,
                score: point.score || 0,
                payload: point.payload as QdrantPoint['payload']
            }));
        } catch (error) {
            console.error(`Search failed in collection '${collectionName}':`, error);
            return [];
        }
    }

    /**
     * Get collection info
     */
    async getCollectionInfo(collectionName: string): Promise<any> {
        try {
            return await this.client.getCollection(collectionName);
        } catch (error) {
            console.error(`Failed to get collection info for '${collectionName}':`, error);
            return null;
        }
    }

    /**
     * Delete collection
     */
    async deleteCollection(collectionName: string): Promise<boolean> {
        try {
            await this.client.deleteCollection(collectionName);
            console.log(`Collection '${collectionName}' deleted successfully`);
            return true;
        } catch (error) {
            console.error(`Failed to delete collection '${collectionName}':`, error);
            return false;
        }
    }

    /**
     * Get all collections
     */
    async getCollections(): Promise<string[]> {
        try {
            const collections = await this.client.getCollections();
            return collections.collections?.map(col => col.name) || [];
        } catch (error) {
            console.error('Failed to get collections:', error);
            return [];
        }
    }
}
</file>

<file path="src/embeddings/embeddingProvider.ts">
/**
 * Core interface for embedding providers that can generate vector embeddings from text
 *
 * This interface defines the contract that all embedding providers must implement,
 * ensuring consistent behavior across different embedding services (OpenAI, Ollama, etc.)
 */
export interface IEmbeddingProvider {
    /**
     * Generate vector embeddings for an array of text chunks
     *
     * This is the main method that converts text into numerical vector representations
     * that can be used for semantic search, similarity comparison, and other AI tasks.
     *
     * @param chunks - Array of text strings to convert to embeddings
     * @returns Promise resolving to array of embedding vectors, where each vector
     *          corresponds to the input chunk at the same index
     */
    generateEmbeddings(chunks: string[]): Promise<number[][]>;

    /**
     * Get the dimension size of embeddings produced by this provider
     *
     * Different embedding models produce vectors of different dimensions.
     * This information is crucial for vector database operations and compatibility checks.
     *
     * @returns The vector dimension size (e.g., 768, 1536, 1024)
     */
    getDimensions(): number;

    /**
     * Get the name/identifier of this embedding provider
     *
     * This method returns a unique identifier that includes both the provider type
     * and the specific model being used, useful for logging and debugging.
     *
     * @returns Provider name in format "provider:model" (e.g., "openai:text-embedding-ada-002")
     */
    getProviderName(): string;

    /**
     * Check if the provider is properly configured and available
     *
     * This method validates that the provider service is accessible and properly
     * configured before attempting to use it for embedding generation.
     *
     * @returns Promise resolving to true if provider is ready and available
     */
    isAvailable(): Promise<boolean>;
}

/**
 * Configuration interface for embedding providers
 *
 * This interface defines the configuration options needed to initialize
 * different types of embedding providers. The structure is designed to be
 * flexible enough to work with various embedding services while maintaining
 * a consistent interface.
 */
export interface EmbeddingConfig {
    /** The type of embedding provider to use ('ollama' or 'openai') */
    provider: 'ollama' | 'openai';
    
    /** The specific model name to use for embeddings (optional, uses default if not specified) */
    model?: string;
    
    /** API key for authentication (required for OpenAI, not needed for Ollama) */
    apiKey?: string;
    
    /** Base URL for the embedding service (optional, uses default if not specified) */
    baseUrl?: string;
    
    /** Maximum number of chunks to process in a single batch (optional, uses provider defaults) */
    maxBatchSize?: number;
    
    /** Timeout for API requests in milliseconds (optional, uses provider defaults) */
    timeout?: number;
}

/**
 * Result interface for embedding generation operations
 *
 * This interface provides detailed information about the embedding generation process,
 * including the actual embeddings, performance metrics, and any errors that occurred.
 */
export interface EmbeddingResult {
    /** The generated embedding vectors, one for each input chunk */
    embeddings: number[][];
    
    /** Total number of tokens processed (if available from the provider) */
    totalTokens?: number;
    
    /** Total processing time in milliseconds */
    processingTime: number;
    
    /** Array of error messages for any chunks that failed to process */
    errors: string[];
}

/**
 * Factory class for creating embedding providers
 *
 * This factory class implements the Factory Design Pattern to provide a clean,
 * centralized way to create different types of embedding providers based on
 * configuration. It supports dynamic imports to avoid loading unnecessary dependencies
 * and integrates with the centralized configuration system.
 */
export class EmbeddingProviderFactory {
    /**
     * Create an embedding provider instance based on configuration
     *
     * This method dynamically imports and instantiates the appropriate embedding provider
     * based on the provider type specified in the configuration. This approach ensures
     * that only the necessary provider code is loaded, improving startup performance.
     *
     * @param config - Configuration object specifying the provider type and its settings
     * @returns Promise resolving to a configured embedding provider instance
     * @throws Error if the specified provider type is not supported
     */
    static async createProvider(config: EmbeddingConfig): Promise<IEmbeddingProvider> {
        switch (config.provider) {
            case 'ollama':
                // Dynamically import Ollama provider to avoid loading it when not needed
                const { OllamaProvider } = await import('./ollamaProvider');
                return new OllamaProvider(config);
            case 'openai':
                // Dynamically import OpenAI provider to avoid loading it when not needed
                const { OpenAIProvider } = await import('./openaiProvider');
                return new OpenAIProvider(config);
            default:
                throw new Error(`Unsupported embedding provider: ${config.provider}. Supported providers: ${this.getSupportedProviders().join(', ')}`);
        }
    }

    /**
     * Create an embedding provider using the centralized ConfigService
     *
     * This method integrates with the application's centralized configuration system
     * to automatically retrieve the appropriate configuration for the specified
     * embedding provider type. This ensures consistency across the application
     * and reduces configuration duplication.
     *
     * @param configService - The centralized configuration service instance
     * @returns Promise resolving to a configured embedding provider instance
     * @throws Error if the provider type is not supported or configuration is invalid
     */
    static async createProviderFromConfigService(configService: any): Promise<IEmbeddingProvider> {
        // Get the configured provider type from the central configuration
        const providerType = configService.getEmbeddingProvider();

        let config: EmbeddingConfig;

        // Build configuration based on provider type
        if (providerType === 'ollama') {
            const ollamaConfig = configService.getOllamaConfig();
            config = {
                provider: 'ollama',
                model: ollamaConfig.model,
                baseUrl: ollamaConfig.apiUrl,
                maxBatchSize: ollamaConfig.maxBatchSize,
                timeout: ollamaConfig.timeout
            };
        } else if (providerType === 'openai') {
            const openaiConfig = configService.getOpenAIConfig();
            config = {
                provider: 'openai',
                model: openaiConfig.model,
                apiKey: openaiConfig.apiKey,
                maxBatchSize: openaiConfig.maxBatchSize,
                timeout: openaiConfig.timeout
            };
        } else {
            throw new Error(`Unsupported embedding provider: ${providerType}. Supported providers: ${this.getSupportedProviders().join(', ')}`);
        }

        // Create the provider using the standard factory method
        return this.createProvider(config);
    }

    /**
     * Get list of supported embedding provider types
     *
     * This method returns an array of all supported embedding provider types,
     * which can be useful for UI components, validation, and documentation.
     *
     * @returns Array of supported provider type strings
     */
    static getSupportedProviders(): string[] {
        return ['ollama', 'openai'];
    }
}
</file>

<file path="src/embeddings/ollamaProvider.ts">
import axios, { AxiosInstance } from 'axios';
import { IEmbeddingProvider, EmbeddingConfig } from './embeddingProvider';

/**
 * Ollama embedding provider implementation
 *
 * This class provides an implementation of the IEmbeddingProvider interface for
 * Ollama, a local open-source large language model runner. It allows users to
 * generate embeddings locally without relying on external APIs, providing better
 * privacy and potentially lower latency for local development workflows.
 *
 * Ollama embeddings are particularly useful for:
 * - Local development environments without internet access
 * - Privacy-sensitive applications where data shouldn't leave the local machine
 * - Applications requiring offline capabilities
 * - Cost-sensitive projects where API costs are a concern
 */
export class OllamaProvider implements IEmbeddingProvider {
    /** HTTP client for making API requests to Ollama */
    private client: AxiosInstance;
    
    /** The name of the embedding model to use */
    private model: string;
    
    /** Base URL of the Ollama service (default: localhost:11434) */
    private baseUrl: string;
    
    /** Maximum number of chunks to process in a single batch (default: 10) */
    private maxBatchSize: number;
    
    /** Request timeout in milliseconds (default: 30000) */
    private timeout: number;

    /**
     * Initialize the Ollama embedding provider
     *
     * @param config - Configuration object for the Ollama provider
     *
     * The constructor sets up the HTTP client with appropriate configuration
     * and validates that the necessary parameters are provided. It uses
     * sensible defaults for most parameters while allowing customization
     * through the configuration object.
     */
    constructor(config: EmbeddingConfig) {
        // Set model with fallback to a popular default
        this.model = config.model || 'nomic-embed-text';
        
        // Set base URL with fallback to local Ollama default
        this.baseUrl = config.baseUrl || 'http://localhost:11434';
        
        // Set batch size with conservative default to avoid overwhelming local service
        this.maxBatchSize = config.maxBatchSize || 10;
        
        // Set timeout with reasonable default for local operations
        this.timeout = config.timeout || 30000;

        // Configure HTTP client for Ollama API communication
        this.client = axios.create({
            baseURL: this.baseUrl,
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }

    /**
     * Generate embeddings for an array of text chunks
     *
     * This method processes text chunks in batches to optimize performance
     * and avoid overwhelming the local Ollama service. It implements robust
     * error handling to ensure that partial failures don't break the entire
     * embedding generation process.
     *
     * @param chunks - Array of text strings to convert to embeddings
     * @returns Promise resolving to array of embedding vectors
     *
     * The method maintains array alignment even when some chunks fail to process
     * by substituting zero vectors for failed chunks, ensuring that the output
     * array always matches the input array in length.
     */
    async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        // Early return for empty input to avoid unnecessary processing
        if (chunks.length === 0) {
            return [];
        }

        const embeddings: number[][] = [];
        const errors: string[] = [];

        // Process chunks in batches to avoid overwhelming the local API
        for (let i = 0; i < chunks.length; i += this.maxBatchSize) {
            const batch = chunks.slice(i, i + this.maxBatchSize);
            
            try {
                const batchEmbeddings = await this.processBatch(batch);
                embeddings.push(...batchEmbeddings);
            } catch (error) {
                const errorMessage = `Failed to process batch ${Math.floor(i / this.maxBatchSize) + 1}: ${error instanceof Error ? error.message : String(error)}`;
                errors.push(errorMessage);
                console.error(errorMessage);
                
                // Add zero vectors for failed chunks to maintain array alignment
                // This ensures the output array length matches the input array length
                for (let j = 0; j < batch.length; j++) {
                    embeddings.push(new Array(this.getDimensions()).fill(0));
                }
            }
        }

        // Log warnings if there were any processing errors
        if (errors.length > 0) {
            console.warn(`Ollama embedding generation completed with ${errors.length} errors`);
        }

        return embeddings;
    }

    /**
     * Process a batch of text chunks for embedding generation
     *
     * This private method handles the actual API communication with Ollama.
     * Unlike some other providers, Ollama typically processes one embedding
     * at a time, so this method loops through each chunk in the batch.
     *
     * @param chunks - Array of text chunks to process
     * @returns Promise resolving to array of embedding vectors
     * @throws Error if the API request fails or returns invalid data
     *
     * The method includes comprehensive error handling for common issues
     * like connection problems, missing models, and API errors.
     */
    private async processBatch(chunks: string[]): Promise<number[][]> {
        const embeddings: number[][] = [];

        // Ollama API typically processes one embedding at a time
        // Loop through each chunk and make individual API calls
        for (const chunk of chunks) {
            try {
                const response = await this.client.post('/api/embeddings', {
                    model: this.model,
                    prompt: chunk
                });

                // Validate response format and extract embedding
                if (response.data && response.data.embedding) {
                    embeddings.push(response.data.embedding);
                } else {
                    throw new Error('Invalid response format from Ollama API');
                }
            } catch (error) {
                // Handle specific error cases with helpful messages
                if (axios.isAxiosError(error)) {
                    if (error.response?.status === 404) {
                        throw new Error(`Model '${this.model}' not found. Please pull the model first: ollama pull ${this.model}`);
                    } else if (error.code === 'ECONNREFUSED') {
                        throw new Error('Cannot connect to Ollama. Please ensure Ollama is running on ' + this.baseUrl);
                    } else {
                        throw new Error(`Ollama API error: ${error.response?.data?.error || error.message}`);
                    }
                } else {
                    throw error;
                }
            }
        }

        return embeddings;
    }

    /**
     * Get the dimension size of embeddings for the current model
     *
     * Different embedding models produce vectors of different dimensions.
     * This method uses a lookup table for common Ollama models and falls
     * back to a reasonable default for unknown models.
     *
     * @returns The vector dimension size (e.g., 768 for nomic-embed-text)
     */
    getDimensions(): number {
        // Common dimensions for popular Ollama embedding models
        const modelDimensions: Record<string, number> = {
            'nomic-embed-text': 768,
            'all-minilm': 384,
            'sentence-transformers/all-MiniLM-L6-v2': 384,
            'mxbai-embed-large': 1024
        };

        // Return known dimension or default to 768 for unknown models
        return modelDimensions[this.model] || 768;
    }

    /**
     * Get the provider name identifier
     *
     * This method returns a unique identifier that includes both the
     * provider type and the specific model being used, useful for
     * logging, debugging, and display purposes.
     *
     * @returns Provider name in format "ollama:model-name"
     */
    getProviderName(): string {
        return `ollama:${this.model}`;
    }

    /**
     * Check if the Ollama service and model are available
     *
     * This method performs two checks:
     * 1. Verifies that the Ollama service is running and accessible
     * 2. Confirms that the specified embedding model is available
     *
     * @returns Promise resolving to true if both service and model are available
     */
    async isAvailable(): Promise<boolean> {
        try {
            // First check: Verify Ollama service is running
            const response = await this.client.get('/api/tags');
            
            // Second check: Verify the specific model is available
            if (response.data && response.data.models) {
                const modelExists = response.data.models.some((model: any) =>
                    model.name === this.model || model.name.startsWith(this.model + ':')
                );
                
                if (!modelExists) {
                    console.warn(`Model '${this.model}' not found in Ollama. Available models:`,
                        response.data.models.map((m: any) => m.name));
                    return false;
                }
            }

            return true;
        } catch (error) {
            // Provide specific error messages for common connection issues
            if (axios.isAxiosError(error) && error.code === 'ECONNREFUSED') {
                console.error('Ollama is not running. Please start Ollama service.');
            } else {
                console.error('Failed to check Ollama availability:', error);
            }
            return false;
        }
    }

    /**
     * Get list of available models from the Ollama service
     *
     * This method queries the Ollama service to get a list of all
     * currently available models. This can be useful for UI components
     * that need to show users what models they can use.
     *
     * @returns Promise resolving to array of available model names
     */
    async getAvailableModels(): Promise<string[]> {
        try {
            const response = await this.client.get('/api/tags');
            if (response.data && response.data.models) {
                return response.data.models.map((model: any) => model.name);
            }
            return [];
        } catch (error) {
            console.error('Failed to get available models:', error);
            return [];
        }
    }

    /**
     * Pull a model from the Ollama registry
     *
     * This method allows the application to automatically download and
     * install models from the Ollama registry if they're not already
     * available locally. This provides a better user experience by
     * handling model management automatically.
     *
     * @param modelName - The name of the model to pull
     * @returns Promise resolving to true if the model was successfully pulled
     */
    async pullModel(modelName: string): Promise<boolean> {
        try {
            console.log(`Pulling model '${modelName}' from Ollama...`);
            await this.client.post('/api/pull', {
                name: modelName
            });
            console.log(`Model '${modelName}' pulled successfully`);
            return true;
        } catch (error) {
            console.error(`Failed to pull model '${modelName}':`, error);
            return false;
        }
    }
}
</file>

<file path="src/embeddings/openaiProvider.ts">
import axios, { AxiosInstance } from 'axios';
import { IEmbeddingProvider, EmbeddingConfig } from './embeddingProvider';

/**
 * OpenAI embedding provider implementation
 *
 * This class provides an implementation of the IEmbeddingProvider interface for
 * OpenAI's embedding services. It leverages OpenAI's powerful embedding models
 * like text-embedding-ada-002 and text-embedding-3-series to generate high-quality
 * vector representations of text for semantic search, clustering, and other AI tasks.
 *
 * OpenAI embeddings are particularly useful for:
 * - High-quality semantic understanding
 * - Access to state-of-the-art language models
 * - Integration with other OpenAI services
 * - Applications requiring the latest in AI capabilities
 */
export class OpenAIProvider implements IEmbeddingProvider {
    /** HTTP client for making API requests to OpenAI */
    private client: AxiosInstance;
    
    /** The name of the embedding model to use */
    private model: string;
    
    /** OpenAI API key for authentication */
    private apiKey: string;
    
    /** Maximum number of chunks to process in a single batch (default: 100) */
    private maxBatchSize: number;
    
    /** Request timeout in milliseconds (default: 60000) */
    private timeout: number;

    /**
     * Initialize the OpenAI embedding provider
     *
     * @param config - Configuration object for the OpenAI provider
     *
     * The constructor validates that an API key is provided and sets up the
     * HTTP client with appropriate authentication headers. It uses sensible
     * defaults for most parameters while allowing customization through the
     * configuration object.
     *
     * @throws Error if API key is not provided
     */
    constructor(config: EmbeddingConfig) {
        // Set model with fallback to a popular default
        this.model = config.model || 'text-embedding-ada-002';
        
        // API key is required for OpenAI services
        this.apiKey = config.apiKey || '';
        
        // Set batch size with larger default since OpenAI supports bigger batches
        this.maxBatchSize = config.maxBatchSize || 100;
        
        // Set longer timeout for external API calls
        this.timeout = config.timeout || 60000;

        // Validate that API key is provided
        if (!this.apiKey) {
            throw new Error('OpenAI API key is required. Please set it in VS Code settings.');
        }

        // Configure HTTP client for OpenAI API communication with authentication
        this.client = axios.create({
            baseURL: 'https://api.openai.com/v1',
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.apiKey}`
            }
        });
    }

    /**
     * Generate embeddings for an array of text chunks
     *
     * This method processes text chunks in batches to optimize performance
     * and stay within OpenAI's rate limits. Unlike some other providers,
     * OpenAI's embedding API can process multiple inputs in a single request,
     * making batch processing very efficient.
     *
     * @param chunks - Array of text strings to convert to embeddings
     * @returns Promise resolving to array of embedding vectors
     *
     * The method maintains array alignment even when some chunks fail to process
     * by substituting zero vectors for failed chunks, ensuring that the output
     * array always matches the input array in length.
     */
    async generateEmbeddings(chunks: string[]): Promise<number[][]> {
        // Early return for empty input to avoid unnecessary processing
        if (chunks.length === 0) {
            return [];
        }

        const embeddings: number[][] = [];
        const errors: string[] = [];

        // Process chunks in batches to optimize API usage and avoid rate limits
        for (let i = 0; i < chunks.length; i += this.maxBatchSize) {
            const batch = chunks.slice(i, i + this.maxBatchSize);
            
            try {
                const batchEmbeddings = await this.processBatch(batch);
                embeddings.push(...batchEmbeddings);
            } catch (error) {
                const errorMessage = `Failed to process batch ${Math.floor(i / this.maxBatchSize) + 1}: ${error instanceof Error ? error.message : String(error)}`;
                errors.push(errorMessage);
                console.error(errorMessage);
                
                // Add zero vectors for failed chunks to maintain array alignment
                // This ensures the output array length matches the input array length
                for (let j = 0; j < batch.length; j++) {
                    embeddings.push(new Array(this.getDimensions()).fill(0));
                }
            }
        }

        // Log warnings if there were any processing errors
        if (errors.length > 0) {
            console.warn(`OpenAI embedding generation completed with ${errors.length} errors`);
        }

        return embeddings;
    }

    /**
     * Process a batch of text chunks for embedding generation
     *
     * This private method handles the actual API communication with OpenAI.
     * Unlike Ollama, OpenAI's embedding API can process multiple inputs
     * in a single request, making it more efficient for batch processing.
     *
     * @param chunks - Array of text chunks to process
     * @returns Promise resolving to array of embedding vectors
     * @throws Error if the API request fails or returns invalid data
     *
     * The method includes comprehensive error handling for common issues
     * like authentication problems, rate limits, invalid requests, and
     * model availability.
     */
    private async processBatch(chunks: string[]): Promise<number[][]> {
        try {
            const response = await this.client.post('/embeddings', {
                model: this.model,
                input: chunks,
                encoding_format: 'float'
            });

            // Validate response format and extract embeddings
            if (response.data && response.data.data) {
                // OpenAI returns embeddings in the same order as input
                return response.data.data.map((item: any) => item.embedding);
            } else {
                throw new Error('Invalid response format from OpenAI API');
            }
        } catch (error) {
            // Handle specific error cases with helpful messages
            if (axios.isAxiosError(error)) {
                if (error.response?.status === 401) {
                    throw new Error('Invalid OpenAI API key. Please check your API key in VS Code settings.');
                } else if (error.response?.status === 429) {
                    throw new Error('OpenAI API rate limit exceeded. Please try again later.');
                } else if (error.response?.status === 400) {
                    const errorData = error.response.data;
                    if (errorData?.error?.code === 'invalid_request_error') {
                        throw new Error(`OpenAI API error: ${errorData.error.message}`);
                    }
                    throw new Error('Bad request to OpenAI API. Check your input data.');
                } else if (error.response?.status === 404) {
                    throw new Error(`Model '${this.model}' not found. Please check the model name.`);
                } else {
                    throw new Error(`OpenAI API error (${error.response?.status}): ${error.response?.data?.error?.message || error.message}`);
                }
            } else {
                throw error;
            }
        }
    }

    /**
     * Get the dimension size of embeddings for the current model
     *
     * Different embedding models produce vectors of different dimensions.
     * This method uses a lookup table for common OpenAI embedding models
     * and falls back to a reasonable default for unknown models.
     *
     * @returns The vector dimension size (e.g., 1536 for ada-002)
     */
    getDimensions(): number {
        // Dimensions for popular OpenAI embedding models
        const modelDimensions: Record<string, number> = {
            'text-embedding-ada-002': 1536,
            'text-embedding-3-small': 1536,
            'text-embedding-3-large': 3072
        };

        // Return known dimension or default to ada-002 dimensions for unknown models
        return modelDimensions[this.model] || 1536;
    }

    /**
     * Get the provider name identifier
     *
     * This method returns a unique identifier that includes both the
     * provider type and the specific model being used, useful for
     * logging, debugging, and display purposes.
     *
     * @returns Provider name in format "openai:model-name"
     */
    getProviderName(): string {
        return `openai:${this.model}`;
    }

    /**
     * Check if the OpenAI service and model are available
     *
     * This method performs a test request to verify that:
     * 1. The API key is valid and authentication works
     * 2. The specified embedding model is available
     * 3. The service is responding correctly
     *
     * @returns Promise resolving to true if the service is available
     */
    async isAvailable(): Promise<boolean> {
        try {
            // Test with a simple embedding request to verify connectivity and auth
            const response = await this.client.post('/embeddings', {
                model: this.model,
                input: 'test',
                encoding_format: 'float'
            });

            return response.status === 200 && response.data?.data?.length > 0;
        } catch (error) {
            // Provide specific error messages for different failure scenarios
            if (axios.isAxiosError(error)) {
                if (error.response?.status === 401) {
                    console.error('OpenAI API key is invalid or missing');
                } else if (error.response?.status === 404) {
                    console.error(`OpenAI model '${this.model}' not found`);
                } else if (error.response?.status === 429) {
                    console.warn('OpenAI API rate limit exceeded, but service is available');
                    return true; // Rate limit means the service is available, just busy
                } else {
                    console.error('OpenAI API availability check failed:', error.response?.data || error.message);
                }
            } else {
                console.error('Failed to check OpenAI availability:', error);
            }
            return false;
        }
    }

    /**
     * Get usage statistics for the last request
     *
     * This method would track token usage from the last API response,
     * which is useful for monitoring API costs and usage limits.
     * Currently returns an empty object as this feature needs implementation.
     *
     * @returns Object with usage statistics (currently empty)
     */
    getLastUsage(): { prompt_tokens?: number; total_tokens?: number } {
        // This would need to be implemented to track usage from the last response
        // For now, return empty object
        return {};
    }

    /**
     * Estimate token count for text (rough approximation)
     *
     * This method provides a rough estimate of how many tokens a piece of text
     * would consume when sent to the OpenAI API. This is useful for:
     * - Pre-validating text before sending to API
     * - Estimating API costs
     * - Implementing usage limits
     *
     * @param text - The text to estimate tokens for
     * @returns Estimated token count (rough approximation)
     *
     * Note: This is a rough approximation. For accurate token counting,
     * use OpenAI's tiktoken library or similar.
     */
    estimateTokens(text: string): number {
        // Rough approximation: 1 token  4 characters for English text
        // This is a simplification - actual tokenization varies by language
        return Math.ceil(text.length / 4);
    }

    /**
     * Check if text is within token limits
     *
     * This method uses the token estimation to check if text would exceed
     * OpenAI's maximum token limit for embedding requests.
     *
     * @param text - The text to check
     * @param maxTokens - Maximum allowed tokens (default: 8191)
     * @returns True if text is within token limits
     */
    isWithinTokenLimit(text: string, maxTokens: number = 8191): boolean {
        return this.estimateTokens(text) <= maxTokens;
    }

    /**
     * Truncate text to fit within token limits
     *
     * This method truncates text to ensure it stays within OpenAI's token
     * limits while preserving as much content as possible.
     *
     * @param text - The text to truncate
     * @param maxTokens - Maximum allowed tokens (default: 8191)
     * @returns Truncated text that fits within token limits
     */
    truncateToTokenLimit(text: string, maxTokens: number = 8191): string {
        const estimatedTokens = this.estimateTokens(text);
        if (estimatedTokens <= maxTokens) {
            return text;
        }

        // Rough truncation based on character count
        // This is a simplification - proper truncation would use actual tokenization
        const maxChars = maxTokens * 4;
        return text.substring(0, maxChars - 3) + '...';
    }
}
</file>

<file path="src/parsing/astParser.ts">
/**
 * Abstract Syntax Tree Parser Module
 * 
 * This module provides functionality for parsing source code into Abstract Syntax Trees (ASTs)
 * using the tree-sitter library. It supports multiple programming languages including TypeScript,
 * JavaScript, Python, and C#. The parser enables code analysis, traversal, and querying of
 * syntax nodes within the parsed code.
 * 
 * Key features:
 * - Multi-language support with extensible architecture
 * - Error recovery and reporting during parsing
 * - File extension to language detection
 * - AST traversal and node querying capabilities
 * - Utility functions for working with syntax nodes
 */

import Parser from 'tree-sitter';
import TypeScript from 'tree-sitter-typescript';
import Python from 'tree-sitter-python';
import CSharp from 'tree-sitter-c-sharp';

// TODO: (agent) Setup mono repo for our application to build and setup our ast parser modules

/**
 * Defines the programming languages supported by the AST parser.
 * Currently supports TypeScript, JavaScript, Python, and C#.
 */
export type SupportedLanguage = 'typescript' | 'javascript' | 'python' | 'csharp';

/**
 * AstParser class provides functionality to parse and analyze source code
 * using the tree-sitter library across multiple programming languages.
 */
export class AstParser {
    /** The tree-sitter parser instance used for parsing source code */
    private parser: Parser;
    
    /** Map of supported languages to their corresponding tree-sitter grammar */
    private languages: Map<SupportedLanguage, any>;

    /**
     * Initializes a new instance of the AstParser class.
     * Sets up the parser and registers all supported language grammars.
     */
    constructor() {
        this.parser = new Parser();
        this.languages = new Map();
        
        // Initialize supported languages
        this.languages.set('typescript', TypeScript.typescript);
        this.languages.set('javascript', TypeScript.javascript);
        this.languages.set('python', Python);
        this.languages.set('csharp', CSharp);
    }

    /**
     * Parses source code into an Abstract Syntax Tree (AST).
     * 
     * @param language - The programming language of the source code
     * @param code - The source code string to parse
     * @returns The parsed AST or null if parsing fails
     * @throws Error if the language is not supported or parsing fails
     */
    public parse(language: SupportedLanguage, code: string): Parser.Tree | null {
        try {
            // Get the language grammar for the specified language
            const languageGrammar = this.languages.get(language);
            if (!languageGrammar) {
                throw new Error(`Unsupported language: ${language}`);
            }

            // Configure the parser with the appropriate language grammar
            this.parser.setLanguage(languageGrammar);
            const tree = this.parser.parse(code);
            
            if (!tree) {
                throw new Error(`Failed to parse code for language: ${language}`);
            }

            return tree;
        } catch (error) {
            console.error(`Error parsing code for language ${language}:`, error);
            return null;
        }
    }

    /**
     * Parses source code with error recovery, collecting syntax errors encountered during parsing.
     * This method is useful for partial or incomplete code that may contain syntax errors.
     * 
     * @param language - The programming language of the source code
     * @param code - The source code string to parse
     * @returns An object containing the parsed tree (or null) and an array of error messages
     */
    public parseWithErrorRecovery(language: SupportedLanguage, code: string): { tree: Parser.Tree | null; errors: string[] } {
        const errors: string[] = [];
        
        try {
            const tree = this.parse(language, code);
            
            if (tree && tree.rootNode.hasError()) {
                // Walk the tree to find error nodes
                const cursor = tree.walk();
                
                /**
                 * Recursive helper function to find and collect error nodes in the AST
                 * @param node - The current syntax node being examined
                 */
                const findErrors = (node: Parser.SyntaxNode) => {
                    if (node.hasError()) {
                        if (node.type === 'ERROR') {
                            // Convert to 1-based line and column numbers for human readability
                            errors.push(`Syntax error at line ${node.startPosition.row + 1}, column ${node.startPosition.column + 1}`);
                        }
                        
                        // Recursively check all child nodes for errors
                        for (let i = 0; i < node.childCount; i++) {
                            findErrors(node.child(i)!);
                        }
                    }
                };
                
                // Start error detection from the root node
                findErrors(tree.rootNode);
            }
            
            return { tree, errors };
        } catch (error) {
            // Handle any exceptions during parsing
            errors.push(`Parse error: ${error instanceof Error ? error.message : String(error)}`);
            return { tree: null, errors };
        }
    }

    /**
     * Determines the programming language based on a file's extension.
     * 
     * @param filePath - The path to the file
     * @returns The detected language or null if the extension is not supported
     */
    public getLanguageFromFilePath(filePath: string): SupportedLanguage | null {
        const extension = filePath.toLowerCase().split('.').pop();
        
        switch (extension) {
            case 'ts':
            case 'tsx':
                return 'typescript';
            case 'js':
            case 'jsx':
                return 'javascript';
            case 'py':
                return 'python';
            case 'cs':
                return 'csharp';
            default:
                return null;
        }
    }

    /**
     * Gets a list of all supported programming languages.
     * 
     * @returns An array of supported language identifiers
     */
    public getSupportedLanguages(): SupportedLanguage[] {
        return Array.from(this.languages.keys());
    }

    /**
     * Checks if a given language is supported by the parser.
     * This is a type guard function that narrows the type of the language parameter.
     * 
     * @param language - The language identifier to check
     * @returns True if the language is supported, false otherwise
     */
    public isLanguageSupported(language: string): language is SupportedLanguage {
        return this.languages.has(language as SupportedLanguage);
    }

    /**
     * Extracts the text content of a syntax node from the original source code.
     * 
     * @param node - The syntax node to extract text from
     * @param code - The original source code string
     * @returns The text content of the node
     */
    public getNodeText(node: Parser.SyntaxNode, code: string): string {
        return code.slice(node.startIndex, node.endIndex);
    }

    /**
     * Gets the location information for a syntax node in human-readable format.
     * Converts from tree-sitter's 0-based indices to 1-based line and column numbers.
     * 
     * @param node - The syntax node to get location information for
     * @returns An object containing start/end line and column numbers (1-based)
     */
    public getNodeLocation(node: Parser.SyntaxNode): { startLine: number; endLine: number; startColumn: number; endColumn: number } {
        return {
            startLine: node.startPosition.row + 1, // Convert to 1-based line numbers
            endLine: node.endPosition.row + 1,
            startColumn: node.startPosition.column + 1, // Convert to 1-based column numbers
            endColumn: node.endPosition.column + 1
        };
    }

    /**
     * Finds all syntax nodes of a specific type in the AST.
     * 
     * @param tree - The parsed syntax tree to search
     * @param nodeType - The type of nodes to find (e.g., 'function_declaration')
     * @returns An array of matching syntax nodes
     */
    public findNodesByType(tree: Parser.Tree, nodeType: string): Parser.SyntaxNode[] {
        const nodes: Parser.SyntaxNode[] = [];
        
        /**
         * Recursive helper function to traverse the AST and collect nodes of the specified type
         * @param node - The current node being examined
         */
        const traverse = (node: Parser.SyntaxNode) => {
            if (node.type === nodeType) {
                nodes.push(node);
            }
            
            // Recursively traverse all child nodes
            for (let i = 0; i < node.childCount; i++) {
                traverse(node.child(i)!);
            }
        };
        
        // Start traversal from the root node
        traverse(tree.rootNode);
        return nodes;
    }

    /**
     * Executes a tree-sitter query against the AST to find matching patterns.
     * Queries use tree-sitter's query language to match specific patterns in the syntax tree.
     * 
     * @param tree - The parsed syntax tree to query
     * @param language - The programming language of the source code
     * @param queryString - The tree-sitter query string
     * @returns An array of query matches or an empty array if the query fails
     */
    public queryNodes(tree: Parser.Tree, language: SupportedLanguage, queryString: string): Parser.QueryMatch[] {
        try {
            const languageGrammar = this.languages.get(language);
            if (!languageGrammar) {
                throw new Error(`Unsupported language: ${language}`);
            }

            // Create and execute the query against the root node
            const query = new Parser.Query(languageGrammar, queryString);
            return query.matches(tree.rootNode);
        } catch (error) {
            console.error(`Error executing query for language ${language}:`, error);
            return [];
        }
    }
}
</file>

<file path="webview/src/lib/vscodeApi.ts">
// VS Code API types
interface VSCodeApi {
    postMessage(message: any): void;
    getState(): any;
    setState(state: any): void;
}

// Declare the global vscode API
declare const acquireVsCodeApi: () => VSCodeApi;

// Message types for type safety
export interface SearchRequest {
    command: 'search';
    query: string;
}

export interface FileContentRequest {
    command: 'getFileContent';
    requestId: string;
    filePath: string;
    includeRelatedChunks?: boolean;
}

export interface RelatedFilesRequest {
    command: 'findRelatedFiles';
    requestId: string;
    query: string;
    currentFilePath?: string;
    maxResults?: number;
    minSimilarity?: number;
}

export interface ContextQueryRequest {
    command: 'queryContext';
    requestId: string;
    contextQuery: {
        query: string;
        filePath?: string;
        includeRelated?: boolean;
        maxResults?: number;
        minSimilarity?: number;
        fileTypes?: string[];
    };
}

export interface ServiceStatusRequest {
    command: 'getServiceStatus';
}

// Response types
export interface SearchResult {
    file: string;
    snippet: string;
    line: number;
    score?: number;
    type?: string;
    name?: string;
    language?: string;
}

export interface FileContentResult {
    filePath: string;
    content: string;
    language?: string;
    size: number;
    lastModified: string;
    relatedChunks?: any[];
}

export interface RelatedFile {
    filePath: string;
    similarity: number;
    reason: string;
    chunkCount: number;
    language?: string;
}

export interface ContextResult {
    query: string;
    results: any[];
    relatedFiles: RelatedFile[];
    totalResults: number;
    processingTime: number;
}

export interface ServiceStatus {
    qdrantConnected: boolean;
    embeddingProvider: string | null;
    collectionExists: boolean;
    collectionInfo?: any;
}

export interface SetupStatus {
    isConfigured: boolean;
    hasConfigFile: boolean;
    databaseConfigured?: boolean;
    embeddingConfigured?: boolean;
}

// Event listener type
type MessageListener = (event: MessageEvent) => void;

/**
 * VS Code API wrapper for webview communication
 */
export class VSCodeApiClient {
    private vscode: VSCodeApi;
    private messageListeners: Map<string, MessageListener[]> = new Map();
    private pendingRequests: Map<string, {
        resolve: (value: any) => void;
        reject: (error: any) => void;
        timeout: NodeJS.Timeout;
    }> = new Map();

    constructor() {
        this.vscode = acquireVsCodeApi();
        this.setupMessageListener();
    }

    private setupMessageListener() {
        window.addEventListener('message', (event) => {
            const message = event.data;
            
            // Handle responses with request IDs
            if (message.requestId && this.pendingRequests.has(message.requestId)) {
                const request = this.pendingRequests.get(message.requestId)!;
                clearTimeout(request.timeout);
                this.pendingRequests.delete(message.requestId);
                
                if (message.error) {
                    request.reject(new Error(message.error));
                } else {
                    request.resolve(message.result);
                }
                return;
            }

            // Handle general messages
            const listeners = this.messageListeners.get(message.command) || [];
            listeners.forEach(listener => listener(event));
        });
    }

    private generateRequestId(): string {
        return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    private sendRequestWithResponse<T>(message: any, timeoutMs: number = 30000): Promise<T> {
        return new Promise((resolve, reject) => {
            const requestId = this.generateRequestId();
            message.requestId = requestId;

            const timeout = setTimeout(() => {
                this.pendingRequests.delete(requestId);
                reject(new Error('Request timeout'));
            }, timeoutMs);

            this.pendingRequests.set(requestId, { resolve, reject, timeout });
            this.vscode.postMessage(message);
        });
    }

    /**
     * Send a message to the extension
     */
    postMessage(message: any): void {
        this.vscode.postMessage(message);
    }

    /**
     * Listen for messages from the extension
     */
    onMessage(command: string, listener: MessageListener): void {
        if (!this.messageListeners.has(command)) {
            this.messageListeners.set(command, []);
        }
        this.messageListeners.get(command)!.push(listener);
    }

    /**
     * Remove message listener
     */
    offMessage(command: string, listener: MessageListener): void {
        const listeners = this.messageListeners.get(command);
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }

    /**
     * Perform a search
     */
    async search(query: string): Promise<SearchResult[]> {
        return new Promise((resolve) => {
            const listener = (event: MessageEvent) => {
                if (event.data.command === 'searchResults') {
                    this.offMessage('searchResults', listener);
                    resolve(event.data.results || []);
                }
            };
            
            this.onMessage('searchResults', listener);
            this.postMessage({ command: 'search', query });
        });
    }

    /**
     * Get file content
     */
    async getFileContent(filePath: string, includeRelatedChunks: boolean = false): Promise<FileContentResult> {
        return this.sendRequestWithResponse<FileContentResult>({
            command: 'getFileContent',
            filePath,
            includeRelatedChunks
        });
    }

    /**
     * Find related files
     */
    async findRelatedFiles(
        query: string, 
        currentFilePath?: string, 
        maxResults: number = 10, 
        minSimilarity: number = 0.5
    ): Promise<RelatedFile[]> {
        return this.sendRequestWithResponse<RelatedFile[]>({
            command: 'findRelatedFiles',
            query,
            currentFilePath,
            maxResults,
            minSimilarity
        });
    }

    /**
     * Perform context query
     */
    async queryContext(contextQuery: {
        query: string;
        filePath?: string;
        includeRelated?: boolean;
        maxResults?: number;
        minSimilarity?: number;
        fileTypes?: string[];
    }): Promise<ContextResult> {
        return this.sendRequestWithResponse<ContextResult>({
            command: 'queryContext',
            contextQuery
        });
    }

    /**
     * Get service status
     */
    async getServiceStatus(): Promise<ServiceStatus> {
        return this.sendRequestWithResponse<ServiceStatus>({
            command: 'getServiceStatus'
        });
    }

    /**
     * Check setup status
     */
    async checkSetupStatus(): Promise<SetupStatus> {
        return this.sendRequestWithResponse<SetupStatus>({
            command: 'checkSetupStatus'
        });
    }

    /**
     * Send ping to test communication
     */
    async ping(): Promise<any> {
        return this.sendRequestWithResponse<any>({
            command: 'ping'
        });
    }

    /**
     * Start indexing
     */
    startIndexing(): void {
        this.postMessage({ command: 'startIndexing' });
    }

    /**
     * Open settings
     */
    openSettings(): void {
        this.postMessage({ command: 'openSettings' });
    }

    /**
     * Get webview state
     */
    getState(): any {
        return this.vscode.getState();
    }

    /**
     * Set webview state
     */
    setState(state: any): void {
        this.vscode.setState(state);
    }
}

// Create and export a singleton instance
export const vscodeApi = new VSCodeApiClient();
</file>

<file path="webview/src/styles.css">
/* VS Code theme integration */
:root {
  --vscode-font-family: var(--vscode-font-family, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif);
  --vscode-foreground: var(--vscode-foreground, #cccccc);
  --vscode-editor-background: var(--vscode-editor-background, #1e1e1e);
  --vscode-panel-border: var(--vscode-panel-border, #3c3c3c);
  --vscode-button-background: var(--vscode-button-background, #0e639c);
  --vscode-button-foreground: var(--vscode-button-foreground, #ffffff);
  --vscode-button-hoverBackground: var(--vscode-button-hoverBackground, #1177bb);
}

/* Fluent UI component customization for VS Code theme */
fluent-button {
  --accent-fill-rest: var(--vscode-button-background);
  --accent-fill-hover: var(--vscode-button-hoverBackground);
  --accent-foreground-rest: var(--vscode-button-foreground);
  --neutral-fill-rest: var(--vscode-editor-background);
  --neutral-stroke-rest: var(--vscode-panel-border);
}

fluent-text-field {
  --neutral-fill-rest: var(--vscode-editor-background);
  --neutral-stroke-rest: var(--vscode-panel-border);
  --neutral-foreground-rest: var(--vscode-foreground);
}

fluent-progress-ring {
  --accent-fill-rest: var(--vscode-button-background);
}

/* Custom styles */
.container {
  font-family: var(--vscode-font-family);
  color: var(--vscode-foreground);
  background-color: var(--vscode-editor-background);
}

.section {
  background-color: var(--vscode-editor-background);
  border-color: var(--vscode-panel-border);
}

.section h2 {
  margin-top: 0;
  color: var(--vscode-foreground);
}

.section h3 {
  color: var(--vscode-foreground);
}

.section p {
  color: var(--vscode-foreground);
  opacity: 0.8;
}

/* Progress section animations */
.progress-section {
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
}

.progress-section.visible {
  opacity: 1;
  max-height: 200px;
  margin-top: 20px;
}

/* Search results styling */
#search-results {
  max-height: 400px;
  overflow-y: auto;
}

#search-results h4 {
  margin: 0 0 5px 0;
  color: var(--vscode-button-background);
}

#search-results p {
  margin: 5px 0;
  font-family: 'Courier New', monospace;
  font-size: 0.9em;
  background-color: rgba(255, 255, 255, 0.05);
  padding: 5px;
  border-radius: 3px;
}

#search-results small {
  color: var(--vscode-foreground);
  opacity: 0.6;
}

/* Search suggestions styles */
.search-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background-color: var(--vscode-dropdown-background, var(--vscode-editor-background));
  border: 1px solid var(--vscode-dropdown-border, var(--vscode-panel-border));
  border-top: none;
  border-radius: 0 0 4px 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  z-index: 1000;
  max-height: 200px;
  overflow-y: auto;
}

.suggestion-item {
  padding: 8px 12px;
  cursor: pointer;
  color: var(--vscode-dropdown-foreground, var(--vscode-foreground));
  border-bottom: 1px solid var(--vscode-dropdown-border, var(--vscode-panel-border));
}

.suggestion-item:last-child {
  border-bottom: none;
}

.suggestion-item:hover {
  background-color: var(--vscode-list-hoverBackground, rgba(255, 255, 255, 0.1));
}

.search-input-container {
  position: relative;
  display: inline-block;
  width: 100%;
}

/* Setup UI styles */
.setup-container {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.setup-header {
  text-align: center;
  margin-bottom: 40px;
  padding: 30px;
  background: var(--vscode-textCodeBlock-background);
  border-radius: 8px;
}

.setup-header h1 {
  margin: 0 0 10px 0;
  color: var(--vscode-foreground);
}

.setup-header p {
  margin: 0;
  color: var(--vscode-descriptionForeground);
}

.setup-section {
  margin-bottom: 30px;
  padding: 20px;
  border: 1px solid var(--vscode-panel-border);
  border-radius: 8px;
  background: var(--vscode-editor-background);
}

.setup-section h2 {
  margin-top: 0;
  color: var(--vscode-textLink-foreground);
  border-bottom: 1px solid var(--vscode-panel-border);
  padding-bottom: 10px;
}

.setup-item {
  margin-bottom: 15px;
}

.setup-item label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
  color: var(--vscode-foreground);
}

.setup-select {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--vscode-input-border);
  background-color: var(--vscode-input-background);
  color: var(--vscode-input-foreground);
  border-radius: 4px;
  font-family: inherit;
  font-size: inherit;
}

.setup-description {
  font-size: 0.9em;
  color: var(--vscode-descriptionForeground);
  margin: 5px 0 0 0;
}

.setup-controls {
  display: flex;
  gap: 10px;
  align-items: center;
  margin-top: 15px;
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9em;
}

.status-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.status-unknown { background-color: #ff9800; }
.status-running { background-color: #4CAF50; }
.status-stopped { background-color: #f44336; }

.provider-config {
  margin-top: 15px;
  padding: 15px;
  background: var(--vscode-textCodeBlock-background);
  border-radius: 4px;
}

.setup-actions {
  text-align: center;
  margin-top: 30px;
  padding: 20px;
  background: var(--vscode-textCodeBlock-background);
  border-radius: 8px;
}

.setup-status {
  margin-top: 15px;
  font-size: 0.9em;
}

.setup-status.info {
  color: var(--vscode-foreground);
}

.setup-status.success {
  color: var(--vscode-textLink-foreground);
}

.setup-status.error {
  color: var(--vscode-errorForeground);
}
</file>

<file path="tsconfig.json">
{
	"compilerOptions": {
		"module": "commonjs",
		"target": "ES2020",
		"outDir": "out",
		"lib": [
			"ES2020",
			"DOM"
		],
		"sourceMap": true,
		"rootDir": "src",
		"strict": true,
		"esModuleInterop": true,
		"allowSyntheticDefaultImports": true
	},
	"exclude": [
		"webview/**/*"
	]
}
</file>

<file path="src/context/contextService.ts">
/**
 * Context Service Module
 * 
 * This module provides a service for managing and querying code context within a VS Code workspace.
 * It leverages vector embeddings and similarity search to find related code chunks and files,
 * enabling semantic code navigation and contextual understanding of codebases.
 * 
 * The service integrates with:
 * - QdrantService for vector database operations
 * - EmbeddingProvider for generating semantic embeddings
 * - IndexingService for processing and indexing code files
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { IndexingService } from '../indexing/indexingService';
import { QdrantService, SearchResult } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';

/**
 * Represents the result of a file content retrieval operation
 * 
 * @property filePath - Path to the file that was retrieved
 * @property content - The text content of the file
 * @property language - Programming language of the file (derived from extension)
 * @property size - File size in bytes
 * @property lastModified - Last modification timestamp
 * @property relatedChunks - Optional array of semantically related code chunks from the same file
 */
export interface FileContentResult {
    filePath: string;
    content: string;
    language?: string;
    size: number;
    lastModified: Date;
    relatedChunks?: SearchResult[];
}

/**
 * Represents a file that is semantically related to a query or another file
 * 
 * @property filePath - Path to the related file
 * @property similarity - Similarity score (0-1) indicating relevance
 * @property reason - Human-readable explanation of why this file is related
 * @property chunkCount - Number of code chunks that matched the query
 * @property language - Programming language of the file
 */
export interface RelatedFile {
    filePath: string;
    similarity: number;
    reason: string;
    chunkCount: number;
    language?: string;
}

/**
 * Parameters for performing a context query
 * 
 * @property query - The search query text
 * @property filePath - Optional current file path for context
 * @property includeRelated - Whether to include related files in results
 * @property maxResults - Maximum number of results to return
 * @property minSimilarity - Minimum similarity threshold (0-1)
 * @property fileTypes - Optional array of file types to filter by
 */
export interface ContextQuery {
    query: string;
    filePath?: string;
    includeRelated?: boolean;
    maxResults?: number;
    minSimilarity?: number;
    fileTypes?: string[];
}

/**
 * Results of a context query operation
 * 
 * @property query - The original search query
 * @property results - Array of matching code chunks
 * @property relatedFiles - Array of related files
 * @property totalResults - Total number of results found
 * @property processingTime - Time taken to process the query in milliseconds
 */
export interface ContextResult {
    query: string;
    results: SearchResult[];
    relatedFiles: RelatedFile[];
    totalResults: number;
    processingTime: number;
}

/**
 * Core service for managing and querying code context
 * 
 * This service provides methods for:
 * - Retrieving file content with related chunks
 * - Finding files related to a query or current file
 * - Performing semantic searches across the codebase
 * - Checking service status and readiness
 */
export class ContextService {
    private workspaceRoot: string;
    private indexingService: IndexingService;
    private qdrantService: QdrantService;
    private embeddingProvider: IEmbeddingProvider;
    
    // Configuration constants
    private readonly DEFAULT_CHUNK_LIMIT = 50;
    private readonly DEFAULT_RELATED_FILES_LIMIT = 10;
    
    /**
     * Creates an empty context result object
     * Helper method to reduce code duplication
     * 
     * @param query - The original query string
     * @param startTime - Optional start time for calculating processing time
     * @returns An empty ContextResult object
     */
    private createEmptyResult(query: string, startTime?: number): ContextResult {
        return {
            query: query,
            results: [],
            relatedFiles: [],
            totalResults: 0,
            processingTime: startTime ? Date.now() - startTime : 0
        };
    }

    /**
     * Constructor now uses dependency injection for better testability and decoupling
     * 
     * @param workspaceRoot - The workspace root path
     * @param qdrantService - Injected QdrantService instance
     * @param embeddingProvider - Injected embedding provider instance
     * @param indexingService - Injected IndexingService instance
     */
    constructor(
        workspaceRoot: string,
        qdrantService: QdrantService,
        embeddingProvider: IEmbeddingProvider,
        indexingService: IndexingService
    ) {
        this.workspaceRoot = workspaceRoot;
        this.qdrantService = qdrantService;
        this.embeddingProvider = embeddingProvider;
        this.indexingService = indexingService;
    }

    /**
     * Generates a unique collection name for the current workspace
     * 
     * The collection name is derived from the workspace folder name,
     * sanitized to ensure compatibility with Qdrant naming requirements.
     * 
     * @returns A sanitized collection name string
     */
    /**
     * Generates a unique collection name for the current workspace
     * 
     * The collection name is derived from the workspace folder name,
     * sanitized to ensure compatibility with Qdrant naming requirements.
     * Uses path module for cross-platform compatibility.
     * 
     * @returns A sanitized collection name string
     */
    private generateCollectionName(): string {
        const workspaceName = path.basename(this.workspaceRoot) || 'workspace';
        const sanitizedName = workspaceName.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        return `code_context_${sanitizedName}`;
    }

    /**
     * Retrieves file content with optional related chunks
     * 
     * @param filePath - Path to the file to retrieve
     * @param includeRelatedChunks - Whether to include semantically related chunks from the same file
     * @returns Promise resolving to file content and metadata
     * @throws Error if file cannot be read or processed
     */
    async getFileContent(filePath: string, includeRelatedChunks: boolean = false): Promise<FileContentResult> {
        try {
            // Resolve absolute path
            const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(this.workspaceRoot, filePath);
            const uri = vscode.Uri.file(absolutePath);

            // Read file content
            const fileData = await vscode.workspace.fs.readFile(uri);
            const content = Buffer.from(fileData).toString('utf8');

            // Get file stats
            const stats = await vscode.workspace.fs.stat(uri);
            
            // Check file size to prevent memory issues with very large files
            const MAX_SAFE_FILE_SIZE = 10 * 1024 * 1024; // 10MB
            if (stats.size > MAX_SAFE_FILE_SIZE) {
                console.warn(`Large file detected (${(stats.size / 1024 / 1024).toFixed(2)}MB): ${filePath}`);
            }
            
            // Determine language from file extension
            const language = this.getLanguageFromPath(filePath);

            const result: FileContentResult = {
                filePath: filePath,
                content: content,
                language: language,
                size: stats.size,
                lastModified: new Date(stats.mtime)
            };

            // Optionally include related chunks
            if (includeRelatedChunks) {
                if (!this.embeddingProvider) {
                    console.warn('Embedding provider not available, cannot include related chunks');
                } else {
                    // Search for chunks from this file
                    const collectionName = this.generateCollectionName();
                    const searchResults = await this.qdrantService.search(
                        collectionName,
                        [], // Empty vector, we'll use filter instead
                        this.DEFAULT_CHUNK_LIMIT,
                        {
                            must: [
                                {
                                    key: 'filePath',
                                    match: { value: filePath }
                                }
                            ]
                        }
                    );
                    result.relatedChunks = searchResults;
                }
            }

            return result;
        } catch (error) {
            console.error(`Failed to get file content for ${filePath}:`, error);
            throw new Error(`Failed to read file: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Finds files related to a query or current file
     * 
     * This method performs semantic search to find files that are conceptually
     * related to the provided query. It groups results by file and calculates
     * file-level similarity scores.
     * 
     * @param query - The search query text
     * @param currentFilePath - Optional current file path to exclude from results
     * @param maxResults - Maximum number of related files to return
     * @param minSimilarity - Minimum similarity threshold (0-1)
     * @returns Promise resolving to array of related files
     */
    async findRelatedFiles(
        query: string,
        currentFilePath?: string,
        maxResults?: number,
        minSimilarity?: number
    ): Promise<RelatedFile[]> {
        // Get configuration values with fallbacks
        const config = vscode.workspace.getConfiguration('code-context-engine');
        maxResults = maxResults ?? config.get<number>('maxSearchResults') ?? 10;
        minSimilarity = minSimilarity ?? config.get<number>('minSimilarityThreshold') ?? 0.5;
        try {
            if (!this.embeddingProvider) {
                throw new Error('Embedding provider not available');
            }

            // Generate embedding for the query
            const queryEmbeddings = await this.embeddingProvider.generateEmbeddings([query]);
            if (queryEmbeddings.length === 0) {
                return [];
            }

            const collectionName = this.generateCollectionName();
            
            // Search for similar chunks - get 3x results to ensure good file coverage
            const searchResults = await this.qdrantService.search(
                collectionName,
                queryEmbeddings[0],
                maxResults * 3 // Get more results to group by file
            );

            // Group results by file and calculate file-level similarity
            const fileGroups = new Map<string, {
                chunks: SearchResult[];
                maxScore: number;
                avgScore: number;
                language?: string;
            }>();

            // Process search results and group by file path
            for (const result of searchResults) {
                // Skip results below similarity threshold
                if (result.score < minSimilarity) continue;
                // Skip current file if provided
                if (currentFilePath && result.payload.filePath === currentFilePath) continue;

                const filePath = result.payload.filePath;
                // Initialize group if this is the first chunk for this file
                if (!fileGroups.has(filePath)) {
                    fileGroups.set(filePath, {
                        chunks: [],
                        maxScore: 0,
                        avgScore: 0,
                        language: result.payload.language
                    });
                }

                // Add chunk to file group and update max score
                const group = fileGroups.get(filePath)!;
                group.chunks.push(result);
                group.maxScore = Math.max(group.maxScore, result.score);
            }

            // Calculate average scores and create RelatedFile objects
            const relatedFiles: RelatedFile[] = [];
            for (const [filePath, group] of fileGroups) {
                // Calculate average similarity score across all chunks
                group.avgScore = group.chunks.reduce((sum, chunk) => sum + chunk.score, 0) / group.chunks.length;
                
                // Generate human-readable reason for the relation
                const topChunk = group.chunks[0];
                const reason = this.generateRelationReason(topChunk, group.chunks.length);

                relatedFiles.push({
                    filePath: filePath,
                    similarity: group.maxScore, // Use max score as the file similarity
                    reason: reason,
                    chunkCount: group.chunks.length,
                    language: group.language
                });
            }

            // Sort by similarity (descending) and return top results
            return relatedFiles
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, maxResults);

        } catch (error) {
            console.error('Failed to find related files:', error);
            return [];
        }
    }

    /**
     * Performs an advanced context query
     * 
     * This is the main entry point for semantic code search. It supports:
     * - Filtering by file type
     * - Including related files
     * - Minimum similarity thresholds
     * - Performance tracking
     * 
     * @param contextQuery - Query parameters
     * @returns Promise resolving to query results
     */
    async queryContext(contextQuery: ContextQuery): Promise<ContextResult> {
        const startTime = Date.now();
        
        try {
            if (!this.embeddingProvider) {
                throw new Error('Embedding provider not available');
            }

            // Generate embedding for the query
            const queryEmbeddings = await this.embeddingProvider.generateEmbeddings([contextQuery.query]);
            if (queryEmbeddings.length === 0) {
                return this.createEmptyResult(contextQuery.query, startTime);
            }

            const collectionName = this.generateCollectionName();

            // Get configuration values with fallbacks
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const maxResults = contextQuery.maxResults ?? config.get<number>('maxSearchResults') ?? 20;
            const defaultMinSimilarity = config.get<number>('minSimilarityThreshold') ?? 0.5;
            
            // Build filter for file types if specified
            let filter: { should: Array<{ key: string, match: { value: string } }> } | undefined = undefined;
            if (contextQuery.fileTypes && contextQuery.fileTypes.length > 0) {
                // Create a filter that matches any of the specified languages
                filter = {
                    should: contextQuery.fileTypes.map(lang => ({
                        key: 'language',
                        match: { value: lang }
                    }))
                };
            }

            // Search for similar chunks
            const searchResults = await this.qdrantService.search(
                collectionName,
                queryEmbeddings[0],
                maxResults,
                filter
            );

            // Filter by minimum similarity if specified
            const minSimilarity = contextQuery.minSimilarity ?? defaultMinSimilarity;
            const filteredResults = searchResults.filter(r => r.score >= minSimilarity);

            // Find related files if requested
            let relatedFiles: RelatedFile[] = [];
            if (contextQuery.includeRelated) {
                relatedFiles = await this.findRelatedFiles(
                    contextQuery.query,
                    contextQuery.filePath,
                    this.DEFAULT_RELATED_FILES_LIMIT, // Use configurable constant
                    minSimilarity
                );
            }

            // Return complete result object with timing information
            return {
                query: contextQuery.query,
                results: filteredResults,
                relatedFiles: relatedFiles,
                totalResults: filteredResults.length,
                processingTime: Date.now() - startTime
            };

        } catch (error) {
            console.error('Context query failed:', error);
            // Return empty results with timing information on error
            return this.createEmptyResult(contextQuery.query, startTime);
        }
    }

    /**
     * Maps file extensions to programming language identifiers
     * 
     * @param filePath - Path to the file
     * @returns Language identifier or undefined if not recognized
     */
    /**
     * Maps file extensions to programming language identifiers
     * Supports common file types and can be extended as needed
     * 
     * @param filePath - Path to the file
     * @returns Language identifier or undefined if not recognized
     */
    private getLanguageFromPath(filePath: string): string | undefined {
        const ext = path.extname(filePath).toLowerCase();
        const languageMap: Record<string, string> = {
            // JavaScript family
            '.ts': 'typescript',
            '.tsx': 'typescript',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.mjs': 'javascript',
            '.cjs': 'javascript',
            
            // Web technologies
            '.html': 'html',
            '.css': 'css',
            '.scss': 'scss',
            '.less': 'less',
            '.vue': 'vue',
            '.svelte': 'svelte',
            
            // Backend languages
            '.py': 'python',
            '.rb': 'ruby',
            '.php': 'php',
            '.java': 'java',
            '.cs': 'csharp',
            '.go': 'go',
            '.rs': 'rust',
            
            // Data formats
            '.json': 'json',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.xml': 'xml',
            '.md': 'markdown',
            
            // Shell scripts
            '.sh': 'shell',
            '.bash': 'shell',
            '.zsh': 'shell',
            '.ps1': 'powershell'
        };
        
        return languageMap[ext];
    }

    /**
     * Generates a human-readable reason for why a file is related
     * 
     * @param topChunk - The highest-scoring chunk from the file
     * @param chunkCount - Total number of matching chunks in the file
     * @returns A descriptive string explaining the relation
     */
    private generateRelationReason(topChunk: SearchResult, chunkCount: number): string {
        const type = topChunk.payload.type;
        const name = topChunk.payload.name;
        
        if (chunkCount > 1) {
            return `Contains ${chunkCount} related ${type}s${name ? ` including "${name}"` : ''}`;
        } else {
            return `Contains related ${type}${name ? ` "${name}"` : ''}`;
        }
    }

    /**
     * Checks if the context service is ready for use
     * 
     * Verifies that both the vector database and embedding provider are available.
     * 
     * @returns Promise resolving to boolean indicating readiness
     */
    /**
     * Checks if the context service is ready for use
     * 
     * Verifies that both the vector database and embedding provider are available.
     * Logs any errors encountered during the check.
     * 
     * @returns Promise resolving to boolean indicating readiness
     */
    async isReady(): Promise<boolean> {
        try {
            // Check if Qdrant is available
            const qdrantReady = await this.qdrantService.healthCheck();
            if (!qdrantReady) {
                console.warn('Qdrant service health check failed');
                return false;
            }

            // Check if embedding provider is available
            if (!this.embeddingProvider) {
                console.warn('Embedding provider not available');
                return false;
            }
            
            return true;
        } catch (error) {
            console.error('Error checking service readiness:', error);
            return false;
        }
    }

    /**
     * Gets detailed status information about the service
     * 
     * Provides information about:
     * - Vector database connection
     * - Embedding provider availability
     * - Collection existence and metadata
     * 
     * @returns Promise resolving to status object
     */
    async getStatus(): Promise<{
        qdrantConnected: boolean;
        embeddingProvider: string | null;
        collectionExists: boolean;
        collectionInfo?: any;
    }> {
        // Check Qdrant connection
        const qdrantConnected = await this.qdrantService.healthCheck();
        
        // Get embedding provider name if available
        let embeddingProvider: string | null = null;
        try {
            embeddingProvider = this.embeddingProvider?.getProviderName() || null;
        } catch {
            // Provider not available
        }

        // Check if collection exists and get its info
        const collectionName = this.generateCollectionName();
        const collectionInfo = await this.qdrantService.getCollectionInfo(collectionName);
        const collectionExists = collectionInfo !== null;

        // Return comprehensive status object
        return {
            qdrantConnected,
            embeddingProvider,
            collectionExists,
            collectionInfo: collectionExists ? collectionInfo : undefined
        };
    }
}
</file>

<file path="src/indexing/fileWalker.ts">
/**
 * File system traversal and management utilities.
 * This module provides functionality for walking through a workspace,
 * finding files based on patterns, and filtering them according to ignore rules.
 *
 * The FileWalker class is responsible for discovering all relevant code files
 * in a workspace while respecting .gitignore patterns and other exclusion rules.
 * It supports multiple programming languages and file types, making it
 * suitable for diverse codebases.
 */
import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import ignore from 'ignore';

/**
 * FileWalker class for traversing and filtering files in a workspace.
 * Handles file discovery, pattern matching, and respects gitignore rules.
 *
 * This class implements a comprehensive file discovery system that:
 * - Scans the entire workspace directory tree
 * - Supports multiple programming languages and file extensions
 * - Respects .gitignore and custom ignore patterns
 * - Provides statistics about discovered files
 * - Filters out non-code files and build artifacts
 */
export class FileWalker {
    /** Root directory of the workspace to scan */
    private workspaceRoot: string;
    /** Instance of ignore package to handle file exclusion patterns */
    private ignoreInstance: ReturnType<typeof ignore>;

    /**
     * Creates a new FileWalker instance
     * @param workspaceRoot - The absolute path to the workspace root directory
     *
     * Initializes the FileWalker with the workspace root directory and sets up
     * default ignore patterns for common build artifacts and directories.
     */
    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
        this.ignoreInstance = ignore();
        
        // Add common patterns to ignore by default
        // These patterns exclude build artifacts, dependencies, and IDE configurations
        this.ignoreInstance.add([
            'node_modules/**',      // Node.js dependencies
            '.git/**',             // Git version control directory
            'dist/**',             // Distribution/build directories
            'build/**',            // Build output directories
            'out/**',              // Output directories
            '*.min.js',            // Minified JavaScript files
            '*.map',               // Source map files
            '.vscode/**',          // VS Code workspace configuration
            '.idea/**',            // IntelliJ IDEA workspace configuration
            '*.log',               // Log files
            'coverage/**',         // Code coverage reports
            '.nyc_output/**'       // NYC test coverage output
        ]);
    }

    /**
     * Loads and parses the .gitignore file from the workspace root
     * Adds all valid ignore patterns to the ignore instance
     * If no .gitignore file is found, continues with default patterns
     *
     * This method reads the .gitignore file (if it exists) and processes each line
     * to extract valid ignore patterns. It filters out comments (lines starting with #)
     * and empty lines, then adds the valid patterns to the ignore instance.
     *
     * @returns Promise that resolves when gitignore is loaded
     */
    private async loadGitignore(): Promise<void> {
        const gitignorePath = path.join(this.workspaceRoot, '.gitignore');
        
        try {
            // Read the gitignore file content
            const gitignoreContent = await fs.promises.readFile(gitignorePath, 'utf8');
            // Process the content: split by lines, trim whitespace, and filter out comments and empty lines
            const lines = gitignoreContent
                .split('\n')
                .map(line => line.trim())
                .filter(line => line && !line.startsWith('#'));
            
            // Add the processed patterns to our ignore instance
            this.ignoreInstance.add(lines);
        } catch (error) {
            // .gitignore file not found or not readable, continue with default patterns
            // This is not an error - we just use the default ignore patterns
            console.log('No .gitignore file found or not readable, using default ignore patterns');
        }
    }

    /**
     * Finds all files in the workspace that match the specified patterns
     * and aren't excluded by ignore rules
     *
     * This method performs a comprehensive search for all relevant files in the workspace.
     * It first loads .gitignore patterns, then searches for files matching multiple
     * patterns for different programming languages and file types. The results are
     * deduplicated and filtered according to the ignore rules.
     *
     * @returns Promise resolving to an array of absolute file paths
     */
    public async findAllFiles(): Promise<string[]> {
        // Load gitignore patterns before searching for files
        // This ensures we respect the project's ignore rules
        await this.loadGitignore();

        // Define patterns for code files we want to index
        // Includes most common programming languages and config file types
        const patterns = [
            '**/*.ts',    // TypeScript
            '**/*.tsx',   // TypeScript React
            '**/*.js',    // JavaScript
            '**/*.jsx',   // JavaScript React
            '**/*.py',    // Python
            '**/*.cs',    // C#
            '**/*.java',  // Java
            '**/*.cpp',   // C++
            '**/*.c',     // C
            '**/*.h',     // C/C++ header
            '**/*.hpp',   // C++ header
            '**/*.go',    // Go
            '**/*.rs',    // Rust
            '**/*.php',   // PHP
            '**/*.rb',    // Ruby
            '**/*.swift', // Swift
            '**/*.kt',    // Kotlin
            '**/*.scala', // Scala
            '**/*.clj',   // Clojure
            '**/*.sh',    // Shell script
            '**/*.ps1',   // PowerShell
            '**/*.sql',   // SQL
            '**/*.md',    // Markdown
            '**/*.json',  // JSON
            '**/*.yaml',  // YAML
            '**/*.yml',   // YAML alternative
            '**/*.xml',   // XML
            '**/*.html',  // HTML
            '**/*.css',   // CSS
            '**/*.scss',  // SCSS
            '**/*.less'   // LESS
        ];

        const allFiles: string[] = [];

        // Process each pattern and collect matching files
        // We use glob to efficiently find files matching each pattern
        for (const pattern of patterns) {
            try {
                // Use glob to find files matching the current pattern
                const files = await new Promise<string[]>((resolve, reject) => {
                    glob.glob(pattern, {
                        cwd: this.workspaceRoot,
                        absolute: true, // Return absolute paths
                        nodir: true,    // Don't include directories
                        dot: false      // Ignore dot files by default
                    }, (err, matches) => {
                        if (err) reject(err);
                        else resolve(matches);
                    });
                });
                // Add found files to our collection
                allFiles.push(...files);
            } catch (error) {
                console.error(`Error finding files with pattern ${pattern}:`, error);
            }
        }

        // Remove duplicates (files that match multiple patterns)
        // For example, a .ts file might match both '**/*.ts' and '**/*.tsx' patterns
        const uniqueFiles = [...new Set(allFiles)];
        
        // Apply ignore patterns to filter out excluded files
        // This respects both .gitignore patterns and our default ignore patterns
        const filteredFiles = uniqueFiles.filter(filePath => {
            // Convert to relative path for ignore pattern matching
            const relativePath = path.relative(this.workspaceRoot, filePath);
            return !this.ignoreInstance.ignores(relativePath);
        });

        return filteredFiles;
    }

    /**
     * Collects statistics about files in the workspace
     *
     * This method provides insights into the composition of the workspace by
     * counting files by their extensions. This information can be useful for
     * understanding the technology stack and estimating indexing time.
     *
     * @returns Promise resolving to an object containing:
     *   - totalFiles: The total number of files found
     *   - filesByExtension: A record mapping file extensions to their count
     */
    public async getFileStats(): Promise<{ totalFiles: number; filesByExtension: Record<string, number> }> {
        // Get all files in the workspace
        const files = await this.findAllFiles();
        const filesByExtension: Record<string, number> = {};

        // Count files by extension
        // This helps understand the distribution of file types in the workspace
        files.forEach(filePath => {
            const ext = path.extname(filePath).toLowerCase();
            filesByExtension[ext] = (filesByExtension[ext] || 0) + 1;
        });

        return {
            totalFiles: files.length,
            filesByExtension
        };
    }

    /**
     * Determines if a file is a code file based on its extension
     *
     * This method checks if a file has a code-related extension, which helps
     * distinguish between source code files and configuration files, documentation,
     * or other non-code files that might be present in the workspace.
     *
     * @param filePath - The path to the file to check
     * @returns true if the file is a code file, false otherwise
     */
    public isCodeFile(filePath: string): boolean {
        // List of extensions considered as code files
        // This includes most common programming language source files
        const codeExtensions = [
            '.ts', '.tsx', '.js', '.jsx', '.py', '.cs', '.java',
            '.cpp', '.c', '.h', '.hpp', '.go', '.rs', '.php',
            '.rb', '.swift', '.kt', '.scala', '.clj'
        ];
        
        // Extract and check the file extension
        const ext = path.extname(filePath).toLowerCase();
        return codeExtensions.includes(ext);
    }
}
</file>

<file path="src/indexing/indexingService.ts">
/**
 * Code indexing and search service for the VS Code extension.
 *
 * This module provides the core functionality for indexing code files in a workspace,
 * generating embeddings, and storing them in a vector database for semantic search.
 * It orchestrates the entire indexing pipeline from file discovery to vector storage.
 */
import * as vscode from 'vscode';
import * as fs from 'fs';
import { FileWalker } from './fileWalker';
import { AstParser, SupportedLanguage } from '../parsing/astParser';
import { Chunker, CodeChunk, ChunkType } from '../parsing/chunker';
import { QdrantService } from '../db/qdrantService';
import { IEmbeddingProvider, EmbeddingProviderFactory, EmbeddingConfig } from '../embeddings/embeddingProvider';
import { LSPService } from '../lsp/lspService';

/**
 * Progress tracking interface for the indexing process.
 *
 * This interface provides real-time updates about the indexing progress,
 * allowing the UI to show the current status and progress to the user.
 */
export interface IndexingProgress {
    /** Currently being processed file path */
    currentFile: string;
    /** Number of files that have been processed so far */
    processedFiles: number;
    /** Total number of files to be processed */
    totalFiles: number;
    /** Current phase of the indexing process */
    currentPhase: 'discovering' | 'parsing' | 'chunking' | 'embedding' | 'storing' | 'complete';
    /** Array of chunks generated so far */
    chunks: CodeChunk[];
    /** Array of error messages encountered during indexing */
    errors: string[];
    /** Optional progress information for embedding generation */
    embeddingProgress?: {
        /** Number of chunks that have been embedded */
        processedChunks: number;
        /** Total number of chunks to be embedded */
        totalChunks: number;
    };
}

/**
 * Result interface for the indexing operation.
 *
 * This interface contains comprehensive information about the indexing operation,
 * including success status, generated chunks, statistics, and any errors encountered.
 */
export interface IndexingResult {
    /** Whether the indexing operation completed successfully */
    success: boolean;
    /** Array of code chunks generated during indexing */
    chunks: CodeChunk[];
    /** Total number of files in the workspace */
    totalFiles: number;
    /** Number of files that were successfully processed */
    processedFiles: number;
    /** Array of error messages encountered during indexing */
    errors: string[];
    /** Duration of the indexing operation in milliseconds */
    duration: number;
    /** Name of the Qdrant collection where chunks were stored */
    collectionName?: string;
    /** Name of the embedding provider used */
    embeddingProvider?: string;
    /** Comprehensive statistics about the indexing operation */
    stats: {
        /** Count of files processed by programming language */
        filesByLanguage: Record<string, number>;
        /** Count of chunks by their type */
        chunksByType: Record<ChunkType, number>;
        /** Total number of lines of code processed */
        totalLines: number;
        /** Total number of bytes processed */
        totalBytes: number;
        /** Total number of embeddings generated */
        totalEmbeddings: number;
        /** Dimensionality of the vector embeddings */
        vectorDimensions: number;
    };
}

/**
 * Main indexing service that orchestrates the entire code indexing pipeline.
 *
 * The IndexingService coordinates all aspects of the indexing process:
 * - File discovery using FileWalker
 * - AST parsing using AstParser
 * - Code chunking using Chunker
 * - Embedding generation using embedding providers
 * - Vector storage using QdrantService
 *
 * It provides a high-level API for starting indexing operations and retrieving
 * workspace statistics, as well as searching through indexed code.
 */
export class IndexingService {
    /** Root directory of the workspace being indexed */
    private workspaceRoot: string;
    /** File walker for discovering and filtering files in the workspace */
    private fileWalker: FileWalker;
    /** AST parser for analyzing code structure and semantics */
    private astParser: AstParser;
    /** Chunker for breaking down code into manageable pieces */
    private chunker: Chunker;
    /** Service for interacting with the Qdrant vector database */
    private qdrantService: QdrantService;
    /** Embedding provider for generating vector representations of code */
    private embeddingProvider: IEmbeddingProvider;
    /** Service for interacting with Language Server Protocol */
    private lspService: LSPService;

    /**
     * Creates a new IndexingService instance using dependency injection
     * @param workspaceRoot - The absolute path to the workspace root directory
     * @param fileWalker - Injected FileWalker instance
     * @param astParser - Injected AstParser instance
     * @param chunker - Injected Chunker instance
     * @param qdrantService - Injected QdrantService instance
     * @param embeddingProvider - Injected embedding provider instance
     * @param lspService - Injected LSPService instance
     */
    constructor(
        workspaceRoot: string,
        fileWalker: FileWalker,
        astParser: AstParser,
        chunker: Chunker,
        qdrantService: QdrantService,
        embeddingProvider: IEmbeddingProvider,
        lspService: LSPService
    ) {
        this.workspaceRoot = workspaceRoot;
        this.fileWalker = fileWalker;
        this.astParser = astParser;
        this.chunker = chunker;
        this.qdrantService = qdrantService;
        this.embeddingProvider = embeddingProvider;
        this.lspService = lspService;
    }



    /**
     * Starts the indexing process for the entire workspace.
     *
     * This method orchestrates the complete indexing pipeline:
     * 1. Initialize embedding provider
     * 2. Discover all relevant files in the workspace
     * 3. Process each file (parse AST, create chunks)
     * 4. Generate embeddings for all chunks
     * 5. Store chunks and embeddings in Qdrant
     *
     * The method provides progress updates through the callback function,
     * allowing the UI to show real-time progress to the user.
     *
     * @param progressCallback - Optional callback function for progress updates
     * @returns Promise resolving to an IndexingResult with comprehensive statistics
     */
    public async startIndexing(
        progressCallback?: (progress: IndexingProgress) => void
    ): Promise<IndexingResult> {
        const startTime = Date.now();
        const result: IndexingResult = {
            success: false,
            chunks: [],
            totalFiles: 0,
            processedFiles: 0,
            errors: [],
            duration: 0,
            stats: {
                filesByLanguage: {},
                chunksByType: {} as Record<ChunkType, number>,
                totalLines: 0,
                totalBytes: 0,
                totalEmbeddings: 0,
                vectorDimensions: 0
            }
        };

        try {
            // Phase 1: Initialize embedding provider
            // This must be done first as it's required for the rest of the pipeline
            progressCallback?.({
                currentFile: '',
                processedFiles: 0,
                totalFiles: 0,
                currentPhase: 'discovering',
                chunks: [],
                errors: []
            });



            // Phase 2: Discover files
            // Find all relevant files in the workspace that match our patterns
            progressCallback?.({
                currentFile: '',
                processedFiles: 0,
                totalFiles: 0,
                currentPhase: 'discovering',
                chunks: [],
                errors: []
            });

            const files = await this.fileWalker.findAllFiles();
            const codeFiles = files.filter(file => this.fileWalker.isCodeFile(file));
            
            result.totalFiles = codeFiles.length;

            // If no code files found, return early with success status
            if (codeFiles.length === 0) {
                result.success = true;
                result.duration = Date.now() - startTime;
                return result;
            }

            // Phase 3: Process files
            // For each file, parse the AST and create code chunks
            for (let i = 0; i < codeFiles.length; i++) {
                const filePath = codeFiles[i];
                
                try {
                    progressCallback?.({
                        currentFile: filePath,
                        processedFiles: i,
                        totalFiles: codeFiles.length,
                        currentPhase: 'parsing',
                        chunks: result.chunks,
                        errors: result.errors
                    });

                    const fileResult = await this.processFile(filePath);
                    
                    if (fileResult.success) {
                        result.chunks.push(...fileResult.chunks);
                        
                        // Update stats
                        if (fileResult.language) {
                            result.stats.filesByLanguage[fileResult.language] =
                                (result.stats.filesByLanguage[fileResult.language] || 0) + 1;
                        }
                        
                        result.stats.totalLines += fileResult.lineCount;
                        result.stats.totalBytes += fileResult.byteCount;
                        
                        // Update chunk stats
                        for (const chunk of fileResult.chunks) {
                            result.stats.chunksByType[chunk.type] =
                                (result.stats.chunksByType[chunk.type] || 0) + 1;
                        }
                    } else {
                        result.errors.push(...fileResult.errors);
                    }
                    
                    result.processedFiles++;
                    
                } catch (error) {
                    const errorMessage = `Error processing file ${filePath}: ${error instanceof Error ? error.message : String(error)}`;
                    result.errors.push(errorMessage);
                    console.error(errorMessage);
                }
            }

            // Phase 4: Generate embeddings
            // If we have chunks and an embedding provider, generate vector embeddings
            if (result.chunks.length > 0 && this.embeddingProvider) {
                progressCallback?.({
                    currentFile: '',
                    processedFiles: result.processedFiles,
                    totalFiles: result.totalFiles,
                    currentPhase: 'embedding',
                    chunks: result.chunks,
                    errors: result.errors,
                    embeddingProgress: {
                        processedChunks: 0,
                        totalChunks: result.chunks.length
                    }
                });

                const chunkContents = result.chunks.map(chunk => chunk.content);
                const embeddings = await this.embeddingProvider.generateEmbeddings(chunkContents);

                result.stats.totalEmbeddings = embeddings.length;
                result.stats.vectorDimensions = this.embeddingProvider.getDimensions();
                result.embeddingProvider = this.embeddingProvider.getProviderName();

                // Phase 5: Store in Qdrant
                // Store the chunks and their embeddings in the vector database
                progressCallback?.({
                    currentFile: '',
                    processedFiles: result.processedFiles,
                    totalFiles: result.totalFiles,
                    currentPhase: 'storing',
                    chunks: result.chunks,
                    errors: result.errors
                });

                const collectionName = this.generateCollectionName();
                result.collectionName = collectionName;

                // Create collection if it doesn't exist
                const collectionCreated = await this.qdrantService.createCollectionIfNotExists(
                    collectionName,
                    this.embeddingProvider.getDimensions()
                );

                if (!collectionCreated) {
                    result.errors.push('Failed to create Qdrant collection');
                } else {
                    // Store chunks with embeddings
                    const stored = await this.qdrantService.upsertChunks(
                        collectionName,
                        result.chunks,
                        embeddings
                    );

                    if (!stored) {
                        result.errors.push('Failed to store chunks in Qdrant');
                    }
                }
            }

            // Phase 6: Complete
            // Mark the indexing process as complete
            progressCallback?.({
                currentFile: '',
                processedFiles: result.processedFiles,
                totalFiles: result.totalFiles,
                currentPhase: 'complete',
                chunks: result.chunks,
                errors: result.errors
            });

            result.success = true;
            result.duration = Date.now() - startTime;

        } catch (error) {
            const errorMessage = `Indexing failed: ${error instanceof Error ? error.message : String(error)}`;
            result.errors.push(errorMessage);
            console.error(errorMessage);
        }

        result.duration = Date.now() - startTime;
        return result;
    }

    /**
     * Processes a single file by reading its content, parsing its AST,
     * and creating code chunks.
     *
     * This method handles the complete processing pipeline for a single file:
     * 1. Read the file content
     * 2. Determine the programming language
     * 3. Parse the Abstract Syntax Tree (AST)
     * 4. Create code chunks from the parsed tree
     *
     * The method includes error recovery and handles various failure scenarios
     * gracefully, returning appropriate error messages when issues occur.
     *
     * @param filePath - The path to the file to process
     * @returns Promise resolving to a processing result with chunks and metadata
     */
    private async processFile(filePath: string): Promise<{
        success: boolean;
        chunks: CodeChunk[];
        language?: SupportedLanguage;
        lineCount: number;
        byteCount: number;
        errors: string[];
    }> {
        const errors: string[] = [];
        
        try {
            // Read file content
            // This is the first step in processing any file
            const content = await fs.promises.readFile(filePath, 'utf8');
            const lineCount = content.split('\n').length;
            const byteCount = Buffer.byteLength(content, 'utf8');
            
            // Determine language
            // We need to know the language to use the correct parser
            const language = this.getLanguage(filePath);
            if (!language) {
                return {
                    success: false,
                    chunks: [],
                    lineCount,
                    byteCount,
                    errors: [`Unsupported file type: ${filePath}`]
                };
            }

            // Parse AST
            // This creates a structured representation of the code
            const parseResult = this.astParser.parseWithErrorRecovery(language, content);
            if (parseResult.errors.length > 0) {
                errors.push(...parseResult.errors.map(err => `${filePath}: ${err}`));
            }

            if (!parseResult.tree) {
                return {
                    success: false,
                    chunks: [],
                    language,
                    lineCount,
                    byteCount,
                    errors: [`Failed to parse AST for ${filePath}`, ...errors]
                };
            }

            // Create chunks
            // Break down the code into manageable pieces for embedding
            const chunks = this.chunker.chunk(filePath, parseResult.tree, content, language);

            // Enhance chunks with LSP metadata
            // This adds semantic information like symbols, definitions, and references
            const enhancedChunks = await this.enhanceChunksWithLSP(chunks, filePath, content, language);

            return {
                success: true,
                chunks: enhancedChunks,
                language,
                lineCount,
                byteCount,
                errors
            };

        } catch (error) {
            return {
                success: false,
                chunks: [],
                lineCount: 0,
                byteCount: 0,
                errors: [`Error processing ${filePath}: ${error instanceof Error ? error.message : String(error)}`]
            };
        }
    }

    /**
     * Enhance code chunks with LSP metadata
     *
     * This method adds semantic information from the Language Server Protocol
     * to each code chunk, including symbols, definitions, references, and hover info.
     *
     * @param chunks - The code chunks to enhance
     * @param filePath - The path to the source file
     * @param content - The full file content
     * @param language - The programming language
     * @returns Promise resolving to enhanced chunks with LSP metadata
     */
    private async enhanceChunksWithLSP(
        chunks: CodeChunk[],
        filePath: string,
        content: string,
        language: SupportedLanguage
    ): Promise<CodeChunk[]> {
        try {
            // Check if LSP is available for this language
            const isLSPAvailable = await this.lspService.isLSPAvailable(language);
            if (!isLSPAvailable) {
                console.log(`LSP not available for ${language}, skipping LSP enhancement`);
                return chunks;
            }

            // Enhance each chunk with LSP metadata
            const enhancedChunks: CodeChunk[] = [];
            for (const chunk of chunks) {
                try {
                    const lspMetadata = await this.lspService.getMetadataForChunk(
                        filePath,
                        chunk.content,
                        chunk.startLine,
                        chunk.endLine,
                        language
                    );

                    enhancedChunks.push({
                        ...chunk,
                        lspMetadata
                    });
                } catch (error) {
                    console.warn(`Failed to get LSP metadata for chunk in ${filePath}:`, error);
                    // Add chunk without LSP metadata
                    enhancedChunks.push(chunk);
                }
            }

            return enhancedChunks;
        } catch (error) {
            console.warn(`Failed to enhance chunks with LSP for ${filePath}:`, error);
            return chunks; // Return original chunks if LSP enhancement fails
        }
    }

    /**
     * Determines the programming language of a file based on its extension.
     *
     * This method delegates to the AST parser to identify the language,
     * which ensures consistency with the parsing capabilities.
     *
     * @param filePath - The path to the file to analyze
     * @returns The supported language or null if the language is not supported
     */
    private getLanguage(filePath: string): SupportedLanguage | null {
        return this.astParser.getLanguageFromFilePath(filePath);
    }

    /**
     * Generates a unique collection name for the Qdrant database.
     *
     * This method creates a sanitized version of the workspace name to use
     * as the collection name. This ensures that the collection name is
     * valid for Qdrant and unique per workspace.
     *
     * @returns A sanitized collection name string
     */
    private generateCollectionName(): string {
        // Generate a collection name based on workspace root
        // This helps organize collections by workspace
        const workspaceName = this.workspaceRoot.split('/').pop() || 'workspace';
        const sanitizedName = workspaceName.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        return `code_context_${sanitizedName}`;
    }

    /**
     * Gets statistics about the workspace for planning purposes.
     *
     * This method provides useful information about the workspace composition,
     * including the total number of files, distribution by file extension,
     * and an estimated indexing time based on the number of code files.
     *
     * @returns Promise resolving to workspace statistics
     */
    public async getWorkspaceStats(): Promise<{
        totalFiles: number;
        filesByExtension: Record<string, number>;
        estimatedIndexingTime: number;
    }> {
        const stats = await this.fileWalker.getFileStats();
        const codeFileCount = Object.entries(stats.filesByExtension)
            .filter(([ext]) => this.fileWalker.isCodeFile(`dummy${ext}`))
            .reduce((sum, [, count]) => sum + count, 0);
        
        // Rough estimate: 50ms per file
        // This is a heuristic that can be refined based on actual performance
        const estimatedIndexingTime = codeFileCount * 50;

        return {
            totalFiles: stats.totalFiles,
            filesByExtension: stats.filesByExtension,
            estimatedIndexingTime
        };
    }

    /**
     * Gets the list of supported programming languages.
     *
     * This method returns all languages that the AST parser can handle,
     * which is useful for UI components that need to show supported languages
     * or filter files by language.
     *
     * @returns Array of supported language identifiers
     */
    public getSupportedLanguages(): SupportedLanguage[] {
        return this.astParser.getSupportedLanguages();
    }

    /**
     * Performs semantic search through the indexed code.
     *
     * This method takes a natural language query, generates an embedding for it,
     * and searches the Qdrant vector database for similar code chunks. The search
     * is based on semantic similarity rather than keyword matching.
     *
     * @param query - The search query in natural language
     * @param limit - Maximum number of results to return (default: 10)
     * @returns Promise resolving to search results
     */
    public async searchCode(query: string, limit: number = 10): Promise<any[]> {
        // Ensure embedding provider is available
        if (!this.embeddingProvider) {
            throw new Error('Embedding provider not available');
        }

        if (!this.embeddingProvider) {
            throw new Error('Embedding provider not available');
        }

        try {
            // Generate embedding for the query
            // This converts the natural language query into a vector representation
            const queryEmbeddings = await this.embeddingProvider.generateEmbeddings([query]);
            if (queryEmbeddings.length === 0) {
                return [];
            }

            const collectionName = this.generateCollectionName();

            // Search in Qdrant
            // This finds the most similar code chunks based on vector similarity
            const results = await this.qdrantService.search(
                collectionName,
                queryEmbeddings[0],
                limit
            );

            return results;
        } catch (error) {
            console.error('Search failed:', error);
            return [];
        }
    }

    /**
     * Gets information about the Qdrant collection used for storing embeddings.
     *
     * This method retrieves metadata about the collection, such as the number
     * of vectors, vector dimensions, and other collection properties. This is
     * useful for debugging and monitoring purposes.
     *
     * @returns Promise resolving to collection information
     */
    public async getCollectionInfo(): Promise<any> {
        const collectionName = this.generateCollectionName();
        return await this.qdrantService.getCollectionInfo(collectionName);
    }

    /**
     * Checks if the Qdrant service is available and responsive.
     *
     * This method performs a health check on the Qdrant service to ensure
     * that the vector database is running and accessible. This is useful
     * for determining if indexing and search operations can proceed.
     *
     * @returns Promise resolving to true if Qdrant is available, false otherwise
     */
    public async isQdrantAvailable(): Promise<boolean> {
        return await this.qdrantService.healthCheck();
    }
}
</file>

<file path="src/parsing/chunker.ts">
import Parser from 'tree-sitter';
import { SupportedLanguage } from './astParser';
import { LSPMetadata } from '../lsp/lspService';
// TODO: (agent) we should be able to process all files except for executables
export interface CodeChunk {
    filePath: string;
    content: string;
    startLine: number;
    endLine: number;
    type: ChunkType;
    name?: string;
    signature?: string;
    docstring?: string;
    language: SupportedLanguage;
    metadata?: Record<string, any>;
    /** LSP metadata including symbols, definitions, and references */
    lspMetadata?: LSPMetadata;
}

export enum ChunkType {
    FUNCTION = 'function',
    CLASS = 'class',
    METHOD = 'method',
    INTERFACE = 'interface',
    ENUM = 'enum',
    VARIABLE = 'variable',
    IMPORT = 'import',
    COMMENT = 'comment',
    MODULE = 'module',
    NAMESPACE = 'namespace',
    PROPERTY = 'property',
    CONSTRUCTOR = 'constructor',
    DECORATOR = 'decorator',
    TYPE_ALIAS = 'type_alias',
    GENERIC = 'generic'
}

export class Chunker {
    private languageQueries: Map<SupportedLanguage, Map<ChunkType, string>>;

    constructor() {
        this.languageQueries = new Map();
        this.initializeQueries();
    }

    private initializeQueries(): void {
        // TypeScript/JavaScript queries
        const tsQueries = new Map<ChunkType, string>();
        tsQueries.set(ChunkType.FUNCTION, `
            (function_declaration
                name: (identifier) @name
                parameters: (formal_parameters) @params
                body: (statement_block) @body) @function
        `);
        tsQueries.set(ChunkType.CLASS, `
            (class_declaration
                name: (type_identifier) @name
                body: (class_body) @body) @class
        `);
        tsQueries.set(ChunkType.METHOD, `
            (method_definition
                name: (property_identifier) @name
                parameters: (formal_parameters) @params
                body: (statement_block) @body) @method
        `);
        tsQueries.set(ChunkType.INTERFACE, `
            (interface_declaration
                name: (type_identifier) @name
                body: (object_type) @body) @interface
        `);
        tsQueries.set(ChunkType.ENUM, `
            (enum_declaration
                name: (identifier) @name
                body: (enum_body) @body) @enum
        `);
        tsQueries.set(ChunkType.IMPORT, `
            (import_statement) @import
        `);

        this.languageQueries.set('typescript', tsQueries);
        this.languageQueries.set('javascript', tsQueries);

        // Python queries
        const pyQueries = new Map<ChunkType, string>();
        pyQueries.set(ChunkType.FUNCTION, `
            (function_definition
                name: (identifier) @name
                parameters: (parameters) @params
                body: (block) @body) @function
        `);
        pyQueries.set(ChunkType.CLASS, `
            (class_definition
                name: (identifier) @name
                body: (block) @body) @class
        `);
        pyQueries.set(ChunkType.METHOD, `
            (function_definition
                name: (identifier) @name
                parameters: (parameters) @params
                body: (block) @body) @method
        `);
        pyQueries.set(ChunkType.IMPORT, `
            (import_statement) @import
            (import_from_statement) @import
        `);

        this.languageQueries.set('python', pyQueries);

        // C# queries
        const csQueries = new Map<ChunkType, string>();
        csQueries.set(ChunkType.CLASS, `
            (class_declaration
                name: (identifier) @name
                body: (declaration_list) @body) @class
        `);
        csQueries.set(ChunkType.METHOD, `
            (method_declaration
                name: (identifier) @name
                parameters: (parameter_list) @params
                body: (block) @body) @method
        `);
        csQueries.set(ChunkType.INTERFACE, `
            (interface_declaration
                name: (identifier) @name
                body: (declaration_list) @body) @interface
        `);
        csQueries.set(ChunkType.NAMESPACE, `
            (namespace_declaration
                name: (identifier) @name
                body: (declaration_list) @body) @namespace
        `);

        this.languageQueries.set('csharp', csQueries);
    }

    public chunk(filePath: string, tree: Parser.Tree, code: string, language: SupportedLanguage): CodeChunk[] {
        const chunks: CodeChunk[] = [];
        const queries = this.languageQueries.get(language);

        if (!queries) {
            console.warn(`No queries defined for language: ${language}`);
            return this.createFileChunk(filePath, code, language);
        }

        // Extract chunks for each type
        for (const [chunkType, queryString] of queries) {
            try {
                const languageGrammar = this.getLanguageGrammar(language);
                if (!languageGrammar) continue;

                const query = new Parser.Query(languageGrammar, queryString);
                const matches = query.matches(tree.rootNode);

                for (const match of matches) {
                    const chunk = this.createChunkFromMatch(filePath, match, code, chunkType, language);
                    if (chunk) {
                        chunks.push(chunk);
                    }
                }
            } catch (error) {
                console.error(`Error processing ${chunkType} chunks for ${language}:`, error);
            }
        }

        // If no chunks were found, create a file-level chunk
        if (chunks.length === 0) {
            chunks.push(...this.createFileChunk(filePath, code, language));
        }

        return chunks;
    }

    private createChunkFromMatch(
        filePath: string,
        match: Parser.QueryMatch,
        code: string,
        chunkType: ChunkType,
        language: SupportedLanguage
    ): CodeChunk | null {
        const captures = match.captures;
        const mainCapture = captures.find((c: any) => c.name === chunkType) || captures[0];
        
        if (!mainCapture) return null;

        const node = mainCapture.node;
        const content = code.slice(node.startIndex, node.endIndex);
        
        // Extract name if available
        const nameCapture = captures.find((c: any) => c.name === 'name');
        const name = nameCapture ? code.slice(nameCapture.node.startIndex, nameCapture.node.endIndex) : undefined;

        // Extract parameters/signature if available
        const paramsCapture = captures.find((c: any) => c.name === 'params');
        const signature = paramsCapture ? code.slice(paramsCapture.node.startIndex, paramsCapture.node.endIndex) : undefined;

        // Extract docstring for Python
        let docstring: string | undefined;
        if (language === 'python' && chunkType === ChunkType.FUNCTION) {
            docstring = this.extractPythonDocstring(node, code);
        }

        return {
            filePath,
            content,
            startLine: node.startPosition.row + 1,
            endLine: node.endPosition.row + 1,
            type: chunkType,
            name,
            signature,
            docstring,
            language,
            metadata: {
                nodeType: node.type,
                hasError: node.hasError(),
                byteLength: node.endIndex - node.startIndex
            }
        };
    }

    private createFileChunk(filePath: string, code: string, language: SupportedLanguage): CodeChunk[] {
        const lines = code.split('\n');
        return [{
            filePath,
            content: code,
            startLine: 1,
            endLine: lines.length,
            type: ChunkType.MODULE,
            name: filePath.split('/').pop()?.split('.')[0],
            language,
            metadata: {
                isFileLevel: true,
                lineCount: lines.length,
                charCount: code.length
            }
        }];
    }

    private extractPythonDocstring(node: Parser.SyntaxNode, code: string): string | undefined {
        // Look for string literal as first statement in function body
        for (let i = 0; i < node.childCount; i++) {
            const child = node.child(i);
            if (child?.type === 'block') {
                const firstStatement = child.child(1); // Skip the colon
                if (firstStatement?.type === 'expression_statement') {
                    const expr = firstStatement.child(0);
                    if (expr?.type === 'string') {
                        return code.slice(expr.startIndex, expr.endIndex);
                    }
                }
                break;
            }
        }
        return undefined;
    }

    private getLanguageGrammar(language: SupportedLanguage): any {
        // Import the actual language grammars
        try {
            switch (language) {
                case 'typescript':
                    return require('tree-sitter-typescript').typescript;
                case 'javascript':
                    return require('tree-sitter-typescript').javascript;
                case 'python':
                    return require('tree-sitter-python');
                case 'csharp':
                    return require('tree-sitter-c-sharp');
                default:
                    return null;
            }
        } catch (error) {
            console.error(`Failed to load grammar for ${language}:`, error);
            return null;
        }
    }

    public getChunksByType(chunks: CodeChunk[], type: ChunkType): CodeChunk[] {
        return chunks.filter(chunk => chunk.type === type);
    }

    public getChunkStats(chunks: CodeChunk[]): Record<ChunkType, number> {
        const stats: Record<ChunkType, number> = {} as Record<ChunkType, number>;
        
        for (const chunk of chunks) {
            stats[chunk.type] = (stats[chunk.type] || 0) + 1;
        }
        
        return stats;
    }
}
</file>

<file path="webview/src/index.ts">
import './styles.css';
import {
    provideFluentDesignSystem,
    fluentButton,
    fluentTextField,
    fluentProgressRing,
    fluentCard,
    fluentBadge,
    fluentAccordion,
    fluentAccordionItem
} from '@fluentui/web-components';
import { vscodeApi, type SearchResult, type RelatedFile, type ServiceStatus } from './lib/vscodeApi';

// Setup state interface
interface SetupState {
    databaseReady: boolean;
    providerSelected: boolean;
    selectedProvider: string;
    databaseType: string;
}

// Register Fluent UI components
provideFluentDesignSystem()
    .register(
        fluentButton(),
        fluentTextField(),
        fluentProgressRing(),
        fluentCard(),
        fluentBadge(),
        fluentAccordion(),
        fluentAccordionItem()
    );

class CodeContextWebview {
    private indexButton: HTMLElement | null;
    private progressSection: HTMLElement | null;
    private progressRing: HTMLElement | null;
    private progressText: HTMLElement | null;
    private searchButton: HTMLElement | null;
    private searchInput: HTMLElement | null;
    private searchResults: HTMLElement | null;
    private settingsButton: HTMLElement | null;
    private serviceStatus: HTMLElement | null;
    private relatedFilesSection: HTMLElement | null;
    private pingButton: HTMLElement | null;
    private pingResult: HTMLElement | null;
    private currentQuery: string = '';
    private isSetupMode: boolean = false;
    private setupState: SetupState = {
        databaseReady: false,
        providerSelected: false,
        selectedProvider: '',
        databaseType: 'qdrant'
    };

    constructor() {
        this.initializeElements();
        this.setupEventListeners();
        this.setupMessageListener();
        this.checkWorkspaceSetup();
    }

    private initializeElements(): void {
        this.indexButton = document.getElementById('index-button');
        this.progressSection = document.getElementById('progress-section');
        this.progressRing = document.getElementById('progress-ring');
        this.progressText = document.getElementById('progress-text');
        this.searchButton = document.getElementById('search-button');
        this.searchInput = document.getElementById('search-input');
        this.searchResults = document.getElementById('search-results');
        this.settingsButton = document.getElementById('settings-button');
        this.serviceStatus = document.getElementById('service-status');
        this.relatedFilesSection = document.getElementById('related-files');
        this.pingButton = document.getElementById('ping-button');
        this.pingResult = document.getElementById('ping-result');
    }

    private setupEventListeners(): void {
        this.indexButton?.addEventListener('click', () => {
            this.startIndexing();
        });

        this.searchButton?.addEventListener('click', () => {
            this.performSearch();
        });

        this.searchInput?.addEventListener('keypress', (event) => {
            if ((event as KeyboardEvent).key === 'Enter') {
                this.performSearch();
            }
        });

        // Add search suggestions
        this.searchInput?.addEventListener('input', () => {
            this.showSearchSuggestions();
        });

        this.settingsButton?.addEventListener('click', () => {
            this.openSettings();
        });

        this.pingButton?.addEventListener('click', () => {
            this.sendPing();
        });
    }

    private setupMessageListener(): void {
        // Listen for indexing progress updates
        vscodeApi.onMessage('indexingProgress', (event) => {
            this.updateIndexingProgress(event.data.progress, event.data.message);
        });

        // Listen for indexing completion
        vscodeApi.onMessage('indexingComplete', (event) => {
            this.indexingComplete(event.data.result);
        });

        // Listen for search results
        vscodeApi.onMessage('searchResults', (event) => {
            this.displaySearchResults(event.data.results, event.data.error);
        });

        // Setup-specific message listeners
        vscodeApi.onMessage('databaseStarted', (event) => {
            this.updateSetupStatus('Database is starting...', 'info');
        });

        vscodeApi.onMessage('databaseStatus', (event) => {
            this.handleDatabaseStatusUpdate(event.data);
        });

        vscodeApi.onMessage('setupIndexingStarted', (event) => {
            this.updateSetupStatus('Configuration saved and indexing started!', 'success');
        });

        vscodeApi.onMessage('setupIndexingProgress', (event) => {
            this.updateSetupStatus(`Indexing: ${event.data.progress.message}`, 'info');
        });

        vscodeApi.onMessage('setupIndexingComplete', (event) => {
            this.updateSetupStatus('Setup and indexing completed successfully!', 'success');
            // Switch to main UI after successful setup
            setTimeout(() => {
                this.isSetupMode = false;
                this.showMainUI();
                this.checkServiceStatus();
            }, 2000);
        });

        vscodeApi.onMessage('setupIndexingError', (event) => {
            this.updateSetupStatus(event.data.error, 'error');
        });
    }

    private handleSetupStatusResponse(message: any): void {
        // This method handles the response from checkSetupStatus
        // It's called by the vscodeApi when a response is received
        if (message.error) {
            console.error('Setup status check failed:', message.error);
            this.showMainUI();
            this.checkServiceStatus();
        }
    }

    private startIndexing(): void {
        vscodeApi.startIndexing();

        // Show progress section
        this.progressSection?.classList.add('visible');
        if (this.indexButton) {
            (this.indexButton as any).disabled = true;
        }
    }

    private updateIndexingProgress(progress: number, message: string): void {
        if (this.progressText) {
            this.progressText.textContent = message;
        }
        // Update progress ring if needed
    }

    private indexingComplete(result?: any): void {
        if (this.progressText) {
            if (result && result.success) {
                this.progressText.textContent = `Indexing complete! Processed ${result.processedFiles} files, created ${result.chunks.length} chunks.`;
            } else {
                this.progressText.textContent = 'Indexing complete!';
            }
        }
        if (this.indexButton) {
            (this.indexButton as any).disabled = false;
        }

        // Hide progress section after a delay
        setTimeout(() => {
            this.progressSection?.classList.remove('visible');
        }, 3000);

        // Refresh service status
        this.checkServiceStatus();
    }

    private async performSearch(): Promise<void> {
        const searchTerm = (this.searchInput as any)?.value;
        if (!searchTerm) return;

        this.currentQuery = searchTerm;

        // Add to search history
        this.addToSearchHistory(searchTerm);

        // Show loading state
        if (this.searchResults) {
            this.searchResults.innerHTML = '<p>Searching...</p>';
        }

        try {
            // Perform search using the new API
            const results = await vscodeApi.search(searchTerm);
            this.displaySearchResults(results);

            // Find related files
            const relatedFiles = await vscodeApi.findRelatedFiles(searchTerm, undefined, 5, 0.6);
            this.displayRelatedFiles(relatedFiles);

        } catch (error) {
            this.displaySearchResults([], `Search failed: ${error}`);
        }
    }

    private displaySearchResults(results: SearchResult[], error?: string): void {
        if (!this.searchResults) return;

        if (error) {
            this.searchResults.innerHTML = `<p style="color: var(--vscode-errorForeground);">${error}</p>`;
            return;
        }

        if (results.length === 0) {
            this.searchResults.innerHTML = '<p>No results found.</p>';
            return;
        }

        const resultsHtml = results.map(result => `
            <fluent-card style="margin-bottom: 15px; padding: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                    <h4 style="margin: 0; color: var(--vscode-textLink-foreground);">${result.file}</h4>
                    ${result.score ? `<fluent-badge appearance="accent">${(result.score * 100).toFixed(1)}%</fluent-badge>` : ''}
                </div>
                ${result.type && result.name ? `<p style="margin: 4px 0; font-size: 0.9em; color: var(--vscode-descriptionForeground);"><strong>${result.type}:</strong> ${result.name}</p>` : ''}
                <p style="margin: 8px 0; font-family: var(--vscode-editor-font-family); background: var(--vscode-textCodeBlock-background); padding: 8px; border-radius: 4px; font-size: 0.9em;">${result.snippet}</p>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <small style="color: var(--vscode-descriptionForeground);">Line ${result.line}${result.language ? `  ${result.language}` : ''}</small>
                    <fluent-button appearance="stealth" onclick="this.openFile('${result.file}', ${result.line})">Open</fluent-button>
                </div>
            </fluent-card>
        `).join('');

        this.searchResults.innerHTML = resultsHtml;
    }

    private openSettings(): void {
        vscodeApi.openSettings();
    }

    private async sendPing(): Promise<void> {
        if (!this.pingResult) return;

        try {
            // Show loading state
            this.pingResult.style.display = 'block';
            this.pingResult.style.backgroundColor = 'var(--vscode-textCodeBlock-background)';
            this.pingResult.style.color = 'var(--vscode-foreground)';
            this.pingResult.textContent = 'Sending ping...';

            // Send ping and wait for response
            const response = await vscodeApi.ping();

            // Show success response
            this.pingResult.style.backgroundColor = 'var(--vscode-testing-iconPassed)';
            this.pingResult.style.color = 'white';
            this.pingResult.textContent = ` Received pong! Response time: ${response.timestamp}`;

            // Hide after 3 seconds
            setTimeout(() => {
                if (this.pingResult) {
                    this.pingResult.style.display = 'none';
                }
            }, 3000);

        } catch (error) {
            // Show error response
            this.pingResult.style.backgroundColor = 'var(--vscode-testing-iconFailed)';
            this.pingResult.style.color = 'white';
            this.pingResult.textContent = ` Ping failed: ${error}`;

            // Hide after 5 seconds
            setTimeout(() => {
                if (this.pingResult) {
                    this.pingResult.style.display = 'none';
                }
            }, 5000);
        }
    }

    private addToSearchHistory(query: string): void {
        const history = this.getSearchHistory();

        // Remove if already exists to avoid duplicates
        const index = history.indexOf(query);
        if (index > -1) {
            history.splice(index, 1);
        }

        // Add to beginning
        history.unshift(query);

        // Keep only last 10 searches
        if (history.length > 10) {
            history.splice(10);
        }

        localStorage.setItem('searchHistory', JSON.stringify(history));
    }

    private getSearchHistory(): string[] {
        try {
            const history = localStorage.getItem('searchHistory');
            return history ? JSON.parse(history) : [];
        } catch {
            return [];
        }
    }

    private showSearchSuggestions(): void {
        if (!this.searchInput) return;

        const query = (this.searchInput as any).value.trim().toLowerCase();
        if (query.length < 2) {
            this.hideSuggestions();
            return;
        }

        const history = this.getSearchHistory();
        const suggestions = history.filter(item =>
            item.toLowerCase().includes(query) && item.toLowerCase() !== query
        ).slice(0, 5);

        if (suggestions.length > 0) {
            this.displaySuggestions(suggestions);
        } else {
            this.hideSuggestions();
        }
    }

    private displaySuggestions(suggestions: string[]): void {
        // Remove existing suggestions
        this.hideSuggestions();

        const suggestionsContainer = document.createElement('div');
        suggestionsContainer.id = 'search-suggestions';
        suggestionsContainer.className = 'search-suggestions';

        suggestions.forEach(suggestion => {
            const suggestionItem = document.createElement('div');
            suggestionItem.className = 'suggestion-item';
            suggestionItem.textContent = suggestion;
            suggestionItem.addEventListener('click', () => {
                if (this.searchInput) {
                    (this.searchInput as any).value = suggestion;
                    this.performSearch();
                    this.hideSuggestions();
                }
            });
            suggestionsContainer.appendChild(suggestionItem);
        });

        // Insert after search input
        this.searchInput?.parentNode?.insertBefore(suggestionsContainer, this.searchInput.nextSibling);
    }

    private hideSuggestions(): void {
        const existing = document.getElementById('search-suggestions');
        if (existing) {
            existing.remove();
        }
    }

    private displayRelatedFiles(relatedFiles: RelatedFile[]): void {
        if (!this.relatedFilesSection) return;

        if (relatedFiles.length === 0) {
            this.relatedFilesSection.innerHTML = '<p>No related files found.</p>';
            return;
        }

        const relatedHtml = relatedFiles.map(file => `
            <fluent-card style="margin-bottom: 10px; padding: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h5 style="margin: 0; color: var(--vscode-textLink-foreground);">${file.filePath}</h5>
                        <p style="margin: 4px 0; font-size: 0.85em; color: var(--vscode-descriptionForeground);">${file.reason}</p>
                        <small style="color: var(--vscode-descriptionForeground);">${file.chunkCount} chunks  ${(file.similarity * 100).toFixed(1)}% similarity${file.language ? `  ${file.language}` : ''}</small>
                    </div>
                    <fluent-button appearance="stealth" onclick="this.openFile('${file.filePath}')">Open</fluent-button>
                </div>
            </fluent-card>
        `).join('');

        this.relatedFilesSection.innerHTML = `
            <h3>Related Files</h3>
            ${relatedHtml}
        `;
    }

    private async checkWorkspaceSetup(): Promise<void> {
        try {
            // Check if workspace is configured
            const setupStatus = await vscodeApi.checkSetupStatus();
            this.isSetupMode = !setupStatus.isConfigured;

            if (this.isSetupMode) {
                this.showSetupUI();
            } else {
                this.showMainUI();
                this.checkServiceStatus();
            }
        } catch (error) {
            console.error('Failed to check workspace setup:', error);
            // Default to main UI if check fails
            this.showMainUI();
            this.checkServiceStatus();
        }
    }

    private async checkServiceStatus(): Promise<void> {
        try {
            const status = await vscodeApi.getServiceStatus();
            this.displayServiceStatus(status);
        } catch (error) {
            console.error('Failed to get service status:', error);
        }
    }

    private displayServiceStatus(status: ServiceStatus): void {
        if (!this.serviceStatus) return;

        const qdrantStatus = status.qdrantConnected ?
            '<fluent-badge appearance="accent">Connected</fluent-badge>' :
            '<fluent-badge appearance="important">Disconnected</fluent-badge>';

        const embeddingStatus = status.embeddingProvider ?
            `<fluent-badge appearance="accent">${status.embeddingProvider}</fluent-badge>` :
            '<fluent-badge appearance="neutral">Not configured</fluent-badge>';

        const collectionStatus = status.collectionExists ?
            '<fluent-badge appearance="accent">Ready</fluent-badge>' :
            '<fluent-badge appearance="neutral">Not indexed</fluent-badge>';

        this.serviceStatus.innerHTML = `
            <div style="display: flex; gap: 15px; align-items: center; font-size: 0.9em;">
                <span>Database: ${qdrantStatus}</span>
                <span>Embeddings: ${embeddingStatus}</span>
                <span>Collection: ${collectionStatus}</span>
            </div>
        `;
    }

    private async openFile(filePath: string, line?: number): Promise<void> {
        try {
            // This would need to be implemented in the extension
            // For now, we can show file content in a modal or new section
            const content = await vscodeApi.getFileContent(filePath, true);
            this.showFileContent(content, line);
        } catch (error) {
            console.error('Failed to open file:', error);
        }
    }

    private showFileContent(content: any, line?: number): void {
        // Create a modal or new section to show file content
        // This is a simplified implementation
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 1000;
            display: flex; align-items: center; justify-content: center;
        `;

        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `
            background: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 8px; padding: 20px; max-width: 80%; max-height: 80%;
            overflow: auto; position: relative;
        `;

        contentDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>${content.filePath}</h3>
                <fluent-button appearance="stealth" onclick="this.parentElement.parentElement.remove()"></fluent-button>
            </div>
            <pre style="background: var(--vscode-textCodeBlock-background); padding: 15px; border-radius: 4px; overflow: auto; font-family: var(--vscode-editor-font-family); font-size: 0.9em;">${content.content}</pre>
            <div style="margin-top: 10px; font-size: 0.85em; color: var(--vscode-descriptionForeground);">
                Size: ${content.size} bytes  Modified: ${new Date(content.lastModified).toLocaleString()}
                ${content.language ? `  Language: ${content.language}` : ''}
            </div>
        `;

        modal.appendChild(contentDiv);
        document.body.appendChild(modal);

        // Close modal on background click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }

    private showSetupUI(): void {
        // Hide main UI elements
        const mainSections = document.querySelectorAll('.section');
        mainSections.forEach(section => {
            (section as HTMLElement).style.display = 'none';
        });

        // Show or create setup UI
        this.createSetupUI();
    }

    private showMainUI(): void {
        // Show main UI elements
        const mainSections = document.querySelectorAll('.section');
        mainSections.forEach(section => {
            (section as HTMLElement).style.display = 'block';
        });

        // Hide setup UI if it exists
        const setupContainer = document.getElementById('setup-container');
        if (setupContainer) {
            setupContainer.style.display = 'none';
        }
    }

    private createSetupUI(): void {
        // Check if setup UI already exists
        let setupContainer = document.getElementById('setup-container');
        if (!setupContainer) {
            setupContainer = document.createElement('div');
            setupContainer.id = 'setup-container';
            setupContainer.className = 'setup-container';

            setupContainer.innerHTML = `
                <div class="setup-header">
                    <h1>Welcome to Code Context Engine!</h1>
                    <p>Let's set up your workspace for AI-powered code search and context discovery.</p>
                </div>

                <div class="setup-section">
                    <h2>Database Configuration</h2>
                    <div class="setup-item">
                        <label for="database-select">Vector Database:</label>
                        <fluent-text-field id="database-select" value="Qdrant" readonly></fluent-text-field>
                        <p class="setup-description">Qdrant is a high-performance vector database for storing code embeddings</p>
                    </div>

                    <div class="setup-item">
                        <label for="database-connection">Connection String:</label>
                        <fluent-text-field id="database-connection" value="http://localhost:6333" placeholder="http://localhost:6333"></fluent-text-field>
                    </div>

                    <div class="setup-controls">
                        <fluent-button id="start-database-btn" appearance="stealth">Start Local Qdrant</fluent-button>
                        <fluent-button id="check-database-btn" appearance="stealth">Check Status</fluent-button>
                        <span id="database-status" class="status-indicator">
                            <span class="status-dot status-unknown"></span>
                            <span>Status unknown</span>
                        </span>
                    </div>
                </div>

                <div class="setup-section">
                    <h2>Embedding Provider</h2>
                    <div class="setup-item">
                        <label for="provider-select">Provider:</label>
                        <select id="provider-select" class="setup-select">
                            <option value="">Select a provider...</option>
                            <option value="ollama">Ollama (Local)</option>
                            <option value="openai">OpenAI (Cloud)</option>
                        </select>
                        <p class="setup-description">Choose between local Ollama or cloud-based OpenAI for generating embeddings</p>
                    </div>

                    <div id="ollama-config" class="provider-config" style="display: none;">
                        <label for="ollama-model">Ollama Model:</label>
                        <select id="ollama-model" class="setup-select">
                            <option value="nomic-embed-text">nomic-embed-text (768 dimensions)</option>
                            <option value="all-minilm">all-minilm (384 dimensions)</option>
                            <option value="mxbai-embed-large">mxbai-embed-large (1024 dimensions)</option>
                        </select>
                    </div>

                    <div id="openai-config" class="provider-config" style="display: none;">
                        <label for="openai-key">OpenAI API Key:</label>
                        <fluent-text-field id="openai-key" type="password" placeholder="sk-..."></fluent-text-field>
                    </div>
                </div>

                <div class="setup-actions">
                    <fluent-button id="index-now-btn" appearance="accent" disabled>Index Now</fluent-button>
                    <p id="setup-status" class="setup-status"></p>
                </div>
            `;

            // Insert setup UI at the beginning of the container
            const container = document.querySelector('.container');
            if (container) {
                container.insertBefore(setupContainer, container.firstChild);
            }
        } else {
            setupContainer.style.display = 'block';
        }

        // Setup event listeners for setup UI
        this.setupSetupEventListeners();
    }

    private setupSetupEventListeners(): void {
        // Database controls
        const startDbBtn = document.getElementById('start-database-btn');
        const checkDbBtn = document.getElementById('check-database-btn');
        const providerSelect = document.getElementById('provider-select') as HTMLSelectElement;
        const indexNowBtn = document.getElementById('index-now-btn');

        startDbBtn?.addEventListener('click', () => this.startDatabase());
        checkDbBtn?.addEventListener('click', () => this.checkDatabaseStatus());
        providerSelect?.addEventListener('change', () => this.onProviderChange());
        indexNowBtn?.addEventListener('click', () => this.startSetupIndexing());
    }

    private startDatabase(): void {
        vscodeApi.postMessage({
            command: 'startDatabase',
            databaseType: this.setupState.databaseType
        });

        this.updateSetupStatus('Starting database...', 'info');
    }

    private checkDatabaseStatus(): void {
        vscodeApi.postMessage({
            command: 'checkDatabaseStatus',
            databaseType: this.setupState.databaseType
        });

        this.updateSetupStatus('Checking database status...', 'info');
    }

    private onProviderChange(): void {
        const providerSelect = document.getElementById('provider-select') as HTMLSelectElement;
        const selectedProvider = providerSelect.value;

        // Hide all provider configs
        document.querySelectorAll('.provider-config').forEach(config => {
            (config as HTMLElement).style.display = 'none';
        });

        // Show selected provider config
        if (selectedProvider === 'ollama') {
            const ollamaConfig = document.getElementById('ollama-config');
            if (ollamaConfig) ollamaConfig.style.display = 'block';
        } else if (selectedProvider === 'openai') {
            const openaiConfig = document.getElementById('openai-config');
            if (openaiConfig) openaiConfig.style.display = 'block';
        }

        // Update setup state
        this.setupState.selectedProvider = selectedProvider;
        this.setupState.providerSelected = selectedProvider !== '';
        this.updateIndexNowButton();
    }

    private updateIndexNowButton(): void {
        const indexNowBtn = document.getElementById('index-now-btn') as any;
        if (indexNowBtn) {
            indexNowBtn.disabled = !(this.setupState.databaseReady && this.setupState.providerSelected);
        }
    }

    private updateSetupStatus(message: string, type: 'info' | 'success' | 'error'): void {
        const statusElement = document.getElementById('setup-status');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.className = `setup-status ${type}`;
        }
    }

    private startSetupIndexing(): void {
        const config = {
            databaseType: this.setupState.databaseType,
            databaseConnection: (document.getElementById('database-connection') as any)?.value || 'http://localhost:6333',
            embeddingProvider: this.setupState.selectedProvider,
            embeddingModel: this.getSelectedEmbeddingModel()
        };

        vscodeApi.postMessage({
            command: 'startSetupIndexing',
            config: config
        });

        this.updateSetupStatus('Starting indexing process...', 'info');
    }

    private getSelectedEmbeddingModel(): string {
        if (this.setupState.selectedProvider === 'ollama') {
            const modelSelect = document.getElementById('ollama-model') as HTMLSelectElement;
            return modelSelect?.value || 'nomic-embed-text';
        } else if (this.setupState.selectedProvider === 'openai') {
            return 'text-embedding-ada-002';
        }
        return '';
    }

    private handleDatabaseStatusUpdate(data: any): void {
        const statusElement = document.getElementById('database-status');
        if (statusElement) {
            const statusDot = statusElement.querySelector('.status-dot');
            const statusText = statusElement.querySelector('span:last-child');

            if (statusDot && statusText) {
                if (data.status === 'running') {
                    statusDot.className = 'status-dot status-running';
                    statusText.textContent = 'Running';
                    this.setupState.databaseReady = true;
                } else {
                    statusDot.className = 'status-dot status-stopped';
                    statusText.textContent = 'Stopped';
                    this.setupState.databaseReady = false;
                }

                this.updateIndexNowButton();
            }
        }
    }
}

// Initialize the webview when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new CodeContextWebview();
});
</file>

<file path=".gitignore">
.codersinflow
.vscode
node_modules
.env
.venv
.codex
out
dist
*.vsix
.claude
CLAUDE.md
.DS_Store
.git
*.log
*.tmp
__pycache__
*.pyc
.env.local
.next
.github

.repomix-output.xml

# Database storage directories
qdrant_storage/
ollama_data/
</file>

<file path="README.md">
# Code Context Engine

AI-powered code context and search extension for VS Code.

## Development Setup

### Prerequisites
- Node.js 16.x or higher
- VS Code

### Installation
1. Clone the repository
2. Install dependencies:
   ```bash
   npm install
   cd webview && npm install
   ```

### Building
1. Build the extension:
   ```bash
   npm run compile
   ```

2. Build the webview:
   ```bash
   cd webview && npm run build
   ```

### Testing the Extension

1. Open this project in VS Code
2. Press `F5` to launch the Extension Development Host
3. In the new VS Code window, open the Command Palette (`Cmd+Shift+P` on Mac, `Ctrl+Shift+P` on Windows/Linux)
4. Run the command: "Open Code Context Panel"
5. The webview should open with the Code Context Engine interface

### Features Implemented

#### Sprint 1: VS Code Extension Boilerplate & UI Setup 
-  VS Code Extension boilerplate with TypeScript
-  Webview integration with Fluent UI components
-  Basic UI with Index Now button and progress indicators
-  VS Code theme integration (light/dark mode support)
-  Message passing between extension and webview
-  Mock search functionality
-  Settings integration

#### Sprint 2: AST Parser & Code Chunking 
-  Tree-sitter integration for TypeScript, JavaScript, Python, and C#
-  FileWalker service for discovering and filtering code files
-  AstParser service for parsing code into Abstract Syntax Trees
-  Chunker service for breaking ASTs into meaningful code segments
-  IndexingService orchestrating the complete indexing pipeline
-  Real-time progress reporting during indexing
-  Support for .gitignore patterns and common ignore rules
-  Comprehensive error handling and recovery

#### Sprint 3: Vectorization & DB Integration 
-  Qdrant vector database integration with Docker Compose setup
-  QdrantService for collection management and vector operations
-  IEmbeddingProvider interface for pluggable embedding providers
-  OllamaProvider for local embedding generation (nomic-embed-text)
-  OpenAIProvider for cloud-based embeddings (text-embedding-ada-002)
-  Complete vectorization pipeline integrated into IndexingService
-  Semantic search functionality with similarity scoring
-  Automatic collection creation and batch vector storage
-  Real-time search through indexed code with VS Code integration

#### Sprint 4: Context Query API 
-  ContextService for advanced query logic and file operations
-  File content retrieval with related chunks discovery
-  Related files discovery with similarity-based ranking
-  Advanced context queries with filtering and metadata
-  Comprehensive webview message handling and API routing
-  TypeScript API client with request/response management
-  Enhanced UI with service status, related files, and file preview
-  Real-time service health monitoring and status display
-  Modal file content viewer with syntax highlighting

#### Sprint 5: Settings UI & Configuration 
-  Comprehensive configuration schema with 12+ settings
-  Settings command registration and webview panel
-  Complete settings UI with provider selection and testing
-  Settings API handlers for get/save/reset operations
-  Connection testing for Qdrant and embedding providers
-  Configuration-driven service initialization
-  Real-time settings validation and error handling
-  Secure API key storage in VS Code settings
-  Advanced options for batch sizes, thresholds, and patterns

#### Sprint 6: LSP Integration & DevOps 
-  LSP service integration with VS Code language servers
-  Enhanced code chunks with semantic metadata (symbols, definitions, references)
-  Automatic LSP data enrichment during indexing process
-  Comprehensive GitHub Actions CI/CD pipeline
-  Multi-Node.js version testing (18.x, 20.x)
-  Automated VSIX packaging and artifact generation
-  Security scanning and code quality checks
-  Docker services integration for testing with Qdrant
-  Release automation with GitHub releases

### Commands Available

- `code-context-engine.openMainPanel` - Opens the main Code Context Engine panel
- `code-context-engine.startIndexing` - Starts repository indexing (placeholder implementation)

### Configuration

The extension contributes the following settings:

- `code-context-engine.embeddingProvider` - Choose between "ollama" and "openai"
- `code-context-engine.databaseConnectionString` - Qdrant database connection string
- `code-context-engine.openaiApiKey` - OpenAI API key (stored securely)

## Next Steps

This completes Sprint 1. The next sprints will implement:

- Sprint 2: AST parsing and code chunking with tree-sitter
- Sprint 3: Vectorization and Qdrant database integration
- Sprint 4: Context query API
- Sprint 5: Settings UI
- Sprint 6: LSP integration and DevOps
- Sprint 7: Documentation and marketplace publishing

## Project Structure

```
 src/
    extension.ts          # Main extension logic
    indexing/
       fileWalker.ts    # File discovery and filtering service
       indexingService.ts # Main indexing orchestrator
    parsing/
       astParser.ts     # AST parsing with tree-sitter
       chunker.ts       # Code chunking service
    db/
       qdrantService.ts # Vector database operations
    embeddings/
       embeddingProvider.ts # Embedding provider interface
       ollamaProvider.ts    # Local Ollama embeddings
       openaiProvider.ts    # OpenAI embeddings
    context/
       contextService.ts    # Advanced context queries and file operations
    types/
        tree-sitter-languages.d.ts # Type declarations
 webview/
    src/
       index.ts         # Webview TypeScript entry point
       index.html       # Webview HTML template
       styles.css       # Webview styles with VS Code theme integration
       lib/
           vscodeApi.ts # VS Code API client wrapper
    dist/                # Built webview files
    package.json         # Webview dependencies
 out/                     # Compiled extension files
 docker-compose.yml       # Qdrant database setup
 package.json             # Extension manifest and dependencies
 tsconfig.json           # TypeScript configuration
```
</file>

<file path="src/extension.ts">
/**
 * Code Context Engine Extension
 * 
 * This extension provides AI-powered code context and search capabilities for VS Code workspaces.
 * It creates a webview panel that allows users to index their repository and search through code.
 */

import * as vscode from 'vscode'; // Import VS Code extension API
import * as path from 'path'; // Import Node.js path module for file path operations
import { IndexingService, IndexingProgress, IndexingResult } from './indexing/indexingService'; // Import our indexing service
import { ContextService, ContextQuery, FileContentResult, RelatedFile } from './context/contextService'; // Import context service
import { ExtensionManager } from './extensionManager'; // Import extension manager

// Simple HTML sanitizer to prevent XSS attacks
function sanitizeHtml(html: string): string {
    // Remove potentially dangerous tags and attributes
    return html
        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // Remove script tags
        .replace(/javascript:/gi, '') // Remove javascript: protocol
        .replace(/on\w+\s*=/gi, '') // Remove event handlers (onclick, onload, etc.)
        .replace(/<script>/gi, '') // Remove encoded script tags
        .replace(/<\/script>/gi, '');
}

// Function to safely escape HTML content
function escapeHtml(unsafe: string): string {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

// Function to validate and sanitize user input
function sanitizeUserInput(input: any): string {
    if (typeof input !== 'string') {
        return '';
    }
    // Remove potentially dangerous characters
    return escapeHtml(input.trim());
}

// Function to validate file paths to prevent path traversal attacks
function validateFilePath(filePath: string): boolean {
    if (typeof filePath !== 'string') {
        return false;
    }
    
    // Check for path traversal attempts
    if (filePath.includes('..') || filePath.includes('~') || filePath.includes('/') || filePath.includes('\\')) {
        return false;
    }
    
    // Check for potentially dangerous characters
    const dangerousChars = /[<>:"|?*]/;
    if (dangerousChars.test(filePath)) {
        return false;
    }
    
    return true;
}

// Function to validate search queries to prevent injection attacks
function validateSearchQuery(query: string): boolean {
    if (typeof query !== 'string') {
        return false;
    }
    
    // Check for potentially dangerous patterns
    const dangerousPatterns = [
        /<script/i,
        /javascript:/i,
        /on\w+\s*=/i,
        /eval\s*\(/i,
        /document\./i,
        /window\./i,
        /alert\s*\(/i
    ];
    
    for (const pattern of dangerousPatterns) {
        if (pattern.test(query)) {
            return false;
        }
    }
    
    return true;
}

// Function to validate database connection strings
function validateConnectionString(connectionString: string): boolean {
    if (typeof connectionString !== 'string') {
        return false;
    }
    
    // Basic URL validation for HTTP/HTTPS
    const urlPattern = /^https?:\/\/.+$/;
    if (!urlPattern.test(connectionString)) {
        return false;
    }
    
    // Check for potentially dangerous characters
    const dangerousChars = /[>"'&|;`$]/;
    if (dangerousChars.test(connectionString)) {
        return false;
    }
    
    return true;
}

// Function to validate API keys
function validateApiKey(apiKey: string): boolean {
    if (typeof apiKey !== 'string') {
        return false;
    }
    
    // Basic API key validation - should be alphanumeric with some special chars
    const apiKeyPattern = /^[a-zA-Z0-9\-_\.~]+$/;
    return apiKeyPattern.test(apiKey) && apiKey.length > 0;
}

// Function to validate docker commands
function validateDockerCommand(action: string): boolean {
    const allowedActions = ['pull', 'logs', 'restart', 'start', 'stop'];
    return allowedActions.includes(action);
}

/**
 * Extension State Manager
 *
 * Singleton pattern to manage global state and prevent memory leaks
 */
class ExtensionStateManager {
    private static instance: ExtensionStateManager;
    private currentPanel: vscode.WebviewPanel | undefined = undefined;
    private extensionManager: ExtensionManager | undefined = undefined;
    private disposables: vscode.Disposable[] = [];

    private constructor() {}

    public static getInstance(): ExtensionStateManager {
        if (!ExtensionStateManager.instance) {
            ExtensionStateManager.instance = new ExtensionStateManager();
        }
        return ExtensionStateManager.instance;
    }

    public setCurrentPanel(panel: vscode.WebviewPanel | undefined): void {
        // Clean up previous panel if it exists
        if (this.currentPanel && this.currentPanel !== panel) {
            this.currentPanel.dispose();
        }
        this.currentPanel = panel;
    }

    public getCurrentPanel(): vscode.WebviewPanel | undefined {
        return this.currentPanel;
    }

    public setExtensionManager(manager: ExtensionManager | undefined): void {
        this.extensionManager = manager;
    }

    public getExtensionManager(): ExtensionManager | undefined {
        return this.extensionManager;
    }

    public addDisposable(disposable: vscode.Disposable): void {
        this.disposables.push(disposable);
    }

    public dispose(): void {
        // Clean up all disposables
        this.disposables.forEach(disposable => {
            if (disposable) {
                disposable.dispose();
            }
        });
        this.disposables = [];

        // Clean up webview panel
        if (this.currentPanel) {
            this.currentPanel.dispose();
            this.currentPanel = undefined;
        }

        // Clean up extension manager
        if (this.extensionManager) {
            this.extensionManager.dispose();
            this.extensionManager = undefined;
        }
    }
}

// Get the singleton instance
const extensionState = ExtensionStateManager.getInstance();

// Global variable to track if extension is in degraded mode
let isDegradedMode: boolean = false;



/**
 * Extension activation point
 * 
 * This function is called when the extension is activated.
 * It registers all commands and sets up event handlers.
 * 
 * @param context - The extension context provided by VS Code
 */
export async function activate(context: vscode.ExtensionContext) {
    console.log('Congratulations, your extension "code-context-engine" is now active!');

    // Initialize ExtensionManager and all services
    try {
        const manager = new ExtensionManager(context);
        await manager.initialize();
        extensionState.setExtensionManager(manager);
        console.log('ExtensionManager initialized successfully');

        // All commands are now registered through the ExtensionManager's CommandManager
        // No need for additional command registration here

    } catch (error) {
        console.error('Failed to initialize ExtensionManager:', error);
        vscode.window.showErrorMessage('Code Context Engine failed to initialize. Please check the logs.');
        throw error; // Don't continue in degraded mode for now
    }
}

    // Register command to open the main webview panel
    let openPanelDisposable = vscode.commands.registerCommand('code-context-engine.openMainPanel', () => {
        // If panel already exists, bring it to focus
        const existingPanel = extensionState.getCurrentPanel();
        if (existingPanel) {
            existingPanel.reveal(vscode.ViewColumn.One);
        } else {
            // Otherwise, create a new panel
            const newPanel = vscode.window.createWebviewPanel(
                'codeContextEngine', // Unique identifier for the panel
                'Code Context Engine', // Title displayed in the UI
                vscode.ViewColumn.One, // Show in the first column of the editor
                {
                    enableScripts: true, // Enable JavaScript in the webview
                    retainContextWhenHidden: true, // Keep the webview state when hidden
                    localResourceRoots: [
                        // Restrict the webview to only load resources from the dist directory
                        vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
                    ]
                }
            );

            // Set the HTML content for the webview using the helper function
            newPanel.webview.html = getWebviewContent(newPanel.webview, context.extensionPath, isDegradedMode);

            // Context service is now managed by ExtensionManager
            // No need to initialize it here

            // Handle messages sent from the webview to the extension
            newPanel.webview.onDidReceiveMessage(
                async message => {
                    switch (message.command) {
                        case 'startIndexing':
                            // When user clicks "Index Repository" button in the webview
                            if (!isDegradedMode && extensionManager) {
                                vscode.commands.executeCommand('code-context-engine.startIndexing');
                            } else {
                                if (currentPanel) {
                                    currentPanel.webview.postMessage({
                                        command: 'serviceStatusResult',
                                        error: 'Indexing not available in degraded mode'
                                    });
                                }
                            }
                            return;
                        case 'search':
                            // When user performs a search in the webview
                            if (currentPanel) {
                                if (!isDegradedMode && extensionManager) {
                                    await handleSearch(message.query, currentPanel.webview);
                                } else {
                                    currentPanel.webview.postMessage({
                                        command: 'searchResults',
                                        results: [],
                                        error: 'Search not available in degraded mode'
                                    });
                                }
                            }
                            return;
                        case 'getFileContent':
                            // Get file content with optional related chunks
                            if (currentPanel) {
                                if (!isDegradedMode && extensionManager) {
                                    await handleGetFileContent(message, currentPanel.webview);
                                } else {
                                    currentPanel.webview.postMessage({
                                        command: 'fileContentResult',
                                        requestId: message.requestId,
                                        error: 'File content retrieval not available in degraded mode'
                                    });
                                }
                            }
                            return;
                        case 'findRelatedFiles':
                            // Find files related to a query
                            if (currentPanel) {
                                if (!isDegradedMode && extensionManager) {
                                    await handleFindRelatedFiles(message, currentPanel.webview);
                                } else {
                                    currentPanel.webview.postMessage({
                                        command: 'relatedFilesResult',
                                        requestId: message.requestId,
                                        error: 'Related files search not available in degraded mode'
                                    });
                                }
                            }
                            return;
                        case 'queryContext':
                            // Advanced context query
                            if (currentPanel) {
                                if (!isDegradedMode && extensionManager) {
                                    await handleQueryContext(message, currentPanel.webview);
                                } else {
                                    currentPanel.webview.postMessage({
                                        command: 'contextQueryResult',
                                        requestId: message.requestId,
                                        error: 'Context query not available in degraded mode'
                                    });
                                }
                            }
                            return;
                        case 'getServiceStatus':
                            // Get service status
                            if (currentPanel) {
                                if (!isDegradedMode && extensionManager) {
                                    await handleGetServiceStatus(currentPanel.webview);
                                } else {
                                    currentPanel.webview.postMessage({
                                        command: 'serviceStatusResult',
                                        result: {
                                            status: 'degraded',
                                            message: 'Extension running in degraded mode - some services unavailable',
                                            services: {
                                                indexing: false,
                                                search: false,
                                                context: false
                                            }
                                        }
                                    });
                                }
                            }
                            return;
                        case 'checkSetupStatus':
                            // Check workspace setup status
                            if (newPanel) {
                                await handleCheckSetupStatus(message, newPanel.webview);
                            }
                            return;
                        case 'startDatabase':
                            // Start database from setup UI
                            if (newPanel) {
                                await handleStartDatabase(message.databaseType, newPanel.webview);
                            }
                            return;
                        case 'checkDatabaseStatus':
                            // Check database status from setup UI
                            if (newPanel) {
                                await handleCheckDatabaseStatus(message.databaseType, newPanel.webview);
                            }
                            return;
                        case 'startSetupIndexing':
                            // Start indexing from setup UI
                            if (newPanel) {
                                await handleStartSetupIndexing(message.config, newPanel.webview);
                            }
                            return;
                        case 'openSettings':
                            // When user clicks "Open Settings" button in the webview
                            vscode.commands.executeCommand('workbench.action.openSettings', 'code-context-engine');
                            return;
                    }
                },
                undefined,
                context.subscriptions // Add to subscriptions for proper disposal
            );

            // Clean up resources when the panel is closed
            newPanel.onDidDispose(
                () => {
                    // Reset the panel reference when it's closed
                    extensionState.setCurrentPanel(undefined);
                },
                null,
                context.subscriptions // Add to subscriptions for proper disposal
            );

            // Store the panel in the state manager
            extensionState.setCurrentPanel(newPanel);
        }
    });

    // Register command to start the repository indexing process
    let indexingDisposable = vscode.commands.registerCommand('code-context-engine.startIndexing', async () => {
        // Check if there's an open workspace folder to index
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders && workspaceFolders.length > 0) {
            const workspaceRoot = workspaceFolders[0].uri.fsPath;
            if (isDegradedMode) {
                vscode.window.showErrorMessage('Indexing not available - extension in degraded mode');
                return;
            }
            if (!extensionManager) {
                vscode.window.showErrorMessage('Extension manager not initialized');
                return;
            }
            const indexingService = extensionManager.getIndexingService();
            if (!indexingService) {
                vscode.window.showErrorMessage('Indexing service not available');
                return;
            }

            // Show progress notification while indexing is in progress
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification, // Show in notification area
                title: "Indexing Repository",
                cancellable: true // Allow user to cancel the operation
            }, async (progress, token) => {
                try {
                    // Start the indexing process with progress updates
                    const result: IndexingResult = await indexingService.startIndexing((indexingProgress: IndexingProgress) => {
                        if (token.isCancellationRequested) {
                            return; // Stop processing if cancelled
                        }

                        // Update the progress notification
                        const percentage = indexingProgress.totalFiles > 0
                            ? Math.round((indexingProgress.processedFiles / indexingProgress.totalFiles) * 100)
                            : 0;

                        progress.report({
                            message: `${indexingProgress.currentPhase}: ${indexingProgress.currentFile ? path.basename(indexingProgress.currentFile) : ''} (${indexingProgress.processedFiles}/${indexingProgress.totalFiles})`,
                            increment: percentage
                        });

                        // Send progress updates to the webview if it's open
                        const panel = extensionState.getCurrentPanel();
                        if (panel) {
                            panel.webview.postMessage({
                                command: 'indexingProgress',
                                progress: indexingProgress
                            });
                        }
                    });

                    // Show completion message if the operation wasn't cancelled
                    if (!token.isCancellationRequested) {
                        const message = result.success
                            ? `Indexing complete! Processed ${result.processedFiles} files, created ${result.chunks.length} chunks in ${Math.round(result.duration / 1000)}s`
                            : `Indexing failed with ${result.errors.length} errors`;

                        if (result.success) {
                            vscode.window.showInformationMessage(message);
                        } else {
                            vscode.window.showErrorMessage(message);
                        }

                        // Send completion message to webview
                        const panel = extensionState.getCurrentPanel();
                        if (panel) {
                            panel.webview.postMessage({
                                command: 'indexingComplete',
                                result: result
                            });
                        }
                    }
                } catch (error) {
                    const errorMessage = `Indexing failed: ${error instanceof Error ? error.message : String(error)}`;
                    vscode.window.showErrorMessage(errorMessage);
                    console.error(errorMessage);
                }
            });
        } else {
            // Show error if no workspace is open
            vscode.window.showErrorMessage("Please open a folder or workspace to index.");
        }
    });

    // Register command to open the settings panel
    let openSettingsDisposable = vscode.commands.registerCommand('code-context-engine.openSettings', () => {
        createSettingsPanel(context);
    });

    // Register command to setup the project
    let setupDisposable = vscode.commands.registerCommand('code-context-engine.setupProject', () => {
        createSetupPanel(context);
    });

    // Add all disposables to the extension context's subscriptions
    // This ensures they get properly cleaned up when the extension is deactivated
    context.subscriptions.push(openPanelDisposable, indexingDisposable, openSettingsDisposable, setupDisposable);
}

/**
 * Handle search requests from the webview
 * 
 * Processes search queries from the user and returns results.
 * Currently implements mock functionality that will be replaced with actual search in future sprints.
 * 
 * @param query - The search query string entered by the user
 * @param webview - The webview instance to send results back to
 */
async function handleSearch(query: string, webview: vscode.Webview) {
    try {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            webview.postMessage({
                command: 'searchResults',
                results: [],
                error: 'No workspace folder open'
            });
            return;
        }

        const workspaceRoot = workspaceFolders[0].uri.fsPath;
        const manager = extensionState.getExtensionManager();
        if (!manager) {
            throw new Error('Extension manager not initialized');
        }
        const indexingService = manager.getIndexingService();
        if (!indexingService) {
            throw new Error('IndexingService not available');
        }

        // Check if Qdrant is available
        const isQdrantAvailable = await indexingService.isQdrantAvailable();
        if (!isQdrantAvailable) {
            webview.postMessage({
                command: 'searchResults',
                results: [],
                error: 'Vector database not available. Please ensure Qdrant is running.'
            });
            return;
        }

        // Perform the search
        const searchResults = await indexingService.searchCode(query, 10);

        // Convert search results to the format expected by the webview
        const formattedResults = searchResults.map(result => ({
            file: result.payload.filePath,
            snippet: result.payload.content.substring(0, 200) + (result.payload.content.length > 200 ? '...' : ''),
            line: result.payload.startLine,
            score: result.score,
            type: result.payload.type,
            name: result.payload.name,
            language: result.payload.language
        }));

        webview.postMessage({
            command: 'searchResults',
            results: formattedResults
        });
    } catch (error) {
        console.error('Search error:', error);
        webview.postMessage({
            command: 'searchResults',
            results: [],
            error: `Search failed: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle file content requests from the webview
 */
async function handleGetFileContent(message: any, webview: vscode.Webview) {
    try {
        const manager = extensionState.getExtensionManager();
        if (!manager) {
            throw new Error('Extension manager not initialized');
        }

        const contextService = manager.getContextService();
        if (!contextService) {
            throw new Error('Context service not available');
        }

        const { filePath, includeRelatedChunks = false } = message;
        const result = await contextService.getFileContent(filePath, includeRelatedChunks);

        webview.postMessage({
            command: 'fileContentResult',
            requestId: message.requestId,
            result: result
        });
    } catch (error) {
        console.error('Get file content error:', error);
        webview.postMessage({
            command: 'fileContentResult',
            requestId: message.requestId,
            error: `Failed to get file content: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle related files requests from the webview
 */
async function handleFindRelatedFiles(message: any, webview: vscode.Webview) {
    try {
        const manager = extensionState.getExtensionManager();
        if (!manager) {
            throw new Error('Extension manager not initialized');
        }

        const contextService = manager.getContextService();
        if (!contextService) {
            throw new Error('Context service not available');
        }

        const { query, currentFilePath, maxResults = 10, minSimilarity = 0.5 } = message;
        const result = await contextService.findRelatedFiles(query, currentFilePath, maxResults, minSimilarity);

        webview.postMessage({
            command: 'relatedFilesResult',
            requestId: message.requestId,
            result: result
        });
    } catch (error) {
        console.error('Find related files error:', error);
        webview.postMessage({
            command: 'relatedFilesResult',
            requestId: message.requestId,
            error: `Failed to find related files: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle context query requests from the webview
 */
async function handleQueryContext(message: any, webview: vscode.Webview) {
    try {
        const manager = extensionState.getExtensionManager();
        if (!manager) {
            throw new Error('Extension manager not initialized');
        }

        const contextService = manager.getContextService();
        if (!contextService) {
            throw new Error('Context service not available');
        }

        const contextQuery: ContextQuery = message.contextQuery;
        const result = await contextService.queryContext(contextQuery);

        webview.postMessage({
            command: 'contextQueryResult',
            requestId: message.requestId,
            result: result
        });
    } catch (error) {
        console.error('Context query error:', error);
        webview.postMessage({
            command: 'contextQueryResult',
            requestId: message.requestId,
            error: `Context query failed: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle service status requests from the webview
 */
async function handleGetServiceStatus(webview: vscode.Webview) {
    try {
        const manager = extensionState.getExtensionManager();
        if (!manager) {
            throw new Error('Extension manager not initialized');
        }

        const contextService = manager.getContextService();
        if (!contextService) {
            throw new Error('Context service not available');
        }

        const status = await contextService.getStatus();

        webview.postMessage({
            command: 'serviceStatusResult',
            result: status
        });
    } catch (error) {
        console.error('Get service status error:', error);
        webview.postMessage({
            command: 'serviceStatusResult',
            error: `Failed to get service status: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Create and configure the settings webview panel
 */
function createSettingsPanel(context: vscode.ExtensionContext) {
    // Create a new webview panel for settings
    const settingsPanel = vscode.window.createWebviewPanel(
        'codeContextEngineSettings',
        'Code Context Engine - Settings',
        vscode.ViewColumn.One,
        {
            enableScripts: true,
            retainContextWhenHidden: true,
            localResourceRoots: [
                vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
            ]
        }
    );

    // Set the HTML content for the settings panel
    settingsPanel.webview.html = getSettingsWebviewContent(context, settingsPanel.webview);

    // Handle messages from the settings webview
    settingsPanel.webview.onDidReceiveMessage(
        async message => {
            switch (message.command) {
                case 'getSettings':
                    await handleGetSettings(settingsPanel.webview);
                    return;
                case 'saveSettings':
                    await handleSaveSettings(message.settings, settingsPanel.webview);
                    return;
                case 'resetSettings':
                    await handleResetSettings(settingsPanel.webview);
                    return;
                case 'testConnection':
                    await handleTestConnection(message.provider, settingsPanel.webview);
                    return;
            }
        },
        undefined,
        context.subscriptions
    );

    // Clean up when panel is disposed
    settingsPanel.onDidDispose(
        () => {
            // Settings panel disposed
        },
        null,
        context.subscriptions
    );
}

/**
 * Handle get settings requests from the settings webview
 */
async function handleGetSettings(webview: vscode.Webview) {
    try {
        const config = vscode.workspace.getConfiguration('code-context-engine');
        const settings = {
            embeddingProvider: config.get('embeddingProvider'),
            databaseConnectionString: config.get('databaseConnectionString'),
            openaiApiKey: config.get('openaiApiKey'),
            ollamaModel: config.get('ollamaModel'),
            openaiModel: config.get('openaiModel'),
            maxSearchResults: config.get('maxSearchResults'),
            minSimilarityThreshold: config.get('minSimilarityThreshold'),
            autoIndexOnStartup: config.get('autoIndexOnStartup'),
            indexingBatchSize: config.get('indexingBatchSize'),
            enableDebugLogging: config.get('enableDebugLogging'),
            excludePatterns: config.get('excludePatterns'),
            supportedLanguages: config.get('supportedLanguages')
        };

        webview.postMessage({
            command: 'settingsLoaded',
            settings: settings
        });
    } catch (error) {
        console.error('Failed to get settings:', error);
        webview.postMessage({
            command: 'settingsError',
            error: `Failed to load settings: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle save settings requests from the settings webview
 */
async function handleSaveSettings(settings: any, webview: vscode.Webview) {
    try {
        const config = vscode.workspace.getConfiguration('code-context-engine');

        // Save each setting
        await config.update('embeddingProvider', settings.embeddingProvider, vscode.ConfigurationTarget.Global);
        await config.update('databaseConnectionString', settings.databaseConnectionString, vscode.ConfigurationTarget.Global);
        await config.update('openaiApiKey', settings.openaiApiKey, vscode.ConfigurationTarget.Global);
        await config.update('ollamaModel', settings.ollamaModel, vscode.ConfigurationTarget.Global);
        await config.update('openaiModel', settings.openaiModel, vscode.ConfigurationTarget.Global);
        await config.update('maxSearchResults', settings.maxSearchResults, vscode.ConfigurationTarget.Global);
        await config.update('minSimilarityThreshold', settings.minSimilarityThreshold, vscode.ConfigurationTarget.Global);
        await config.update('autoIndexOnStartup', settings.autoIndexOnStartup, vscode.ConfigurationTarget.Global);
        await config.update('indexingBatchSize', settings.indexingBatchSize, vscode.ConfigurationTarget.Global);
        await config.update('enableDebugLogging', settings.enableDebugLogging, vscode.ConfigurationTarget.Global);
        await config.update('excludePatterns', settings.excludePatterns, vscode.ConfigurationTarget.Global);
        await config.update('supportedLanguages', settings.supportedLanguages, vscode.ConfigurationTarget.Global);

        webview.postMessage({
            command: 'settingsSaved',
            success: true
        });

        vscode.window.showInformationMessage('Settings saved successfully!');
    } catch (error) {
        console.error('Failed to save settings:', error);
        webview.postMessage({
            command: 'settingsError',
            error: `Failed to save settings: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle reset settings requests from the settings webview
 */
async function handleResetSettings(webview: vscode.Webview) {
    try {
        const config = vscode.workspace.getConfiguration('code-context-engine');

        // Reset to default values
        await config.update('embeddingProvider', undefined, vscode.ConfigurationTarget.Global);
        await config.update('databaseConnectionString', undefined, vscode.ConfigurationTarget.Global);
        await config.update('openaiApiKey', undefined, vscode.ConfigurationTarget.Global);
        await config.update('ollamaModel', undefined, vscode.ConfigurationTarget.Global);
        await config.update('openaiModel', undefined, vscode.ConfigurationTarget.Global);
        await config.update('maxSearchResults', undefined, vscode.ConfigurationTarget.Global);
        await config.update('minSimilarityThreshold', undefined, vscode.ConfigurationTarget.Global);
        await config.update('autoIndexOnStartup', undefined, vscode.ConfigurationTarget.Global);
        await config.update('indexingBatchSize', undefined, vscode.ConfigurationTarget.Global);
        await config.update('enableDebugLogging', undefined, vscode.ConfigurationTarget.Global);
        await config.update('excludePatterns', undefined, vscode.ConfigurationTarget.Global);
        await config.update('supportedLanguages', undefined, vscode.ConfigurationTarget.Global);

        // Send back the default settings
        await handleGetSettings(webview);

        vscode.window.showInformationMessage('Settings reset to defaults!');
    } catch (error) {
        console.error('Failed to reset settings:', error);
        webview.postMessage({
            command: 'settingsError',
            error: `Failed to reset settings: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle test connection requests from the settings webview
 */
async function handleTestConnection(provider: string, webview: vscode.Webview) {
    try {
        if (provider === 'qdrant') {
            // Test Qdrant connection
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const connectionString = config.get<string>('databaseConnectionString') || 'http://localhost:6333';

            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (workspaceFolders && workspaceFolders.length > 0) {
                const manager = extensionState.getExtensionManager();
                if (!manager) {
                    throw new Error('ExtensionManager not available');
                }
                const indexingService = manager.getIndexingService();
                if (!indexingService) {
                    throw new Error('IndexingService not available');
                }
                const isAvailable = await indexingService.isQdrantAvailable();

                webview.postMessage({
                    command: 'connectionTestResult',
                    provider: 'qdrant',
                    success: isAvailable,
                    message: isAvailable ? 'Qdrant connection successful!' : 'Failed to connect to Qdrant database'
                });
            }
        } else if (provider === 'embedding') {
            // Test embedding provider
            const config = vscode.workspace.getConfiguration('code-context-engine');
            const embeddingProvider = config.get<string>('embeddingProvider') || 'ollama';

            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (workspaceFolders && workspaceFolders.length > 0) {
                const manager = extensionState.getExtensionManager();
                if (!manager) {
                    throw new Error('ExtensionManager not available');
                }
                const contextService = manager.getContextService();
                if (!contextService) {
                    throw new Error('ContextService not available');
                }
                const isReady = await contextService.isReady();

                webview.postMessage({
                    command: 'connectionTestResult',
                    provider: 'embedding',
                    success: isReady,
                    message: isReady ? `${embeddingProvider} provider is ready!` : `Failed to connect to ${embeddingProvider} provider`
                });
            }
        }
    } catch (error) {
        console.error('Connection test failed:', error);
        webview.postMessage({
            command: 'connectionTestResult',
            provider: provider,
            success: false,
            message: `Connection test failed: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Generate the HTML content for the webview panel
 * 
 * Creates the UI for the extension's main panel, including repository indexing,
 * search functionality, and settings access.
 * 
 * @param webview - The webview instance to generate content for
 * @param extensionPath - The file system path to the extension
 * @returns HTML content as a string
 */
function getWebviewContent(webview: vscode.Webview, extensionPath: string, isDegradedMode: boolean = false): string {
    // Get the URIs for the built JavaScript bundle file
    // This converts the local file path to a URI that the webview can access
    const scriptUri = webview.asWebviewUri(vscode.Uri.file(path.join(extensionPath, 'webview', 'dist', 'bundle.js')));

    // Sanitize the HTML template to prevent XSS
    const htmlTemplate = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Context Engine</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .header {
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
        }
        .progress-section {
            display: none;
        }
        .progress-section.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Code Context Engine</h1>
            <p>AI-powered code context and search for your workspace</p>
        </div>

        <div class="section">
            <h2>Repository Indexing</h2>
            <p>Index your repository to enable AI-powered code search and context analysis.</p>

            <div id="service-status" style="margin-bottom: 15px;">
                <!-- Service status will be populated here -->
            </div>

            ${isDegradedMode ?
                `<div style="background-color: var(--vscode-editorError-foreground); color: var(--vscode-editor-background); padding: 10px; border-radius: 4px; margin-bottom: 15px;">
                    <strong>Extension in Degraded Mode</strong><br>
                    Some services are unavailable. Please restart VS Code to restore full functionality.
                </div>` :
                `<fluent-button id="index-button" appearance="accent">Index Repository</fluent-button>`
            }

            <div id="progress-section" class="progress-section">
                <h3>Indexing Progress</h3>
                <fluent-progress-ring id="progress-ring"></fluent-progress-ring>
                <p id="progress-text">Starting indexing process...</p>
            </div>
        </div>

        <div class="section">
            <h2>Search & Context</h2>
            <p>Search through your indexed code and get AI-powered context.</p>
            <fluent-text-field id="search-input" placeholder="Search your code..." style="width: 100%; margin-bottom: 10px;"></fluent-text-field>
            <fluent-button id="search-button">Search</fluent-button>

            <div id="search-results" style="margin-top: 20px;">
                <!-- Search results will be displayed here -->
            </div>

            <div id="related-files" style="margin-top: 20px;">
                <!-- Related files will be displayed here -->
            </div>
        </div>

        <div class="section">
            <h2>Settings</h2>
            <p>Configure your Code Context Engine preferences.</p>
            <fluent-button id="settings-button" appearance="stealth">Open Settings</fluent-button>
        </div>
    </div>

    <script src="${scriptUri}"></script>
</body>
</html>`;

    return sanitizeHtml(htmlTemplate);
}

/**
 * Generate the HTML content for the settings webview panel
 */
function getSettingsWebviewContent(context: vscode.ExtensionContext, webview: vscode.Webview): string {
    // Sanitize the HTML template to prevent XSS
    const htmlTemplate = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Context Engine - Settings</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            font-size: var(--vscode-font-size);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            margin: 0;
            padding: 20px;
        }
        .settings-container {
            max-width: 800px;
            margin: 0 auto;
        }
        .setting-group {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 8px;
            background-color: var(--vscode-editor-background);
        }
        .setting-group h3 {
            margin-top: 0;
            color: var(--vscode-textLink-foreground);
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 10px;
        }
        .setting-item {
            margin-bottom: 15px;
        }
        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .setting-item input, .setting-item select, .setting-item textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--vscode-input-border);
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border-radius: 4px;
            font-family: inherit;
            font-size: inherit;
        }
        .setting-item input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }
        .setting-item .description {
            font-size: 0.9em;
            color: var(--vscode-descriptionForeground);
            margin-top: 5px;
        }
        .button-group {
            margin-top: 30px;
            text-align: center;
        }
        .button {
            padding: 10px 20px;
            margin: 0 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: inherit;
        }
        .button-primary {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
        }
        .button-secondary {
            background-color: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
        }
        .button:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="settings-container">
        <h1>Code Context Engine Settings</h1>

        <div class="setting-group">
            <h3>Embedding Provider</h3>
            <div class="setting-item">
                <label for="embeddingProvider">Provider:</label>
                <select id="embeddingProvider">
                    <option value="ollama">Ollama (Local)</option>
                    <option value="openai">OpenAI (Cloud)</option>
                </select>
                <div class="description">Choose between local Ollama or cloud-based OpenAI for generating embeddings</div>
            </div>

            <div class="setting-item" id="ollamaSettings">
                <label for="ollamaModel">Ollama Model:</label>
                <select id="ollamaModel">
                    <option value="nomic-embed-text">nomic-embed-text (768 dimensions)</option>
                    <option value="all-minilm">all-minilm (384 dimensions)</option>
                    <option value="mxbai-embed-large">mxbai-embed-large (1024 dimensions)</option>
                </select>
                <div class="description">Select the Ollama model for embedding generation</div>
            </div>

            <div class="setting-item" id="openaiSettings" style="display: none;">
                <label for="openaiApiKey">OpenAI API Key:</label>
                <input type="password" id="openaiApiKey" placeholder="sk-...">
                <div class="description">Your OpenAI API key (stored securely in VS Code settings)</div>

                <label for="openaiModel" style="margin-top: 15px;">OpenAI Model:</label>
                <select id="openaiModel">
                    <option value="text-embedding-ada-002">text-embedding-ada-002 (1536 dimensions)</option>
                    <option value="text-embedding-3-small">text-embedding-3-small (1536 dimensions)</option>
                    <option value="text-embedding-3-large">text-embedding-3-large (3072 dimensions)</option>
                </select>
            </div>

            <button class="button button-secondary" onclick="testEmbeddingConnection()">Test Connection</button>
        </div>

        <div class="setting-group">
            <h3>Vector Database</h3>
            <div class="setting-item">
                <label for="databaseConnectionString">Qdrant Connection String:</label>
                <input type="text" id="databaseConnectionString" placeholder="http://localhost:6333">
                <div class="description">URL for your Qdrant vector database instance</div>
            </div>
            <button class="button button-secondary" onclick="testDatabaseConnection()">Test Connection</button>
        </div>

        <div class="button-group">
            <button class="button button-primary" onclick="saveSettings()">Save Settings</button>
            <button class="button button-secondary" onclick="resetSettings()">Reset to Defaults</button>
        </div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();

        // Load settings when page loads
        window.addEventListener('load', () => {
            vscode.postMessage({ command: 'getSettings' });
        });

        // Handle provider selection
        document.getElementById('embeddingProvider').addEventListener('change', (e) => {
            const provider = e.target.value;
            document.getElementById('ollamaSettings').style.display = provider === 'ollama' ? 'block' : 'none';
            document.getElementById('openaiSettings').style.display = provider === 'openai' ? 'block' : 'none';
        });

        // Handle messages from extension
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'settingsLoaded':
                    loadSettings(message.settings);
                    break;
                case 'settingsSaved':
                    if (message.success) {
                        alert('Settings saved successfully!');
                    }
                    break;
                case 'settingsError':
                    alert('Error: ' + message.error);
                    break;
                case 'connectionTestResult':
                    showConnectionResult(message);
                    break;
            }
        });

        function loadSettings(settings) {
            document.getElementById('embeddingProvider').value = settings.embeddingProvider || 'ollama';
            document.getElementById('databaseConnectionString').value = settings.databaseConnectionString || 'http://localhost:6333';
            document.getElementById('openaiApiKey').value = settings.openaiApiKey || '';
            document.getElementById('ollamaModel').value = settings.ollamaModel || 'nomic-embed-text';
            document.getElementById('openaiModel').value = settings.openaiModel || 'text-embedding-ada-002';

            // Trigger provider change to show/hide sections
            document.getElementById('embeddingProvider').dispatchEvent(new Event('change'));
        }

        function saveSettings() {
            const settings = {
                embeddingProvider: document.getElementById('embeddingProvider').value,
                databaseConnectionString: document.getElementById('databaseConnectionString').value,
                openaiApiKey: document.getElementById('openaiApiKey').value,
                ollamaModel: document.getElementById('ollamaModel').value,
                openaiModel: document.getElementById('openaiModel').value
            };

            vscode.postMessage({ command: 'saveSettings', settings });
        }

        function resetSettings() {
            if (confirm('Are you sure you want to reset all settings to their default values?')) {
                vscode.postMessage({ command: 'resetSettings' });
            }
        }

        function testDatabaseConnection() {
            vscode.postMessage({ command: 'testConnection', provider: 'qdrant' });
        }

        function testEmbeddingConnection() {
            vscode.postMessage({ command: 'testConnection', provider: 'embedding' });
        }

        function showConnectionResult(result) {
            const message = result.success ?
                \` \${result.message}\` :
                \` \${result.message}\`;
            alert(message);
        }
    </script>
</body>
</html>`;

    return sanitizeHtml(htmlTemplate);
}

/**
 * Check if the workspace is configured and set context accordingly
 */
async function checkWorkspaceConfiguration(context: vscode.ExtensionContext) {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
        // No workspace open
        await vscode.commands.executeCommand('setContext', 'code-context.isConfigured', false);
        return;
    }

    try {
        // Look for code-context.json in the workspace root
        const configFiles = await vscode.workspace.findFiles('code-context.json', null, 1);
        const isConfigured = configFiles.length > 0;

        await vscode.commands.executeCommand('setContext', 'code-context.isConfigured', isConfigured);

        if (!isConfigured) {
            // Show welcome message for unconfigured workspace
            vscode.window.showInformationMessage(
                'Welcome to Code Context Engine! This workspace hasn\'t been indexed yet.',
                'Setup Project'
            ).then(selection => {
                if (selection === 'Setup Project') {
                    vscode.commands.executeCommand('code-context-engine.setupProject');
                }
            });
        }
    } catch (error) {
        console.error('Failed to check workspace configuration:', error);
        await vscode.commands.executeCommand('setContext', 'code-context.isConfigured', false);
    }
}

/**
 * Create and configure the setup webview panel
 */
function createSetupPanel(context: vscode.ExtensionContext) {
    // Create a new webview panel for setup
    const setupPanel = vscode.window.createWebviewPanel(
        'codeContextEngineSetup',
        'Code Context Engine - Setup',
        vscode.ViewColumn.One,
        {
            enableScripts: true,
            retainContextWhenHidden: true,
            localResourceRoots: [
                vscode.Uri.file(path.join(context.extensionPath, 'webview', 'dist'))
            ]
        }
    );

    // Set the HTML content for the setup panel
    setupPanel.webview.html = getSetupWebviewContent(context, setupPanel.webview);

    // Handle messages from the setup webview
    setupPanel.webview.onDidReceiveMessage(
        async message => {
            switch (message.command) {
                case 'startDatabase':
                    await handleStartDatabase(message.databaseType, setupPanel.webview);
                    return;
                case 'checkDatabaseStatus':
                    await handleCheckDatabaseStatus(message.databaseType, setupPanel.webview);
                    return;
                case 'saveConfiguration':
                    await handleSaveConfiguration(message.config, setupPanel.webview);
                    return;
                case 'startIndexing':
                    await handleStartIndexingFromSetup(message.config, setupPanel.webview);
                    return;
                case 'stopDatabase':
                    await handleStopDatabase(message.databaseType, setupPanel.webview);
                    return;
                case 'openDatabaseUI':
                    await handleOpenDatabaseUI(message.connectionString, setupPanel.webview);
                    return;
                case 'runDockerCommand':
                    await handleRunDockerCommand(message.action, setupPanel.webview);
                    return;
            }
        },
        undefined,
        context.subscriptions
    );

    // Clean up when panel is disposed
    setupPanel.onDidDispose(
        () => {
            // Setup panel disposed
        },
        null,
        context.subscriptions
    );
}

/**
 * Handle stop database command from setup panel
 */
async function handleStopDatabase(databaseType: string, webview: vscode.Webview) {
    try {
        if (databaseType === 'qdrant') {
            // Create a new terminal and stop the Qdrant container
            const terminal = vscode.window.createTerminal('Stop Qdrant');
            terminal.sendText('docker stop $(docker ps -q --filter ancestor=qdrant/qdrant)');
            terminal.show();

            webview.postMessage({
                command: 'databaseStopped',
                databaseType: 'qdrant',
                message: 'Stopping Qdrant database...'
            });

            // Wait a moment and check status
            setTimeout(async () => {
                await handleCheckDatabaseStatus('qdrant', webview);
            }, 3000);
        }
    } catch (error) {
        console.error('Failed to stop database:', error);
        webview.postMessage({
            command: 'databaseError',
            error: `Failed to stop ${databaseType}: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle open database UI command from setup panel
 */
async function handleOpenDatabaseUI(connectionString: string, webview: vscode.Webview) {
    try {
        // Extract the base URL and open the Qdrant dashboard
        const url = new URL(connectionString);
        const dashboardUrl = `${url.protocol}//${url.host}/dashboard`;

        await vscode.env.openExternal(vscode.Uri.parse(dashboardUrl));

        webview.postMessage({
            command: 'databaseUIOpened',
            message: 'Qdrant dashboard opened in browser'
        });
    } catch (error) {
        console.error('Failed to open database UI:', error);
        webview.postMessage({
            command: 'databaseError',
            error: `Failed to open database UI: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle run docker command from setup panel
 */
// Helper function to safely execute shell commands
async function executeCommand(command: string): Promise<string> {
    // Validate command to prevent injection
    const dangerousPatterns = [
        /;\s*rm\s+-rf/i,
        /;\s*sudo\s+rm/i,
        /;\s*del\s+/i,
        /;\s*rmdir/i,
        /;\s*format/i,
        /;\s*shutdown/i,
        /;\s*reboot/i,
        /;\s*cd\s+/i,
        /;\s*export/i,
        /;\s*source/i,
        /&&\s*rm/i,
        /\|\s*rm/i,
        /\|\s*sudo/i
    ];

    for (const pattern of dangerousPatterns) {
        if (pattern.test(command)) {
            throw new Error('Potentially dangerous command detected');
        }
    }

    // Use VS Code's terminal API for safer execution
    return new Promise((resolve, reject) => {
        const terminal = vscode.window.createTerminal('Command Execution');
        terminal.show();

        // Send the command and capture output
        terminal.sendText(command);

        // For simplicity, we'll just return a success message
        // In a real implementation, you'd want to capture the actual output
        setTimeout(() => {
            terminal.dispose();
            resolve('Command executed successfully');
        }, 1000);
    });
}

async function handleRunDockerCommand(action: string, webview: vscode.Webview) {
    try {
        // Validate docker command action
        if (!validateDockerCommand(action)) {
            webview.postMessage({
                command: 'dockerError',
                error: 'Invalid docker command: potentially dangerous action detected'
            });
            return;
        }

        const terminal = vscode.window.createTerminal(`Docker ${action}`);
        let command = '';

        switch (action) {
            case 'pull':
                command = 'docker pull qdrant/qdrant:latest';
                break;
            case 'logs':
                command = 'docker logs $(docker ps -q --filter ancestor=qdrant/qdrant)';
                break;
            case 'restart':
                command = 'docker restart $(docker ps -q --filter ancestor=qdrant/qdrant)';
                break;
            default:
                throw new Error(`Unknown docker action: ${action}`);
        }

        terminal.sendText(command);
        terminal.show();

        webview.postMessage({
            command: 'dockerCommandExecuted',
            action: action,
            message: `Docker ${action} command executed`
        });
    } catch (error) {
        console.error('Failed to run docker command:', error);
        webview.postMessage({
            command: 'dockerError',
            error: `Failed to run docker ${action}: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Generate the HTML content for the setup webview panel
 */
function getSetupWebviewContent(context: vscode.ExtensionContext, webview: vscode.Webview): string {
    // Sanitize the HTML template to prevent XSS
    const htmlTemplate = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Context Engine - Setup</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            font-size: var(--vscode-font-size);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            margin: 0;
            padding: 20px;
        }
        .setup-container {
            max-width: 800px;
            margin: 0 auto;
        }
        .setup-step {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 8px;
            background-color: var(--vscode-editor-background);
        }
        .setup-step h3 {
            margin-top: 0;
            color: var(--vscode-textLink-foreground);
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 10px;
        }
        .setup-item {
            margin-bottom: 15px;
        }
        .setup-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .setup-item input, .setup-item select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--vscode-input-border);
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border-radius: 4px;
            font-family: inherit;
            font-size: inherit;
        }
        .setup-item .description {
            font-size: 0.9em;
            color: var(--vscode-descriptionForeground);
            margin-top: 5px;
        }
        .button-group {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: inherit;
        }
        .button-primary {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
        }
        .button-secondary {
            background-color: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
        }
        .button:hover {
            opacity: 0.8;
        }
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-running { background-color: #4CAF50; }
        .status-stopped { background-color: #f44336; }
        .status-unknown { background-color: #ff9800; }
        .welcome-section {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: var(--vscode-textCodeBlock-background);
            border-radius: 8px;
        }
        .final-step {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            background: var(--vscode-textCodeBlock-background);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="setup-container">
        <div class="welcome-section">
            <h1>Welcome to Code Context Engine!</h1>
            <p>Let's set up your workspace for AI-powered code search and context discovery.</p>
            <p>This setup will help you configure the database and embedding provider needed to index your code.</p>
        </div>

        <div class="setup-step">
            <h3>Step 1: Vector Database Configuration</h3>
            <div class="setup-item">
                <label for="databaseType">Database Type:</label>
                <select id="databaseType">
                    <option value="qdrant">Qdrant (Recommended)</option>
                </select>
                <div class="description">Qdrant is a high-performance vector database for storing code embeddings</div>
            </div>

            <div class="setup-item">
                <label for="databaseConnectionString">Connection String:</label>
                <input type="text" id="databaseConnectionString" value="http://localhost:6333" placeholder="http://localhost:6333">
                <div class="description">URL for your Qdrant database instance</div>
            </div>

            <div class="button-group">
                <button class="button button-secondary" onclick="startDatabase()">Start Local Qdrant</button>
                <button class="button button-secondary" onclick="stopDatabase()">Stop Database</button>
                <button class="button button-secondary" onclick="checkDatabaseStatus()">Check Status</button>
                <button class="button button-secondary" onclick="openDatabaseUI()">Open Qdrant UI</button>
                <span id="databaseStatus">
                    <span class="status-indicator status-unknown"></span>
                    <span>Status unknown</span>
                </span>
            </div>

            <div class="setup-item">
                <label>Docker Commands:</label>
                <div class="description">Quick commands to manage your Qdrant database</div>
                <div class="button-group">
                    <button class="button button-secondary" onclick="runDockerCommand('pull')">Pull Latest Image</button>
                    <button class="button button-secondary" onclick="runDockerCommand('logs')">View Logs</button>
                    <button class="button button-secondary" onclick="runDockerCommand('restart')">Restart Container</button>
                </div>
            </div>
        </div>

        <div class="setup-step">
            <h3>Step 2: Embedding Provider Configuration</h3>
            <div class="setup-item">
                <label for="embeddingProvider">Provider:</label>
                <select id="embeddingProvider" onchange="toggleProviderSettings()">
                    <option value="ollama">Ollama (Local)</option>
                    <option value="openai">OpenAI (Cloud)</option>
                </select>
                <div class="description">Choose between local Ollama or cloud-based OpenAI for generating embeddings</div>
            </div>

            <div class="setup-item" id="ollamaSettings">
                <label for="ollamaModel">Ollama Model:</label>
                <select id="ollamaModel">
                    <option value="nomic-embed-text">nomic-embed-text (768 dimensions)</option>
                    <option value="all-minilm">all-minilm (384 dimensions)</option>
                    <option value="mxbai-embed-large">mxbai-embed-large (1024 dimensions)</option>
                </select>
                <div class="description">Select the Ollama model for embedding generation</div>
            </div>

            <div class="setup-item" id="openaiSettings" style="display: none;">
                <label for="openaiApiKey">OpenAI API Key:</label>
                <input type="password" id="openaiApiKey" placeholder="sk-...">
                <div class="description">Your OpenAI API key (will be stored securely in VS Code settings)</div>
            </div>
        </div>

        <div class="final-step">
            <h3>Ready to Index Your Workspace?</h3>
            <p>Once you've configured the database and embedding provider, click below to save your configuration and start indexing.</p>
            <div class="button-group" style="justify-content: center;">
                <button class="button button-secondary" onclick="saveConfiguration()">Save Configuration</button>
                <button class="button button-primary" onclick="startIndexing()" id="indexButton" disabled>Save & Start Indexing</button>
            </div>
            <div id="setupStatus" style="margin-top: 15px;"></div>
            <div id="progressContainer" style="display: none; margin-top: 20px;">
                <h4>Indexing Progress</h4>
                <div class="progress-bar-container" style="width: 100%; background-color: var(--vscode-progressBar-background); border-radius: 4px; overflow: hidden;">
                    <div id="progressBar" style="height: 20px; background-color: var(--vscode-progressBar-foreground); width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="progressText" style="margin-top: 10px; font-size: 0.9em;"></div>
                <div id="progressDetails" style="margin-top: 10px; font-size: 0.8em; color: var(--vscode-descriptionForeground);"></div>
            </div>
        </div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();

        function toggleProviderSettings() {
            const provider = document.getElementById('embeddingProvider').value;
            document.getElementById('ollamaSettings').style.display = provider === 'ollama' ? 'block' : 'none';
            document.getElementById('openaiSettings').style.display = provider === 'openai' ? 'block' : 'none';
        }

        function startDatabase() {
            const databaseType = document.getElementById('databaseType').value;
            vscode.postMessage({
                command: 'startDatabase',
                databaseType: databaseType
            });
        }

        function checkDatabaseStatus() {
            const databaseType = document.getElementById('databaseType').value;
            vscode.postMessage({
                command: 'checkDatabaseStatus',
                databaseType: databaseType
            });
        }

        function stopDatabase() {
            const databaseType = document.getElementById('databaseType').value;
            vscode.postMessage({
                command: 'stopDatabase',
                databaseType: databaseType
            });
        }

        function openDatabaseUI() {
            const connectionString = document.getElementById('databaseConnectionString').value;
            vscode.postMessage({
                command: 'openDatabaseUI',
                connectionString: connectionString
            });
        }

        function runDockerCommand(action) {
            vscode.postMessage({
                command: 'runDockerCommand',
                action: action
            });
        }

        function saveConfiguration() {
            const config = getConfiguration();
            vscode.postMessage({
                command: 'saveConfiguration',
                config: config
            });
        }

        function startIndexing() {
            const config = getConfiguration();
            vscode.postMessage({
                command: 'startIndexing',
                config: config
            });
        }

        function getConfiguration() {
            return {
                databaseType: document.getElementById('databaseType').value,
                databaseConnectionString: document.getElementById('databaseConnectionString').value,
                embeddingProvider: document.getElementById('embeddingProvider').value,
                embeddingModel: document.getElementById('embeddingProvider').value === 'ollama'
                    ? document.getElementById('ollamaModel').value
                    : 'text-embedding-ada-002',
                openaiApiKey: document.getElementById('openaiApiKey').value
            };
        }

        // Handle messages from extension
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'databaseStarted':
                    updateStatus('Database is starting...', 'info');
                    break;
                case 'databaseStatus':
                    updateDatabaseStatus(message.status, message.message);
                    break;
                case 'databaseError':
                    updateStatus(message.error, 'error');
                    break;
                case 'configurationSaved':
                    updateStatus('Configuration saved successfully!', 'success');
                    document.getElementById('indexButton').disabled = false;
                    break;
                case 'configurationError':
                    updateStatus(message.error, 'error');
                    break;
                case 'indexingStarted':
                    updateStatus('Indexing started...', 'info');
                    showProgressContainer(true);
                    break;
                case 'indexingProgress':
                    updateProgress(message.progress);
                    break;
                case 'indexingComplete':
                    updateStatus('Indexing completed successfully!', 'success');
                    showProgressContainer(false);
                    break;
                case 'indexingError':
                    updateStatus(message.error, 'error');
                    break;
                case 'databaseStopped':
                    updateStatus('Database stopped', 'info');
                    break;
                case 'databaseUIOpened':
                    updateStatus(message.message, 'success');
                    break;
                case 'dockerCommandExecuted':
                    updateStatus(message.message, 'success');
                    break;
                case 'dockerError':
                    updateStatus(message.error, 'error');
                    break;
            }
        });

        function updateDatabaseStatus(status, message) {
            const statusElement = document.getElementById('databaseStatus');
            const indicator = statusElement.querySelector('.status-indicator');
            const text = statusElement.querySelector('span:last-child');

            indicator.className = 'status-indicator status-' + status;
            text.textContent = message;

            // Enable indexing button if database is running
            if (status === 'running') {
                document.getElementById('indexButton').disabled = false;
            }
        }

        function updateStatus(message, type) {
            const statusElement = document.getElementById('setupStatus');
            const color = type === 'error' ? 'var(--vscode-errorForeground)' :
                         type === 'success' ? 'var(--vscode-textLink-foreground)' :
                         'var(--vscode-foreground)';
            statusElement.innerHTML = \`<p style="color: \${color};">\${message}</p>\`;
        }

        function showProgressContainer(show) {
            const container = document.getElementById('progressContainer');
            container.style.display = show ? 'block' : 'none';
            if (!show) {
                // Reset progress
                document.getElementById('progressBar').style.width = '0%';
                document.getElementById('progressText').textContent = '';
                document.getElementById('progressDetails').textContent = '';
            }
        }

        function updateProgress(progress) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressDetails = document.getElementById('progressDetails');

            // Calculate percentage
            const percentage = progress.totalFiles > 0 ?
                Math.round((progress.processedFiles / progress.totalFiles) * 100) : 0;

            progressBar.style.width = percentage + '%';
            progressText.textContent = \`\${percentage}% - \${progress.message}\`;
            progressDetails.textContent = \`Files: \${progress.processedFiles}/\${progress.totalFiles} | Chunks: \${progress.totalChunks || 0} | Errors: \${progress.errors || 0}\`;
        }

        // Check database status on load
        window.addEventListener('load', () => {
            checkDatabaseStatus();
        });
    </script>
</body>
</html>`;

    return sanitizeHtml(htmlTemplate);
}

/**
 * Handle check setup status command
 */
async function handleCheckSetupStatus(message: any, webview: vscode.Webview) {
    try {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            webview.postMessage({
                command: 'checkSetupStatusResponse',
                requestId: message.requestId,
                result: {
                    isConfigured: false,
                    hasConfigFile: false,
                    databaseConfigured: false,
                    embeddingConfigured: false
                }
            });
            return;
        }

        // Check for code-context.json file
        const configPath = path.join(workspaceFolders[0].uri.fsPath, 'code-context.json');
        let hasConfigFile = false;
        let isConfigured = false;
        let databaseConfigured = false;
        let embeddingConfigured = false;

        try {
            await vscode.workspace.fs.stat(vscode.Uri.file(configPath));
            hasConfigFile = true;

            // Read and parse config file
            const configData = await vscode.workspace.fs.readFile(vscode.Uri.file(configPath));
            const config = JSON.parse(configData.toString());

            databaseConfigured = !!(config.database && config.database.type);
            embeddingConfigured = !!(config.embedding && config.embedding.provider);
            isConfigured = databaseConfigured && embeddingConfigured;
        } catch (error) {
            // Config file doesn't exist or is invalid
            hasConfigFile = false;
        }

        webview.postMessage({
            command: 'checkSetupStatusResponse',
            requestId: message.requestId,
            result: {
                isConfigured,
                hasConfigFile,
                databaseConfigured,
                embeddingConfigured
            }
        });
    } catch (error) {
        console.error('Failed to check setup status:', error);
        webview.postMessage({
            command: 'checkSetupStatusResponse',
            requestId: message.requestId,
            error: `Failed to check setup status: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle start setup indexing command
 */
async function handleStartSetupIndexing(config: any, webview: vscode.Webview) {
    try {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            throw new Error('No workspace folder open');
        }

        // Save configuration to code-context.json
        const configPath = path.join(workspaceFolders[0].uri.fsPath, 'code-context.json');
        const configContent = {
            version: '1.0',
            database: {
                type: config.databaseType || 'qdrant',
                connectionString: config.databaseConnection || 'http://localhost:6333'
            },
            embedding: {
                provider: config.embeddingProvider || 'ollama',
                model: config.embeddingModel || 'nomic-embed-text'
            },
            indexing: {
                excludePatterns: ['**/node_modules/**', '**/dist/**', '**/build/**'],
                supportedLanguages: ['typescript', 'javascript', 'python', 'csharp']
            },
            createdAt: new Date().toISOString()
        };

        await vscode.workspace.fs.writeFile(
            vscode.Uri.file(configPath),
            Buffer.from(JSON.stringify(configContent, null, 2))
        );

        // Update VS Code settings
        const vsCodeConfig = vscode.workspace.getConfiguration('code-context-engine');
        await vsCodeConfig.update('embeddingProvider', config.embeddingProvider, vscode.ConfigurationTarget.Workspace);
        await vsCodeConfig.update('databaseConnectionString', config.databaseConnection, vscode.ConfigurationTarget.Workspace);

        // Start indexing
        const manager = extensionState.getExtensionManager();
        if (!manager) {
            throw new Error('Extension manager not initialized');
        }
        const indexingService = manager.getIndexingService();
        if (!indexingService) {
            throw new Error('IndexingService not available');
        }

        webview.postMessage({
            command: 'setupIndexingStarted',
            message: 'Configuration saved and indexing started!'
        });

        // Start indexing with progress updates
        const result = await indexingService.startIndexing((progress: IndexingProgress) => {
            webview.postMessage({
                command: 'setupIndexingProgress',
                progress: progress
            });
        });

        webview.postMessage({
            command: 'setupIndexingComplete',
            result: result,
            message: 'Setup and indexing completed successfully!'
        });

        vscode.window.showInformationMessage('Workspace setup and indexing completed successfully!');
    } catch (error) {
        console.error('Failed to start setup indexing:', error);
        webview.postMessage({
            command: 'setupIndexingError',
            error: `Failed to start setup indexing: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle start database command from setup panel
 */
async function handleStartDatabase(databaseType: string, webview: vscode.Webview) {
    try {
        if (databaseType === 'qdrant') {
            // Create a new terminal and run docker-compose up for Qdrant
            const terminal = vscode.window.createTerminal('Qdrant Database');
            terminal.sendText('docker run -p 6333:6333 qdrant/qdrant:latest');
            terminal.show();

            webview.postMessage({
                command: 'databaseStarted',
                databaseType: 'qdrant',
                message: 'Qdrant database is starting...'
            });

            // Wait a moment and check status
            setTimeout(async () => {
                await handleCheckDatabaseStatus('qdrant', webview);
            }, 5000);
        }
    } catch (error) {
        console.error('Failed to start database:', error);
        webview.postMessage({
            command: 'databaseError',
            error: `Failed to start ${databaseType}: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle check database status command from setup panel
 */
async function handleCheckDatabaseStatus(databaseType: string, webview: vscode.Webview) {
    try {
        if (databaseType === 'qdrant') {
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (workspaceFolders && workspaceFolders.length > 0) {
                const manager = extensionState.getExtensionManager();
                if (!manager) {
                    throw new Error('ExtensionManager not available');
                }
                const indexingService = manager.getIndexingService();
                if (!indexingService) {
                    throw new Error('IndexingService not available');
                }
                const isAvailable = await indexingService.isQdrantAvailable();

                webview.postMessage({
                    command: 'databaseStatus',
                    databaseType: 'qdrant',
                    status: isAvailable ? 'running' : 'stopped',
                    message: isAvailable ? 'Qdrant is running and accessible' : 'Qdrant is not accessible'
                });
            }
        }
    } catch (error) {
        console.error('Failed to check database status:', error);
        webview.postMessage({
            command: 'databaseStatus',
            databaseType: databaseType,
            status: 'error',
            message: `Failed to check status: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle save configuration command from setup panel
 */
async function handleSaveConfiguration(config: any, webview: vscode.Webview) {
    try {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            throw new Error('No workspace folder open');
        }

        const configPath = path.join(workspaceFolders[0].uri.fsPath, 'code-context.json');
        const configContent = {
            version: '1.0',
            database: {
                type: config.databaseType || 'qdrant',
                connectionString: config.databaseConnectionString || 'http://localhost:6333'
            },
            embedding: {
                provider: config.embeddingProvider || 'ollama',
                model: config.embeddingModel || 'nomic-embed-text'
            },
            indexing: {
                excludePatterns: config.excludePatterns || ['**/node_modules/**', '**/dist/**', '**/build/**'],
                supportedLanguages: config.supportedLanguages || ['typescript', 'javascript', 'python', 'csharp']
            },
            createdAt: new Date().toISOString()
        };

        await vscode.workspace.fs.writeFile(
            vscode.Uri.file(configPath),
            Buffer.from(JSON.stringify(configContent, null, 2))
        );

        // Update context
        await vscode.commands.executeCommand('setContext', 'code-context.isConfigured', true);

        webview.postMessage({
            command: 'configurationSaved',
            success: true,
            message: 'Configuration saved successfully!'
        });

        vscode.window.showInformationMessage('Code Context configuration saved successfully!');
    } catch (error) {
        console.error('Failed to save configuration:', error);
        webview.postMessage({
            command: 'configurationError',
            error: `Failed to save configuration: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Handle start indexing command from setup panel
 */
async function handleStartIndexingFromSetup(config: any, webview: vscode.Webview) {
    try {
        // First save the configuration
        await handleSaveConfiguration(config, webview);

        // Then start indexing
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            throw new Error('No workspace folder open');
        }

        const manager = extensionState.getExtensionManager();
        if (!manager) {
            throw new Error('Extension manager not initialized');
        }
        const indexingService = manager.getIndexingService();
        if (!indexingService) {
            throw new Error('IndexingService not available');
        }

        webview.postMessage({
            command: 'indexingStarted',
            message: 'Starting indexing process...'
        });

        // Start indexing with progress updates
        const result = await indexingService.startIndexing((progress: IndexingProgress) => {
            webview.postMessage({
                command: 'indexingProgress',
                progress: progress
            });
        });

        webview.postMessage({
            command: 'indexingComplete',
            result: result,
            message: 'Indexing completed successfully!'
        });

        vscode.window.showInformationMessage('Workspace indexing completed successfully!');
    } catch (error) {
        console.error('Failed to start indexing:', error);
        webview.postMessage({
            command: 'indexingError',
            error: `Failed to start indexing: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

/**
 * Extension deactivation point
 *
 * This function is called when the extension is deactivated.
 * Properly disposes of the ExtensionManager and all its resources.
 */
export function deactivate() {
    // Use the state manager to clean up all resources
    extensionState.dispose();
}
</file>

<file path="package.json">
{
  "name": "code-context-engine",
  "displayName": "Code Context Engine",
  "description": "AI-powered code context and search extension for VS Code",
  "version": "0.0.1",
  "publisher": "bramburn",
  "engines": {
    "vscode": "^1.74.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/bramburn/bigcontext.git"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onCommand:code-context-engine.openMainPanel",
    "onCommand:code-context-engine.startIndexing",
    "onCommand:code-context-engine.setupProject"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "code-context-engine.openMainPanel",
        "title": "Open Code Context Panel",
        "category": "Code Context"
      },
      {
        "command": "code-context-engine.startIndexing",
        "title": "Index Repository",
        "category": "Code Context"
      },
      {
        "command": "code-context-engine.setupProject",
        "title": "Setup Project",
        "category": "Code Context"
      }
    ],
    "configuration": {
      "title": "Code Context Engine",
      "properties": {
        "code-context-engine.embeddingProvider": {
          "type": "string",
          "default": "ollama",
          "enum": [
            "ollama",
            "openai"
          ],
          "description": "Embedding provider to use for vectorization",
          "enumDescriptions": [
            "Local Ollama embedding service (free, private)",
            "OpenAI embedding service (requires API key)"
          ]
        },
        "code-context-engine.databaseConnectionString": {
          "type": "string",
          "default": "http://localhost:6333",
          "description": "Qdrant vector database connection string",
          "pattern": "^https?://.*:\\d+$",
          "patternErrorMessage": "Must be a valid HTTP/HTTPS URL with port (e.g., http://localhost:6333)"
        },
        "code-context-engine.openaiApiKey": {
          "type": "string",
          "default": "",
          "description": "OpenAI API key for embedding generation (stored securely in VS Code settings)"
        },
        "code-context-engine.ollamaModel": {
          "type": "string",
          "default": "nomic-embed-text",
          "description": "Ollama model to use for embeddings",
          "enum": [
            "nomic-embed-text",
            "all-minilm",
            "mxbai-embed-large"
          ],
          "enumDescriptions": [
            "Nomic Embed Text (768 dimensions, recommended)",
            "All-MiniLM (384 dimensions, faster)",
            "MxBai Embed Large (1024 dimensions, more accurate)"
          ]
        },
        "code-context-engine.openaiModel": {
          "type": "string",
          "default": "text-embedding-ada-002",
          "description": "OpenAI model to use for embeddings",
          "enum": [
            "text-embedding-ada-002",
            "text-embedding-3-small",
            "text-embedding-3-large"
          ],
          "enumDescriptions": [
            "Ada-002 (1536 dimensions, cost-effective)",
            "Embedding-3-Small (1536 dimensions, improved performance)",
            "Embedding-3-Large (3072 dimensions, highest quality)"
          ]
        },
        "code-context-engine.maxSearchResults": {
          "type": "number",
          "default": 20,
          "minimum": 1,
          "maximum": 100,
          "description": "Maximum number of search results to return"
        },
        "code-context-engine.minSimilarityThreshold": {
          "type": "number",
          "default": 0.5,
          "minimum": 0,
          "maximum": 1,
          "description": "Minimum similarity threshold for search results (0.0 to 1.0)"
        },
        "code-context-engine.autoIndexOnStartup": {
          "type": "boolean",
          "default": false,
          "description": "Automatically start indexing when workspace is opened"
        },
        "code-context-engine.indexingBatchSize": {
          "type": "number",
          "default": 100,
          "minimum": 10,
          "maximum": 1000,
          "description": "Number of code chunks to process in each batch during indexing"
        },
        "code-context-engine.enableDebugLogging": {
          "type": "boolean",
          "default": false,
          "description": "Enable detailed debug logging for troubleshooting"
        },
        "code-context-engine.excludePatterns": {
          "type": "array",
          "default": [
            "**/node_modules/**",
            "**/dist/**",
            "**/build/**",
            "**/.git/**",
            "**/coverage/**"
          ],
          "items": {
            "type": "string"
          },
          "description": "File patterns to exclude from indexing (in addition to .gitignore)"
        },
        "code-context-engine.supportedLanguages": {
          "type": "array",
          "default": [
            "typescript",
            "javascript",
            "python",
            "csharp"
          ],
          "items": {
            "type": "string",
            "enum": [
              "typescript",
              "javascript",
              "python",
              "csharp"
            ]
          },
          "description": "Programming languages to include in indexing"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile && npm run build-webview",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "pretest": "npm run compile && npm run lint",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js",
    "build-webview": "cd webview && npm run build",
    "package": "vsce package --no-dependencies",
    "publish": "vsce publish --no-dependencies",
    "clean": "rimraf out *.vsix",
    "dev": "npm run watch"
  },
  "devDependencies": {
    "@types/mocha": "^10.0.10",
    "@types/node": "16.x",
    "@types/vscode": "^1.74.0",
    "@typescript-eslint/eslint-plugin": "^5.45.0",
    "@typescript-eslint/parser": "^5.45.0",
    "@vscode/test-electron": "^2.5.2",
    "eslint": "^8.28.0",
    "mocha": "^11.7.1",
    "rimraf": "^5.0.10",
    "typescript": "^4.9.4",
    "vsce": "^2.15.0"
  },
  "dependencies": {
    "@qdrant/js-client-rest": "^1.7.0",
    "axios": "^1.6.0",
    "glob": "^8.0.3",
    "ignore": "^5.2.4",
    "tree-sitter": "^0.20.4",
    "tree-sitter-c-sharp": "^0.20.0",
    "tree-sitter-python": "^0.20.4",
    "tree-sitter-typescript": "^0.20.3",
    "vscode-languageclient": "^9.0.1",
    "vscode-languageserver": "^9.0.1"
  }
}
</file>

</files>
