This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/webviewManager.ts, src/messageRouter.ts, src/extension.ts, src/shared/communicationTypes.ts, src/context/contextService.ts, webview/src/**/*.svelte, webview/src/**/*.ts, webview/vite.config.ts, webview/svelte.config.js
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  context/
    contextService.ts
  shared/
    communicationTypes.ts
  extension.ts
  messageRouter.ts
  webviewManager.ts
webview/
  src/
    lib/
      components/
        ConnectionTester.svelte
        DiagnosticsView.svelte
        ErrorBoundary.svelte
        GuidedTour.svelte
        HistoryView.svelte
        IndexingView.svelte
        NoWorkspaceView.svelte
        NoWorkspaceView.test.ts
        QueryView.svelte
        ResultCard.svelte
        SetupView.svelte
        ValidatedInput.svelte
        ValidatedInput.test.ts
        ValidationMessage.svelte
        WorkspaceSelector.svelte
      stores/
        appStore.test.ts
        appStore.ts
        persistence.ts
        viewStore.ts
      utils/
        animations.ts
        connectionTesting.ts
        fluentUI.ts
        performance.ts
        validation.test.ts
        validation.ts
      index.ts
      vscodeApi.ts
    routes/
      +layout.svelte
      +page.svelte
      page.svelte.spec.ts
    test/
      setup.ts
    app.d.ts
    demo.spec.ts
  svelte.config.js
  vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="webview/src/lib/components/ConnectionTester.svelte">
<script lang="ts">
    import { createEventDispatcher } from 'svelte';
    import { registerCoreComponents } from '$lib/utils/fluentUI';
    import { 
        testDatabaseConnection, 
        testProviderConnection,
        type ConnectionTestResult,
        type ConnectionTestStatus,
        type DatabaseTestConfig,
        type ProviderTestConfig
    } from '$lib/utils/connectionTesting';
    import ValidationMessage from './ValidationMessage.svelte';
    import { connectionTestToValidation } from '$lib/utils/connectionTesting';

    // Register Fluent UI components
    registerCoreComponents();

    // Props
    export let type: 'database' | 'provider';
    export let config: DatabaseTestConfig | ProviderTestConfig;
    export let disabled: boolean = false;
    export let autoTest: boolean = false;
    export let showDetails: boolean = true;
    export let compact: boolean = false;

    // State
    let status: ConnectionTestStatus = 'idle';
    let testResult: ConnectionTestResult | null = null;
    let lastTestedConfig: string = '';

    // Event dispatcher
    const dispatch = createEventDispatcher<{
        testStart: void;
        testComplete: { result: ConnectionTestResult };
        testError: { error: string };
    }>();

    // Reactive statements
    $: configString = JSON.stringify(config);
    $: hasConfigChanged = configString !== lastTestedConfig;
    $: canTest = !disabled && config && Object.keys(config).length > 0;
    $: showTestButton = status === 'idle' || status === 'success' || status === 'error';

    // Auto-test when config changes (if enabled)
    $: if (autoTest && hasConfigChanged && canTest && status === 'idle') {
        testConnection();
    }

    /**
     * Test the connection
     */
    async function testConnection(): Promise<void> {
        if (!canTest || status === 'testing') return;

        status = 'testing';
        testResult = null;
        dispatch('testStart');

        try {
            let result: ConnectionTestResult;
            
            if (type === 'database') {
                result = await testDatabaseConnection(config as DatabaseTestConfig);
            } else {
                result = await testProviderConnection(config as ProviderTestConfig);
            }

            testResult = result;
            status = result.success ? 'success' : 'error';
            lastTestedConfig = configString;
            
            dispatch('testComplete', { result });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            testResult = {
                success: false,
                message: `Connection test failed: ${errorMessage}`,
                details: 'Please check your configuration and try again'
            };
            status = 'error';
            
            dispatch('testError', { error: errorMessage });
        }
    }

    /**
     * Reset the test state
     */
    function resetTest(): void {
        status = 'idle';
        testResult = null;
        lastTestedConfig = '';
    }

    /**
     * Get status icon
     */
    function getStatusIcon(currentStatus: ConnectionTestStatus): string {
        switch (currentStatus) {
            case 'testing': return 'üîÑ';
            case 'success': return '‚úÖ';
            case 'error': return '‚ùå';
            default: return 'üîó';
        }
    }

    /**
     * Get status message
     */
    function getStatusMessage(currentStatus: ConnectionTestStatus): string {
        switch (currentStatus) {
            case 'testing': return 'Testing connection...';
            case 'success': return 'Connection successful';
            case 'error': return 'Connection failed';
            default: return 'Ready to test';
        }
    }
</script>

<div class="connection-tester" class:compact>
    <div class="tester-header">
        <div class="status-indicator">
            <span class="status-icon">{getStatusIcon(status)}</span>
            <span class="status-text">{getStatusMessage(status)}</span>
        </div>

        {#if showTestButton}
            <fluent-button
                appearance={status === 'success' ? 'outline' : 'accent'}
                disabled={!canTest || disabled}
                on:click={testConnection}
                on:keydown={(e) => e.key === 'Enter' && testConnection()}
                size={compact ? 'small' : 'medium'}
                role="button"
                tabindex="0"
                aria-label="Test connection"
            >
                {#if hasConfigChanged && status !== 'idle'}
                    üîÑ Retest
                {:else if status === 'success'}
                    ‚úì Test Again
                {:else}
                    üîó Test Connection
                {/if}
            </fluent-button>
        {:else if status === 'testing'}
            <div class="testing-indicator">
                <fluent-progress-ring size={compact ? 'small' : 'medium'}></fluent-progress-ring>
                <span class="testing-text">Testing...</span>
            </div>
        {/if}
    </div>

    {#if testResult && showDetails}
        <div class="test-results">
            <ValidationMessage 
                result={connectionTestToValidation(testResult)}
                showIcon={true}
                compact={compact}
                maxMessages={3}
            />

            {#if testResult.success && (testResult.latency || testResult.version)}
                <div class="connection-details">
                    {#if testResult.latency}
                        <div class="detail-item">
                            <span class="detail-label">Latency:</span>
                            <span class="detail-value">{testResult.latency}ms</span>
                        </div>
                    {/if}
                    
                    {#if testResult.version}
                        <div class="detail-item">
                            <span class="detail-label">Version:</span>
                            <span class="detail-value">{testResult.version}</span>
                        </div>
                    {/if}
                </div>
            {/if}
        </div>
    {/if}

    {#if hasConfigChanged && testResult}
        <div class="config-changed-notice">
            <span class="notice-icon">‚ö†Ô∏è</span>
            <span class="notice-text">Configuration has changed. Test again to verify the new settings.</span>
        </div>
    {/if}
</div>

<style>
    .connection-tester {
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        padding: 16px;
        background-color: var(--vscode-textCodeBlock-background);
        margin: 12px 0;
    }

    .connection-tester.compact {
        padding: 12px;
        margin: 8px 0;
    }

    .tester-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
    }

    .compact .tester-header {
        margin-bottom: 8px;
    }

    .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .status-icon {
        font-size: 16px;
    }

    .compact .status-icon {
        font-size: 14px;
    }

    .status-text {
        font-size: 14px;
        font-weight: 500;
        color: var(--vscode-foreground);
    }

    .compact .status-text {
        font-size: 12px;
    }

    .testing-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .testing-text {
        font-size: 13px;
        color: var(--vscode-descriptionForeground);
    }

    .compact .testing-text {
        font-size: 11px;
    }

    .test-results {
        margin-top: 12px;
    }

    .compact .test-results {
        margin-top: 8px;
    }

    .connection-details {
        margin-top: 8px;
        padding: 8px;
        background-color: var(--vscode-editor-background);
        border-radius: 4px;
        border: 1px solid var(--vscode-panel-border);
    }

    .detail-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
        font-size: 12px;
    }

    .detail-item:last-child {
        margin-bottom: 0;
    }

    .detail-label {
        color: var(--vscode-descriptionForeground);
        font-weight: 500;
    }

    .detail-value {
        color: var(--vscode-foreground);
        font-family: var(--vscode-editor-font-family);
    }

    .config-changed-notice {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
        padding: 6px 8px;
        background-color: var(--vscode-inputValidation-warningBackground);
        border: 1px solid var(--vscode-inputValidation-warningBorder);
        border-radius: 4px;
        font-size: 11px;
        color: var(--vscode-inputValidation-warningForeground);
    }

    .notice-icon {
        flex-shrink: 0;
        font-size: 12px;
    }

    .notice-text {
        flex: 1;
        line-height: 1.3;
    }

    /* Animation for status changes */
    .status-indicator {
        transition: all 0.3s ease;
    }

    .testing-indicator {
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    /* Responsive design */
    @media (max-width: 600px) {
        .tester-header {
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
        }

        .status-indicator {
            justify-content: center;
        }

        .connection-details {
            font-size: 11px;
        }
    }
</style>
</file>

<file path="webview/src/lib/components/GuidedTour.svelte">
<script>
    import { createEventDispatcher, onMount } from 'svelte';
    import { postMessage } from '../vscodeApi';

    const dispatch = createEventDispatcher();

    // Tour state
    let showTour = false;
    let currentStep = 0;
    let tourSteps = [];

    // Tour configuration
    const tourConfig = [
        {
            id: 'query-input',
            title: 'Search Your Code',
            content: 'Use this input box to ask questions about your codebase. Try queries like "how does authentication work?" or "find all database connections".',
            target: '#query-input, .query-input, [data-tour="query-input"]',
            position: 'bottom'
        },
        {
            id: 'results-area',
            title: 'View Results',
            content: 'Your search results will appear here. You can click on file paths to open them directly in the editor, or copy code snippets to your clipboard.',
            target: '#results-area, .results-area, [data-tour="results"]',
            position: 'top'
        },
        {
            id: 'settings-button',
            title: 'Configure Settings',
            content: 'Access extension settings and diagnostics here. You can configure your embedding provider, database connection, and indexing preferences.',
            target: '#settings-button, .settings-button, [data-tour="settings"]',
            position: 'left'
        }
    ];

    // Initialize tour
    onMount(() => {
        tourSteps = tourConfig;
    });

    // Public API for starting the tour
    export function startTour() {
        showTour = true;
        currentStep = 0;
        highlightCurrentStep();
    }

    // Public API for stopping the tour
    export function stopTour() {
        showTour = false;
        currentStep = 0;
        removeHighlights();
        dispatch('tourCompleted');
        
        // Notify the extension that the tour is completed
        postMessage('setGlobalState', {
            key: 'hasCompletedFirstRun',
            value: true
        });
    }

    function nextStep() {
        if (currentStep < tourSteps.length - 1) {
            currentStep++;
            highlightCurrentStep();
        } else {
            stopTour();
        }
    }

    function previousStep() {
        if (currentStep > 0) {
            currentStep--;
            highlightCurrentStep();
        }
    }

    function skipTour() {
        stopTour();
    }

    function highlightCurrentStep() {
        // Remove previous highlights
        removeHighlights();
        
        // Add highlight to current step target
        const step = tourSteps[currentStep];
        if (step && step.target) {
            const targetElement = document.querySelector(step.target);
            if (targetElement) {
                targetElement.classList.add('tour-highlight');
                
                // Scroll element into view
                targetElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }
        }
    }

    function removeHighlights() {
        // Remove all tour highlights
        const highlightedElements = document.querySelectorAll('.tour-highlight');
        highlightedElements.forEach(el => el.classList.remove('tour-highlight'));
    }

    // Reactive statement to handle step changes
    $: if (showTour && currentStep >= 0) {
        setTimeout(highlightCurrentStep, 100);
    }

    // Get current step data
    $: currentStepData = tourSteps[currentStep] || {};
</script>

{#if showTour}
    <!-- Tour overlay -->
    <div class="tour-overlay" on:click={skipTour} on:keydown={(e) => e.key === 'Escape' && skipTour()} role="button" tabindex="0">
        <!-- Tour modal -->
        <div class="tour-modal" on:click|stopPropagation role="dialog" aria-modal="true" tabindex="-1">
            <!-- Header -->
            <div class="tour-header">
                <h3 class="tour-title">{currentStepData.title || 'Welcome Tour'}</h3>
                <button class="tour-close" on:click={skipTour} title="Close tour">
                    √ó
                </button>
            </div>

            <!-- Content -->
            <div class="tour-content">
                <p>{currentStepData.content || 'Welcome to Code Context Engine!'}</p>
            </div>

            <!-- Footer -->
            <div class="tour-footer">
                <div class="tour-progress">
                    <span class="tour-step-counter">
                        Step {currentStep + 1} of {tourSteps.length}
                    </span>
                    <div class="tour-progress-bar">
                        <div 
                            class="tour-progress-fill" 
                            style="width: {((currentStep + 1) / tourSteps.length) * 100}%"
                        ></div>
                    </div>
                </div>

                <div class="tour-buttons">
                    <button 
                        class="tour-btn tour-btn-secondary" 
                        on:click={skipTour}
                    >
                        Skip Tour
                    </button>
                    
                    {#if currentStep > 0}
                        <button 
                            class="tour-btn tour-btn-secondary" 
                            on:click={previousStep}
                        >
                            Previous
                        </button>
                    {/if}
                    
                    <button 
                        class="tour-btn tour-btn-primary" 
                        on:click={nextStep}
                    >
                        {currentStep < tourSteps.length - 1 ? 'Next' : 'Finish'}
                    </button>
                </div>
            </div>
        </div>
    </div>
{/if}

<style>
    .tour-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        backdrop-filter: blur(2px);
    }

    .tour-modal {
        background-color: var(--vscode-editor-background);
        border: 1px solid var(--vscode-panel-border);
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 400px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        animation: tourSlideIn 0.3s ease-out;
    }

    @keyframes tourSlideIn {
        from {
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    .tour-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid var(--vscode-panel-border);
        background-color: var(--vscode-titleBar-activeBackground);
    }

    .tour-title {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
        color: var(--vscode-titleBar-activeForeground);
    }

    .tour-close {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: var(--vscode-titleBar-activeForeground);
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background-color 0.2s;
    }

    .tour-close:hover {
        background-color: var(--vscode-titleBar-inactiveBackground);
    }

    .tour-content {
        padding: 20px;
        line-height: 1.5;
        color: var(--vscode-foreground);
    }

    .tour-content p {
        margin: 0;
    }

    .tour-footer {
        padding: 16px 20px;
        border-top: 1px solid var(--vscode-panel-border);
        background-color: var(--vscode-panel-background);
    }

    .tour-progress {
        margin-bottom: 16px;
    }

    .tour-step-counter {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
        margin-bottom: 8px;
        display: block;
    }

    .tour-progress-bar {
        width: 100%;
        height: 4px;
        background-color: var(--vscode-progressBar-background);
        border-radius: 2px;
        overflow: hidden;
    }

    .tour-progress-fill {
        height: 100%;
        background-color: var(--vscode-progressBar-foreground);
        transition: width 0.3s ease;
    }

    .tour-buttons {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
    }

    .tour-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s;
    }

    .tour-btn-primary {
        background-color: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
    }

    .tour-btn-primary:hover {
        background-color: var(--vscode-button-hoverBackground);
    }

    .tour-btn-secondary {
        background-color: var(--vscode-button-secondaryBackground);
        color: var(--vscode-button-secondaryForeground);
    }

    .tour-btn-secondary:hover {
        background-color: var(--vscode-button-secondaryHoverBackground);
    }

    /* Global highlight style for tour targets */
    :global(.tour-highlight) {
        position: relative;
        z-index: 9999;
        box-shadow: 0 0 0 2px var(--vscode-focusBorder), 0 0 0 4px rgba(0, 122, 255, 0.2);
        border-radius: 4px;
        transition: box-shadow 0.3s ease;
    }
</style>
</file>

<file path="webview/src/lib/components/HistoryView.svelte">
<script>
    import { createEventDispatcher, onMount } from 'svelte';
    import { postMessage, onMessage } from '../vscodeApi';

    const dispatch = createEventDispatcher();

    // Props
    export let historyItems = [];
    export let maxItems = 20;

    // State
    let loading = false;
    let error = null;
    let searchTerm = '';
    let filteredItems = [];

    // Reactive filtering
    $: filteredItems = searchTerm 
        ? historyItems.filter(item => 
            item.query.toLowerCase().includes(searchTerm.toLowerCase())
          ).slice(0, maxItems)
        : historyItems.slice(0, maxItems);

    onMount(() => {
        // Request search history when component mounts
        loadHistory();

        // Listen for history updates
        const unsubscribe = onMessage('searchHistoryResponse', (message) => {
            historyItems = message.history || [];
            loading = false;
            error = null;
        });

        const unsubscribeAdded = onMessage('searchHistoryAdded', (message) => {
            if (message.success) {
                // Refresh history after adding new item
                loadHistory();
            }
        });

        const unsubscribeCleared = onMessage('searchHistoryCleared', (message) => {
            if (message.success) {
                historyItems = [];
                error = null;
            }
        });

        return () => {
            unsubscribe();
            unsubscribeAdded();
            unsubscribeCleared();
        };
    });

    function loadHistory() {
        loading = true;
        error = null;
        postMessage('getSearchHistory', { limit: 50 });
    }

    function handleRerun(query) {
        dispatch('rerun', { query });
    }

    function handleRemoveItem(itemId) {
        // For now, we'll just filter it out locally
        // In a full implementation, you'd send a message to remove it from storage
        historyItems = historyItems.filter(item => item.id !== itemId);
    }

    function clearAllHistory() {
        if (confirm('Are you sure you want to clear all search history? This action cannot be undone.')) {
            loading = true;
            postMessage('clearSearchHistory');
        }
    }

    function formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        
        return date.toLocaleDateString();
    }

    function formatResultsCount(count) {
        if (count === 0) return 'No results';
        if (count === 1) return '1 result';
        return `${count} results`;
    }

    function getQueryPreview(query, maxLength = 60) {
        if (query.length <= maxLength) return query;
        return query.substring(0, maxLength) + '...';
    }
</script>

<div class="history-container">
    <div class="history-header">
        <h3 class="history-title">
            <span class="history-icon">üïí</span>
            Search History
        </h3>
        
        <div class="history-actions">
            <button 
                class="action-btn refresh-btn" 
                on:click={loadHistory}
                disabled={loading}
                title="Refresh history"
            >
                {loading ? '‚ü≥' : '‚Üª'}
            </button>
            
            {#if historyItems.length > 0}
                <button 
                    class="action-btn clear-btn" 
                    on:click={clearAllHistory}
                    title="Clear all history"
                >
                    üóëÔ∏è
                </button>
            {/if}
        </div>
    </div>

    {#if historyItems.length > 5}
        <div class="search-filter">
            <input 
                type="text" 
                placeholder="Filter history..." 
                bind:value={searchTerm}
                class="filter-input"
            />
        </div>
    {/if}

    <div class="history-content">
        {#if loading}
            <div class="loading-state">
                <div class="loading-spinner"></div>
                <span>Loading history...</span>
            </div>
        {:else if error}
            <div class="error-state">
                <span class="error-icon">‚ö†Ô∏è</span>
                <span class="error-message">{error}</span>
                <button class="retry-btn" on:click={loadHistory}>Retry</button>
            </div>
        {:else if filteredItems.length === 0}
            <div class="empty-state">
                {#if searchTerm}
                    <span class="empty-icon">üîç</span>
                    <span class="empty-message">No history items match "{searchTerm}"</span>
                    <button class="clear-filter-btn" on:click={() => searchTerm = ''}>
                        Clear filter
                    </button>
                {:else}
                    <span class="empty-icon">üìù</span>
                    <span class="empty-message">No search history yet</span>
                    <span class="empty-hint">Your search queries will appear here</span>
                {/if}
            </div>
        {:else}
            <div class="history-list">
                {#each filteredItems as item (item.id)}
                    <div class="history-item" on:click={() => handleRerun(item.query)}>
                        <div class="item-content">
                            <div class="item-header">
                                <span class="query-text" title={item.query}>
                                    {getQueryPreview(item.query)}
                                </span>
                                <button 
                                    class="remove-btn" 
                                    on:click|stopPropagation={() => handleRemoveItem(item.id)}
                                    title="Remove from history"
                                >
                                    √ó
                                </button>
                            </div>
                            
                            <div class="item-meta">
                                <span class="results-count">
                                    {formatResultsCount(item.resultsCount)}
                                </span>
                                
                                {#if item.resultFormat}
                                    <span class="format-badge {item.resultFormat}">
                                        {item.resultFormat.toUpperCase()}
                                    </span>
                                {/if}
                                
                                <span class="timestamp">
                                    {formatTimestamp(item.timestamp)}
                                </span>
                                
                                {#if item.executionTime}
                                    <span class="execution-time">
                                        {item.executionTime}ms
                                    </span>
                                {/if}
                            </div>
                        </div>
                    </div>
                {/each}
            </div>
            
            {#if historyItems.length > maxItems}
                <div class="history-footer">
                    <span class="items-info">
                        Showing {Math.min(maxItems, filteredItems.length)} of {historyItems.length} items
                    </span>
                </div>
            {/if}
        {/if}
    </div>
</div>

<style>
    .history-container {
        background-color: var(--vscode-editor-background);
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        overflow: hidden;
    }

    .history-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: var(--vscode-titleBar-activeBackground);
        border-bottom: 1px solid var(--vscode-panel-border);
    }

    .history-title {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: var(--vscode-titleBar-activeForeground);
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .history-icon {
        font-size: 16px;
    }

    .history-actions {
        display: flex;
        gap: 8px;
    }

    .action-btn {
        background: none;
        border: 1px solid var(--vscode-panel-border);
        border-radius: 4px;
        color: var(--vscode-foreground);
        cursor: pointer;
        font-size: 12px;
        padding: 4px 8px;
        transition: all 0.2s ease;
    }

    .action-btn:hover:not(:disabled) {
        background-color: var(--vscode-button-secondaryHoverBackground);
        border-color: var(--vscode-focusBorder);
    }

    .action-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .refresh-btn {
        animation: spin 1s linear infinite;
    }

    .refresh-btn:not(.loading) {
        animation: none;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    .search-filter {
        padding: 12px 16px;
        border-bottom: 1px solid var(--vscode-panel-border);
        background-color: var(--vscode-sideBar-background);
    }

    .filter-input {
        width: 100%;
        background-color: var(--vscode-input-background);
        border: 1px solid var(--vscode-input-border);
        border-radius: 4px;
        color: var(--vscode-input-foreground);
        font-size: 13px;
        padding: 6px 8px;
    }

    .filter-input:focus {
        border-color: var(--vscode-focusBorder);
        outline: none;
    }

    .history-content {
        max-height: 400px;
        overflow-y: auto;
    }

    .loading-state, .error-state, .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 32px 16px;
        text-align: center;
        color: var(--vscode-descriptionForeground);
    }

    .loading-spinner {
        width: 20px;
        height: 20px;
        border: 2px solid var(--vscode-panel-border);
        border-top: 2px solid var(--vscode-progressBar-foreground);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 8px;
    }

    .error-icon, .empty-icon {
        font-size: 24px;
        margin-bottom: 8px;
    }

    .error-message, .empty-message {
        font-size: 13px;
        margin-bottom: 8px;
    }

    .empty-hint {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
        opacity: 0.7;
    }

    .retry-btn, .clear-filter-btn {
        background-color: var(--vscode-button-secondaryBackground);
        border: none;
        border-radius: 4px;
        color: var(--vscode-button-secondaryForeground);
        cursor: pointer;
        font-size: 11px;
        padding: 4px 8px;
        margin-top: 8px;
    }

    .history-list {
        padding: 8px 0;
    }

    .history-item {
        cursor: pointer;
        padding: 8px 16px;
        transition: background-color 0.2s ease;
        border-bottom: 1px solid var(--vscode-panel-border);
    }

    .history-item:last-child {
        border-bottom: none;
    }

    .history-item:hover {
        background-color: var(--vscode-list-hoverBackground);
    }

    .item-content {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .item-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 8px;
    }

    .query-text {
        flex: 1;
        font-size: 13px;
        font-weight: 500;
        color: var(--vscode-foreground);
        line-height: 1.3;
        word-break: break-word;
    }

    .remove-btn {
        background: none;
        border: none;
        color: var(--vscode-descriptionForeground);
        cursor: pointer;
        font-size: 16px;
        line-height: 1;
        opacity: 0;
        padding: 0;
        transition: all 0.2s ease;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .history-item:hover .remove-btn {
        opacity: 1;
    }

    .remove-btn:hover {
        color: var(--vscode-errorForeground);
        background-color: var(--vscode-inputValidation-errorBackground);
        border-radius: 2px;
    }

    .item-meta {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
    }

    .results-count {
        font-weight: 500;
    }

    .format-badge {
        background-color: var(--vscode-badge-background);
        color: var(--vscode-badge-foreground);
        border-radius: 3px;
        padding: 1px 4px;
        font-size: 9px;
        font-weight: 600;
        text-transform: uppercase;
    }

    .format-badge.json {
        background-color: var(--vscode-charts-blue);
    }

    .format-badge.xml {
        background-color: var(--vscode-charts-orange);
    }

    .timestamp {
        color: var(--vscode-descriptionForeground);
    }

    .execution-time {
        color: var(--vscode-charts-green);
        font-family: var(--vscode-editor-font-family);
    }

    .history-footer {
        padding: 8px 16px;
        border-top: 1px solid var(--vscode-panel-border);
        background-color: var(--vscode-sideBar-background);
        text-align: center;
    }

    .items-info {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
    }
</style>
</file>

<file path="webview/src/lib/components/NoWorkspaceView.svelte">
<script lang="ts">
    import { fluentCard, fluentButton } from '@fluentui/web-components';
    import { postMessage } from '$lib/vscodeApi';

    function handleOpenFolder() {
        postMessage('requestOpenFolder');
    }
</script>

<fluent-card class="no-workspace-container">
    <h2>No Workspace Open</h2>
    <p>No workspace is open. Please open a folder to use the Code Context Engine.</p>
    <fluent-button
        appearance="accent"
        on:click={handleOpenFolder}
        on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && handleOpenFolder()}
        role="button"
        tabindex="0"
    >Open Folder</fluent-button>
</fluent-card>

<style>
    .no-workspace-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        padding: 2rem;
        text-align: center;
    }

    h2 {
        color: var(--vscode-foreground);
        margin-bottom: 1rem;
    }

    p {
        color: var(--vscode-descriptionForeground);
        max-width: 500px;
    }
</style>
</file>

<file path="webview/src/lib/components/NoWorkspaceView.test.ts">
/**
 * Test scenarios for NoWorkspaceView component
 * 
 * This file documents the test scenarios that should be verified
 * to ensure the NoWorkspaceView component works correctly.
 */

// Test Scenario 1: Component Rendering
// Description: Verify that the NoWorkspaceView component renders correctly
// Expected Behavior:
// - The component should display a title "No Workspace Open"
// - The component should display a message "No workspace is open. Please open a folder to use the Code Context Engine."
// - The component should have proper styling classes applied

// Test Scenario 2: Integration with App State
// Description: Verify that the NoWorkspaceView component is conditionally rendered based on app state
// Expected Behavior:
// - When isWorkspaceOpen is false, the NoWorkspaceView should be displayed
// - When isWorkspaceOpen is true, the NoWorkspaceView should not be displayed
// - Other views should be rendered normally when isWorkspaceOpen is true

// Test Scenario 3: Message Handling
// Description: Verify that the initial state message is handled correctly
// Expected Behavior:
// - When the webview receives an 'initialState' message with isWorkspaceOpen: false, the app store should be updated
// - The UI should reflect the updated state by showing the NoWorkspaceView

// Test Scenario 4: Responsive Design
// Description: Verify that the component displays correctly on different screen sizes
// Expected Behavior:
// - The component should be centered on the screen
// - The text should be readable and properly formatted
// - The component should adapt to different viewport sizes

// Test Scenario 5: Open Folder Button
// Description: Verify that the "Open Folder" button works correctly
// Expected Behavior:
// - The component should display a "Open Folder" button
// - When the button is clicked, it should send a 'requestOpenFolder' message to the extension
// - The button should have proper styling and be responsive to user interaction

// Test Scenario 6: Workspace State Changes
// Description: Verify that the component responds to workspace state changes
// Expected Behavior:
// - When the webview receives a 'workspaceStateChanged' message with isWorkspaceOpen: true, the app store should be updated
// - The UI should reflect the updated state by hiding the NoWorkspaceView
// - When the webview receives a 'workspaceStateChanged' message with isWorkspaceOpen: false, the app store should be updated
// - The UI should reflect the updated state by showing the NoWorkspaceView

// Test Scenario 7: Accessibility
// Description: Verify that the component is accessible
// Expected Behavior:
// - The component should have proper semantic HTML structure
// - The text should have sufficient contrast
// - The component should be navigable using keyboard
// - The "Open Folder" button should be accessible via keyboard and have proper ARIA attributes

// Note: These test scenarios should be implemented using a proper testing framework
// such as Jest with Svelte Testing Library when the testing environment is configured.
</file>

<file path="webview/src/lib/components/ResultCard.svelte">
<script>
    import { createEventDispatcher } from 'svelte';
    import hljs from 'highlight.js';
    import 'highlight.js/styles/github-dark.css';
    import { postMessage } from '../vscodeApi';

    const dispatch = createEventDispatcher();

    // Props
    export let result;
    export let index = 0;

    // State
    let highlightedCode = '';
    let isExpanded = false;
    let copyButtonText = 'Copy';

    // Reactive highlighting
    $: if (result && result.content) {
        try {
            // Detect language from file extension
            const language = detectLanguage(result.file);
            highlightedCode = hljs.highlight(result.content, {
                language: language,
                ignoreIllegals: true
            }).value;
        } catch (e) {
            console.error('Highlighting failed:', e);
            highlightedCode = escapeHtml(result.content); // Fallback to escaped plain text
        }
    }

    function detectLanguage(filePath) {
        if (!filePath) return 'plaintext';
        
        const ext = filePath.split('.').pop()?.toLowerCase();
        const languageMap = {
            'js': 'javascript',
            'jsx': 'javascript',
            'ts': 'typescript',
            'tsx': 'typescript',
            'py': 'python',
            'java': 'java',
            'cpp': 'cpp',
            'c': 'c',
            'cs': 'csharp',
            'php': 'php',
            'rb': 'ruby',
            'go': 'go',
            'rs': 'rust',
            'swift': 'swift',
            'kt': 'kotlin',
            'scala': 'scala',
            'sh': 'bash',
            'bash': 'bash',
            'zsh': 'bash',
            'fish': 'bash',
            'ps1': 'powershell',
            'sql': 'sql',
            'html': 'html',
            'htm': 'html',
            'xml': 'xml',
            'css': 'css',
            'scss': 'scss',
            'sass': 'sass',
            'less': 'less',
            'json': 'json',
            'yaml': 'yaml',
            'yml': 'yaml',
            'toml': 'toml',
            'ini': 'ini',
            'cfg': 'ini',
            'conf': 'ini',
            'md': 'markdown',
            'markdown': 'markdown',
            'dockerfile': 'dockerfile',
            'makefile': 'makefile',
            'r': 'r',
            'R': 'r',
            'dart': 'dart',
            'vue': 'vue',
            'svelte': 'svelte'
        };
        
        return languageMap[ext] || 'plaintext';
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function openFile() {
        postMessage('openFile', {
            path: result.file,
            line: result.lineNumber || 1
        });
    }

    async function copySnippet() {
        try {
            await navigator.clipboard.writeText(result.content);
            copyButtonText = 'Copied!';
            setTimeout(() => {
                copyButtonText = 'Copy';
            }, 2000);
        } catch (err) {
            console.error('Failed to copy:', err);
            copyButtonText = 'Failed';
            setTimeout(() => {
                copyButtonText = 'Copy';
            }, 2000);
        }
    }

    function toggleExpanded() {
        isExpanded = !isExpanded;
    }

    function getScoreColor(score) {
        if (score >= 0.8) return 'var(--vscode-charts-green)';
        if (score >= 0.6) return 'var(--vscode-charts-yellow)';
        if (score >= 0.4) return 'var(--vscode-charts-orange)';
        return 'var(--vscode-charts-red)';
    }

    function truncateContent(content, maxLines = 10) {
        if (!content) return '';
        const lines = content.split('\n');
        if (lines.length <= maxLines) return content;
        return lines.slice(0, maxLines).join('\n') + '\n...';
    }

    // Reactive content for display
    $: displayContent = isExpanded ? result.content : truncateContent(result.content);
    $: displayHighlighted = isExpanded ? highlightedCode : truncateContent(highlightedCode);
</script>

<div class="result-card" data-tour="results">
    <div class="card-header">
        <div class="file-info">
            <button 
                class="file-path" 
                on:click={openFile}
                title="Click to open file in editor"
            >
                <span class="file-icon">üìÑ</span>
                <span class="file-name">{result.file}</span>
                {#if result.lineNumber}
                    <span class="line-number">:{result.lineNumber}</span>
                {/if}
            </button>
        </div>
        
        <div class="card-actions">
            <div class="score-badge" style="background-color: {getScoreColor(result.score)}">
                {Math.round(result.score * 100)}%
            </div>
            
            <button 
                class="action-btn copy-btn" 
                on:click={copySnippet}
                title="Copy code snippet"
            >
                {copyButtonText}
            </button>
            
            {#if result.content && result.content.split('\n').length > 10}
                <button 
                    class="action-btn expand-btn" 
                    on:click={toggleExpanded}
                    title={isExpanded ? 'Collapse' : 'Expand'}
                >
                    {isExpanded ? '‚ñ≤' : '‚ñº'}
                </button>
            {/if}
        </div>
    </div>

    <div class="card-content">
        <pre class="code-snippet"><code class="hljs">{@html displayHighlighted}</code></pre>
    </div>

    {#if result.context}
        <div class="card-context">
            <strong>Context:</strong> {result.context}
        </div>
    {/if}

    {#if result.relatedFiles && result.relatedFiles.length > 0}
        <details class="related-files">
            <summary>Related Files ({result.relatedFiles.length})</summary>
            <div class="related-files-list">
                {#each result.relatedFiles as relatedFile}
                    <div class="related-file">
                        <button 
                            class="file-path related-file-link" 
                            on:click={() => postMessage('openFile', { path: relatedFile.file })}
                            title="Open related file"
                        >
                            üìÑ {relatedFile.file}
                        </button>
                        <span class="related-reason">{relatedFile.reason}</span>
                        <div class="score-badge small" style="background-color: {getScoreColor(relatedFile.score)}">
                            {Math.round(relatedFile.score * 100)}%
                        </div>
                    </div>
                {/each}
            </div>
        </details>
    {/if}
</div>

<style>
    .result-card {
        background-color: var(--vscode-editor-background);
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        margin-bottom: 12px;
        overflow: hidden;
        transition: box-shadow 0.2s ease;
    }

    .result-card:hover {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border-color: var(--vscode-focusBorder);
    }

    .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: var(--vscode-titleBar-activeBackground);
        border-bottom: 1px solid var(--vscode-panel-border);
    }

    .file-info {
        flex: 1;
        min-width: 0;
    }

    .file-path {
        background: none;
        border: none;
        color: var(--vscode-textLink-foreground);
        cursor: pointer;
        font-family: var(--vscode-font-family);
        font-size: 13px;
        padding: 0;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: color 0.2s ease;
    }

    .file-path:hover {
        color: var(--vscode-textLink-activeForeground);
        text-decoration: underline;
    }

    .file-icon {
        font-size: 14px;
    }

    .file-name {
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .line-number {
        color: var(--vscode-descriptionForeground);
        font-weight: normal;
    }

    .card-actions {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .score-badge {
        color: white;
        font-size: 11px;
        font-weight: 600;
        padding: 4px 8px;
        border-radius: 12px;
        white-space: nowrap;
    }

    .score-badge.small {
        font-size: 10px;
        padding: 2px 6px;
    }

    .action-btn {
        background-color: var(--vscode-button-secondaryBackground);
        border: none;
        border-radius: 4px;
        color: var(--vscode-button-secondaryForeground);
        cursor: pointer;
        font-size: 11px;
        padding: 6px 10px;
        transition: background-color 0.2s ease;
    }

    .action-btn:hover {
        background-color: var(--vscode-button-secondaryHoverBackground);
    }

    .copy-btn {
        min-width: 50px;
    }

    .expand-btn {
        width: 24px;
        padding: 6px;
    }

    .card-content {
        padding: 0;
    }

    .code-snippet {
        margin: 0;
        padding: 16px;
        background-color: var(--vscode-textCodeBlock-background);
        font-family: var(--vscode-editor-font-family);
        font-size: var(--vscode-editor-font-size);
        line-height: 1.4;
        overflow-x: auto;
        white-space: pre;
    }

    .code-snippet code {
        background: none;
        padding: 0;
    }

    .card-context {
        padding: 12px 16px;
        background-color: var(--vscode-textBlockQuote-background);
        border-top: 1px solid var(--vscode-panel-border);
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
    }

    .related-files {
        border-top: 1px solid var(--vscode-panel-border);
    }

    .related-files summary {
        padding: 12px 16px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        color: var(--vscode-foreground);
        background-color: var(--vscode-sideBar-background);
        transition: background-color 0.2s ease;
    }

    .related-files summary:hover {
        background-color: var(--vscode-list-hoverBackground);
    }

    .related-files-list {
        padding: 8px 16px 12px;
        background-color: var(--vscode-sideBar-background);
    }

    .related-file {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 4px 0;
        font-size: 11px;
    }

    .related-file-link {
        font-size: 11px;
    }

    .related-reason {
        flex: 1;
        color: var(--vscode-descriptionForeground);
        font-style: italic;
    }

    /* Responsive adjustments */
    @media (max-width: 600px) {
        .card-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }

        .card-actions {
            align-self: flex-end;
        }

        .file-name {
            max-width: 200px;
        }
    }
</style>
</file>

<file path="webview/src/lib/components/ValidatedInput.svelte">
<script lang="ts">
    import { onMount, createEventDispatcher } from 'svelte';
    import type { ValidationResult } from '$lib/utils/validation';
    import { createDebouncedValidator } from '$lib/utils/validation';
    import { registerFormComponents } from '$lib/utils/fluentUI';

    // Register required Fluent UI components
    registerFormComponents();

    // Props
    export let value: string = '';
    export let type: 'text' | 'password' | 'url' | 'number' | 'select' = 'text';
    export let placeholder: string = '';
    export let label: string = '';
    export let required: boolean = false;
    export let disabled: boolean = false;
    export let options: { value: string; label: string }[] = []; // For select type
    export let validator: ((value: string) => ValidationResult) | null = null;
    export let validateOnChange: boolean = true;
    export let validateOnBlur: boolean = true;
    export let debounceMs: number = 300;
    export let showValidationIcon: boolean = true;
    export let size: 'small' | 'medium' | 'large' = 'medium';

    // State
    let validationResult: ValidationResult | null = null;
    let isValidating: boolean = false;
    let hasBeenTouched: boolean = false;
    let inputElement: HTMLElement | null = null;

    // Event dispatcher
    const dispatch = createEventDispatcher<{
        input: { value: string; isValid: boolean };
        validation: { result: ValidationResult };
        blur: { value: string };
        focus: { value: string };
    }>();

    // Create debounced validator
    let debouncedValidator: ((value: string) => Promise<ValidationResult>) | null = null;
    
    $: if (validator) {
        debouncedValidator = createDebouncedValidator(validator, debounceMs);
    }

    // Validation state
    $: isValid = validationResult?.isValid ?? true;
    $: hasErrors = (validationResult?.errors?.length ?? 0) > 0;
    $: hasWarnings = (validationResult?.warnings?.length ?? 0) > 0;
    $: hasSuggestions = (validationResult?.suggestions?.length ?? 0) > 0;

    // CSS classes based on validation state
    $: validationClass = hasBeenTouched ? (hasErrors ? 'error' : isValid ? 'valid' : '') : '';

    /**
     * Perform validation
     */
    async function performValidation(inputValue: string, immediate: boolean = false): Promise<void> {
        if (!validator || !hasBeenTouched) return;

        isValidating = true;

        try {
            let result: ValidationResult;
            
            if (immediate || !debouncedValidator) {
                result = validator(inputValue);
            } else {
                result = await debouncedValidator(inputValue);
            }

            validationResult = result;
            dispatch('validation', { result });
        } catch (error) {
            console.error('Validation error:', error);
            validationResult = {
                isValid: false,
                errors: ['Validation failed'],
                warnings: [],
                suggestions: []
            };
        } finally {
            isValidating = false;
        }
    }

    /**
     * Handle input change
     */
    function handleInput(event: Event): void {
        const target = event.target as HTMLInputElement | HTMLSelectElement;
        value = target.value;
        hasBeenTouched = true;

        dispatch('input', { value, isValid });

        if (validateOnChange) {
            performValidation(value);
        }
    }

    /**
     * Handle input blur
     */
    function handleBlur(event: Event): void {
        const target = event.target as HTMLInputElement | HTMLSelectElement;
        hasBeenTouched = true;
        
        dispatch('blur', { value: target.value });

        if (validateOnBlur) {
            performValidation(value, true);
        }
    }

    /**
     * Handle input focus
     */
    function handleFocus(event: Event): void {
        const target = event.target as HTMLInputElement | HTMLSelectElement;
        dispatch('focus', { value: target.value });
    }

    /**
     * Clear validation state
     */
    export function clearValidation(): void {
        validationResult = null;
        hasBeenTouched = false;
        isValidating = false;
    }

    /**
     * Trigger immediate validation
     */
    export function validate(): Promise<ValidationResult | null> {
        hasBeenTouched = true;
        if (validator) {
            performValidation(value, true);
            return Promise.resolve(validationResult);
        }
        return Promise.resolve(null);
    }

    /**
     * Focus the input
     */
    export function focus(): void {
        if (inputElement) {
            inputElement.focus();
        }
    }

    onMount(() => {
        // Initial validation if value is provided
        if (value && validator) {
            performValidation(value, true);
        }
    });
</script>

<div class="validated-input {validationClass}" class:disabled>
    {#if label}
        <label for="input-{label}" class="input-label">
            {label}
            {#if required}
                <span class="required-indicator">*</span>
            {/if}
        </label>
    {/if}

    <div class="input-container">
        {#if type === 'select'}
            <fluent-select
                bind:this={inputElement}
                id="input-{label}"
                {value}
                {disabled}
                on:change={handleInput}
                on:blur={handleBlur}
                on:focus={handleFocus}
                class="input-field {size}"
                role="combobox"
                aria-label={label || placeholder}
                aria-invalid={hasErrors}
                aria-expanded="false"
                aria-controls="options-{label}"
                aria-describedby={hasErrors || hasWarnings || hasSuggestions ? `validation-${label}` : undefined}
            >
                {#if placeholder}
                    <fluent-option value="">{placeholder}</fluent-option>
                {/if}
                {#each options as option}
                    <fluent-option value={option.value}>{option.label}</fluent-option>
                {/each}
            </fluent-select>
        {:else}
            <fluent-text-field
                bind:this={inputElement}
                id="input-{label}"
                {type}
                {value}
                {placeholder}
                {disabled}
                on:input={handleInput}
                on:blur={handleBlur}
                on:focus={handleFocus}
                class="input-field {size}"
                role="textbox"
                aria-label={label || placeholder}
                aria-invalid={hasErrors}
                aria-describedby={hasErrors || hasWarnings || hasSuggestions ? `validation-${label}` : undefined}
            ></fluent-text-field>
        {/if}

        {#if showValidationIcon && hasBeenTouched}
            <div class="validation-icon">
                {#if isValidating}
                    <div class="loading-spinner"></div>
                {:else if hasErrors}
                    <span class="error-icon" title="Validation errors">‚ö†Ô∏è</span>
                {:else if isValid}
                    <span class="success-icon" title="Valid">‚úÖ</span>
                {/if}
            </div>
        {/if}
    </div>

    {#if validationResult && hasBeenTouched && (hasErrors || hasWarnings || hasSuggestions)}
        <div id="validation-{label}" class="validation-messages" role="alert" aria-live="polite">
            {#if hasErrors}
                <div class="validation-errors">
                    {#each validationResult.errors as error}
                        <div class="validation-message error">
                            <span class="message-icon">‚ùå</span>
                            <span class="message-text">{error}</span>
                        </div>
                    {/each}
                </div>
            {/if}

            {#if hasWarnings}
                <div class="validation-warnings">
                    {#each validationResult.warnings as warning}
                        <div class="validation-message warning">
                            <span class="message-icon">‚ö†Ô∏è</span>
                            <span class="message-text">{warning}</span>
                        </div>
                    {/each}
                </div>
            {/if}

            {#if hasSuggestions}
                <div class="validation-suggestions">
                    {#each validationResult.suggestions as suggestion}
                        <div class="validation-message suggestion">
                            <span class="message-icon">üí°</span>
                            <span class="message-text">{suggestion}</span>
                        </div>
                    {/each}
                </div>
            {/if}
        </div>
    {/if}
</div>

<style>
    .validated-input {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
    }

    .validated-input.disabled {
        opacity: 0.6;
        pointer-events: none;
    }

    .input-label {
        font-size: 14px;
        font-weight: 500;
        color: var(--vscode-foreground);
        margin-bottom: 4px;
    }

    .required-indicator {
        color: var(--vscode-errorForeground);
        margin-left: 2px;
    }

    .input-container {
        position: relative;
        display: flex;
        align-items: center;
    }

    .input-field {
        flex: 1;
        transition: border-color 0.2s ease;
    }

    .input-field.small {
        font-size: 12px;
    }

    .input-field.medium {
        font-size: 14px;
    }

    .input-field.large {
        font-size: 16px;
    }

    .validated-input.error .input-field {
        border-color: var(--vscode-inputValidation-errorBorder);
        background-color: var(--vscode-inputValidation-errorBackground);
    }

    .validated-input.valid .input-field {
        border-color: var(--vscode-charts-green);
    }

    .validation-icon {
        position: absolute;
        right: 8px;
        display: flex;
        align-items: center;
        pointer-events: none;
    }

    .loading-spinner {
        width: 16px;
        height: 16px;
        border: 2px solid var(--vscode-panel-border);
        border-top: 2px solid var(--vscode-button-background);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .error-icon, .success-icon {
        font-size: 16px;
    }

    .validation-messages {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .validation-message {
        display: flex;
        align-items: flex-start;
        gap: 6px;
        font-size: 12px;
        line-height: 1.4;
        padding: 4px 0;
    }

    .validation-message.error {
        color: var(--vscode-inputValidation-errorForeground);
    }

    .validation-message.warning {
        color: var(--vscode-inputValidation-warningForeground);
    }

    .validation-message.suggestion {
        color: var(--vscode-textLink-foreground);
    }

    .message-icon {
        flex-shrink: 0;
        font-size: 12px;
        margin-top: 1px;
    }

    .message-text {
        flex: 1;
    }

    /* Responsive design */
    @media (max-width: 600px) {
        .validated-input {
            margin-bottom: 12px;
        }

        .validation-message {
            font-size: 11px;
        }
    }
</style>
</file>

<file path="webview/src/lib/components/ValidatedInput.test.ts">
/**
 * ValidatedInput Component Integration Tests
 * 
 * Tests for the ValidatedInput component including user interactions,
 * validation behavior, and event handling.
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, fireEvent, waitFor } from '@testing-library/svelte';
import ValidatedInput from './ValidatedInput.svelte';
import { validators } from '$lib/utils/validation';

describe('ValidatedInput Component', () => {
	beforeEach(() => {
		vi.clearAllMocks();
	});

	describe('Basic Rendering', () => {
		it('should render text input with label', () => {
			const { getByLabelText, getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					placeholder: 'Enter text'
				}
			});

			expect(getByText('Test Input')).toBeInTheDocument();
			expect(getByLabelText('Test Input')).toBeInTheDocument();
		});

		it('should render select input with options', () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'select',
					label: 'Test Select',
					value: '',
					options: [
						{ value: 'option1', label: 'Option 1' },
						{ value: 'option2', label: 'Option 2' }
					]
				}
			});

			const select = getByLabelText('Test Select');
			expect(select).toBeInTheDocument();
			expect(select.tagName.toLowerCase()).toBe('fluent-select');
		});

		it('should show required indicator when required', () => {
			const { getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Required Input',
					required: true
				}
			});

			expect(getByText('*')).toBeInTheDocument();
		});

		it('should be disabled when disabled prop is true', () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Disabled Input',
					disabled: true
				}
			});

			const input = getByLabelText('Disabled Input');
			expect(input).toHaveAttribute('disabled');
		});
	});

	describe('User Interactions', () => {
		it('should emit input event when value changes', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: ''
				}
			});

			const inputEvents: any[] = [];
			component.$on('input', (event) => {
				inputEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'test value' } });

			expect(inputEvents).toHaveLength(1);
			expect(inputEvents[0]).toEqual({
				value: 'test value',
				isValid: true
			});
		});

		it('should emit blur event when input loses focus', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'initial'
				}
			});

			const blurEvents: any[] = [];
			component.$on('blur', (event) => {
				blurEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			await fireEvent.blur(input);

			expect(blurEvents).toHaveLength(1);
			expect(blurEvents[0]).toEqual({ value: 'initial' });
		});

		it('should emit focus event when input gains focus', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'initial'
				}
			});

			const focusEvents: any[] = [];
			component.$on('focus', (event) => {
				focusEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			await fireEvent.focus(input);

			expect(focusEvents).toHaveLength(1);
			expect(focusEvents[0]).toEqual({ value: 'initial' });
		});
	});

	describe('Validation Behavior', () => {
		it('should validate on input when validateOnChange is true', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required,
					validateOnChange: true
				}
			});

			const validationEvents: any[] = [];
			component.$on('validation', (event) => {
				validationEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			
			// First input should trigger validation
			await fireEvent.input(input, { target: { value: '' } });
			await waitFor(() => {
				expect(validationEvents.length).toBeGreaterThan(0);
			});

			// Should show validation error for empty required field
			expect(validationEvents[0].result.isValid).toBe(false);
			expect(validationEvents[0].result.errors).toContain('Field is required');
		});

		it('should validate on blur when validateOnBlur is true', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required,
					validateOnChange: false,
					validateOnBlur: true
				}
			});

			const validationEvents: any[] = [];
			component.$on('validation', (event) => {
				validationEvents.push(event.detail);
			});

			const input = getByLabelText('Test Input');
			
			// Input should not trigger validation
			await fireEvent.input(input, { target: { value: '' } });
			expect(validationEvents).toHaveLength(0);

			// Blur should trigger validation
			await fireEvent.blur(input);
			await waitFor(() => {
				expect(validationEvents.length).toBeGreaterThan(0);
			});

			expect(validationEvents[0].result.isValid).toBe(false);
		});

		it('should show validation icon when validation is complete', async () => {
			const { getByLabelText, container } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'valid value',
					validator: validators.required,
					showValidationIcon: true
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'valid value' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				const successIcon = container.querySelector('.success-icon');
				expect(successIcon).toBeInTheDocument();
			});
		});

		it('should show error icon for invalid input', async () => {
			const { getByLabelText, container } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required,
					showValidationIcon: true
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				const errorIcon = container.querySelector('.error-icon');
				expect(errorIcon).toBeInTheDocument();
			});
		});

		it('should show loading spinner during validation', async () => {
			const slowValidator = vi.fn(() => {
				return new Promise(resolve => {
					setTimeout(() => resolve(validators.required('test')), 100);
				});
			});

			const { getByLabelText, container } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: slowValidator,
					showValidationIcon: true,
					debounceMs: 0
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'test' } });

			// Should show loading spinner
			const loadingSpinner = container.querySelector('.loading-spinner');
			expect(loadingSpinner).toBeInTheDocument();
		});
	});

	describe('Validation Messages', () => {
		it('should display error messages', async () => {
			const { getByLabelText, getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				expect(getByText('Field is required')).toBeInTheDocument();
			});
		});

		it('should display warning messages', async () => {
			const warningValidator = () => ({
				isValid: true,
				errors: [],
				warnings: ['This is a warning'],
				suggestions: []
			});

			const { getByLabelText, getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'test',
					validator: warningValidator
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'test' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				expect(getByText('This is a warning')).toBeInTheDocument();
			});
		});

		it('should display suggestion messages', async () => {
			const suggestionValidator = () => ({
				isValid: true,
				errors: [],
				warnings: [],
				suggestions: ['This is a suggestion']
			});

			const { getByLabelText, getByText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: 'test',
					validator: suggestionValidator
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: 'test' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				expect(getByText('This is a suggestion')).toBeInTheDocument();
			});
		});
	});

	describe('Accessibility', () => {
		it('should have proper ARIA attributes', () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: ''
				}
			});

			const input = getByLabelText('Test Input');
			expect(input).toHaveAttribute('role', 'textbox');
			expect(input).toHaveAttribute('aria-label', 'Test Input');
		});

		it('should set aria-invalid when validation fails', async () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				expect(input).toHaveAttribute('aria-invalid', 'true');
			});
		});

		it('should associate validation messages with input', async () => {
			const { getByLabelText } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			await waitFor(() => {
				const describedBy = input.getAttribute('aria-describedby');
				expect(describedBy).toContain('validation-Test Input');
			});
		});
	});

	describe('Component Methods', () => {
		it('should clear validation when clearValidation is called', async () => {
			const { getByLabelText, component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const input = getByLabelText('Test Input');
			await fireEvent.input(input, { target: { value: '' } });
			await fireEvent.blur(input);

			// Wait for validation to complete
			await waitFor(() => {
				expect(input).toHaveAttribute('aria-invalid', 'true');
			});

			// Clear validation
			component.clearValidation();

			// Validation should be cleared
			expect(input).not.toHaveAttribute('aria-invalid');
		});

		it('should trigger validation when validate is called', async () => {
			const { component } = render(ValidatedInput, {
				props: {
					type: 'text',
					label: 'Test Input',
					value: '',
					validator: validators.required
				}
			});

			const validationEvents: any[] = [];
			component.$on('validation', (event) => {
				validationEvents.push(event.detail);
			});

			// Trigger validation manually
			await component.validate();

			expect(validationEvents).toHaveLength(1);
			expect(validationEvents[0].result.isValid).toBe(false);
		});
	});
});
</file>

<file path="webview/src/lib/components/ValidationMessage.svelte">
<script lang="ts">
    import { createEventDispatcher } from 'svelte';
    import type { ValidationResult } from '$lib/utils/validation';

    // Props
    export let result: ValidationResult | null = null;
    export let showIcon: boolean = true;
    export let showDismiss: boolean = false;
    export let compact: boolean = false;
    export let maxMessages: number = 5;

    // Event dispatcher
    const dispatch = createEventDispatcher<{
        dismiss: void;
    }>();

    // Computed properties
    $: hasErrors = result?.errors.length > 0;
    $: hasWarnings = result?.warnings.length > 0;
    $: hasSuggestions = result?.suggestions.length > 0;
    $: hasAnyMessages = hasErrors || hasWarnings || hasSuggestions;

    // Get the primary message type for styling
    $: primaryType = hasErrors ? 'error' : hasWarnings ? 'warning' : 'suggestion';

    // Truncate messages if needed
    $: displayErrors = result?.errors.slice(0, maxMessages) || [];
    $: displayWarnings = result?.warnings.slice(0, maxMessages) || [];
    $: displaySuggestions = result?.suggestions.slice(0, maxMessages) || [];
    $: hasMoreMessages = (result?.errors.length || 0) + (result?.warnings.length || 0) + (result?.suggestions.length || 0) > maxMessages;

    function handleDismiss(): void {
        dispatch('dismiss');
    }

    function getIcon(type: 'error' | 'warning' | 'suggestion'): string {
        switch (type) {
            case 'error': return '‚ùå';
            case 'warning': return '‚ö†Ô∏è';
            case 'suggestion': return 'üí°';
            default: return '';
        }
    }
</script>

{#if result && hasAnyMessages}
    <div 
        class="validation-message-container {primaryType}" 
        class:compact
        role="alert" 
        aria-live="polite"
    >
        <div class="validation-content">
            {#if showIcon}
                <div class="validation-icon">
                    {getIcon(primaryType)}
                </div>
            {/if}

            <div class="validation-messages">
                <!-- Error messages -->
                {#if hasErrors}
                    <div class="message-group errors">
                        {#each displayErrors as error}
                            <div class="message-item error">
                                {#if !showIcon || compact}
                                    <span class="inline-icon">{getIcon('error')}</span>
                                {/if}
                                <span class="message-text">{error}</span>
                            </div>
                        {/each}
                    </div>
                {/if}

                <!-- Warning messages -->
                {#if hasWarnings}
                    <div class="message-group warnings">
                        {#each displayWarnings as warning}
                            <div class="message-item warning">
                                {#if !showIcon || compact}
                                    <span class="inline-icon">{getIcon('warning')}</span>
                                {/if}
                                <span class="message-text">{warning}</span>
                            </div>
                        {/each}
                    </div>
                {/if}

                <!-- Suggestion messages -->
                {#if hasSuggestions}
                    <div class="message-group suggestions">
                        {#each displaySuggestions as suggestion}
                            <div class="message-item suggestion">
                                {#if !showIcon || compact}
                                    <span class="inline-icon">{getIcon('suggestion')}</span>
                                {/if}
                                <span class="message-text">{suggestion}</span>
                            </div>
                        {/each}
                    </div>
                {/if}

                <!-- More messages indicator -->
                {#if hasMoreMessages}
                    <div class="more-messages">
                        <span class="more-text">
                            ... and {((result?.errors.length || 0) + (result?.warnings.length || 0) + (result?.suggestions.length || 0)) - maxMessages} more message{((result?.errors.length || 0) + (result?.warnings.length || 0) + (result?.suggestions.length || 0)) - maxMessages === 1 ? '' : 's'}
                        </span>
                    </div>
                {/if}
            </div>

            {#if showDismiss}
                <button 
                    class="dismiss-button"
                    on:click={handleDismiss}
                    on:keydown={(e) => e.key === 'Enter' && handleDismiss()}
                    aria-label="Dismiss validation messages"
                    title="Dismiss"
                >
                    ‚úï
                </button>
            {/if}
        </div>
    </div>
{/if}

<style>
    .validation-message-container {
        border-radius: 4px;
        padding: 12px;
        margin: 8px 0;
        border-left: 4px solid;
        background-color: var(--vscode-textCodeBlock-background);
        transition: all 0.2s ease;
    }

    .validation-message-container.compact {
        padding: 8px;
        margin: 4px 0;
    }

    .validation-message-container.error {
        border-left-color: var(--vscode-inputValidation-errorBorder);
        background-color: var(--vscode-inputValidation-errorBackground);
    }

    .validation-message-container.warning {
        border-left-color: var(--vscode-inputValidation-warningBorder);
        background-color: var(--vscode-inputValidation-warningBackground);
    }

    .validation-message-container.suggestion {
        border-left-color: var(--vscode-textLink-foreground);
        background-color: var(--vscode-textCodeBlock-background);
    }

    .validation-content {
        display: flex;
        align-items: flex-start;
        gap: 8px;
    }

    .validation-icon {
        flex-shrink: 0;
        font-size: 16px;
        margin-top: 2px;
    }

    .compact .validation-icon {
        font-size: 14px;
        margin-top: 1px;
    }

    .validation-messages {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .compact .validation-messages {
        gap: 4px;
    }

    .message-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .compact .message-group {
        gap: 2px;
    }

    .message-item {
        display: flex;
        align-items: flex-start;
        gap: 6px;
        font-size: 13px;
        line-height: 1.4;
    }

    .compact .message-item {
        font-size: 12px;
        gap: 4px;
    }

    .message-item.error {
        color: var(--vscode-inputValidation-errorForeground);
    }

    .message-item.warning {
        color: var(--vscode-inputValidation-warningForeground);
    }

    .message-item.suggestion {
        color: var(--vscode-textLink-foreground);
    }

    .inline-icon {
        flex-shrink: 0;
        font-size: 12px;
        margin-top: 1px;
    }

    .compact .inline-icon {
        font-size: 10px;
    }

    .message-text {
        flex: 1;
        word-break: break-word;
    }

    .more-messages {
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px solid var(--vscode-panel-border);
    }

    .more-text {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
        font-style: italic;
    }

    .dismiss-button {
        flex-shrink: 0;
        background: none;
        border: none;
        color: var(--vscode-foreground);
        cursor: pointer;
        font-size: 14px;
        padding: 2px 4px;
        border-radius: 2px;
        transition: background-color 0.2s ease;
        margin-top: -2px;
    }

    .dismiss-button:hover {
        background-color: var(--vscode-list-hoverBackground);
    }

    .dismiss-button:focus {
        outline: 1px solid var(--vscode-focusBorder);
        outline-offset: 1px;
    }

    /* Animation for new messages */
    .validation-message-container {
        animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Responsive design */
    @media (max-width: 600px) {
        .validation-message-container {
            padding: 8px;
            margin: 6px 0;
        }

        .message-item {
            font-size: 12px;
        }

        .validation-icon {
            font-size: 14px;
        }
    }
</style>
</file>

<file path="webview/src/lib/stores/appStore.test.ts">
/**
 * App Store Unit Tests
 * 
 * Tests for the centralized application state management stores.
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { get } from 'svelte/store';
import {
	appState,
	setupState,
	indexingState,
	searchState,
	appActions,
	setupActions,
	indexingActions,
	searchActions,
	isSetupComplete,
	canStartIndexing,
	hasSearchResults,
	currentError,
	resetAllState
} from './appStore';

describe('App Store', () => {
	beforeEach(() => {
		// Reset all state before each test
		resetAllState();
	});

	describe('appState', () => {
		it('should have correct initial state', () => {
			const state = get(appState);
			expect(state).toEqual({
				isInitialized: false,
				isLoading: false,
				error: null,
				lastActivity: null
			});
		});

		it('should initialize correctly', () => {
			appActions.initialize();
			const state = get(appState);
			
			expect(state.isInitialized).toBe(true);
			expect(state.lastActivity).toBeInstanceOf(Date);
		});

		it('should set loading state', () => {
			appActions.setLoading(true);
			expect(get(appState).isLoading).toBe(true);
			
			appActions.setLoading(false);
			expect(get(appState).isLoading).toBe(false);
		});

		it('should set and clear errors', () => {
			const errorMessage = 'Test error';
			appActions.setError(errorMessage);
			expect(get(appState).error).toBe(errorMessage);
			
			appActions.clearError();
			expect(get(appState).error).toBe(null);
		});

		it('should update activity timestamp', () => {
			const beforeTime = Date.now();
			appActions.updateActivity();
			const afterTime = Date.now();
			
			const lastActivity = get(appState).lastActivity;
			expect(lastActivity).toBeInstanceOf(Date);
			expect(lastActivity!.getTime()).toBeGreaterThanOrEqual(beforeTime);
			expect(lastActivity!.getTime()).toBeLessThanOrEqual(afterTime);
		});
	});

	describe('setupState', () => {
		it('should have correct initial state', () => {
			const state = get(setupState);
			expect(state).toEqual({
				databaseStatus: 'idle',
				providerStatus: 'idle',
				selectedDatabase: '',
				selectedProvider: '',
				isSetupComplete: false,
				setupErrors: []
			});
		});

		it('should update database status', () => {
			setupActions.setDatabaseStatus('starting');
			expect(get(setupState).databaseStatus).toBe('starting');
			
			setupActions.setDatabaseStatus('ready');
			expect(get(setupState).databaseStatus).toBe('ready');
		});

		it('should update provider status', () => {
			setupActions.setProviderStatus('starting');
			expect(get(setupState).providerStatus).toBe('starting');
			
			setupActions.setProviderStatus('ready');
			expect(get(setupState).providerStatus).toBe('ready');
		});

		it('should update selected database and reset status', () => {
			setupActions.setDatabaseStatus('ready');
			setupActions.setSelectedDatabase('qdrant');
			
			const state = get(setupState);
			expect(state.selectedDatabase).toBe('qdrant');
			expect(state.databaseStatus).toBe('idle');
		});

		it('should manage setup errors', () => {
			const error1 = 'Database connection failed';
			const error2 = 'Provider authentication failed';
			
			setupActions.addSetupError(error1);
			expect(get(setupState).setupErrors).toEqual([error1]);
			
			setupActions.addSetupError(error2);
			expect(get(setupState).setupErrors).toEqual([error1, error2]);
			
			setupActions.clearSetupErrors();
			expect(get(setupState).setupErrors).toEqual([]);
		});
	});

	describe('indexingState', () => {
		it('should have correct initial state', () => {
			const state = get(indexingState);
			expect(state.isIndexing).toBe(false);
			expect(state.progress).toBe(0);
			expect(state.message).toBe('Ready to start indexing...');
			expect(state.filesProcessed).toBe(0);
			expect(state.totalFiles).toBe(0);
			expect(state.currentFile).toBe('');
		});

		it('should start indexing', () => {
			const beforeTime = Date.now();
			indexingActions.startIndexing();
			const afterTime = Date.now();
			
			const state = get(indexingState);
			expect(state.isIndexing).toBe(true);
			expect(state.progress).toBe(0);
			expect(state.message).toBe('Starting indexing process...');
			expect(state.stats.startTime).toBeInstanceOf(Date);
			expect(state.stats.startTime!.getTime()).toBeGreaterThanOrEqual(beforeTime);
			expect(state.stats.startTime!.getTime()).toBeLessThanOrEqual(afterTime);
		});

		it('should update progress', () => {
			indexingActions.updateProgress(50, 'Processing files...', 25, 50, 'test.js');
			
			const state = get(indexingState);
			expect(state.progress).toBe(50);
			expect(state.message).toBe('Processing files...');
			expect(state.filesProcessed).toBe(25);
			expect(state.totalFiles).toBe(50);
			expect(state.currentFile).toBe('test.js');
		});

		it('should complete indexing successfully', () => {
			indexingActions.startIndexing();
			indexingActions.completeIndexing(true, 100);
			
			const state = get(indexingState);
			expect(state.isIndexing).toBe(false);
			expect(state.progress).toBe(100);
			expect(state.message).toBe('Indexing completed successfully!');
			expect(state.totalFiles).toBe(100);
		});

		it('should handle indexing failure', () => {
			indexingActions.startIndexing();
			indexingActions.completeIndexing(false);
			
			const state = get(indexingState);
			expect(state.isIndexing).toBe(false);
			expect(state.message).toBe('Indexing failed.');
		});

		it('should stop indexing', () => {
			indexingActions.startIndexing();
			indexingActions.stopIndexing();
			
			const state = get(indexingState);
			expect(state.isIndexing).toBe(false);
			expect(state.message).toBe('Indexing stopped by user.');
		});
	});

	describe('searchState', () => {
		it('should have correct initial state', () => {
			const state = get(searchState);
			expect(state.query).toBe('');
			expect(state.isSearching).toBe(false);
			expect(state.results).toEqual([]);
			expect(state.history).toEqual([]);
		});

		it('should set query', () => {
			searchActions.setQuery('test query');
			expect(get(searchState).query).toBe('test query');
		});

		it('should start search', () => {
			searchActions.setResults([{ id: '1', file: 'test.js', content: 'test', score: 0.9 }], {
				totalResults: 1,
				searchTime: 100,
				query: 'test'
			});
			
			searchActions.startSearch();
			const state = get(searchState);
			expect(state.isSearching).toBe(true);
			expect(state.results).toEqual([]);
		});

		it('should set search results and update history', () => {
			const results = [
				{ id: '1', file: 'test.js', content: 'test content', score: 0.9 },
				{ id: '2', file: 'app.js', content: 'app content', score: 0.8 }
			];
			const stats = {
				totalResults: 2,
				searchTime: 150,
				query: 'test query'
			};

			searchActions.setQuery('test query');
			searchActions.setResults(results, stats);
			
			const state = get(searchState);
			expect(state.isSearching).toBe(false);
			expect(state.results).toEqual(results);
			expect(state.stats).toEqual(stats);
			expect(state.history).toContain('test query');
		});

		it('should not duplicate queries in history', () => {
			searchActions.setQuery('test query');
			searchActions.setResults([], { totalResults: 0, searchTime: 100, query: 'test query' });
			searchActions.setResults([], { totalResults: 0, searchTime: 100, query: 'test query' });
			
			const state = get(searchState);
			expect(state.history.filter(q => q === 'test query')).toHaveLength(1);
		});

		it('should limit history to 10 items', () => {
			for (let i = 0; i < 15; i++) {
				searchActions.setQuery(`query ${i}`);
				searchActions.setResults([], { totalResults: 0, searchTime: 100, query: `query ${i}` });
			}
			
			const state = get(searchState);
			expect(state.history).toHaveLength(10);
			expect(state.history[0]).toBe('query 14'); // Most recent first
		});
	});

	describe('Derived Stores', () => {
		it('isSetupComplete should be true when both database and provider are ready', () => {
			expect(get(isSetupComplete)).toBe(false);
			
			setupActions.setDatabaseStatus('ready');
			expect(get(isSetupComplete)).toBe(false);
			
			setupActions.setProviderStatus('ready');
			expect(get(isSetupComplete)).toBe(true);
		});

		it('canStartIndexing should be true when setup is complete and not indexing', () => {
			expect(get(canStartIndexing)).toBe(false);
			
			setupActions.setDatabaseStatus('ready');
			setupActions.setProviderStatus('ready');
			expect(get(canStartIndexing)).toBe(true);
			
			indexingActions.startIndexing();
			expect(get(canStartIndexing)).toBe(false);
		});

		it('hasSearchResults should reflect search results state', () => {
			expect(get(hasSearchResults)).toBe(false);
			
			searchActions.setResults([{ id: '1', file: 'test.js', content: 'test', score: 0.9 }], {
				totalResults: 1,
				searchTime: 100,
				query: 'test'
			});
			expect(get(hasSearchResults)).toBe(true);
		});

		it('currentError should return the first available error', () => {
			expect(get(currentError)).toBe(null);
			
			appActions.setError('App error');
			expect(get(currentError)).toBe('App error');
			
			appActions.clearError();
			setupActions.addSetupError('Setup error');
			expect(get(currentError)).toBe('Setup error');
		});
	});

	describe('resetAllState', () => {
		it('should reset all stores to initial state', () => {
			// Modify all stores
			appActions.initialize();
			appActions.setError('Test error');
			setupActions.setDatabaseStatus('ready');
			setupActions.setSelectedDatabase('qdrant');
			indexingActions.startIndexing();
			searchActions.setQuery('test');
			
			// Reset all state
			resetAllState();
			
			// Verify all stores are back to initial state
			expect(get(appState).isInitialized).toBe(false);
			expect(get(appState).error).toBe(null);
			expect(get(setupState).databaseStatus).toBe('idle');
			expect(get(setupState).selectedDatabase).toBe('');
			expect(get(indexingState).isIndexing).toBe(false);
			expect(get(searchState).query).toBe('');
		});
	});
});
</file>

<file path="webview/src/lib/stores/persistence.ts">
/**
 * State Persistence Utility
 * 
 * Handles saving and loading application state using VS Code's webview state API.
 * This ensures that the application state persists across webview reloads.
 */

import { getState, setState } from '$lib/vscodeApi';
import { 
    appState, 
    setupState, 
    indexingState, 
    searchState,
    type AppState,
    type SetupState,
    type IndexingState,
    type SearchState
} from './appStore';

// State keys for persistence
const STATE_KEYS = {
    APP: 'app',
    SETUP: 'setup',
    INDEXING: 'indexing',
    SEARCH: 'search'
} as const;

// Interface for persisted state
interface PersistedState {
    app?: Partial<AppState>;
    setup?: Partial<SetupState>;
    indexing?: Partial<IndexingState>;
    search?: Partial<SearchState>;
    version?: string;
    timestamp?: number;
}

// Current state version for migration purposes
const STATE_VERSION = '1.0.0';

/**
 * Save current application state to VS Code's webview state
 */
export function saveState(): void {
    try {
        // Get current state values
        let currentAppState: AppState;
        let currentSetupState: SetupState;
        let currentIndexingState: IndexingState;
        let currentSearchState: SearchState;

        // Subscribe to get current values
        const unsubscribeApp = appState.subscribe(state => currentAppState = state);
        const unsubscribeSetup = setupState.subscribe(state => currentSetupState = state);
        const unsubscribeIndexing = indexingState.subscribe(state => currentIndexingState = state);
        const unsubscribeSearch = searchState.subscribe(state => currentSearchState = state);

        // Clean up subscriptions immediately
        unsubscribeApp();
        unsubscribeSetup();
        unsubscribeIndexing();
        unsubscribeSearch();

        // Create persisted state object
        const persistedState: PersistedState = {
            app: {
                isInitialized: currentAppState!.isInitialized,
                error: null, // Don't persist errors
                lastActivity: currentAppState!.lastActivity
            },
            setup: {
                databaseStatus: currentSetupState!.databaseStatus,
                providerStatus: currentSetupState!.providerStatus,
                selectedDatabase: currentSetupState!.selectedDatabase,
                selectedProvider: currentSetupState!.selectedProvider,
                isSetupComplete: currentSetupState!.isSetupComplete,
                setupErrors: [] // Don't persist errors
            },
            indexing: {
                isIndexing: false, // Don't persist active indexing state
                progress: currentIndexingState!.progress,
                message: currentIndexingState!.message,
                filesProcessed: currentIndexingState!.filesProcessed,
                totalFiles: currentIndexingState!.totalFiles,
                currentFile: '', // Don't persist current file
                stats: {
                    ...currentIndexingState!.stats,
                    startTime: null // Don't persist start time
                }
            },
            search: {
                query: currentSearchState!.query,
                isSearching: false, // Don't persist active search state
                results: [], // Don't persist results (they may be stale)
                history: currentSearchState!.history,
                stats: currentSearchState!.stats
            },
            version: STATE_VERSION,
            timestamp: Date.now()
        };

        // Save to VS Code state
        setState(persistedState);
        
        console.log('State saved successfully');
    } catch (error) {
        console.error('Failed to save state:', error);
    }
}

/**
 * Load application state from VS Code's webview state
 */
export function loadState(): void {
    try {
        const persistedState = getState() as PersistedState | null;
        
        if (!persistedState) {
            console.log('No persisted state found, using defaults');
            return;
        }

        // Check version compatibility
        if (persistedState.version !== STATE_VERSION) {
            console.warn(`State version mismatch. Expected ${STATE_VERSION}, got ${persistedState.version}. Using defaults.`);
            return;
        }

        // Check if state is too old (older than 24 hours)
        const maxAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
        if (persistedState.timestamp && (Date.now() - persistedState.timestamp) > maxAge) {
            console.log('Persisted state is too old, using defaults');
            return;
        }

        // Restore app state
        if (persistedState.app) {
            appState.update(current => ({
                ...current,
                ...persistedState.app,
                isLoading: false, // Always start with loading false
                error: null // Never restore errors
            }));
        }

        // Restore setup state
        if (persistedState.setup) {
            setupState.update(current => ({
                ...current,
                ...persistedState.setup,
                setupErrors: [] // Never restore errors
            }));
        }

        // Restore indexing state
        if (persistedState.indexing) {
            indexingState.update(current => ({
                ...current,
                ...persistedState.indexing,
                isIndexing: false, // Never restore active indexing
                currentFile: '', // Don't restore current file
                stats: {
                    ...current.stats,
                    ...persistedState.indexing.stats,
                    startTime: null // Don't restore start time
                }
            }));
        }

        // Restore search state
        if (persistedState.search) {
            searchState.update(current => ({
                ...current,
                ...persistedState.search,
                isSearching: false, // Never restore active search
                results: [] // Don't restore stale results
            }));
        }

        console.log('State loaded successfully');
    } catch (error) {
        console.error('Failed to load state:', error);
    }
}

/**
 * Clear all persisted state
 */
export function clearPersistedState(): void {
    try {
        setState(null);
        console.log('Persisted state cleared');
    } catch (error) {
        console.error('Failed to clear persisted state:', error);
    }
}

/**
 * Set up automatic state saving
 * This will save state whenever any store changes
 */
export function setupAutoSave(): () => void {
    const unsubscribeFunctions: (() => void)[] = [];
    
    // Debounce save operations to avoid excessive saves
    let saveTimeout: NodeJS.Timeout | null = null;
    
    const debouncedSave = () => {
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        saveTimeout = setTimeout(() => {
            saveState();
            saveTimeout = null;
        }, 1000); // Save 1 second after last change
    };

    // Subscribe to all stores
    unsubscribeFunctions.push(
        appState.subscribe(debouncedSave),
        setupState.subscribe(debouncedSave),
        indexingState.subscribe(debouncedSave),
        searchState.subscribe(debouncedSave)
    );

    // Return cleanup function
    return () => {
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
    };
}

/**
 * Initialize persistence system
 * Call this once when the application starts
 */
export function initializePersistence(): () => void {
    // Load existing state
    loadState();
    
    // Set up auto-save
    const cleanupAutoSave = setupAutoSave();
    
    // Save state when the page is about to unload
    const handleBeforeUnload = () => {
        saveState();
    };
    
    if (typeof window !== 'undefined') {
        window.addEventListener('beforeunload', handleBeforeUnload);
    }
    
    // Return cleanup function
    return () => {
        cleanupAutoSave();
        if (typeof window !== 'undefined') {
            window.removeEventListener('beforeunload', handleBeforeUnload);
        }
    };
}
</file>

<file path="webview/src/lib/utils/animations.ts">
/**
 * Animation Utilities
 * 
 * Provides smooth, performant animations and transitions for the application.
 * Uses CSS transforms and will-change properties for optimal performance.
 */

// Animation configuration
export interface AnimationConfig {
    duration?: number;
    easing?: string;
    delay?: number;
    fill?: 'none' | 'forwards' | 'backwards' | 'both';
}

// Default animation settings
export const DEFAULT_ANIMATION: AnimationConfig = {
    duration: 300,
    easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    delay: 0,
    fill: 'both'
};

// Easing functions
export const EASINGS = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'cubic-bezier(0.4, 0.0, 1, 1)',
    easeOut: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
    easeInOut: 'cubic-bezier(0.4, 0.0, 0.2, 1)',
    bounceIn: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
    bounceOut: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
    spring: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)'
} as const;

/**
 * Fade in animation
 */
export function fadeIn(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    // Optimize for performance
    element.style.willChange = 'opacity';
    
    const animation = element.animate([
        { opacity: 0 },
        { opacity: 1 }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    // Clean up will-change after animation
    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Fade out animation
 */
export function fadeOut(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    element.style.willChange = 'opacity';
    
    const animation = element.animate([
        { opacity: 1 },
        { opacity: 0 }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Slide in from top animation
 */
export function slideInFromTop(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    element.style.willChange = 'transform, opacity';
    
    const animation = element.animate([
        { 
            transform: 'translateY(-20px)',
            opacity: 0
        },
        { 
            transform: 'translateY(0)',
            opacity: 1
        }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Slide in from bottom animation
 */
export function slideInFromBottom(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    element.style.willChange = 'transform, opacity';
    
    const animation = element.animate([
        { 
            transform: 'translateY(20px)',
            opacity: 0
        },
        { 
            transform: 'translateY(0)',
            opacity: 1
        }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Scale in animation
 */
export function scaleIn(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    element.style.willChange = 'transform, opacity';
    
    const animation = element.animate([
        { 
            transform: 'scale(0.9)',
            opacity: 0
        },
        { 
            transform: 'scale(1)',
            opacity: 1
        }
    ], {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Pulse animation for loading states
 */
export function pulse(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration = 1000, easing = EASINGS.easeInOut } = config;
    
    element.style.willChange = 'opacity';
    
    const animation = element.animate([
        { opacity: 1 },
        { opacity: 0.5 },
        { opacity: 1 }
    ], {
        duration,
        easing,
        iterations: Infinity
    });

    return animation;
}

/**
 * Shake animation for errors
 */
export function shake(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration = 500, easing = EASINGS.easeInOut } = config;
    
    element.style.willChange = 'transform';
    
    const animation = element.animate([
        { transform: 'translateX(0)' },
        { transform: 'translateX(-10px)' },
        { transform: 'translateX(10px)' },
        { transform: 'translateX(-10px)' },
        { transform: 'translateX(10px)' },
        { transform: 'translateX(0)' }
    ], {
        duration,
        easing
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Bounce animation for success states
 */
export function bounce(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration = 600, easing = EASINGS.bounceOut } = config;
    
    element.style.willChange = 'transform';
    
    const animation = element.animate([
        { transform: 'scale(1)' },
        { transform: 'scale(1.1)' },
        { transform: 'scale(0.95)' },
        { transform: 'scale(1.05)' },
        { transform: 'scale(1)' }
    ], {
        duration,
        easing
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Progress bar animation
 */
export function animateProgress(element: HTMLElement, fromPercent: number, toPercent: number, config: AnimationConfig = {}): Animation {
    const { duration = 500, easing = EASINGS.easeOut } = config;
    
    element.style.willChange = 'width';
    
    const animation = element.animate([
        { width: `${fromPercent}%` },
        { width: `${toPercent}%` }
    ], {
        duration,
        easing,
        fill: 'forwards'
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Stagger animations for lists
 */
export function staggerIn(elements: HTMLElement[], config: AnimationConfig = {}): Animation[] {
    const { delay = 0 } = config;
    const staggerDelay = 100; // 100ms between each element
    
    return elements.map((element, index) => {
        return slideInFromBottom(element, {
            ...config,
            delay: delay + (index * staggerDelay)
        });
    });
}

/**
 * Create a smooth transition between two states
 */
export function transition(
    element: HTMLElement,
    fromStyles: Partial<CSSStyleDeclaration>,
    toStyles: Partial<CSSStyleDeclaration>,
    config: AnimationConfig = {}
): Animation {
    const { duration, easing, delay, fill } = { ...DEFAULT_ANIMATION, ...config };
    
    // Set will-change for all properties that will be animated
    const properties = Object.keys(toStyles);
    element.style.willChange = properties.join(', ');
    
    const keyframes = [fromStyles, toStyles];
    
    const animation = element.animate(keyframes, {
        duration,
        easing,
        delay,
        fill
    });

    animation.addEventListener('finish', () => {
        element.style.willChange = 'auto';
    });

    return animation;
}

/**
 * Create a loading spinner animation
 */
export function spin(element: HTMLElement, config: AnimationConfig = {}): Animation {
    const { duration = 1000, easing = EASINGS.linear } = config;
    
    element.style.willChange = 'transform';
    
    const animation = element.animate([
        { transform: 'rotate(0deg)' },
        { transform: 'rotate(360deg)' }
    ], {
        duration,
        easing,
        iterations: Infinity
    });

    return animation;
}

/**
 * Animate element entrance based on intersection observer
 */
export function animateOnIntersection(
    element: HTMLElement,
    animationFunction: (el: HTMLElement) => Animation,
    options: IntersectionObserverInit = {}
): IntersectionObserver {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                animationFunction(entry.target as HTMLElement);
                observer.unobserve(entry.target);
            }
        });
    }, {
        threshold: 0.1,
        ...options
    });

    observer.observe(element);
    return observer;
}

/**
 * Prefers reduced motion check
 */
export function prefersReducedMotion(): boolean {
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
}

/**
 * Animate with respect to user preferences
 */
export function respectfulAnimate(
    element: HTMLElement,
    animationFunction: (el: HTMLElement, config?: AnimationConfig) => Animation,
    config: AnimationConfig = {}
): Animation | null {
    if (prefersReducedMotion()) {
        // Skip animation or use a very fast one
        return animationFunction(element, { ...config, duration: 0 });
    }
    
    return animationFunction(element, config);
}
</file>

<file path="webview/src/lib/utils/connectionTesting.ts">
/**
 * Connection Testing Utilities
 * 
 * Provides functionality to test database and provider connections
 * with real-time feedback and validation.
 */

import { postMessage } from '$lib/vscodeApi';
import type { ValidationResult } from './validation';

// Connection test result interface
export interface ConnectionTestResult {
    success: boolean;
    message: string;
    details?: string;
    latency?: number;
    version?: string;
    capabilities?: string[];
}

// Connection test status
export type ConnectionTestStatus = 'idle' | 'testing' | 'success' | 'error';

// Database configuration for testing
export interface DatabaseTestConfig {
    type: 'qdrant' | 'chromadb' | 'pinecone';
    host?: string;
    port?: number;
    apiKey?: string;
    environment?: string;
    collection?: string;
}

// Provider configuration for testing
export interface ProviderTestConfig {
    type: 'ollama' | 'openai' | 'azure';
    apiKey?: string;
    endpoint?: string;
    model?: string;
}

/**
 * Test database connection
 */
export async function testDatabaseConnection(config: DatabaseTestConfig): Promise<ConnectionTestResult> {
    const startTime = Date.now();
    
    try {
        // Send test request to extension
        const response = await sendConnectionTestRequest('testDatabase', config);
        const latency = Date.now() - startTime;
        
        if (response.success) {
            return {
                success: true,
                message: `Successfully connected to ${config.type}`,
                details: response.details || `Connection established in ${latency}ms`,
                latency,
                version: response.version,
                capabilities: response.capabilities
            };
        } else {
            return {
                success: false,
                message: response.message || `Failed to connect to ${config.type}`,
                details: response.details
            };
        }
    } catch (error) {
        return {
            success: false,
            message: `Connection test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            details: 'Please check your configuration and try again'
        };
    }
}

/**
 * Test provider connection
 */
export async function testProviderConnection(config: ProviderTestConfig): Promise<ConnectionTestResult> {
    const startTime = Date.now();
    
    try {
        // Send test request to extension
        const response = await sendConnectionTestRequest('testProvider', config);
        const latency = Date.now() - startTime;
        
        if (response.success) {
            return {
                success: true,
                message: `Successfully connected to ${config.type}`,
                details: response.details || `Connection established in ${latency}ms`,
                latency,
                version: response.version,
                capabilities: response.capabilities
            };
        } else {
            return {
                success: false,
                message: response.message || `Failed to connect to ${config.type}`,
                details: response.details
            };
        }
    } catch (error) {
        return {
            success: false,
            message: `Connection test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            details: 'Please check your configuration and try again'
        };
    }
}

/**
 * Send connection test request to extension
 */
async function sendConnectionTestRequest(command: string, config: any): Promise<any> {
    return new Promise((resolve, reject) => {
        const requestId = generateRequestId();
        const timeout = setTimeout(() => {
            reject(new Error('Connection test timed out'));
        }, 30000); // 30 second timeout

        // Listen for response
        const handleMessage = (event: MessageEvent) => {
            const message = event.data;
            if (message.command === `${command}Response` && message.requestId === requestId) {
                clearTimeout(timeout);
                window.removeEventListener('message', handleMessage);
                resolve(message);
            }
        };

        window.addEventListener('message', handleMessage);

        // Send request
        postMessage(command, {
            requestId,
            config
        });
    });
}

/**
 * Generate unique request ID
 */
function generateRequestId(): string {
    return `test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Convert connection test result to validation result
 */
export function connectionTestToValidation(testResult: ConnectionTestResult): ValidationResult {
    if (testResult.success) {
        const suggestions: string[] = [];
        
        if (testResult.latency && testResult.latency > 1000) {
            suggestions.push('Connection latency is high. Consider using a closer server.');
        }
        
        if (testResult.capabilities && testResult.capabilities.length > 0) {
            suggestions.push(`Available features: ${testResult.capabilities.join(', ')}`);
        }

        return {
            isValid: true,
            errors: [],
            warnings: [],
            suggestions: [
                testResult.message,
                ...(testResult.details ? [testResult.details] : []),
                ...suggestions
            ]
        };
    } else {
        return {
            isValid: false,
            errors: [testResult.message],
            warnings: [],
            suggestions: testResult.details ? [testResult.details] : []
        };
    }
}

/**
 * Create a validator that includes connection testing
 */
export function createConnectionValidator<T extends DatabaseTestConfig | ProviderTestConfig>(
    testFunction: (config: T) => Promise<ConnectionTestResult>,
    baseValidator?: (config: T) => ValidationResult
): (config: T) => Promise<ValidationResult> {
    return async (config: T): Promise<ValidationResult> => {
        // First run base validation if provided
        if (baseValidator) {
            const baseResult = baseValidator(config);
            if (!baseResult.isValid) {
                return baseResult;
            }
        }

        // Then run connection test
        try {
            const testResult = await testFunction(config);
            return connectionTestToValidation(testResult);
        } catch (error) {
            return {
                isValid: false,
                errors: [`Connection test failed: ${error instanceof Error ? error.message : 'Unknown error'}`],
                warnings: [],
                suggestions: ['Please check your configuration and network connection']
            };
        }
    };
}

/**
 * Debounced connection tester
 */
export function createDebouncedConnectionTester<T>(
    testFunction: (config: T) => Promise<ConnectionTestResult>,
    delay: number = 2000
): (config: T) => Promise<ConnectionTestResult> {
    let timeoutId: NodeJS.Timeout;
    let currentPromise: Promise<ConnectionTestResult> | null = null;
    
    return (config: T): Promise<ConnectionTestResult> => {
        // Cancel previous test
        if (timeoutId) {
            clearTimeout(timeoutId);
        }

        // Return existing promise if still running
        if (currentPromise) {
            return currentPromise;
        }

        return new Promise((resolve, reject) => {
            timeoutId = setTimeout(async () => {
                try {
                    currentPromise = testFunction(config);
                    const result = await currentPromise;
                    currentPromise = null;
                    resolve(result);
                } catch (error) {
                    currentPromise = null;
                    reject(error);
                }
            }, delay);
        });
    };
}

/**
 * Quick connection health check
 */
export async function quickHealthCheck(type: 'database' | 'provider', config: any): Promise<boolean> {
    try {
        const command = type === 'database' ? 'quickDatabaseCheck' : 'quickProviderCheck';
        const response = await sendConnectionTestRequest(command, config);
        return response.success === true;
    } catch {
        return false;
    }
}

/**
 * Batch connection test for multiple configurations
 */
export async function batchConnectionTest(
    tests: Array<{
        name: string;
        type: 'database' | 'provider';
        config: DatabaseTestConfig | ProviderTestConfig;
    }>
): Promise<Array<{ name: string; result: ConnectionTestResult }>> {
    const results = await Promise.allSettled(
        tests.map(async (test) => {
            const result = test.type === 'database' 
                ? await testDatabaseConnection(test.config as DatabaseTestConfig)
                : await testProviderConnection(test.config as ProviderTestConfig);
            
            return { name: test.name, result };
        })
    );

    return results.map((result, index) => {
        if (result.status === 'fulfilled') {
            return result.value;
        } else {
            return {
                name: tests[index].name,
                result: {
                    success: false,
                    message: 'Test failed to execute',
                    details: result.reason?.message || 'Unknown error'
                }
            };
        }
    });
}
</file>

<file path="webview/src/lib/utils/fluentUI.ts">
/**
 * Centralized Fluent UI Configuration
 * 
 * This file centralizes all Fluent UI component imports and registration
 * to optimize bundle size through tree-shaking and avoid duplicate registrations.
 */

import { 
    provideFluentDesignSystem,
    fluentButton,
    fluentTextField,
    fluentSelect,
    fluentOption,
    fluentProgressRing,
    fluentCard,
    fluentBadge,
    fluentAccordion,
    fluentAccordionItem
} from '@fluentui/web-components';

// Track which components have been registered to avoid duplicates
const registeredComponents = new Set<string>();

/**
 * Register core Fluent UI components that are used across the application
 */
export function registerCoreComponents(): void {
    if (registeredComponents.has('core')) return;

    const designSystem = provideFluentDesignSystem();
    
    designSystem.register(
        fluentButton(),
        fluentTextField(),
        fluentCard(),
        fluentProgressRing()
    );

    registeredComponents.add('core');
}

/**
 * Register form-related Fluent UI components
 */
export function registerFormComponents(): void {
    if (registeredComponents.has('form')) return;

    const designSystem = provideFluentDesignSystem();
    
    designSystem.register(
        fluentSelect(),
        fluentOption()
    );

    registeredComponents.add('form');
}

/**
 * Register display-related Fluent UI components
 */
export function registerDisplayComponents(): void {
    if (registeredComponents.has('display')) return;

    const designSystem = provideFluentDesignSystem();
    
    designSystem.register(
        fluentBadge(),
        fluentAccordion(),
        fluentAccordionItem()
    );

    registeredComponents.add('display');
}

/**
 * Register all Fluent UI components at once
 * Use this for components that need all features
 */
export function registerAllComponents(): void {
    registerCoreComponents();
    registerFormComponents();
    registerDisplayComponents();
}

/**
 * Get the design system instance
 */
export function getDesignSystem() {
    return provideFluentDesignSystem();
}

/**
 * Check if a component group has been registered
 */
export function isRegistered(componentGroup: 'core' | 'form' | 'display'): boolean {
    return registeredComponents.has(componentGroup);
}

/**
 * Reset registration tracking (useful for testing)
 */
export function resetRegistrations(): void {
    registeredComponents.clear();
}
</file>

<file path="webview/src/lib/utils/performance.ts">
/**
 * Performance Monitoring Utilities
 * 
 * Provides tools for monitoring and optimizing application performance,
 * including component loading times, render performance, and user interactions.
 */

// Performance metrics interface
export interface PerformanceMetric {
    name: string;
    startTime: number;
    endTime?: number;
    duration?: number;
    metadata?: Record<string, any>;
}

// Performance tracker class
class PerformanceTracker {
    private metrics: Map<string, PerformanceMetric> = new Map();
    private observers: PerformanceObserver[] = [];
    private isEnabled: boolean = true;

    constructor() {
        this.setupObservers();
    }

    /**
     * Start tracking a performance metric
     */
    start(name: string, metadata?: Record<string, any>): void {
        if (!this.isEnabled) return;

        const metric: PerformanceMetric = {
            name,
            startTime: performance.now(),
            metadata
        };

        this.metrics.set(name, metric);
        
        // Mark the start in the browser's performance timeline
        if (performance.mark) {
            performance.mark(`${name}-start`);
        }
    }

    /**
     * End tracking a performance metric
     */
    end(name: string): PerformanceMetric | null {
        if (!this.isEnabled) return null;

        const metric = this.metrics.get(name);
        if (!metric) {
            console.warn(`Performance metric '${name}' was not started`);
            return null;
        }

        metric.endTime = performance.now();
        metric.duration = metric.endTime - metric.startTime;

        // Mark the end and measure in the browser's performance timeline
        if (performance.mark && performance.measure) {
            performance.mark(`${name}-end`);
            performance.measure(name, `${name}-start`, `${name}-end`);
        }

        // Log slow operations
        if (metric.duration > 1000) {
            console.warn(`Slow operation detected: ${name} took ${metric.duration.toFixed(2)}ms`);
        }

        return metric;
    }

    /**
     * Get a performance metric
     */
    get(name: string): PerformanceMetric | undefined {
        return this.metrics.get(name);
    }

    /**
     * Get all performance metrics
     */
    getAll(): PerformanceMetric[] {
        return Array.from(this.metrics.values());
    }

    /**
     * Clear all metrics
     */
    clear(): void {
        this.metrics.clear();
        
        if (performance.clearMarks) {
            performance.clearMarks();
        }
        if (performance.clearMeasures) {
            performance.clearMeasures();
        }
    }

    /**
     * Get performance summary
     */
    getSummary(): {
        totalMetrics: number;
        averageDuration: number;
        slowestOperation: PerformanceMetric | null;
        fastestOperation: PerformanceMetric | null;
    } {
        const completedMetrics = Array.from(this.metrics.values()).filter(m => m.duration !== undefined);
        
        if (completedMetrics.length === 0) {
            return {
                totalMetrics: 0,
                averageDuration: 0,
                slowestOperation: null,
                fastestOperation: null
            };
        }

        const durations = completedMetrics.map(m => m.duration!);
        const averageDuration = durations.reduce((sum, duration) => sum + duration, 0) / durations.length;
        
        const slowestOperation = completedMetrics.reduce((slowest, current) => 
            (current.duration! > slowest.duration!) ? current : slowest
        );
        
        const fastestOperation = completedMetrics.reduce((fastest, current) => 
            (current.duration! < fastest.duration!) ? current : fastest
        );

        return {
            totalMetrics: completedMetrics.length,
            averageDuration,
            slowestOperation,
            fastestOperation
        };
    }

    /**
     * Setup performance observers
     */
    private setupObservers(): void {
        if (typeof PerformanceObserver === 'undefined') return;

        try {
            // Observe navigation timing
            const navigationObserver = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'navigation') {
                        this.logNavigationTiming(entry as PerformanceNavigationTiming);
                    }
                }
            });
            navigationObserver.observe({ entryTypes: ['navigation'] });
            this.observers.push(navigationObserver);

            // Observe resource loading
            const resourceObserver = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'resource') {
                        this.logResourceTiming(entry as PerformanceResourceTiming);
                    }
                }
            });
            resourceObserver.observe({ entryTypes: ['resource'] });
            this.observers.push(resourceObserver);

            // Observe long tasks
            if ('longtask' in PerformanceObserver.supportedEntryTypes) {
                const longTaskObserver = new PerformanceObserver((list) => {
                    for (const entry of list.getEntries()) {
                        console.warn(`Long task detected: ${entry.duration.toFixed(2)}ms`);
                    }
                });
                longTaskObserver.observe({ entryTypes: ['longtask'] });
                this.observers.push(longTaskObserver);
            }
        } catch (error) {
            console.warn('Failed to setup performance observers:', error);
        }
    }

    /**
     * Log navigation timing
     */
    private logNavigationTiming(entry: PerformanceNavigationTiming): void {
        const metrics = {
            domContentLoaded: entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart,
            loadComplete: entry.loadEventEnd - entry.loadEventStart,
            domInteractive: entry.domInteractive - entry.navigationStart,
            firstPaint: 0,
            firstContentfulPaint: 0
        };

        // Get paint timings if available
        const paintEntries = performance.getEntriesByType('paint');
        for (const paintEntry of paintEntries) {
            if (paintEntry.name === 'first-paint') {
                metrics.firstPaint = paintEntry.startTime;
            } else if (paintEntry.name === 'first-contentful-paint') {
                metrics.firstContentfulPaint = paintEntry.startTime;
            }
        }

        console.log('Navigation Performance:', metrics);
    }

    /**
     * Log resource timing
     */
    private logResourceTiming(entry: PerformanceResourceTiming): void {
        // Only log slow resources
        if (entry.duration > 500) {
            console.warn(`Slow resource: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
        }
    }

    /**
     * Enable or disable performance tracking
     */
    setEnabled(enabled: boolean): void {
        this.isEnabled = enabled;
    }

    /**
     * Cleanup observers
     */
    destroy(): void {
        this.observers.forEach(observer => observer.disconnect());
        this.observers = [];
        this.clear();
    }
}

// Global performance tracker instance
export const performanceTracker = new PerformanceTracker();

/**
 * Decorator for measuring function performance
 */
export function measurePerformance(name?: string) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        const metricName = name || `${target.constructor.name}.${propertyKey}`;

        descriptor.value = function (...args: any[]) {
            performanceTracker.start(metricName);
            
            try {
                const result = originalMethod.apply(this, args);
                
                // Handle async functions
                if (result && typeof result.then === 'function') {
                    return result.finally(() => {
                        performanceTracker.end(metricName);
                    });
                } else {
                    performanceTracker.end(metricName);
                    return result;
                }
            } catch (error) {
                performanceTracker.end(metricName);
                throw error;
            }
        };

        return descriptor;
    };
}

/**
 * Measure component loading time
 */
export function measureComponentLoad(componentName: string): {
    start: () => void;
    end: () => void;
} {
    const metricName = `component-load-${componentName}`;
    
    return {
        start: () => performanceTracker.start(metricName, { type: 'component-load', component: componentName }),
        end: () => performanceTracker.end(metricName)
    };
}

/**
 * Measure user interaction performance
 */
export function measureInteraction(interactionName: string, callback: () => void | Promise<void>): void {
    const metricName = `interaction-${interactionName}`;
    
    performanceTracker.start(metricName, { type: 'user-interaction', interaction: interactionName });
    
    try {
        const result = callback();
        
        if (result && typeof result.then === 'function') {
            result.finally(() => {
                performanceTracker.end(metricName);
            });
        } else {
            performanceTracker.end(metricName);
        }
    } catch (error) {
        performanceTracker.end(metricName);
        throw error;
    }
}

/**
 * Get performance insights
 */
export function getPerformanceInsights(): {
    summary: ReturnType<PerformanceTracker['getSummary']>;
    recommendations: string[];
} {
    const summary = performanceTracker.getSummary();
    const recommendations: string[] = [];

    // Analyze performance and provide recommendations
    if (summary.averageDuration > 100) {
        recommendations.push('Consider optimizing slow operations or implementing lazy loading');
    }

    if (summary.slowestOperation && summary.slowestOperation.duration! > 1000) {
        recommendations.push(`Optimize ${summary.slowestOperation.name} - it's taking ${summary.slowestOperation.duration!.toFixed(2)}ms`);
    }

    // Check for memory usage
    if (performance.memory) {
        const memoryUsage = (performance.memory as any).usedJSHeapSize / 1024 / 1024;
        if (memoryUsage > 50) {
            recommendations.push(`High memory usage detected: ${memoryUsage.toFixed(2)}MB`);
        }
    }

    return {
        summary,
        recommendations
    };
}

/**
 * Export performance data for analysis
 */
export function exportPerformanceData(): string {
    const data = {
        timestamp: new Date().toISOString(),
        metrics: performanceTracker.getAll(),
        summary: performanceTracker.getSummary(),
        insights: getPerformanceInsights(),
        userAgent: navigator.userAgent,
        url: window.location.href
    };

    return JSON.stringify(data, null, 2);
}
</file>

<file path="webview/src/lib/utils/validation.test.ts">
/**
 * Validation Utilities Unit Tests
 * 
 * Tests for the comprehensive validation system.
 */

import { describe, it, expect, vi } from 'vitest';
import {
	validators,
	validateDatabaseConfig,
	validateProviderConfig,
	createValidResult,
	createInvalidResult,
	combineValidationResults,
	createDebouncedValidator
} from './validation';

describe('Validation Utilities', () => {
	describe('Helper Functions', () => {
		it('should create valid result', () => {
			const result = createValidResult(['warning'], ['suggestion']);
			expect(result).toEqual({
				isValid: true,
				errors: [],
				warnings: ['warning'],
				suggestions: ['suggestion']
			});
		});

		it('should create invalid result', () => {
			const result = createInvalidResult(['error'], ['warning'], ['suggestion']);
			expect(result).toEqual({
				isValid: false,
				errors: ['error'],
				warnings: ['warning'],
				suggestions: ['suggestion']
			});
		});

		it('should combine validation results', () => {
			const result1 = createValidResult(['warning1']);
			const result2 = createInvalidResult(['error1']);
			const result3 = createValidResult([], ['suggestion1']);

			const combined = combineValidationResults(result1, result2, result3);
			expect(combined).toEqual({
				isValid: false,
				errors: ['error1'],
				warnings: ['warning1'],
				suggestions: ['suggestion1']
			});
		});
	});

	describe('Basic Validators', () => {
		describe('required', () => {
			it('should pass for non-empty values', () => {
				expect(validators.required('test')).toEqual(createValidResult());
				expect(validators.required(0)).toEqual(createValidResult());
				expect(validators.required(false)).toEqual(createValidResult());
			});

			it('should fail for empty values', () => {
				expect(validators.required('')).toEqual(createInvalidResult(['Field is required']));
				expect(validators.required(null)).toEqual(createInvalidResult(['Field is required']));
				expect(validators.required(undefined)).toEqual(createInvalidResult(['Field is required']));
			});

			it('should use custom field name', () => {
				const result = validators.required('', 'Username');
				expect(result.errors[0]).toBe('Username is required');
			});
		});

		describe('stringLength', () => {
			it('should pass for valid length strings', () => {
				expect(validators.stringLength('test', 1, 10)).toEqual(createValidResult());
				expect(validators.stringLength('hello', 5, 5)).toEqual(createValidResult());
			});

			it('should fail for strings that are too short', () => {
				const result = validators.stringLength('hi', 5, 10);
				expect(result.isValid).toBe(false);
				expect(result.errors[0]).toContain('at least 5 characters');
			});

			it('should fail for strings that are too long', () => {
				const result = validators.stringLength('this is a very long string', 1, 10);
				expect(result.isValid).toBe(false);
				expect(result.errors[0]).toContain('no more than 10 characters');
			});

			it('should fail for non-string values', () => {
				const result = validators.stringLength(123 as any, 1, 10);
				expect(result.isValid).toBe(false);
				expect(result.errors[0]).toContain('must be a string');
			});
		});

		describe('url', () => {
			it('should pass for valid URLs', () => {
				expect(validators.url('https://example.com')).toEqual(createValidResult());
				expect(validators.url('http://localhost:3000')).toEqual(createValidResult());
				expect(validators.url('ftp://files.example.com')).toEqual(createValidResult());
			});

			it('should pass for empty values (optional)', () => {
				expect(validators.url('')).toEqual(createValidResult());
			});

			it('should fail for invalid URLs', () => {
				expect(validators.url('not-a-url').isValid).toBe(false);
				expect(validators.url('http://').isValid).toBe(false);
				expect(validators.url('just-text').isValid).toBe(false);
			});
		});

		describe('port', () => {
			it('should pass for valid port numbers', () => {
				expect(validators.port(80)).toEqual(createValidResult());
				expect(validators.port('3000')).toEqual(createValidResult());
				expect(validators.port(65535)).toEqual(createValidResult());
			});

			it('should fail for invalid port numbers', () => {
				expect(validators.port(0).isValid).toBe(false);
				expect(validators.port(65536).isValid).toBe(false);
				expect(validators.port(-1).isValid).toBe(false);
				expect(validators.port('not-a-number').isValid).toBe(false);
			});
		});

		describe('apiKey', () => {
			it('should pass for valid API keys', () => {
				expect(validators.apiKey('sk-1234567890abcdef')).toEqual(
					expect.objectContaining({ isValid: true })
				);
				expect(validators.apiKey('valid-api-key-123')).toEqual(
					expect.objectContaining({ isValid: true })
				);
			});

			it('should fail for invalid API keys', () => {
				expect(validators.apiKey('').isValid).toBe(false);
				expect(validators.apiKey('key with spaces').isValid).toBe(false);
				expect(validators.apiKey('your-api-key').isValid).toBe(false);
				expect(validators.apiKey('placeholder').isValid).toBe(false);
			});

			it('should provide warnings for short keys', () => {
				const result = validators.apiKey('short');
				expect(result.warnings).toContain('API Key seems unusually short');
			});

			it('should provide security suggestions', () => {
				const result = validators.apiKey('my-secret-key');
				expect(result.suggestions).toContain('Ensure this API key is kept secure and not shared');
			});
		});

		describe('searchQuery', () => {
			it('should pass for valid search queries', () => {
				expect(validators.searchQuery('function test')).toEqual(
					expect.objectContaining({ isValid: true })
				);
				expect(validators.searchQuery('class Component')).toEqual(
					expect.objectContaining({ isValid: true })
				);
			});

			it('should fail for empty queries', () => {
				expect(validators.searchQuery('').isValid).toBe(false);
				expect(validators.searchQuery('   ').isValid).toBe(false);
			});

			it('should provide warnings for short queries', () => {
				const result = validators.searchQuery('ab');
				expect(result.warnings).toContain('Very short queries may not return meaningful results');
			});

			it('should provide warnings for very long queries', () => {
				const longQuery = 'a'.repeat(600);
				const result = validators.searchQuery(longQuery);
				expect(result.warnings).toContain('Very long queries may be truncated');
			});

			it('should provide suggestions for single word queries', () => {
				const result = validators.searchQuery('function');
				expect(result.suggestions).toContain('Try using multiple words or phrases for better results');
			});
		});
	});

	describe('Database Configuration Validation', () => {
		describe('Qdrant', () => {
			it('should pass for valid Qdrant config', () => {
				const config = {
					type: 'qdrant' as const,
					host: 'localhost',
					port: 6333
				};
				const result = validateDatabaseConfig(config);
				expect(result.isValid).toBe(true);
			});

			it('should provide default port suggestion', () => {
				const config = {
					type: 'qdrant' as const,
					host: 'localhost'
				};
				const result = validateDatabaseConfig(config);
				expect(result.suggestions).toContain('Default port 6333 will be used');
			});
		});

		describe('ChromaDB', () => {
			it('should pass for valid ChromaDB config', () => {
				const config = {
					type: 'chromadb' as const,
					host: 'localhost',
					port: 8000
				};
				const result = validateDatabaseConfig(config);
				expect(result.isValid).toBe(true);
			});
		});

		describe('Pinecone', () => {
			it('should require API key and environment', () => {
				const config = {
					type: 'pinecone' as const
				};
				const result = validateDatabaseConfig(config);
				expect(result.isValid).toBe(false);
				expect(result.errors).toContain('API Key is required');
				expect(result.errors).toContain('Environment is required');
			});

			it('should pass for valid Pinecone config', () => {
				const config = {
					type: 'pinecone' as const,
					apiKey: 'valid-api-key-123',
					environment: 'us-west1-gcp'
				};
				const result = validateDatabaseConfig(config);
				expect(result.isValid).toBe(true);
			});
		});

		it('should fail for missing database type', () => {
			const config = {};
			const result = validateDatabaseConfig(config as any);
			expect(result.isValid).toBe(false);
			expect(result.errors).toContain('Database type is required');
		});

		it('should fail for invalid database type', () => {
			const config = { type: 'invalid' };
			const result = validateDatabaseConfig(config as any);
			expect(result.isValid).toBe(false);
			expect(result.errors).toContain('Invalid database type');
		});
	});

	describe('Provider Configuration Validation', () => {
		describe('Ollama', () => {
			it('should pass for valid Ollama config', () => {
				const config = {
					type: 'ollama' as const,
					endpoint: 'http://localhost:11434',
					model: 'nomic-embed-text'
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(true);
			});

			it('should provide default endpoint suggestion', () => {
				const config = {
					type: 'ollama' as const
				};
				const result = validateProviderConfig(config);
				expect(result.suggestions).toContain('Default endpoint http://localhost:11434 will be used');
			});
		});

		describe('OpenAI', () => {
			it('should require API key', () => {
				const config = {
					type: 'openai' as const
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(false);
				expect(result.errors).toContain('OpenAI API Key is required');
			});

			it('should validate API key format', () => {
				const config = {
					type: 'openai' as const,
					apiKey: 'invalid-key'
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(false);
				expect(result.errors).toContain('OpenAI API keys should start with "sk-"');
			});

			it('should pass for valid OpenAI config', () => {
				const config = {
					type: 'openai' as const,
					apiKey: 'sk-1234567890abcdef',
					model: 'text-embedding-ada-002'
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(true);
			});
		});

		describe('Azure', () => {
			it('should require API key and endpoint', () => {
				const config = {
					type: 'azure' as const
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(false);
				expect(result.errors).toContain('Azure API Key is required');
				expect(result.errors).toContain('Azure Endpoint is required');
			});

			it('should validate Azure endpoint format', () => {
				const config = {
					type: 'azure' as const,
					apiKey: 'valid-key',
					endpoint: 'https://example.com'
				};
				const result = validateProviderConfig(config);
				expect(result.warnings).toContain('Endpoint doesn\'t appear to be an Azure OpenAI endpoint');
			});

			it('should pass for valid Azure config', () => {
				const config = {
					type: 'azure' as const,
					apiKey: 'valid-key',
					endpoint: 'https://my-resource.openai.azure.com/'
				};
				const result = validateProviderConfig(config);
				expect(result.isValid).toBe(true);
			});
		});
	});

	describe('Debounced Validator', () => {
		it('should debounce validation calls', async () => {
			const mockValidator = vi.fn(() => createValidResult());
			const debouncedValidator = createDebouncedValidator(mockValidator, 50);

			// Call multiple times quickly
			debouncedValidator('test1');
			debouncedValidator('test2');
			const finalResult = debouncedValidator('test3');

			// Wait for the final result
			await finalResult;

			// Wait a bit more to ensure debouncing worked
			await new Promise(resolve => setTimeout(resolve, 100));

			// Should only call the validator once with the last value
			expect(mockValidator).toHaveBeenCalledTimes(1);
			expect(mockValidator).toHaveBeenCalledWith('test3');
		});

		it('should handle validation errors', async () => {
			const mockValidator = vi.fn(() => {
				throw new Error('Validation failed');
			});
			const debouncedValidator = createDebouncedValidator(mockValidator, 10);

			// The debounced validator should catch errors and return invalid result
			const result = await debouncedValidator('test');
			expect(result.isValid).toBe(false);
			expect(result.errors[0]).toContain('Validation failed');
		});
	});
});
</file>

<file path="webview/src/lib/utils/validation.ts">
/**
 * Comprehensive Validation Utilities
 * 
 * Provides validation functions for all user inputs in the Code Context Engine.
 * Includes database connections, provider configurations, search queries, and more.
 */

// Validation result interface
export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings: string[];
    suggestions: string[];
}

// Validation rule interface
export interface ValidationRule<T = any> {
    name: string;
    validate: (value: T) => ValidationResult;
    required?: boolean;
    async?: boolean;
}

// Database configuration interfaces
export interface DatabaseConfig {
    type: 'qdrant' | 'chromadb' | 'pinecone';
    host?: string;
    port?: number;
    apiKey?: string;
    environment?: string;
    collection?: string;
}

export interface ProviderConfig {
    type: 'ollama' | 'openai' | 'azure';
    apiKey?: string;
    endpoint?: string;
    model?: string;
    temperature?: number;
    maxTokens?: number;
}

/**
 * Create a successful validation result
 */
export function createValidResult(warnings: string[] = [], suggestions: string[] = []): ValidationResult {
    return {
        isValid: true,
        errors: [],
        warnings,
        suggestions
    };
}

/**
 * Create a failed validation result
 */
export function createInvalidResult(errors: string[], warnings: string[] = [], suggestions: string[] = []): ValidationResult {
    return {
        isValid: false,
        errors,
        warnings,
        suggestions
    };
}

/**
 * Combine multiple validation results
 */
export function combineValidationResults(...results: ValidationResult[]): ValidationResult {
    const combined: ValidationResult = {
        isValid: true,
        errors: [],
        warnings: [],
        suggestions: []
    };

    for (const result of results) {
        if (!result.isValid) {
            combined.isValid = false;
        }
        combined.errors.push(...result.errors);
        combined.warnings.push(...result.warnings);
        combined.suggestions.push(...result.suggestions);
    }

    return combined;
}

// Basic validation functions
export const validators = {
    /**
     * Validate that a value is not empty
     */
    required: (value: any, fieldName: string = 'Field'): ValidationResult => {
        if (value === null || value === undefined || value === '') {
            return createInvalidResult([`${fieldName} is required`]);
        }
        return createValidResult();
    },

    /**
     * Validate string length
     */
    stringLength: (value: string, min: number = 0, max: number = Infinity, fieldName: string = 'Field'): ValidationResult => {
        if (typeof value !== 'string') {
            return createInvalidResult([`${fieldName} must be a string`]);
        }

        const length = value.length;
        const errors: string[] = [];

        if (length < min) {
            errors.push(`${fieldName} must be at least ${min} characters long`);
        }
        if (length > max) {
            errors.push(`${fieldName} must be no more than ${max} characters long`);
        }

        return errors.length > 0 ? createInvalidResult(errors) : createValidResult();
    },

    /**
     * Validate URL format
     */
    url: (value: string, fieldName: string = 'URL'): ValidationResult => {
        if (!value) {
            return createValidResult();
        }

        try {
            new URL(value);
            return createValidResult();
        } catch {
            return createInvalidResult([`${fieldName} must be a valid URL`]);
        }
    },

    /**
     * Validate port number
     */
    port: (value: number | string, fieldName: string = 'Port'): ValidationResult => {
        const port = typeof value === 'string' ? parseInt(value, 10) : value;
        
        if (isNaN(port)) {
            return createInvalidResult([`${fieldName} must be a valid number`]);
        }

        if (port < 1 || port > 65535) {
            return createInvalidResult([`${fieldName} must be between 1 and 65535`]);
        }

        return createValidResult();
    },

    /**
     * Validate API key format
     */
    apiKey: (value: string, fieldName: string = 'API Key'): ValidationResult => {
        if (!value) {
            return createInvalidResult([`${fieldName} is required`]);
        }

        const warnings: string[] = [];
        const suggestions: string[] = [];

        // Check for common API key patterns
        if (value.length < 10) {
            warnings.push(`${fieldName} seems unusually short`);
        }

        if (value.includes(' ')) {
            return createInvalidResult([`${fieldName} should not contain spaces`]);
        }

        if (value === 'your-api-key' || value === 'placeholder' || value === 'test') {
            return createInvalidResult([`Please enter a valid ${fieldName}`]);
        }

        // Check for potential security issues
        if (value.toLowerCase().includes('key') || value.toLowerCase().includes('secret')) {
            suggestions.push('Ensure this API key is kept secure and not shared');
        }

        return createValidResult(warnings, suggestions);
    },

    /**
     * Validate search query
     */
    searchQuery: (value: string, fieldName: string = 'Search query'): ValidationResult => {
        if (!value || !value.trim()) {
            return createInvalidResult([`${fieldName} cannot be empty`]);
        }

        const trimmed = value.trim();
        const warnings: string[] = [];
        const suggestions: string[] = [];

        if (trimmed.length < 3) {
            warnings.push('Very short queries may not return meaningful results');
        }

        if (trimmed.length > 500) {
            warnings.push('Very long queries may be truncated');
        }

        // Check for potentially problematic characters
        if (/[<>{}[\]\\]/.test(trimmed)) {
            warnings.push('Special characters in queries may affect search results');
        }

        // Provide helpful suggestions
        if (trimmed.split(' ').length === 1) {
            suggestions.push('Try using multiple words or phrases for better results');
        }

        return createValidResult(warnings, suggestions);
    }
};

// Database-specific validation
export const databaseValidators = {
    /**
     * Validate Qdrant configuration
     */
    qdrant: (config: Partial<DatabaseConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // Host validation
        if (config.host) {
            results.push(validators.url(`http://${config.host}`, 'Host'));
        }

        // Port validation
        if (config.port) {
            results.push(validators.port(config.port, 'Port'));
        } else {
            results.push(createValidResult([], ['Default port 6333 will be used']));
        }

        return combineValidationResults(...results);
    },

    /**
     * Validate ChromaDB configuration
     */
    chromadb: (config: Partial<DatabaseConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // Host validation
        if (config.host) {
            results.push(validators.url(`http://${config.host}`, 'Host'));
        }

        // Port validation
        if (config.port) {
            results.push(validators.port(config.port, 'Port'));
        } else {
            results.push(createValidResult([], ['Default port 8000 will be used']));
        }

        return combineValidationResults(...results);
    },

    /**
     * Validate Pinecone configuration
     */
    pinecone: (config: Partial<DatabaseConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // API key is required for Pinecone
        results.push(validators.required(config.apiKey, 'API Key'));
        if (config.apiKey) {
            results.push(validators.apiKey(config.apiKey, 'Pinecone API Key'));
        }

        // Environment validation
        results.push(validators.required(config.environment, 'Environment'));
        if (config.environment) {
            results.push(validators.stringLength(config.environment, 1, 50, 'Environment'));
        }

        return combineValidationResults(...results);
    }
};

// Provider-specific validation
export const providerValidators = {
    /**
     * Validate Ollama configuration
     */
    ollama: (config: Partial<ProviderConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // Endpoint validation (optional, defaults to localhost)
        if (config.endpoint) {
            results.push(validators.url(config.endpoint, 'Endpoint'));
        } else {
            results.push(createValidResult([], ['Default endpoint http://localhost:11434 will be used']));
        }

        // Model validation
        if (config.model) {
            results.push(validators.stringLength(config.model, 1, 100, 'Model'));
        } else {
            results.push(createValidResult([], ['Default model will be used']));
        }

        return combineValidationResults(...results);
    },

    /**
     * Validate OpenAI configuration
     */
    openai: (config: Partial<ProviderConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // API key is required
        results.push(validators.required(config.apiKey, 'OpenAI API Key'));
        if (config.apiKey) {
            results.push(validators.apiKey(config.apiKey, 'OpenAI API Key'));
            
            // OpenAI API keys have a specific format
            if (!config.apiKey.startsWith('sk-')) {
                results.push(createInvalidResult(['OpenAI API keys should start with "sk-"']));
            }
        }

        // Model validation
        if (config.model) {
            const validModels = ['text-embedding-ada-002', 'text-embedding-3-small', 'text-embedding-3-large'];
            if (!validModels.includes(config.model)) {
                results.push(createValidResult(['Unknown model specified'], [`Consider using one of: ${validModels.join(', ')}`]));
            }
        }

        return combineValidationResults(...results);
    },

    /**
     * Validate Azure OpenAI configuration
     */
    azure: (config: Partial<ProviderConfig>): ValidationResult => {
        const results: ValidationResult[] = [];

        // API key is required
        results.push(validators.required(config.apiKey, 'Azure API Key'));
        if (config.apiKey) {
            results.push(validators.apiKey(config.apiKey, 'Azure API Key'));
        }

        // Endpoint is required for Azure
        results.push(validators.required(config.endpoint, 'Azure Endpoint'));
        if (config.endpoint) {
            results.push(validators.url(config.endpoint, 'Azure Endpoint'));
            
            // Azure endpoints should contain 'openai.azure.com'
            if (!config.endpoint.includes('openai.azure.com')) {
                results.push(createValidResult(['Endpoint doesn\'t appear to be an Azure OpenAI endpoint'], ['Azure endpoints typically contain "openai.azure.com"']));
            }
        }

        return combineValidationResults(...results);
    }
};

/**
 * Validate complete database configuration
 */
export function validateDatabaseConfig(config: Partial<DatabaseConfig>): ValidationResult {
    if (!config.type) {
        return createInvalidResult(['Database type is required']);
    }

    switch (config.type) {
        case 'qdrant':
            return databaseValidators.qdrant(config);
        case 'chromadb':
            return databaseValidators.chromadb(config);
        case 'pinecone':
            return databaseValidators.pinecone(config);
        default:
            return createInvalidResult(['Invalid database type']);
    }
}

/**
 * Validate complete provider configuration
 */
export function validateProviderConfig(config: Partial<ProviderConfig>): ValidationResult {
    if (!config.type) {
        return createInvalidResult(['Provider type is required']);
    }

    switch (config.type) {
        case 'ollama':
            return providerValidators.ollama(config);
        case 'openai':
            return providerValidators.openai(config);
        case 'azure':
            return providerValidators.azure(config);
        default:
            return createInvalidResult(['Invalid provider type']);
    }
}

/**
 * Debounced validation function
 */
export function createDebouncedValidator<T>(
    validator: (value: T) => ValidationResult,
    delay: number = 300
): (value: T) => Promise<ValidationResult> {
    let timeoutId: NodeJS.Timeout;

    return (value: T): Promise<ValidationResult> => {
        return new Promise((resolve) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                try {
                    resolve(validator(value));
                } catch (error) {
                    resolve(createInvalidResult([
                        `Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
                    ]));
                }
            }, delay);
        });
    };
}
</file>

<file path="webview/src/lib/index.ts">
// place files you want to import through the `$lib` alias in this folder.
</file>

<file path="webview/src/routes/+layout.svelte">
<script lang="ts">
	import '../app.css';
	import favicon from '$lib/assets/favicon.svg';

	let { children } = $props();
</script>

<svelte:head>
	<link rel="icon" href={favicon} />
</svelte:head>

{@render children?.()}
</file>

<file path="webview/src/routes/page.svelte.spec.ts">
import { page } from '@vitest/browser/context';
import { describe, expect, it } from 'vitest';
import { render } from 'vitest-browser-svelte';
import Page from './+page.svelte';

describe('/+page.svelte', () => {
	it('should render h1', async () => {
		render(Page);

		const heading = page.getByRole('heading', { level: 1 });
		await expect.element(heading).toBeInTheDocument();
	});
});
</file>

<file path="webview/src/test/setup.ts">
/**
 * Test Setup Configuration
 * 
 * Global test setup for Vitest, including DOM environment setup,
 * mock configurations, and test utilities.
 */

import '@testing-library/jest-dom';
import { vi } from 'vitest';

// Mock VS Code API
const mockVSCodeApi = {
	postMessage: vi.fn(),
	setState: vi.fn(),
	getState: vi.fn(() => null)
};

// Mock window.acquireVsCodeApi
Object.defineProperty(window, 'acquireVsCodeApi', {
	value: () => mockVSCodeApi,
	writable: true
});

// Mock performance API if not available
if (!global.performance) {
	global.performance = {
		now: vi.fn(() => Date.now()),
		mark: vi.fn(),
		measure: vi.fn(),
		clearMarks: vi.fn(),
		clearMeasures: vi.fn(),
		getEntriesByType: vi.fn(() => []),
		getEntriesByName: vi.fn(() => [])
	} as any;
}

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation((callback) => ({
	observe: vi.fn(),
	unobserve: vi.fn(),
	disconnect: vi.fn()
}));

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation((callback) => ({
	observe: vi.fn(),
	unobserve: vi.fn(),
	disconnect: vi.fn()
}));

// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
	writable: true,
	value: vi.fn().mockImplementation(query => ({
		matches: false,
		media: query,
		onchange: null,
		addListener: vi.fn(),
		removeListener: vi.fn(),
		addEventListener: vi.fn(),
		removeEventListener: vi.fn(),
		dispatchEvent: vi.fn(),
	})),
});

// Mock CSS custom properties
Object.defineProperty(document.documentElement.style, 'setProperty', {
	value: vi.fn(),
	writable: true
});

// Mock Fluent UI web components
vi.mock('@fluentui/web-components', () => ({
	provideFluentDesignSystem: vi.fn(() => ({
		register: vi.fn()
	})),
	fluentButton: vi.fn(),
	fluentTextField: vi.fn(),
	fluentSelect: vi.fn(),
	fluentOption: vi.fn(),
	fluentProgressRing: vi.fn(),
	fluentCard: vi.fn(),
	fluentBadge: vi.fn(),
	fluentAccordion: vi.fn(),
	fluentAccordionItem: vi.fn()
}));

// Global test utilities
export const testUtils = {
	mockVSCodeApi,
	
	// Helper to wait for next tick
	nextTick: () => new Promise(resolve => setTimeout(resolve, 0)),
	
	// Helper to wait for component updates
	waitForUpdate: () => new Promise(resolve => setTimeout(resolve, 10)),
	
	// Helper to create mock events
	createMockEvent: (type: string, properties: Record<string, any> = {}) => {
		const event = new Event(type, { bubbles: true, cancelable: true });
		Object.assign(event, properties);
		return event;
	},
	
	// Helper to create mock input events
	createMockInputEvent: (value: string) => {
		const event = new Event('input', { bubbles: true });
		Object.defineProperty(event, 'target', {
			value: { value },
			enumerable: true
		});
		return event;
	},
	
	// Helper to create mock change events
	createMockChangeEvent: (value: string) => {
		const event = new Event('change', { bubbles: true });
		Object.defineProperty(event, 'target', {
			value: { value },
			enumerable: true
		});
		return event;
	}
};

// Make test utilities globally available
(global as any).testUtils = testUtils;
</file>

<file path="webview/src/app.d.ts">
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};
</file>

<file path="webview/src/demo.spec.ts">
import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});
</file>

<file path="webview/svelte.config.js">
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		// Use static adapter for VS Code webview
		adapter: adapter({
			pages: 'build',
			assets: 'build',
			fallback: 'index.html',
			precompress: false,
			strict: true
		})
	}
};

export default config;
</file>

<file path="src/shared/communicationTypes.ts">
/**
 * Shared Communication Types
 * 
 * This module defines type-safe interfaces for communication between the
 * VS Code extension and the webview. These types ensure consistency and
 * prevent runtime errors due to message format mismatches.
 * 
 * Features:
 * - Type-safe message definitions
 * - Request/response patterns
 * - Event-based communication
 * - Error handling types
 * - State synchronization types
 */

/**
 * Base message interface for all communication
 */
export interface BaseMessage {
    /** Unique identifier for the message */
    id: string;
    /** Timestamp when the message was created */
    timestamp: number;
    /** Type of the message */
    type: string;
}

/**
 * Request message interface
 */
export interface RequestMessage<T = any> extends BaseMessage {
    /** Request payload */
    payload: T;
    /** Whether this request expects a response */
    expectsResponse: boolean;
}

/**
 * Response message interface
 */
export interface ResponseMessage<T = any> extends BaseMessage {
    /** ID of the original request */
    requestId: string;
    /** Whether the request was successful */
    success: boolean;
    /** Response payload (if successful) */
    payload?: T;
    /** Error information (if failed) */
    error?: ErrorInfo;
}

/**
 * Event message interface
 */
export interface EventMessage<T = any> extends BaseMessage {
    /** Event name */
    event: string;
    /** Event payload */
    payload: T;
}

/**
 * Error information interface
 */
export interface ErrorInfo {
    /** Error code */
    code: string;
    /** Human-readable error message */
    message: string;
    /** Additional error details */
    details?: Record<string, any>;
    /** Stack trace (for debugging) */
    stack?: string;
}

/**
 * Message types for extension to webview communication
 */
export enum ExtensionToWebviewMessageType {
    // Configuration messages
    CONFIG_UPDATE = 'config_update',
    CONFIG_VALIDATION_RESULT = 'config_validation_result',
    
    // Search messages
    SEARCH_RESULTS = 'search_results',
    SEARCH_ERROR = 'search_error',
    SEARCH_PROGRESS = 'search_progress',
    
    // Indexing messages
    INDEXING_STATUS = 'indexing_status',
    INDEXING_PROGRESS = 'indexing_progress',
    INDEXING_COMPLETE = 'indexing_complete',
    INDEXING_ERROR = 'indexing_error',
    
    // State messages
    STATE_UPDATE = 'state_update',
    THEME_UPDATE = 'theme_update',
    
    // Notification messages
    NOTIFICATION = 'notification',
    
    // Error messages
    ERROR = 'error'
}

/**
 * Message types for webview to extension communication
 */
export enum WebviewToExtensionMessageType {
    // Configuration requests
    GET_CONFIG = 'get_config',
    UPDATE_CONFIG = 'update_config',
    VALIDATE_CONFIG = 'validate_config',
    
    // Search requests
    SEARCH = 'search',
    CANCEL_SEARCH = 'cancel_search',
    GET_SEARCH_HISTORY = 'get_search_history',
    
    // Indexing requests
    START_INDEXING = 'start_indexing',
    STOP_INDEXING = 'stop_indexing',
    GET_INDEXING_STATUS = 'get_indexing_status',
    
    // File operations
    OPEN_FILE = 'open_file',
    SHOW_FILE_IN_EXPLORER = 'show_file_in_explorer',
    REQUEST_OPEN_FOLDER = 'request_open_folder',
    
    // State requests
    GET_STATE = 'get_state',
    
    // Ready signal
    WEBVIEW_READY = 'webview_ready'
}

/**
 * Configuration update payload
 */
export interface ConfigUpdatePayload {
    /** Configuration section that was updated */
    section: string;
    /** New configuration values */
    config: Record<string, any>;
    /** Whether the update was successful */
    success: boolean;
    /** Validation errors (if any) */
    errors?: string[];
}

/**
 * Search request payload
 */
export interface SearchRequestPayload {
    /** Search query */
    query: string;
    /** Search filters */
    filters?: {
        fileTypes?: string[];
        languages?: string[];
        dateRange?: {
            start: string;
            end: string;
        };
        maxResults?: number;
        minSimilarity?: number;
    };
    /** Search options */
    options?: {
        useQueryExpansion?: boolean;
        useLLMReRanking?: boolean;
        includeMetadata?: boolean;
    };
}

/**
 * Search result item
 */
export interface SearchResultItem {
    /** Unique identifier */
    id: string;
    /** File path */
    filePath: string;
    /** Line number */
    lineNumber: number;
    /** Content preview */
    preview: string;
    /** Similarity score */
    similarity: number;
    /** Chunk type */
    chunkType: string;
    /** Programming language */
    language: string;
    /** Additional metadata */
    metadata?: Record<string, any>;
    /** LLM re-ranking information */
    llmScore?: number;
    finalScore?: number;
    explanation?: string;
    wasReRanked?: boolean;
}

/**
 * Search results payload
 */
export interface SearchResultsPayload {
    /** Search query */
    query: string;
    /** Search results */
    results: SearchResultItem[];
    /** Total number of results found */
    totalResults: number;
    /** Time taken for the search (in milliseconds) */
    searchTime: number;
    /** Whether query expansion was used */
    usedQueryExpansion?: boolean;
    /** Expanded terms (if query expansion was used) */
    expandedTerms?: string[];
    /** Whether LLM re-ranking was used */
    usedLLMReRanking?: boolean;
    /** Number of results that were re-ranked */
    reRankedCount?: number;
}

/**
 * Indexing status payload
 */
export interface IndexingStatusPayload {
    /** Whether indexing is currently running */
    isRunning: boolean;
    /** Current progress (0-100) */
    progress: number;
    /** Current status message */
    status: string;
    /** Number of files processed */
    filesProcessed: number;
    /** Total number of files to process */
    totalFiles: number;
    /** Number of chunks created */
    chunksCreated: number;
    /** Indexing start time */
    startTime?: number;
    /** Estimated time remaining (in milliseconds) */
    estimatedTimeRemaining?: number;
    /** Any errors encountered */
    errors?: string[];
}

/**
 * File operation payload
 */
export interface FileOperationPayload {
    /** File path */
    filePath: string;
    /** Line number (optional) */
    lineNumber?: number;
    /** Column number (optional) */
    columnNumber?: number;
    /** Whether to reveal the file in explorer */
    reveal?: boolean;
}

/**
 * Extension state payload
 */
export interface ExtensionStatePayload {
    /** Current configuration */
    config: Record<string, any>;
    /** Indexing status */
    indexingStatus: IndexingStatusPayload;
    /** Search history */
    searchHistory: Array<{
        query: string;
        timestamp: number;
        resultCount: number;
    }>;
    /** Extension version */
    version: string;
    /** Current theme */
    theme: 'light' | 'dark' | 'high-contrast';
    /** Available providers */
    availableProviders: {
        embedding: string[];
        llm: string[];
    };
}

/**
 * Notification payload
 */
export interface NotificationPayload {
    /** Notification type */
    type: 'info' | 'warning' | 'error' | 'success';
    /** Notification message */
    message: string;
    /** Optional title */
    title?: string;
    /** Actions available for the notification */
    actions?: Array<{
        title: string;
        action: string;
    }>;
    /** Whether the notification should auto-dismiss */
    autoDismiss?: boolean;
    /** Auto-dismiss timeout (in milliseconds) */
    timeout?: number;
}

/**
 * Progress update payload
 */
export interface ProgressUpdatePayload {
    /** Operation identifier */
    operationId: string;
    /** Progress percentage (0-100) */
    progress: number;
    /** Current status message */
    message: string;
    /** Whether the operation can be cancelled */
    cancellable: boolean;
    /** Whether the operation is complete */
    complete: boolean;
    /** Any errors encountered */
    error?: ErrorInfo;
}

/**
 * Type guards for message validation
 */
export class MessageTypeGuards {
    static isRequestMessage(message: any): message is RequestMessage {
        return message && 
               typeof message.id === 'string' &&
               typeof message.timestamp === 'number' &&
               typeof message.type === 'string' &&
               message.payload !== undefined &&
               typeof message.expectsResponse === 'boolean';
    }

    static isResponseMessage(message: any): message is ResponseMessage {
        return message && 
               typeof message.id === 'string' &&
               typeof message.timestamp === 'number' &&
               typeof message.type === 'string' &&
               typeof message.requestId === 'string' &&
               typeof message.success === 'boolean';
    }

    static isEventMessage(message: any): message is EventMessage {
        return message && 
               typeof message.id === 'string' &&
               typeof message.timestamp === 'number' &&
               typeof message.type === 'string' &&
               typeof message.event === 'string' &&
               message.payload !== undefined;
    }

    static isSearchRequestPayload(payload: any): payload is SearchRequestPayload {
        return payload && typeof payload.query === 'string';
    }

    static isFileOperationPayload(payload: any): payload is FileOperationPayload {
        return payload && typeof payload.filePath === 'string';
    }
}

/**
 * Message factory for creating type-safe messages
 */
export class MessageFactory {
    private static generateId(): string {
        return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
    }

    static createRequest<T>(type: string, payload: T, expectsResponse: boolean = true): RequestMessage<T> {
        return {
            id: this.generateId(),
            timestamp: Date.now(),
            type,
            payload,
            expectsResponse
        };
    }

    static createResponse<T>(requestId: string, type: string, success: boolean, payload?: T, error?: ErrorInfo): ResponseMessage<T> {
        return {
            id: this.generateId(),
            timestamp: Date.now(),
            type,
            requestId,
            success,
            payload,
            error
        };
    }

    static createEvent<T>(type: string, event: string, payload: T): EventMessage<T> {
        return {
            id: this.generateId(),
            timestamp: Date.now(),
            type,
            event,
            payload
        };
    }
}
</file>

<file path="webview/src/lib/components/ErrorBoundary.svelte">
<script lang="ts">
    import { onMount } from 'svelte';
    import { appActions } from '$lib/stores/appStore';
    import { registerCoreComponents } from '$lib/utils/fluentUI';

    // Register Fluent UI components
    registerCoreComponents();

    // Props
    export let fallbackMessage = 'Something went wrong. Please try again.';
    export let showDetails = false;
    export let onError: ((error: Error) => void) | null = null;

    // State
    let hasError = false;
    let errorMessage = '';
    let errorStack = '';
    let errorDetails = '';

    // Error handler
    function handleError(error: Error | ErrorEvent | PromiseRejectionEvent) {
        hasError = true;
        
        if (error instanceof Error) {
            errorMessage = error.message;
            errorStack = error.stack || '';
            errorDetails = `${error.name}: ${error.message}`;
        } else if (error instanceof ErrorEvent) {
            errorMessage = error.message;
            errorStack = error.error?.stack || '';
            errorDetails = `${error.filename}:${error.lineno}:${error.colno} - ${error.message}`;
        } else if (error instanceof PromiseRejectionEvent) {
            errorMessage = error.reason?.message || 'Promise rejection';
            errorStack = error.reason?.stack || '';
            errorDetails = `Unhandled Promise Rejection: ${error.reason}`;
        } else {
            errorMessage = 'Unknown error occurred';
            errorDetails = String(error);
        }

        // Log error for debugging
        console.error('ErrorBoundary caught error:', error);
        
        // Report to app store
        appActions.setError(errorMessage);
        
        // Call custom error handler if provided
        if (onError && error instanceof Error) {
            try {
                onError(error);
            } catch (handlerError) {
                console.error('Error in custom error handler:', handlerError);
            }
        }
    }

    // Reset error state
    function resetError() {
        hasError = false;
        errorMessage = '';
        errorStack = '';
        errorDetails = '';
        appActions.clearError();
    }

    // Reload the component/page
    function reloadComponent() {
        resetError();
        // Force a re-render by updating a reactive variable
        window.location.reload();
    }

    onMount(() => {
        // Global error handlers
        const handleGlobalError = (event: ErrorEvent) => {
            handleError(event);
        };

        const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
            handleError(event);
        };

        // Add global error listeners
        window.addEventListener('error', handleGlobalError);
        window.addEventListener('unhandledrejection', handleUnhandledRejection);

        return () => {
            window.removeEventListener('error', handleGlobalError);
            window.removeEventListener('unhandledrejection', handleUnhandledRejection);
        };
    });

    // Reactive statement to catch component errors
    $: if (hasError) {
        console.warn('Component is in error state:', errorMessage);
    }
</script>

{#if hasError}
    <div class="error-boundary">
        <fluent-card class="error-card">
            <div class="error-content">
                <div class="error-icon">‚ö†Ô∏è</div>
                <h3 class="error-title">Oops! Something went wrong</h3>
                <p class="error-message">{fallbackMessage}</p>
                
                {#if showDetails && errorDetails}
                    <details class="error-details">
                        <summary>Technical Details</summary>
                        <div class="error-details-content">
                            <p><strong>Error:</strong> {errorMessage}</p>
                            {#if errorStack}
                                <pre class="error-stack">{errorStack}</pre>
                            {/if}
                        </div>
                    </details>
                {/if}

                <div class="error-actions">
                    <fluent-button
                        appearance="accent"
                        on:click={resetError}
                        on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && resetError()}
                        role="button"
                        tabindex="0"
                    >
                        Try Again
                    </fluent-button>

                    <fluent-button
                        on:click={reloadComponent}
                        on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && reloadComponent()}
                        role="button"
                        tabindex="0"
                    >
                        Reload
                    </fluent-button>
                </div>
            </div>
        </fluent-card>
    </div>
{:else}
    <slot />
{/if}

<style>
    .error-boundary {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 200px;
        padding: 20px;
    }

    .error-card {
        max-width: 500px;
        width: 100%;
        padding: 30px;
        text-align: center;
    }

    .error-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    .error-icon {
        font-size: 48px;
        margin-bottom: 10px;
    }

    .error-title {
        margin: 0;
        color: var(--vscode-errorForeground);
        font-size: 20px;
        font-weight: 600;
    }

    .error-message {
        margin: 0;
        color: var(--vscode-foreground);
        font-size: 16px;
        line-height: 1.5;
    }

    .error-details {
        width: 100%;
        margin-top: 15px;
        text-align: left;
    }

    .error-details summary {
        cursor: pointer;
        font-weight: 500;
        color: var(--vscode-textLink-foreground);
        margin-bottom: 10px;
    }

    .error-details summary:hover {
        color: var(--vscode-textLink-activeForeground);
    }

    .error-details-content {
        padding: 10px;
        background-color: var(--vscode-textCodeBlock-background);
        border-radius: 4px;
        border: 1px solid var(--vscode-panel-border);
    }

    .error-details-content p {
        margin: 0 0 10px 0;
        font-size: 14px;
    }

    .error-stack {
        margin: 0;
        padding: 10px;
        background-color: var(--vscode-editor-background);
        border: 1px solid var(--vscode-panel-border);
        border-radius: 3px;
        font-family: var(--vscode-editor-font-family);
        font-size: 12px;
        line-height: 1.4;
        color: var(--vscode-foreground);
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .error-actions {
        display: flex;
        gap: 10px;
        margin-top: 20px;
    }

    .error-actions fluent-button {
        min-width: 100px;
    }

    /* Responsive design */
    @media (max-width: 600px) {
        .error-boundary {
            padding: 10px;
        }

        .error-card {
            padding: 20px;
        }

        .error-actions {
            flex-direction: column;
            width: 100%;
        }

        .error-actions fluent-button {
            width: 100%;
        }
    }
</style>
</file>

<file path="webview/src/lib/components/SetupView.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import {
        provideFluentDesignSystem,
        fluentButton,
        fluentTextField,
        fluentSelect,
        fluentOption,
        fluentProgressRing,
        fluentCard
    } from '@fluentui/web-components';
    import { postMessage, onMessage } from '$lib/vscodeApi';
    import {
        setupState,
        indexingState,
        setupActions,
        indexingActions,
        appActions,
        isSetupComplete,
        canStartIndexing
    } from '$lib/stores/appStore';
    import ValidatedInput from './ValidatedInput.svelte';
    import ConnectionTester from './ConnectionTester.svelte';
    import { validators } from '$lib/utils/validation';
    import type { ValidationResult } from '$lib/utils/validation';
    
    // Register Fluent UI components
    provideFluentDesignSystem().register(
        fluentButton(),
        fluentTextField(),
        fluentSelect(),
        fluentOption(),
        fluentProgressRing(),
        fluentCard()
    );

    // Local UI state (non-persistent)
    let errorMessage = '';
    let successMessage = '';

    // Validation state
    let databaseValidation: ValidationResult | null = null;
    let providerValidation: ValidationResult | null = null;
    let databaseConfigFields = {
        host: '',
        port: '',
        apiKey: '',
        environment: ''
    };
    let providerConfigFields = {
        apiKey: '',
        endpoint: '',
        model: ''
    };

    // Message handlers
    let unsubscribeFunctions: (() => void)[] = [];

    onMount(() => {
        // Set up message listeners using the wrapper
        unsubscribeFunctions.push(
            onMessage('databaseStatus', (message) => {
                setupActions.setDatabaseStatus(message.status);
            }),
            onMessage('providerStatus', (message) => {
                setupActions.setProviderStatus(message.status);
            }),
            onMessage('indexingProgress', (message) => {
                indexingActions.updateProgress(
                    message.percentage || 0,
                    message.message || 'Indexing in progress...',
                    message.filesProcessed,
                    message.totalFiles,
                    message.currentFile
                );
            }),
            onMessage('indexingCompleted', (message) => {
                indexingActions.completeIndexing(message.success ?? false, message.totalFiles);
                if (message.success) {
                    successMessage = 'Indexing completed successfully!';
                } else {
                    errorMessage = 'Indexing failed. Please check the logs.';
                }
            }),
            onMessage('error', (message) => {
                errorMessage = message.message;
                appActions.setError(message.message);
            })
        );

        // Request initial status
        postMessage('getSetupStatus');
    });

    onDestroy(() => {
        // Clean up message listeners
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    });





    function startDatabase() {
        const currentSetup = $setupState;
        if (!currentSetup.selectedDatabase) {
            errorMessage = 'Please select a database first';
            return;
        }

        setupActions.setDatabaseStatus('starting');
        errorMessage = '';

        postMessage('startDatabase', {
            database: currentSetup.selectedDatabase
        });
    }

    function configureProvider() {
        const currentSetup = $setupState;
        if (!currentSetup.selectedProvider) {
            errorMessage = 'Please select a provider first';
            return;
        }

        setupActions.setProviderStatus('starting');
        errorMessage = '';

        postMessage('configureProvider', {
            provider: currentSetup.selectedProvider
        });
    }

    function startIndexing() {
        const currentSetup = $setupState;
        if (!$canStartIndexing) {
            errorMessage = 'Please complete database and provider setup first';
            return;
        }

        indexingActions.startIndexing();
        errorMessage = '';

        postMessage('startIndexing', {
            configuration: {
                database: currentSetup.selectedDatabase,
                provider: currentSetup.selectedProvider
            }
        });
    }

    function clearMessages() {
        errorMessage = '';
        successMessage = '';
    }


</script>

<div class="setup-view">
    <div class="setup-header">
        <h1>Welcome to Code Context Engine</h1>
        <p>Let's get you set up! Configure your database and embedding provider to start indexing your code.</p>
    </div>

    <!-- Progress Steps -->
    <div class="setup-progress">
        <div class="progress-step" class:active={$setupState.databaseStatus === 'idle' || $setupState.databaseStatus === 'starting'} class:completed={$setupState.databaseStatus === 'ready'}>
            <div class="step-number">1</div>
            <div class="step-label">Database</div>
        </div>
        <div class="progress-line"></div>
        <div class="progress-step" class:active={$setupState.providerStatus === 'idle' || $setupState.providerStatus === 'starting'} class:completed={$setupState.providerStatus === 'ready'}>
            <div class="step-number">2</div>
            <div class="step-label">Provider</div>
        </div>
        <div class="progress-line"></div>
        <div class="progress-step" class:active={$isSetupComplete} class:completed={false}>
            <div class="step-number">3</div>
            <div class="step-label">Ready</div>
        </div>
    </div>

    <!-- Error/Success Messages -->
    {#if errorMessage}
        <div class="notification error">
            {errorMessage}
            <button class="notification-close" on:click={clearMessages}>√ó</button>
        </div>
    {/if}

    {#if successMessage}
        <div class="notification success">
            {successMessage}
            <button class="notification-close" on:click={clearMessages}>√ó</button>
        </div>
    {/if}

    <!-- Database Setup -->
    <fluent-card class="setup-section">
        <h3>Database Configuration</h3>
        <p>Select and configure your vector database for code indexing.</p>
        
        <ValidatedInput
            type="select"
            label="Vector Database"
            value={$setupState.selectedDatabase}
            required={true}
            placeholder="Select a database..."
            options={[
                { value: "qdrant", label: "Qdrant (Local/Docker)" },
                { value: "chromadb", label: "ChromaDB (Local/Docker)" },
                { value: "pinecone", label: "Pinecone (Cloud)" }
            ]}
            validator={(value) => validators.required(value, 'Database')}
            on:input={(e) => {
                setupActions.setSelectedDatabase(e.detail.value);
                errorMessage = '';
            }}
            on:validation={(e) => {
                databaseValidation = e.detail.result;
            }}
        />

        {#if $setupState.selectedDatabase}
            <!-- Database-specific configuration fields -->
            {#if $setupState.selectedDatabase === 'qdrant' || $setupState.selectedDatabase === 'chromadb'}
                <div class="config-fields">
                    <ValidatedInput
                        type="text"
                        label="Host"
                        value={databaseConfigFields.host}
                        placeholder="localhost"
                        validator={(value) => value ? validators.url(`http://${value}`, 'Host') : { isValid: true, errors: [], warnings: [], suggestions: ['Default localhost will be used'] }}
                        on:input={(e) => {
                            databaseConfigFields.host = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="number"
                        label="Port"
                        value={databaseConfigFields.port}
                        placeholder={$setupState.selectedDatabase === 'qdrant' ? '6333' : '8000'}
                        validator={(value) => value ? validators.port(value, 'Port') : { isValid: true, errors: [], warnings: [], suggestions: [`Default port ${$setupState.selectedDatabase === 'qdrant' ? '6333' : '8000'} will be used`] }}
                        on:input={(e) => {
                            databaseConfigFields.port = e.detail.value;
                        }}
                    />
                </div>
            {:else if $setupState.selectedDatabase === 'pinecone'}
                <div class="config-fields">
                    <ValidatedInput
                        type="password"
                        label="API Key"
                        value={databaseConfigFields.apiKey}
                        placeholder="Enter your Pinecone API key"
                        required={true}
                        validator={(value) => validators.apiKey(value, 'Pinecone API Key')}
                        on:input={(e) => {
                            databaseConfigFields.apiKey = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="text"
                        label="Environment"
                        value={databaseConfigFields.environment}
                        placeholder="us-west1-gcp"
                        required={true}
                        validator={(value) => validators.stringLength(value, 1, 50, 'Environment')}
                        on:input={(e) => {
                            databaseConfigFields.environment = e.detail.value;
                        }}
                    />
                </div>
            {/if}

            <!-- Connection Testing -->
            <ConnectionTester
                type="database"
                config={{
                    type: $setupState.selectedDatabase as 'qdrant' | 'chromadb' | 'pinecone',
                    host: databaseConfigFields.host || 'localhost',
                    port: databaseConfigFields.port ? parseInt(databaseConfigFields.port) : undefined,
                    apiKey: databaseConfigFields.apiKey,
                    environment: databaseConfigFields.environment
                }}
                disabled={$setupState.databaseStatus === 'starting'}
                showDetails={true}
                on:testComplete={(e) => {
                    if (e.detail.result.success) {
                        successMessage = 'Database connection test successful!';
                    } else {
                        errorMessage = `Database connection test failed: ${e.detail.result.message}`;
                    }
                }}
            />

            <div class="action-section">
                <fluent-button
                    appearance="accent"
                    disabled={$setupState.databaseStatus === 'starting' || $setupState.databaseStatus === 'ready'}
                    on:click={startDatabase}
                    role="button"
                    tabindex="0"
                    on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && startDatabase()}
                >
                    {#if $setupState.databaseStatus === 'starting'}
                        <fluent-progress-ring></fluent-progress-ring>
                        Starting...
                    {:else if $setupState.databaseStatus === 'ready'}
                        ‚úì Database Ready
                    {:else}
                        Start {$setupState.selectedDatabase === 'pinecone' ? 'Validate' : 'Local'} {$setupState.selectedDatabase}
                    {/if}
                </fluent-button>
            </div>
        {/if}
    </fluent-card>

    <!-- Provider Setup -->
    <fluent-card class="setup-section">
        <h3>Embedding Provider Configuration</h3>
        <p>Choose your AI embedding provider for semantic code search.</p>
        
        <ValidatedInput
            type="select"
            label="Embedding Provider"
            value={$setupState.selectedProvider}
            required={true}
            placeholder="Select a provider..."
            options={[
                { value: "ollama", label: "Ollama (Local)" },
                { value: "openai", label: "OpenAI" },
                { value: "azure", label: "Azure OpenAI" }
            ]}
            validator={(value) => validators.required(value, 'Provider')}
            on:input={(e) => {
                setupActions.setSelectedProvider(e.detail.value);
                errorMessage = '';
            }}
            on:validation={(e) => {
                providerValidation = e.detail.result;
            }}
        />

        {#if $setupState.selectedProvider}
            <!-- Provider-specific configuration fields -->
            {#if $setupState.selectedProvider === 'openai'}
                <div class="config-fields">
                    <ValidatedInput
                        type="password"
                        label="OpenAI API Key"
                        value={providerConfigFields.apiKey}
                        placeholder="sk-..."
                        required={true}
                        validator={(value) => validators.apiKey(value, 'OpenAI API Key')}
                        on:input={(e) => {
                            providerConfigFields.apiKey = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="text"
                        label="Model (Optional)"
                        value={providerConfigFields.model}
                        placeholder="text-embedding-ada-002"
                        validator={(value) => value ? validators.stringLength(value, 1, 100, 'Model') : { isValid: true, errors: [], warnings: [], suggestions: [] }}
                        on:input={(e) => {
                            providerConfigFields.model = e.detail.value;
                        }}
                    />
                </div>
            {:else if $setupState.selectedProvider === 'azure'}
                <div class="config-fields">
                    <ValidatedInput
                        type="password"
                        label="Azure API Key"
                        value={providerConfigFields.apiKey}
                        placeholder="Enter your Azure API key"
                        required={true}
                        validator={(value) => validators.apiKey(value, 'Azure API Key')}
                        on:input={(e) => {
                            providerConfigFields.apiKey = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="url"
                        label="Azure Endpoint"
                        value={providerConfigFields.endpoint}
                        placeholder="https://your-resource.openai.azure.com/"
                        required={true}
                        validator={(value) => validators.url(value, 'Azure Endpoint')}
                        on:input={(e) => {
                            providerConfigFields.endpoint = e.detail.value;
                        }}
                    />
                </div>
            {:else if $setupState.selectedProvider === 'ollama'}
                <div class="config-fields">
                    <ValidatedInput
                        type="url"
                        label="Ollama Endpoint"
                        value={providerConfigFields.endpoint}
                        placeholder="http://localhost:11434"
                        validator={(value) => value ? validators.url(value, 'Ollama Endpoint') : { isValid: true, errors: [], warnings: [], suggestions: ['Default endpoint http://localhost:11434 will be used'] }}
                        on:input={(e) => {
                            providerConfigFields.endpoint = e.detail.value;
                        }}
                    />

                    <ValidatedInput
                        type="text"
                        label="Model (Optional)"
                        value={providerConfigFields.model}
                        placeholder="nomic-embed-text"
                        validator={(value) => value ? validators.stringLength(value, 1, 100, 'Model') : { isValid: true, errors: [], warnings: [], suggestions: [] }}
                        on:input={(e) => {
                            providerConfigFields.model = e.detail.value;
                        }}
                    />
                </div>
            {/if}

            <!-- Connection Testing -->
            <ConnectionTester
                type="provider"
                config={{
                    type: $setupState.selectedProvider as 'ollama' | 'openai' | 'azure',
                    apiKey: providerConfigFields.apiKey,
                    endpoint: providerConfigFields.endpoint,
                    model: providerConfigFields.model
                }}
                disabled={$setupState.providerStatus === 'starting'}
                showDetails={true}
                on:testComplete={(e) => {
                    if (e.detail.result.success) {
                        successMessage = 'Provider connection test successful!';
                    } else {
                        errorMessage = `Provider connection test failed: ${e.detail.result.message}`;
                    }
                }}
            />

            <div class="action-section">
                <fluent-button
                    appearance="accent"
                    disabled={$setupState.providerStatus === 'starting' || $setupState.providerStatus === 'ready'}
                    on:click={configureProvider}
                    role="button"
                    tabindex="0"
                    on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && configureProvider()}
                >
                    {#if $setupState.providerStatus === 'starting'}
                        <fluent-progress-ring></fluent-progress-ring>
                        Configuring...
                    {:else if $setupState.providerStatus === 'ready'}
                        ‚úì Provider Ready
                    {:else}
                        Configure {$setupState.selectedProvider}
                    {/if}
                </fluent-button>
            </div>
        {/if}
    </fluent-card>

    <!-- Indexing Section -->
    <div class="setup-actions">
        <fluent-button
            appearance="accent"
            size="large"
            disabled={!$canStartIndexing}
            on:click={startIndexing}
            role="button"
            tabindex="0"
            on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && startIndexing()}
        >
            {#if $indexingState.isIndexing}
                <fluent-progress-ring></fluent-progress-ring>
                Indexing...
            {:else}
                üöÄ Index Now
            {/if}
        </fluent-button>
        
        <p class="action-help">
            {#if $isSetupComplete}
                Ready to index your codebase!
            {:else}
                Complete the configuration above to enable indexing.
            {/if}
        </p>
    </div>

    <!-- Indexing Progress -->
    {#if $indexingState.isIndexing}
        <fluent-card class="indexing-progress">
            <h3>Indexing in Progress</h3>
            <div class="progress-bar">
                <div class="progress-fill" style="width: {$indexingState.progress}%"></div>
            </div>
            <p class="progress-text">{$indexingState.message}</p>
        </fluent-card>
    {/if}
</div>

<style>
    .setup-view {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        font-family: var(--vscode-font-family);
    }

    .setup-header {
        text-align: center;
        margin-bottom: 30px;
    }

    .setup-header h1 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
        font-size: 28px;
    }

    .setup-header p {
        margin: 0;
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
    }

    .setup-progress {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 40px;
        padding: 20px;
    }

    .progress-step {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }

    .step-number {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        border: 2px solid var(--vscode-panel-border);
        background-color: var(--vscode-sideBar-background);
        color: var(--vscode-descriptionForeground);
        transition: all 0.3s ease;
    }

    .progress-step.active .step-number {
        background-color: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
        border-color: var(--vscode-button-background);
    }

    .progress-step.completed .step-number {
        background-color: var(--vscode-charts-green);
        color: white;
        border-color: var(--vscode-charts-green);
    }

    .step-label {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
        font-weight: 500;
    }

    .progress-step.active .step-label {
        color: var(--vscode-foreground);
    }

    .progress-line {
        width: 60px;
        height: 2px;
        background-color: var(--vscode-panel-border);
        margin: 0 10px;
    }

    .setup-section {
        margin-bottom: 20px;
        padding: 20px;
    }

    .setup-section h3 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
    }

    .setup-section p {
        margin: 0 0 20px 0;
        color: var(--vscode-descriptionForeground);
    }

    .config-fields {
        margin: 20px 0;
        padding: 16px;
        background-color: var(--vscode-textCodeBlock-background);
        border-radius: 6px;
        border: 1px solid var(--vscode-panel-border);
    }



    .action-section {
        margin-top: 15px;
    }

    .setup-actions {
        text-align: center;
        padding: 20px;
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        background-color: var(--vscode-sideBar-background);
        margin-bottom: 20px;
    }

    .action-help {
        margin: 10px 0 0 0;
        font-size: 14px;
        color: var(--vscode-descriptionForeground);
    }

    .indexing-progress {
        padding: 20px;
    }

    .indexing-progress h3 {
        margin: 0 0 15px 0;
        color: var(--vscode-textLink-foreground);
    }

    .progress-bar {
        width: 100%;
        height: 8px;
        background-color: var(--vscode-progressBar-background);
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 10px;
    }

    .progress-fill {
        height: 100%;
        background-color: var(--vscode-progressBar-foreground);
        transition: width 0.3s ease;
    }

    .progress-text {
        margin: 0;
        font-size: 14px;
        color: var(--vscode-foreground);
    }

    .notification {
        padding: 12px 16px;
        border-radius: 4px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .notification.error {
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        color: var(--vscode-inputValidation-errorForeground);
    }

    .notification.success {
        background-color: var(--vscode-charts-green);
        color: white;
    }

    .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
        margin-left: 10px;
    }
</style>
</file>

<file path="webview/src/lib/components/WorkspaceSelector.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import { postMessage, onMessage } from '../vscodeApi';
    import { appActions } from '../stores/appStore';

    // Component props
    export let showLabel = true;
    export let compact = false;

    // Local state
    let workspaces: Array<{
        id: string;
        name: string;
        path: string;
        isActive: boolean;
    }> = [];
    
    let currentWorkspace: string | null = null;
    let isLoading = false;
    let hasMultipleWorkspaces = false;

    // Cleanup functions
    let unsubscribeFunctions: Array<() => void> = [];

    /**
     * Component initialization
     */
    onMount(() => {
        console.log('WorkspaceSelector: Component mounted');

        // Set up message listeners
        unsubscribeFunctions.push(
            onMessage('workspaceListResponse', (message) => {
                if (message.success) {
                    workspaces = message.data.workspaces || [];
                    currentWorkspace = message.data.current || null;
                    hasMultipleWorkspaces = workspaces.length > 1;
                    console.log(`WorkspaceSelector: Received ${workspaces.length} workspaces`);
                } else {
                    console.error('WorkspaceSelector: Failed to get workspace list:', message.error);
                    appActions.setError(message.error || 'Failed to load workspaces');
                }
                isLoading = false;
            }),
            onMessage('workspaceSwitchResponse', (message) => {
                if (message.success) {
                    currentWorkspace = message.data.workspaceId;
                    // Update the active workspace in our local list
                    workspaces = workspaces.map(w => ({
                        ...w,
                        isActive: w.id === message.data.workspaceId
                    }));
                    console.log(`WorkspaceSelector: Switched to workspace: ${message.data.workspaceId}`);
                    appActions.clearError();
                } else {
                    console.error('WorkspaceSelector: Failed to switch workspace:', message.error);
                    appActions.setError(message.error || 'Failed to switch workspace');
                }
            }),
            onMessage('workspaceChanged', (message) => {
                // Handle workspace changes from external sources
                if (message.data.workspace) {
                    currentWorkspace = message.data.workspace.id;
                    // Refresh the workspace list
                    refreshWorkspaces();
                }
            }),
            onMessage('error', (message) => {
                console.error('WorkspaceSelector: Received error:', message.message);
                appActions.setError(message.message);
                isLoading = false;
            })
        );

        // Request initial workspace list
        refreshWorkspaces();
    });

    /**
     * Component cleanup
     */
    onDestroy(() => {
        console.log('WorkspaceSelector: Component destroyed');
        unsubscribeFunctions.forEach(fn => fn());
    });

    /**
     * Refreshes the workspace list from the backend
     */
    function refreshWorkspaces() {
        isLoading = true;
        postMessage('getWorkspaceList');
    }

    /**
     * Switches to a different workspace
     * @param workspaceId - The ID of the workspace to switch to
     */
    function switchWorkspace(workspaceId: string) {
        if (workspaceId === currentWorkspace) {
            return; // Already on this workspace
        }

        console.log(`WorkspaceSelector: Switching to workspace: ${workspaceId}`);
        postMessage('switchWorkspace', { workspaceId });
    }

    /**
     * Handles keyboard navigation for accessibility
     * @param event - The keyboard event
     * @param callback - The function to call on Enter/Space
     */
    function handleKeyboardClick(event: KeyboardEvent, callback: () => void) {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            callback();
        }
    }

    /**
     * Gets a shortened display name for a workspace
     * @param workspace - The workspace object
     * @returns A shortened display name
     */
    function getDisplayName(workspace: any): string {
        if (compact && workspace.name.length > 20) {
            return workspace.name.substring(0, 17) + '...';
        }
        return workspace.name;
    }

    /**
     * Gets the tooltip text for a workspace
     * @param workspace - The workspace object
     * @returns Tooltip text with full path
     */
    function getTooltip(workspace: any): string {
        return `${workspace.name}\n${workspace.path}`;
    }
</script>

<!-- Only show the component if there are multiple workspaces -->
{#if hasMultipleWorkspaces}
    <div class="workspace-selector" class:compact>
        {#if showLabel && !compact}
            <label for="workspace-select" class="workspace-label">
                Workspace:
            </label>
        {/if}
        
        <div class="workspace-dropdown">
            <fluent-select
                id="workspace-select"
                value={currentWorkspace || ''}
                disabled={isLoading || workspaces.length === 0}
                on:change={(e) => switchWorkspace(e.target.value)}
                aria-label="Select workspace"
            >
                {#if isLoading}
                    <fluent-option value="" disabled>Loading workspaces...</fluent-option>
                {:else if workspaces.length === 0}
                    <fluent-option value="" disabled>No workspaces found</fluent-option>
                {:else}
                    {#each workspaces as workspace (workspace.id)}
                        <fluent-option 
                            value={workspace.id}
                            selected={workspace.isActive}
                            title={getTooltip(workspace)}
                        >
                            {getDisplayName(workspace)}
                            {#if workspace.isActive}
                                <span class="active-indicator">‚óè</span>
                            {/if}
                        </fluent-option>
                    {/each}
                {/if}
            </fluent-select>
            
            {#if !compact}
                <fluent-button
                    appearance="stealth"
                    on:click={refreshWorkspaces}
                    on:keydown={(e) => handleKeyboardClick(e, refreshWorkspaces)}
                    disabled={isLoading}
                    title="Refresh workspace list"
                    aria-label="Refresh workspace list"
                    role="button"
                    tabindex="0"
                >
                    {#if isLoading}
                        <fluent-progress-ring></fluent-progress-ring>
                    {:else}
                        üîÑ
                    {/if}
                </fluent-button>
            {/if}
        </div>
        
        {#if !compact && currentWorkspace}
            <div class="workspace-info">
                {#each workspaces as workspace (workspace.id)}
                    {#if workspace.isActive}
                        <span class="workspace-path" title={workspace.path}>
                            üìÅ {workspace.path}
                        </span>
                    {/if}
                {/each}
            </div>
        {/if}
    </div>
{/if}

<style>
    .workspace-selector {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
        padding: 12px;
        border: 1px solid var(--vscode-widget-border);
        border-radius: 4px;
        background-color: var(--vscode-editor-background);
    }

    .workspace-selector.compact {
        flex-direction: row;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
        padding: 8px;
    }

    .workspace-label {
        font-weight: 600;
        color: var(--vscode-foreground);
        font-size: 14px;
        margin-bottom: 4px;
    }

    .workspace-dropdown {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .workspace-dropdown fluent-select {
        flex: 1;
        min-width: 200px;
    }

    .workspace-dropdown fluent-button {
        flex-shrink: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .workspace-info {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 4px;
    }

    .workspace-path {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
        font-family: var(--vscode-editor-font-family);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 100%;
    }

    .active-indicator {
        color: var(--vscode-textLink-foreground);
        margin-left: 8px;
        font-weight: bold;
    }

    /* Compact mode adjustments */
    .workspace-selector.compact .workspace-dropdown fluent-select {
        min-width: 150px;
    }

    .workspace-selector.compact .workspace-label {
        margin-bottom: 0;
        font-size: 13px;
        white-space: nowrap;
    }

    /* Loading state */
    fluent-select:disabled {
        opacity: 0.6;
    }

    /* Responsive design */
    @media (max-width: 400px) {
        .workspace-selector:not(.compact) {
            padding: 8px;
        }
        
        .workspace-dropdown fluent-select {
            min-width: 120px;
        }
        
        .workspace-path {
            font-size: 11px;
        }
    }
</style>
</file>

<file path="webview/src/lib/stores/appStore.ts">
/**
 * Application State Store
 * 
 * Centralized state management for the Code Context Engine application.
 * This store manages the overall application state and coordinates between different feature stores.
 */

import { writable, derived, type Readable } from 'svelte/store';
import { currentView, type ViewType } from './viewStore';

// Application-wide state interfaces
export interface AppState {
    isInitialized: boolean;
    isLoading: boolean;
    error: string | null;
    lastActivity: Date | null;
    isWorkspaceOpen: boolean;
}

export interface SetupState {
    databaseStatus: 'idle' | 'starting' | 'ready' | 'error';
    providerStatus: 'idle' | 'starting' | 'ready' | 'error';
    selectedDatabase: string;
    selectedProvider: string;
    isSetupComplete: boolean;
    setupErrors: string[];
}

export interface IndexingState {
    isIndexing: boolean;
    progress: number;
    message: string;
    filesProcessed: number;
    totalFiles: number;
    currentFile: string;
    stats: {
        totalChunks: number;
        processedChunks: number;
        errors: number;
        startTime: Date | null;
        estimatedTimeRemaining: string;
    };
}

export interface SearchState {
    query: string;
    isSearching: boolean;
    results: SearchResult[];
    history: string[];
    stats: {
        totalResults: number;
        searchTime: number;
        query: string;
    };
}

export interface SearchResult {
    id: string;
    file: string;
    content: string;
    score: number;
    lineNumber?: number;
    context?: string;
    relatedFiles?: RelatedFile[];
}

export interface RelatedFile {
    file: string;
    score: number;
    reason: string;
}

// Create individual stores
export const appState = writable<AppState>({
    isInitialized: false,
    isLoading: false,
    error: null,
    lastActivity: null,
    isWorkspaceOpen: false
});

export const setupState = writable<SetupState>({
    databaseStatus: 'idle',
    providerStatus: 'idle',
    selectedDatabase: '',
    selectedProvider: '',
    isSetupComplete: false,
    setupErrors: []
});

export const indexingState = writable<IndexingState>({
    isIndexing: false,
    progress: 0,
    message: 'Ready to start indexing...',
    filesProcessed: 0,
    totalFiles: 0,
    currentFile: '',
    stats: {
        totalChunks: 0,
        processedChunks: 0,
        errors: 0,
        startTime: null,
        estimatedTimeRemaining: ''
    }
});

export const searchState = writable<SearchState>({
    query: '',
    isSearching: false,
    results: [],
    history: [],
    stats: {
        totalResults: 0,
        searchTime: 0,
        query: ''
    }
});

// Derived stores for computed values
export const isSetupComplete: Readable<boolean> = derived(
    setupState,
    ($setupState) => $setupState.databaseStatus === 'ready' && $setupState.providerStatus === 'ready'
);

export const canStartIndexing: Readable<boolean> = derived(
    [setupState, indexingState],
    ([$setupState, $indexingState]) => 
        $setupState.databaseStatus === 'ready' && 
        $setupState.providerStatus === 'ready' && 
        !$indexingState.isIndexing
);

export const hasSearchResults: Readable<boolean> = derived(
    searchState,
    ($searchState) => $searchState.results.length > 0
);

export const currentError: Readable<string | null> = derived(
    [appState, setupState],
    ([$appState, $setupState]) => {
        if ($appState.error) return $appState.error;
        if ($setupState.setupErrors.length > 0) return $setupState.setupErrors[0];
        return null;
    }
);

// Action creators for updating state
export const appActions = {
    initialize: () => {
        appState.update(state => ({
            ...state,
            isInitialized: true,
            lastActivity: new Date()
        }));
    },

    setLoading: (loading: boolean) => {
        appState.update(state => ({
            ...state,
            isLoading: loading,
            lastActivity: new Date()
        }));
    },

    setError: (error: string | null) => {
        appState.update(state => ({
            ...state,
            error,
            lastActivity: new Date()
        }));
    },

    clearError: () => {
        appState.update(state => ({
            ...state,
            error: null
        }));
        setupState.update(state => ({
            ...state,
            setupErrors: []
        }));
    },

    updateActivity: () => {
        appState.update(state => ({
            ...state,
            lastActivity: new Date()
        }));
    },

    setWorkspaceOpen: (isOpen: boolean) => {
        appState.update(state => ({
            ...state,
            isWorkspaceOpen: isOpen,
            lastActivity: new Date()
        }));
    }
};

export const setupActions = {
    setDatabaseStatus: (status: SetupState['databaseStatus']) => {
        setupState.update(state => ({
            ...state,
            databaseStatus: status
        }));
    },

    setProviderStatus: (status: SetupState['providerStatus']) => {
        setupState.update(state => ({
            ...state,
            providerStatus: status
        }));
    },

    setSelectedDatabase: (database: string) => {
        setupState.update(state => ({
            ...state,
            selectedDatabase: database,
            databaseStatus: 'idle'
        }));
    },

    setSelectedProvider: (provider: string) => {
        setupState.update(state => ({
            ...state,
            selectedProvider: provider,
            providerStatus: 'idle'
        }));
    },

    addSetupError: (error: string) => {
        setupState.update(state => ({
            ...state,
            setupErrors: [...state.setupErrors, error]
        }));
    },

    clearSetupErrors: () => {
        setupState.update(state => ({
            ...state,
            setupErrors: []
        }));
    }
};

export const indexingActions = {
    startIndexing: () => {
        indexingState.update(state => ({
            ...state,
            isIndexing: true,
            progress: 0,
            message: 'Starting indexing process...',
            stats: {
                ...state.stats,
                startTime: new Date(),
                errors: 0
            }
        }));
    },

    updateProgress: (progress: number, message: string, filesProcessed?: number, totalFiles?: number, currentFile?: string) => {
        indexingState.update(state => ({
            ...state,
            progress,
            message,
            filesProcessed: filesProcessed ?? state.filesProcessed,
            totalFiles: totalFiles ?? state.totalFiles,
            currentFile: currentFile ?? state.currentFile
        }));
    },

    completeIndexing: (success: boolean, totalFiles?: number) => {
        indexingState.update(state => ({
            ...state,
            isIndexing: false,
            progress: success ? 100 : state.progress,
            message: success ? 'Indexing completed successfully!' : 'Indexing failed.',
            totalFiles: totalFiles ?? state.totalFiles
        }));
    },

    stopIndexing: () => {
        indexingState.update(state => ({
            ...state,
            isIndexing: false,
            message: 'Indexing stopped by user.'
        }));
    }
};

export const searchActions = {
    setQuery: (query: string) => {
        searchState.update(state => ({
            ...state,
            query
        }));
    },

    startSearch: () => {
        searchState.update(state => ({
            ...state,
            isSearching: true,
            results: []
        }));
    },

    setResults: (results: SearchResult[], stats: SearchState['stats']) => {
        searchState.update(state => ({
            ...state,
            isSearching: false,
            results,
            stats,
            history: state.query && !state.history.includes(state.query) 
                ? [state.query, ...state.history.slice(0, 9)] 
                : state.history
        }));
    },

    setSearchError: () => {
        searchState.update(state => ({
            ...state,
            isSearching: false,
            results: []
        }));
    },

    setHistory: (history: string[]) => {
        searchState.update(state => ({
            ...state,
            history
        }));
    }
};

// Helper function to reset all state (useful for testing or cleanup)
export const resetAllState = () => {
    appState.set({
        isInitialized: false,
        isLoading: false,
        error: null,
        lastActivity: null,
        isWorkspaceOpen: false
    });

    setupState.set({
        databaseStatus: 'idle',
        providerStatus: 'idle',
        selectedDatabase: '',
        selectedProvider: '',
        isSetupComplete: false,
        setupErrors: []
    });

    indexingState.set({
        isIndexing: false,
        progress: 0,
        message: 'Ready to start indexing...',
        filesProcessed: 0,
        totalFiles: 0,
        currentFile: '',
        stats: {
            totalChunks: 0,
            processedChunks: 0,
            errors: 0,
            startTime: null,
            estimatedTimeRemaining: ''
        }
    });

    searchState.set({
        query: '',
        isSearching: false,
        results: [],
        history: [],
        stats: {
            totalResults: 0,
            searchTime: 0,
            query: ''
        }
    });
};
</file>

<file path="webview/src/lib/stores/viewStore.ts">
import { writable } from 'svelte/store';

/**
 * Type definition for the different views available in the application
 */
export type ViewType = 'setup' | 'indexing' | 'query' | 'diagnostics';

/**
 * Writable store to manage the currently active view
 * Default value is 'setup' as users typically start with setup
 */
export const currentView = writable<ViewType>('setup');

/**
 * Helper function to set the current view
 * @param view - The view to switch to
 */
export function setCurrentView(view: ViewType) {
    currentView.set(view);
}

/**
 * Helper function to get the current view value
 * @returns Promise that resolves to the current view
 */
export function getCurrentView(): Promise<ViewType> {
    return new Promise((resolve) => {
        const unsubscribe = currentView.subscribe((view) => {
            unsubscribe();
            resolve(view);
        });
    });
}
</file>

<file path="webview/vite.config.ts">
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [sveltekit()],
	build: {
		// Optimize bundle size
		minify: 'terser',
		terserOptions: {
			compress: {
				drop_console: true,
				drop_debugger: true,
			},
		},
		// Enable tree-shaking
		rollupOptions: {
			output: {
				manualChunks: (id) => {
					// Separate vendor chunks for better caching
					if (id.includes('node_modules')) {
						if (id.includes('@fluentui/web-components')) {
							return 'fluent-ui';
						}
						return 'vendor';
					}
				},
			},
		},
		// Set chunk size warning limit
		chunkSizeWarningLimit: 1000,
	},
	// Optimize dependencies
	optimizeDeps: {
		include: ['@fluentui/web-components'],
	},
	test: {
		expect: { requireAssertions: true },
		projects: [
			{
				extends: './vite.config.ts',
				test: {
					name: 'client',
					environment: 'browser',
					browser: {
						enabled: true,
						provider: 'playwright',
						instances: [{ browser: 'chromium' }]
					},
					include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
					exclude: ['src/lib/server/**'],
					setupFiles: ['./vitest-setup-client.ts']
				}
			},
			{
				extends: './vite.config.ts',
				test: {
					name: 'server',
					environment: 'node',
					include: ['src/**/*.{test,spec}.{js,ts}'],
					exclude: ['src/**/*.svelte.{test,spec}.{js,ts}']
				}
			}
		]
	}
});
</file>

<file path="webview/src/lib/components/IndexingView.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import {
        provideFluentDesignSystem,
        fluentButton,
        fluentProgressRing,
        fluentCard,
        fluentBadge
    } from '@fluentui/web-components';
    import { postMessage, onMessage } from '$lib/vscodeApi';
    import {
        indexingState,
        indexingActions,
        appActions
    } from '$lib/stores/appStore';
    
    // Register Fluent UI components
    provideFluentDesignSystem().register(
        fluentButton(),
        fluentProgressRing(),
        fluentCard(),
        fluentBadge()
    );

    // Component state
    let isIndexing = false;
    let isPaused = false;
    let indexingProgress = 0;
    let indexingMessage = 'Ready to start indexing...';
    let filesProcessed = 0;
    let totalFiles = 0;
    let currentFile = '';
    let indexingStats = {
        totalChunks: 0,
        processedChunks: 0,
        errors: 0,
        startTime: null as Date | null,
        estimatedTimeRemaining: ''
    };
    let errorMessage = '';
    let successMessage = '';

    // Message handlers
    let unsubscribeFunctions: (() => void)[] = [];

    onMount(() => {
        // Set up message listeners using the wrapper
        unsubscribeFunctions.push(
            onMessage('indexingStarted', () => {
                indexingActions.startIndexing();
                errorMessage = '';
                successMessage = '';
            }),
            onMessage('indexingProgress', (message) => {
                indexingActions.updateProgress(
                    message.percentage || 0,
                    message.message || 'Indexing in progress...',
                    message.filesProcessed,
                    message.totalFiles,
                    message.currentFile
                );
            }),
            onMessage('indexingCompleted', (message) => {
                indexingActions.completeIndexing(message.success ?? false, message.totalFiles);

                if (message.success) {
                    successMessage = `Indexing completed successfully! Processed ${message.totalFiles || 0} files.`;

                    // Check if this is the first successful indexing and trigger tour
                    postMessage('checkFirstRunAndStartTour');
                } else {
                    errorMessage = 'Indexing failed. Please check the logs and try again.';
                }
            }),
            onMessage('indexingStopped', () => {
                indexingActions.stopIndexing();
            }),
            onMessage('pauseIndexingResponse', (message) => {
                if (message.success) {
                    isPaused = true;
                    indexingMessage = 'Indexing paused';
                } else {
                    errorMessage = message.error || 'Failed to pause indexing';
                }
            }),
            onMessage('resumeIndexingResponse', (message) => {
                if (message.success) {
                    isPaused = false;
                    indexingMessage = 'Indexing resumed';
                } else {
                    errorMessage = message.error || 'Failed to resume indexing';
                }
            }),
            onMessage('indexingStatus', (message) => {
                if (message.isIndexing) {
                    indexingActions.startIndexing();
                }
                indexingActions.updateProgress(
                    message.progress || 0,
                    message.message || 'Ready to start indexing...'
                );
                // Update pause state if provided
                if (message.isPaused !== undefined) {
                    isPaused = message.isPaused;
                }
            }),
            onMessage('error', (message) => {
                errorMessage = message.message;
                appActions.setError(message.message);
            })
        );

        // Request current indexing status
        postMessage('getIndexingStatus');
    });

    onDestroy(() => {
        // Clean up message listeners
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    });



    function startIndexing() {
        errorMessage = '';
        successMessage = '';
        
        postMessage('startIndexing');
    }

    function stopIndexing() {
        postMessage('stopIndexing');
    }

    function pauseIndexing() {
        postMessage('pauseIndexing');
    }

    function resumeIndexing() {
        postMessage('resumeIndexing');
    }

    function clearMessages() {
        errorMessage = '';
        successMessage = '';
    }

    function formatTime(seconds: number): string {
        if (seconds < 60) {
            return `${Math.round(seconds)}s`;
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.round(seconds % 60);
            return `${minutes}m ${remainingSeconds}s`;
        } else {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }
    }

    function getElapsedTime(): string {
        if (!indexingStats.startTime) return '';
        const elapsed = (Date.now() - indexingStats.startTime.getTime()) / 1000;
        return formatTime(elapsed);
    }

    $: progressPercentage = Math.round(indexingProgress);
    $: fileProgressText = totalFiles > 0 ? `${filesProcessed} / ${totalFiles} files` : '';
</script>

<div class="indexing-view">
    <div class="indexing-header">
        <h1>Code Indexing</h1>
        <p>Monitor the progress of your codebase indexing process.</p>
    </div>

    <!-- Error/Success Messages -->
    {#if errorMessage}
        <div class="notification error">
            {errorMessage}
            <button class="notification-close" on:click={clearMessages}>√ó</button>
        </div>
    {/if}

    {#if successMessage}
        <div class="notification success">
            {successMessage}
            <button class="notification-close" on:click={clearMessages}>√ó</button>
        </div>
    {/if}

    <!-- Main Indexing Status -->
    <fluent-card class="indexing-status">
        <div class="status-header">
            <h2>Indexing Status</h2>
            <fluent-badge
                appearance={isIndexing ? (isPaused ? 'neutral' : 'accent') : (successMessage ? 'success' : 'neutral')}
            >
                {isIndexing ? (isPaused ? 'Paused' : 'In Progress') : (successMessage ? 'Completed' : 'Ready')}
            </fluent-badge>
        </div>

        <div class="progress-section">
            <div class="progress-info">
                <span class="progress-label">{indexingMessage}</span>
                <span class="progress-percentage">{progressPercentage}%</span>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" style="width: {progressPercentage}%"></div>
            </div>

            {#if fileProgressText}
                <div class="file-progress">
                    {fileProgressText}
                </div>
            {/if}

            {#if currentFile}
                <div class="current-file">
                    Processing: <code>{currentFile}</code>
                </div>
            {/if}
        </div>

        <div class="action-section">
            {#if isIndexing}
                <div class="indexing-controls">
                    {#if isPaused}
                        <fluent-button
                            appearance="accent"
                            on:click={resumeIndexing}
                            role="button"
                            tabindex="0"
                            on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && resumeIndexing()}
                        >
                            <span class="button-icon">‚ñ∂Ô∏è</span>
                            Resume Indexing
                        </fluent-button>
                    {:else}
                        <fluent-button
                            appearance="outline"
                            on:click={pauseIndexing}
                            role="button"
                            tabindex="0"
                            on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && pauseIndexing()}
                        >
                            <span class="button-icon">‚è∏Ô∏è</span>
                            Pause Indexing
                        </fluent-button>
                    {/if}

                    <fluent-button
                        appearance="stealth"
                        on:click={stopIndexing}
                        role="button"
                        tabindex="0"
                        on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && stopIndexing()}
                    >
                        <span class="button-icon">‚èπÔ∏è</span>
                        Stop Indexing
                    </fluent-button>
                </div>
            {:else}
                <fluent-button
                    appearance="accent"
                    on:click={startIndexing}
                    role="button"
                    tabindex="0"
                    on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && startIndexing()}
                >
                    <span class="button-icon">üöÄ</span>
                    Start Indexing
                </fluent-button>
            {/if}
        </div>
    </fluent-card>

    <!-- Indexing Statistics -->
    {#if isIndexing || indexingStats.totalChunks > 0}
        <fluent-card class="indexing-stats">
            <h3>Statistics</h3>
            
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Files Processed</span>
                    <span class="stat-value">{filesProcessed}</span>
                </div>
                
                <div class="stat-item">
                    <span class="stat-label">Total Files</span>
                    <span class="stat-value">{totalFiles}</span>
                </div>
                
                <div class="stat-item">
                    <span class="stat-label">Chunks Created</span>
                    <span class="stat-value">{indexingStats.processedChunks}</span>
                </div>
                
                <div class="stat-item">
                    <span class="stat-label">Errors</span>
                    <span class="stat-value" class:error={indexingStats.errors > 0}>
                        {indexingStats.errors}
                    </span>
                </div>
                
                {#if indexingStats.startTime}
                    <div class="stat-item">
                        <span class="stat-label">Elapsed Time</span>
                        <span class="stat-value">{getElapsedTime()}</span>
                    </div>
                {/if}
                
                {#if indexingStats.estimatedTimeRemaining}
                    <div class="stat-item">
                        <span class="stat-label">Est. Remaining</span>
                        <span class="stat-value">{indexingStats.estimatedTimeRemaining}</span>
                    </div>
                {/if}
            </div>
        </fluent-card>
    {/if}

    <!-- Progress Ring for Active Indexing -->
    {#if isIndexing}
        <div class="progress-ring-container">
            <fluent-progress-ring></fluent-progress-ring>
        </div>
    {/if}
</div>

<style>
    .indexing-view {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        font-family: var(--vscode-font-family);
    }

    .indexing-header {
        text-align: center;
        margin-bottom: 30px;
    }

    .indexing-header h1 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
        font-size: 28px;
    }

    .indexing-header p {
        margin: 0;
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
    }

    .indexing-status {
        margin-bottom: 20px;
        padding: 20px;
    }

    .status-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .status-header h2 {
        margin: 0;
        color: var(--vscode-textLink-foreground);
    }

    .progress-section {
        margin-bottom: 20px;
    }

    .progress-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .progress-label {
        color: var(--vscode-foreground);
        font-weight: 500;
    }

    .progress-percentage {
        color: var(--vscode-textLink-foreground);
        font-weight: bold;
    }

    .progress-bar {
        width: 100%;
        height: 12px;
        background-color: var(--vscode-progressBar-background);
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 10px;
    }

    .progress-fill {
        height: 100%;
        background-color: var(--vscode-progressBar-foreground);
        transition: width 0.3s ease;
        border-radius: 6px;
    }

    .file-progress {
        font-size: 14px;
        color: var(--vscode-descriptionForeground);
        margin-bottom: 5px;
    }

    .current-file {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
    }

    .current-file code {
        background-color: var(--vscode-textCodeBlock-background);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: var(--vscode-editor-font-family);
    }

    .action-section {
        text-align: center;
    }

    .indexing-controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
    }

    .button-icon {
        margin-right: 8px;
    }

    .indexing-stats {
        margin-bottom: 20px;
        padding: 20px;
    }

    .indexing-stats h3 {
        margin: 0 0 15px 0;
        color: var(--vscode-textLink-foreground);
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
    }

    .stat-item {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    .stat-label {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
        text-transform: uppercase;
        font-weight: 500;
    }

    .stat-value {
        font-size: 18px;
        font-weight: bold;
        color: var(--vscode-foreground);
    }

    .stat-value.error {
        color: var(--vscode-errorForeground);
    }

    .progress-ring-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
    }

    .notification {
        padding: 12px 16px;
        border-radius: 4px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .notification.error {
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        color: var(--vscode-inputValidation-errorForeground);
    }

    .notification.success {
        background-color: var(--vscode-charts-green);
        color: white;
    }

    .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
        margin-left: 10px;
    }
</style>
</file>

<file path="webview/src/lib/components/DiagnosticsView.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import {
        provideFluentDesignSystem,
        fluentButton,
        fluentCard,
        fluentBadge,
        fluentProgressRing
    } from '@fluentui/web-components';
    import { postMessage, onMessage } from '$lib/vscodeApi';
    import { setupState, appActions } from '$lib/stores/appStore';
    import ConnectionTester from './ConnectionTester.svelte';
    import WorkspaceSelector from './WorkspaceSelector.svelte';
    
    // Register Fluent UI components
    provideFluentDesignSystem().register(
        fluentButton(),
        fluentCard(),
        fluentBadge(),
        fluentProgressRing()
    );

    // Local state for diagnostics
    let systemStatus = {
        database: 'unknown',
        provider: 'unknown',
        lastIndexed: null as Date | null,
        totalChunks: 0,
        lastError: null as string | null
    };

    // Index management state
    let indexInfo = {
        fileCount: 0,
        vectorCount: 0,
        collectionName: 'No collection found'
    };

    // Workspace management state
    let workspaceInfo = {
        current: null as string | null,
        total: 0,
        hasMultiple: false
    };

    let isTestingConnections = false;
    let isClearingIndex = false;
    let testResults = {
        database: null as any,
        provider: null as any
    };

    // Message handlers
    let unsubscribeFunctions: (() => void)[] = [];

    onMount(() => {
        // Set up message listeners
        unsubscribeFunctions.push(
            onMessage('systemStatus', (message) => {
                systemStatus = { ...systemStatus, ...message.data };
            }),
            onMessage('connectionTestResult', (message) => {
                if (message.data.type === 'database') {
                    testResults.database = message.data.result;
                } else if (message.data.type === 'provider') {
                    testResults.provider = message.data.result;
                }
                isTestingConnections = false;
            }),
            onMessage('getIndexInfoResponse', (message) => {
                if (message.success) {
                    indexInfo = { ...indexInfo, ...message.data };
                }
            }),
            onMessage('clearIndexResponse', (message) => {
                isClearingIndex = false;
                if (message.success) {
                    // Refresh index info after clearing
                    indexInfo = {
                        fileCount: 0,
                        vectorCount: 0,
                        collectionName: 'No collection found'
                    };
                    // Clear any previous errors since the operation was successful
                    appActions.clearError();
                } else {
                    appActions.setError(message.error || 'Failed to clear index');
                }
            }),
            onMessage('workspaceStatsResponse', (message) => {
                if (message.success) {
                    workspaceInfo = {
                        current: message.data.current,
                        total: message.data.total,
                        hasMultiple: message.data.total > 1
                    };
                }
            }),
            onMessage('workspaceChanged', (message) => {
                // Refresh workspace and index info when workspace changes
                if (message.data.workspace) {
                    workspaceInfo.current = message.data.workspace.name;
                    // Refresh index info for the new workspace
                    postMessage('getIndexInfo');
                }
            }),
            onMessage('error', (message) => {
                systemStatus.lastError = message.message;
                appActions.setError(message.message);
                isTestingConnections = false;
                isClearingIndex = false;
            })
        );

        // Request initial system status, index info, and workspace stats
        postMessage('getSystemStatus');
        postMessage('getIndexInfo');
        postMessage('getWorkspaceStats');
    });

    onDestroy(() => {
        // Clean up message listeners
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    });

    function openSettings() {
        postMessage('openSettings');
    }

    function testDatabaseConnection() {
        if (isTestingConnections) return;
        
        isTestingConnections = true;
        testResults.database = null;
        
        postMessage('testDatabaseConnection', {
            type: $setupState.selectedDatabase,
            config: {
                // Use current configuration from settings
                host: 'localhost', // This would come from actual settings
                port: $setupState.selectedDatabase === 'qdrant' ? 6333 : 8000
            }
        });
    }

    function testProviderConnection() {
        if (isTestingConnections) return;
        
        isTestingConnections = true;
        testResults.provider = null;
        
        postMessage('testProviderConnection', {
            type: $setupState.selectedProvider,
            config: {
                // Use current configuration from settings
                endpoint: $setupState.selectedProvider === 'ollama' ? 'http://localhost:11434' : undefined
            }
        });
    }

    function refreshStatus() {
        postMessage('getSystemStatus');
    }

    function clearError() {
        systemStatus.lastError = null;
        appActions.clearError();
    }

    function refreshIndexInfo() {
        postMessage('getIndexInfo');
    }

    function clearIndex() {
        if (isClearingIndex) return;

        // Confirm with user before clearing
        if (confirm('Are you sure you want to clear the entire index? This action cannot be undone.')) {
            isClearingIndex = true;
            postMessage('clearIndex');
        }
    }

    // Helper functions
    function getStatusBadgeAppearance(status: string) {
        switch (status) {
            case 'ready':
            case 'connected':
                return 'accent';
            case 'error':
            case 'disconnected':
                return 'important';
            case 'starting':
            case 'connecting':
                return 'neutral';
            default:
                return 'neutral';
        }
    }

    function formatDate(date: Date | null): string {
        if (!date) return 'Never';
        return date.toLocaleString();
    }

    // Helper function for keyboard event handling
    function handleKeyboardClick(event: KeyboardEvent, callback: () => void) {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            callback();
        }
    }
</script>

<div class="diagnostics-view">
    <div class="diagnostics-header">
        <h1>Status & Diagnostics</h1>
        <p>Monitor system status, test connections, and access configuration settings.</p>

        <!-- Workspace Selection -->
        {#if workspaceInfo.hasMultiple}
            <WorkspaceSelector showLabel={true} compact={false} />
        {/if}

        <div class="header-actions">
            <fluent-button
                appearance="accent"
                on:click={openSettings}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, openSettings)}
                role="button"
                tabindex="0"
            >
                ‚öôÔ∏è Edit Configuration
            </fluent-button>
            <fluent-button
                on:click={refreshStatus}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, refreshStatus)}
                role="button"
                tabindex="0"
            >
                üîÑ Refresh Status
            </fluent-button>
        </div>
    </div>

    <!-- Error Display -->
    {#if systemStatus.lastError}
        <div class="error-banner">
            <div class="error-content">
                <strong>‚ö†Ô∏è Error:</strong> {systemStatus.lastError}
            </div>
            <fluent-button
                appearance="stealth"
                on:click={clearError}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, clearError)}
                role="button"
                tabindex="0"
            >√ó</fluent-button>
        </div>
    {/if}

    <!-- Current Configuration Display -->
    <fluent-card class="config-section">
        <h3>Current Configuration</h3>
        <div class="config-grid">
            <div class="config-item">
                <label for="database-value">Database:</label>
                <div class="config-value">
                    <span id="database-value">{$setupState.selectedDatabase || 'Not configured'}</span>
                    <fluent-badge appearance={getStatusBadgeAppearance($setupState.databaseStatus)}>
                        {$setupState.databaseStatus}
                    </fluent-badge>
                </div>
            </div>
            
            <div class="config-item">
                <label for="provider-value">Embedding Provider:</label>
                <div class="config-value">
                    <span id="provider-value">{$setupState.selectedProvider || 'Not configured'}</span>
                    <fluent-badge appearance={getStatusBadgeAppearance($setupState.providerStatus)}>
                        {$setupState.providerStatus}
                    </fluent-badge>
                </div>
            </div>
            
            <div class="config-item">
                <label for="last-indexed-value">Last Indexed:</label>
                <div class="config-value">
                    <span id="last-indexed-value">{formatDate(systemStatus.lastIndexed)}</span>
                </div>
            </div>
            
            <div class="config-item">
                <label for="total-chunks-value">Total Chunks:</label>
                <div class="config-value">
                    <span id="total-chunks-value">{systemStatus.totalChunks.toLocaleString()}</span>
                </div>
            </div>
        </div>
    </fluent-card>

    <!-- Index Management -->
    <fluent-card class="index-section">
        <h3>Index Management</h3>
        <p>Monitor and manage your workspace index.</p>

        {#if workspaceInfo.current}
            <div class="workspace-context">
                <span class="workspace-label">Current Workspace:</span>
                <span class="workspace-name">{workspaceInfo.current}</span>
                {#if workspaceInfo.hasMultiple}
                    <span class="workspace-count">({workspaceInfo.total} total)</span>
                {/if}
            </div>
        {/if}

        <div class="index-grid">
            <div class="index-item">
                <label for="file-count-value">Indexed Files:</label>
                <div class="index-value">
                    <span id="file-count-value">{indexInfo.fileCount.toLocaleString()}</span>
                </div>
            </div>

            <div class="index-item">
                <label for="vector-count-value">Total Vectors:</label>
                <div class="index-value">
                    <span id="vector-count-value">{indexInfo.vectorCount.toLocaleString()}</span>
                </div>
            </div>

            <div class="index-item">
                <label for="collection-name-value">Collection:</label>
                <div class="index-value">
                    <span id="collection-name-value">{indexInfo.collectionName}</span>
                </div>
            </div>
        </div>

        <div class="index-actions">
            <fluent-button
                appearance="outline"
                on:click={refreshIndexInfo}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, refreshIndexInfo)}
                role="button"
                tabindex="0"
            >
                üîÑ Refresh Index Info
            </fluent-button>

            <fluent-button
                appearance="outline"
                disabled={isClearingIndex || indexInfo.vectorCount === 0}
                on:click={clearIndex}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, clearIndex)}
                role="button"
                tabindex="0"
                style="color: var(--vscode-errorForeground);"
            >
                {#if isClearingIndex}
                    <fluent-progress-ring></fluent-progress-ring>
                    Clearing...
                {:else}
                    üóëÔ∏è Clear Index
                {/if}
            </fluent-button>
        </div>
    </fluent-card>

    <!-- Connection Testing -->
    <fluent-card class="testing-section">
        <h3>Connection Testing</h3>
        <p>Test your database and embedding provider connections to ensure everything is working correctly.</p>
        
        <div class="test-grid">
            <!-- Database Connection Test -->
            <div class="test-item">
                <h4>Database Connection</h4>
                <div class="test-actions">
                    <fluent-button
                        appearance="outline"
                        disabled={isTestingConnections || !$setupState.selectedDatabase}
                        on:click={testDatabaseConnection}
                        on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, testDatabaseConnection)}
                        role="button"
                        tabindex="0"
                    >
                        {#if isTestingConnections && testResults.database === null}
                            <fluent-progress-ring></fluent-progress-ring>
                            Testing...
                        {:else}
                            üîç Test Database
                        {/if}
                    </fluent-button>
                </div>
                
                {#if testResults.database}
                    <div class="test-result" class:success={testResults.database.success} class:error={!testResults.database.success}>
                        <strong>{testResults.database.success ? '‚úÖ Success' : '‚ùå Failed'}:</strong>
                        {testResults.database.message}
                        {#if testResults.database.details}
                            <div class="test-details">{testResults.database.details}</div>
                        {/if}
                    </div>
                {/if}
            </div>

            <!-- Provider Connection Test -->
            <div class="test-item">
                <h4>Embedding Provider</h4>
                <div class="test-actions">
                    <fluent-button
                        appearance="outline"
                        disabled={isTestingConnections || !$setupState.selectedProvider}
                        on:click={testProviderConnection}
                        on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, testProviderConnection)}
                        role="button"
                        tabindex="0"
                    >
                        {#if isTestingConnections && testResults.provider === null}
                            <fluent-progress-ring></fluent-progress-ring>
                            Testing...
                        {:else}
                            üîç Test Provider
                        {/if}
                    </fluent-button>
                </div>
                
                {#if testResults.provider}
                    <div class="test-result" class:success={testResults.provider.success} class:error={!testResults.provider.success}>
                        <strong>{testResults.provider.success ? '‚úÖ Success' : '‚ùå Failed'}:</strong>
                        {testResults.provider.message}
                        {#if testResults.provider.details}
                            <div class="test-details">{testResults.provider.details}</div>
                        {/if}
                    </div>
                {/if}
            </div>
        </div>
    </fluent-card>

    <!-- Quick Actions -->
    <fluent-card class="actions-section">
        <h3>Quick Actions</h3>
        <div class="action-buttons">
            <fluent-button
                appearance="accent"
                on:click={openSettings}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, openSettings)}
                role="button"
                tabindex="0"
            >
                ‚öôÔ∏è Open Settings
            </fluent-button>
            <fluent-button
                on:click={() => postMessage('openMainPanel')}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, () => postMessage('openMainPanel'))}
                role="button"
                tabindex="0"
            >
                üè† Main Panel
            </fluent-button>
            <fluent-button
                on:click={() => postMessage('startIndexing')}
                disabled={!$setupState.isSetupComplete}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, () => postMessage('startIndexing'))}
                role="button"
                tabindex="0"
            >
                üöÄ Start Indexing
            </fluent-button>
        </div>
    </fluent-card>
</div>

<style>
    .diagnostics-view {
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        font-family: var(--vscode-font-family);
    }

    .diagnostics-header {
        text-align: center;
        margin-bottom: 30px;
    }

    .diagnostics-header h1 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
        font-size: 28px;
    }

    .diagnostics-header p {
        margin: 0 0 20px 0;
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
    }

    .header-actions {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
    }

    .error-banner {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        margin-bottom: 20px;
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        border-radius: 4px;
        color: var(--vscode-inputValidation-errorForeground);
    }

    .error-content {
        flex: 1;
    }

    .config-section, .index-section, .testing-section, .actions-section {
        margin-bottom: 20px;
        padding: 20px;
    }

    .config-section h3, .index-section h3, .testing-section h3, .actions-section h3 {
        margin: 0 0 15px 0;
        color: var(--vscode-textLink-foreground);
    }

    .config-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
    }

    .config-item {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    .config-item label {
        font-weight: 600;
        color: var(--vscode-foreground);
        font-size: 14px;
    }

    .config-value {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .config-value span {
        color: var(--vscode-descriptionForeground);
    }

    .index-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
    }

    .index-item {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    .index-item label {
        font-weight: 600;
        color: var(--vscode-foreground);
        font-size: 14px;
    }

    .index-value {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .index-value span {
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
        font-weight: 500;
    }

    .index-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-start;
    }

    .workspace-context {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 15px;
        padding: 8px 12px;
        background-color: var(--vscode-editor-inactiveSelectionBackground);
        border-radius: 4px;
        border-left: 3px solid var(--vscode-textLink-foreground);
    }

    .workspace-label {
        font-weight: 600;
        color: var(--vscode-foreground);
        font-size: 13px;
    }

    .workspace-name {
        color: var(--vscode-textLink-foreground);
        font-weight: 500;
        font-size: 13px;
    }

    .workspace-count {
        color: var(--vscode-descriptionForeground);
        font-size: 12px;
        font-style: italic;
    }

    .test-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
    }

    .test-item {
        padding: 15px;
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        background-color: var(--vscode-textCodeBlock-background);
    }

    .test-item h4 {
        margin: 0 0 10px 0;
        color: var(--vscode-foreground);
    }

    .test-actions {
        margin-bottom: 15px;
    }

    .test-result {
        padding: 10px;
        border-radius: 4px;
        font-size: 14px;
    }

    .test-result.success {
        background-color: var(--vscode-charts-green);
        color: white;
    }

    .test-result.error {
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        color: var(--vscode-inputValidation-errorForeground);
    }

    .test-details {
        margin-top: 5px;
        font-size: 12px;
        opacity: 0.9;
    }

    .action-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }

    @media (max-width: 600px) {
        .config-grid {
            grid-template-columns: 1fr;
        }
        
        .test-grid {
            grid-template-columns: 1fr;
        }
        
        .header-actions, .action-buttons {
            flex-direction: column;
            align-items: center;
        }
    }
</style>
</file>

<file path="webview/src/lib/vscodeApi.ts">
/**
 * VS Code API Wrapper
 * 
 * This module provides a clean, typed interface for communicating with the VS Code extension.
 * It wraps the acquireVsCodeApi() call and provides helper functions for message passing.
 */

// Types for VS Code API communication
export interface VSCodeMessage {
    command: string;
    requestId?: string;
    [key: string]: any;
}

export interface VSCodeResponse {
    command: string;
    requestId?: string;
    success?: boolean;
    data?: any;
    error?: string;
    [key: string]: any;
}

// Message handler type
export type MessageHandler = (message: VSCodeResponse) => void;

// VS Code API instance
let vscodeApi: any = null;

// Message handlers registry
const messageHandlers = new Map<string, MessageHandler[]>();

// Request-response tracking
const pendingRequests = new Map<string, {
    resolve: (value: any) => void;
    reject: (error: any) => void;
    timeout: NodeJS.Timeout;
}>();

/**
 * Initialize the VS Code API
 * This should be called once when the webview loads
 */
export function initializeVSCodeApi(): void {
    if (typeof window !== 'undefined' && (window as any).acquireVsCodeApi) {
        vscodeApi = (window as any).acquireVsCodeApi();
        
        // Set up the global message listener
        window.addEventListener('message', handleIncomingMessage);
        
        console.log('VS Code API initialized');
    } else {
        console.warn('VS Code API not available - running outside of VS Code webview');
    }
}

/**
 * Handle incoming messages from the extension
 */
function handleIncomingMessage(event: MessageEvent): void {
    const message: VSCodeResponse = event.data;
    
    // Handle request-response pattern
    if (message.requestId && pendingRequests.has(message.requestId)) {
        const request = pendingRequests.get(message.requestId)!;
        clearTimeout(request.timeout);
        pendingRequests.delete(message.requestId);
        
        if (message.error) {
            request.reject(new Error(message.error));
        } else {
            request.resolve(message.data || message);
        }
        return;
    }
    
    // Handle command-based messages
    if (message.command && messageHandlers.has(message.command)) {
        const handlers = messageHandlers.get(message.command)!;
        handlers.forEach(handler => {
            try {
                handler(message);
            } catch (error) {
                console.error(`Error in message handler for command '${message.command}':`, error);
            }
        });
    }
}

/**
 * Send a message to the VS Code extension
 * @param command - The command to send
 * @param data - Additional data to send with the command
 */
export function postMessage(command: string, data: any = {}): void {
    if (!vscodeApi) {
        console.warn('VS Code API not initialized. Call initializeVSCodeApi() first.');
        return;
    }
    
    const message: VSCodeMessage = {
        command,
        ...data
    };
    
    vscodeApi.postMessage(message);
}

/**
 * Send a message and wait for a response
 * @param command - The command to send
 * @param data - Additional data to send with the command
 * @param timeout - Timeout in milliseconds (default: 10000)
 * @returns Promise that resolves with the response
 */
export function sendRequest(command: string, data: any = {}, timeout: number = 10000): Promise<any> {
    return new Promise((resolve, reject) => {
        if (!vscodeApi) {
            reject(new Error('VS Code API not initialized'));
            return;
        }
        
        const requestId = generateRequestId();
        
        // Set up timeout
        const timeoutHandle = setTimeout(() => {
            pendingRequests.delete(requestId);
            reject(new Error(`Request timeout for command: ${command}`));
        }, timeout);
        
        // Store the request
        pendingRequests.set(requestId, {
            resolve,
            reject,
            timeout: timeoutHandle
        });
        
        // Send the message
        const message: VSCodeMessage = {
            command,
            requestId,
            ...data
        };
        
        vscodeApi.postMessage(message);
    });
}

/**
 * Register a message handler for a specific command
 * @param command - The command to listen for
 * @param handler - The handler function
 * @returns Unsubscribe function
 */
export function onMessage(command: string, handler: MessageHandler): () => void {
    if (!messageHandlers.has(command)) {
        messageHandlers.set(command, []);
    }
    
    const handlers = messageHandlers.get(command)!;
    handlers.push(handler);
    
    // Return unsubscribe function
    return () => {
        const index = handlers.indexOf(handler);
        if (index > -1) {
            handlers.splice(index, 1);
        }
        
        // Clean up empty handler arrays
        if (handlers.length === 0) {
            messageHandlers.delete(command);
        }
    };
}

/**
 * Remove all message handlers for a command
 * @param command - The command to clear handlers for
 */
export function clearMessageHandlers(command?: string): void {
    if (command) {
        messageHandlers.delete(command);
    } else {
        messageHandlers.clear();
    }
}

/**
 * Generate a unique request ID
 */
function generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Get the current state of the VS Code API
 */
export function getState(): any {
    if (!vscodeApi) {
        return null;
    }
    return vscodeApi.getState();
}

/**
 * Set the state in VS Code
 * @param state - The state to save
 */
export function setState(state: any): void {
    if (!vscodeApi) {
        console.warn('VS Code API not initialized');
        return;
    }
    vscodeApi.setState(state);
}

/**
 * Check if the VS Code API is available and initialized
 */
export function isInitialized(): boolean {
    return vscodeApi !== null;
}

// Auto-initialize when the module is loaded
if (typeof window !== 'undefined') {
    // Initialize on next tick to ensure DOM is ready
    setTimeout(initializeVSCodeApi, 0);
}
</file>

<file path="webview/src/lib/components/QueryView.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import {
        provideFluentDesignSystem,
        fluentButton,
        fluentTextField,
        fluentCard,
        fluentBadge,
        fluentAccordion,
        fluentAccordionItem
    } from '@fluentui/web-components';
    import { postMessage, onMessage } from '$lib/vscodeApi';
    import {
        searchState,
        searchActions,
        appActions
    } from '$lib/stores/appStore';
    import ResultCard from './ResultCard.svelte';
    import HistoryView from './HistoryView.svelte';
    
    // Register Fluent UI components
    provideFluentDesignSystem().register(
        fluentButton(),
        fluentTextField(),
        fluentCard(),
        fluentBadge(),
        fluentAccordion(),
        fluentAccordionItem()
    );

    // Component state
    let searchQuery = '';
    let maxResults = 20; // Default max results
    let includeContent = false; // Default to not include file content
    let isSearching = false;
    let searchResults: SearchResult[] = [];
    let xmlResults = ''; // For XML formatted results
    let resultFormat: 'json' | 'xml' = 'json'; // Track result format
    let viewMode: 'UI' | 'XML' = 'UI'; // Toggle between UI cards and raw XML
    let searchHistory: string[] = [];

    // Pagination state
    let currentPage = 1;
    let pageSize = 20;
    let totalResults = 0;
    let totalPages = 0;
    let hasMore = false;
    let isLoadingMore = false;
    let errorMessage = '';
    let searchStats = {
        totalResults: 0,
        searchTime: 0,
        query: ''
    };

    interface SearchResult {
        id: string;
        file: string;
        content: string;
        score: number;
        lineNumber?: number;
        context?: string;
        relatedFiles?: RelatedFile[];
    }

    interface RelatedFile {
        file: string;
        score: number;
        reason: string;
    }

    // Message handlers
    let unsubscribeFunctions: (() => void)[] = [];

    onMount(() => {
        // Set up message listeners using the wrapper
        unsubscribeFunctions.push(
            onMessage('searchResults', (message) => {
                isSearching = false;
                isLoadingMore = false;
                resultFormat = message.format || 'json';

                // Update pagination state
                const newPage = message.page || 1;
                const newPageSize = message.pageSize || 20;
                const newTotalResults = message.totalResults || 0;
                const newTotalPages = message.totalPages || 0;
                const newHasMore = message.hasMore || false;

                // Determine if this is a new search or pagination
                const isNewSearch = newPage === 1 || currentPage === 1;
                const isPagination = newPage > 1 && newPage > currentPage;

                if (resultFormat === 'xml') {
                    // Handle XML results (no pagination for XML)
                    xmlResults = message.results || '';
                    searchResults = []; // Clear JSON results
                } else {
                    // Handle JSON results with pagination support
                    if (isNewSearch) {
                        // New search: replace results
                        searchResults = message.results || [];
                    } else if (isPagination) {
                        // Pagination: append results
                        searchResults = [...searchResults, ...(message.results || [])];
                    } else {
                        // Fallback: replace results
                        searchResults = message.results || [];
                    }
                    xmlResults = ''; // Clear XML results
                }

                // Update pagination state
                currentPage = newPage;
                pageSize = newPageSize;
                totalResults = newTotalResults;
                totalPages = newTotalPages;
                hasMore = newHasMore;

                searchStats = {
                    totalResults: totalResults,
                    searchTime: message.searchTime || 0,
                    query: message.query || ''
                };

                // Save search to history (only for first page to avoid duplicates)
                if (message.query && message.query.trim() && currentPage === 1) {
                    const resultsCount = resultFormat === 'json' ? totalResults : (xmlResults ? 1 : 0);
                    postMessage('addSearchHistory', {
                        query: message.query.trim(),
                        resultsCount: resultsCount,
                        resultFormat: resultFormat,
                        executionTime: message.searchTime || 0
                    });
                }

                if ((resultFormat === 'json' && searchResults.length === 0) ||
                    (resultFormat === 'xml' && !xmlResults.trim())) {
                    if (searchQuery.trim()) {
                        errorMessage = 'No results found for your query.';
                    }
                }
            }),
            onMessage('searchHistory', (message) => {
                searchHistory = message.history || [];
            }),
            onMessage('searchError', (message) => {
                isSearching = false;
                errorMessage = message.message || 'Search failed. Please try again.';
            }),
            onMessage('error', (message) => {
                errorMessage = message.message;
            })
        );

        // Request search history
        postMessage('getSearchHistory');
    });

    onDestroy(() => {
        // Clean up message listeners
        unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    });



    function handleSearch(resetPagination = true) {
        if (!searchQuery.trim()) {
            errorMessage = 'Please enter a search query.';
            return;
        }

        isSearching = true;
        errorMessage = '';

        // Reset pagination for new searches
        if (resetPagination) {
            currentPage = 1;
            searchResults = [];
        }

        postMessage('search', {
            query: searchQuery.trim(),
            maxResults: maxResults,
            includeContent: includeContent,
            page: currentPage,
            pageSize: pageSize
        });
    }

    function handleKeyPress(event: KeyboardEvent) {
        if (event.key === 'Enter') {
            handleSearch();
        }
    }

    function selectHistoryItem(query: string) {
        searchQuery = query;
        handleSearch();
    }

    function loadMoreResults() {
        if (!hasMore || isLoadingMore || !searchQuery.trim()) {
            return;
        }

        isLoadingMore = true;
        currentPage += 1;

        postMessage('search', {
            query: searchQuery.trim(),
            maxResults: maxResults,
            includeContent: includeContent,
            page: currentPage,
            pageSize: pageSize
        });
    }

    function openFile(filePath: string, lineNumber?: number) {
        postMessage('openFile', {
            file: filePath,
            line: lineNumber
        });
    }

    function clearMessages() {
        errorMessage = '';
    }

    function formatSearchTime(ms: number): string {
        if (ms < 1000) {
            return `${Math.round(ms)}ms`;
        } else {
            return `${(ms / 1000).toFixed(2)}s`;
        }
    }

    function getScoreColor(score: number): string {
        if (score >= 0.8) return 'var(--vscode-charts-green)';
        if (score >= 0.6) return 'var(--vscode-charts-yellow)';
        if (score >= 0.4) return 'var(--vscode-charts-orange)';
        return 'var(--vscode-charts-red)';
    }

    function truncateContent(content: string, maxLength: number = 200): string {
        if (content.length <= maxLength) return content;
        return content.substring(0, maxLength) + '...';
    }

    // Helper function for keyboard event handling
    function handleKeyboardClick(event: KeyboardEvent, callback: () => void) {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            callback();
        }
    }
</script>

<div class="query-view">
    <div class="query-header">
        <h1>Code Search</h1>
        <p>Search through your indexed codebase using semantic similarity.</p>
    </div>

    <!-- Search Input -->
    <fluent-card class="search-section">
        <div class="search-input-container">
            <fluent-text-field
                placeholder="Enter your search query (e.g., 'function that handles user authentication')"
                value={searchQuery}
                on:input={(e: Event) => searchQuery = (e.target as HTMLInputElement).value}
                on:keypress={handleKeyPress}
                class="search-input"
                size="large"
                role="textbox"
                tabindex="0"
            ></fluent-text-field>

            <fluent-button
                appearance="accent"
                disabled={isSearching || !searchQuery.trim()}
                on:click={handleSearch}
                on:keydown={(e: KeyboardEvent) => e.key === 'Enter' && handleSearch()}
                class="search-button"
                role="button"
                tabindex="0"
            >
                {#if isSearching}
                    Searching...
                {:else}
                    üîç Search
                {/if}
            </fluent-button>
        </div>

        <!-- Advanced Search Controls -->
        <div class="advanced-controls">
            <div class="control-group">
                <label for="max-results">Max Results:</label>
                <fluent-text-field
                    id="max-results"
                    type="number"
                    value={maxResults.toString()}
                    on:input={(e: Event) => maxResults = parseInt((e.target as HTMLInputElement).value) || 20}
                    min="1"
                    max="100"
                    class="number-input"
                    size="small"
                ></fluent-text-field>
            </div>

            <div class="control-group">
                <label for="include-content" class="checkbox-label">
                    <input
                        id="include-content"
                        type="checkbox"
                        bind:checked={includeContent}
                        class="checkbox-input"
                    />
                    <span class="checkbox-text">Include file content</span>
                </label>
            </div>
        </div>

        {#if searchStats.query && searchStats.totalResults > 0}
            <div class="search-stats">
                Found {searchStats.totalResults} results for "{searchStats.query}" 
                in {formatSearchTime(searchStats.searchTime)}
            </div>
        {/if}
    </fluent-card>

    <!-- Error Messages -->
    {#if errorMessage}
        <div class="notification error">
            {errorMessage}
            <button
                class="notification-close"
                on:click={clearMessages}
                on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, clearMessages)}
                role="button"
                tabindex="0"
            >√ó</button>
        </div>
    {/if}

    <!-- Search History -->
    {#if searchHistory.length > 0 && !isSearching && searchResults.length === 0}
        <fluent-card class="search-history">
            <h3>Recent Searches</h3>
            <div class="history-items">
                {#each searchHistory.slice(0, 5) as historyItem}
                    <button
                        class="history-item"
                        on:click={() => selectHistoryItem(historyItem)}
                        on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, () => selectHistoryItem(historyItem))}
                        role="button"
                        tabindex="0"
                    >
                        {historyItem}
                    </button>
                {/each}
            </div>
        </fluent-card>
    {/if}

    <!-- Search History (show when no active search and no results) -->
    {#if !isSearching && !searchQuery.trim() && searchResults.length === 0 && !xmlResults}
        <div class="history-section">
            <HistoryView on:rerun={(event) => {
                searchQuery = event.detail.query;
                handleSearch();
            }} />
        </div>
    {/if}

    <!-- View Mode Toggle (only show when we have results) -->
    {#if (resultFormat === 'json' && searchResults.length > 0) || (resultFormat === 'xml' && xmlResults)}
        <div class="view-toggle-section">
            <fluent-card class="view-toggle-card">
                <div class="view-toggle-container">
                    <span class="toggle-label">View Mode:</span>
                    <div class="toggle-buttons">
                        <button
                            class="toggle-btn {viewMode === 'UI' ? 'active' : ''}"
                            on:click={() => viewMode = 'UI'}
                        >
                            üé® UI View
                        </button>
                        <button
                            class="toggle-btn {viewMode === 'XML' ? 'active' : ''}"
                            on:click={() => viewMode = 'XML'}
                        >
                            üìÑ XML View
                        </button>
                    </div>
                </div>
            </fluent-card>
        </div>
    {/if}

    <!-- Search Results Display -->
    {#if (resultFormat === 'json' && searchResults.length > 0) || (resultFormat === 'xml' && xmlResults)}
        <div class="results-section">
            {#if viewMode === 'UI'}
                <!-- UI View: Interactive Cards -->
                {#if resultFormat === 'json' && searchResults.length > 0}
                    {#each searchResults as result, index}
                        <ResultCard {result} {index} />
                    {/each}
                {:else if resultFormat === 'xml' && xmlResults}
                    <!-- For XML results, show a message that UI view is not available -->
                    <fluent-card class="xml-ui-message">
                        <div class="message-content">
                            <h3>üé® UI View Not Available</h3>
                            <p>The UI view is only available for JSON formatted results. Switch to XML view to see the raw data.</p>
                        </div>
                    </fluent-card>
                {/if}
            {:else}
                <!-- XML View: Raw Data -->
                {#if resultFormat === 'json' && searchResults.length > 0}
                    <!-- Convert JSON results to XML-like display -->
                    <fluent-card class="xml-results">
                        <div class="xml-header">
                            <h3>üìÑ Search Results (JSON Data)</h3>
                            <div class="xml-actions">
                                <fluent-button
                                    appearance="outline"
                                    on:click={() => copyToClipboard(JSON.stringify(searchResults, null, 2))}
                                >
                                    üìã Copy JSON
                                </fluent-button>
                            </div>
                        </div>
                        <pre class="xml-content"><code>{JSON.stringify(searchResults, null, 2)}</code></pre>
                    </fluent-card>
                {:else if resultFormat === 'xml' && xmlResults}
                    <!-- Show actual XML results -->
                    <fluent-card class="xml-results">
                        <div class="xml-header">
                            <h3>üìÑ Search Results (XML Format)</h3>
                            <div class="xml-actions">
                                <fluent-button
                                    appearance="outline"
                                    on:click={() => copyToClipboard(xmlResults)}
                                >
                                    üìã Copy XML
                                </fluent-button>
                            </div>
                        </div>
                        <pre class="xml-content"><code>{xmlResults}</code></pre>
                    </fluent-card>
                {/if}
            {/if}
        </div>
    {/if}

    <!-- Pagination Controls -->
    {#if (resultFormat === 'json' && searchResults.length > 0) || (resultFormat === 'xml' && xmlResults)}
        <div class="pagination-section">
            <fluent-card class="pagination-card">
                <div class="pagination-info">
                    <span class="results-summary">
                        Showing {searchResults.length} of {totalResults} results
                        {#if totalPages > 1}
                            (Page {currentPage} of {totalPages})
                        {/if}
                    </span>

                    {#if searchStats.searchTime > 0}
                        <span class="search-time">
                            ‚Ä¢ {formatSearchTime(searchStats.searchTime)}
                        </span>
                    {/if}
                </div>

                {#if hasMore && viewMode === 'UI'}
                    <div class="pagination-actions">
                        <fluent-button
                            appearance="outline"
                            disabled={isLoadingMore}
                            on:click={loadMoreResults}
                            class="load-more-btn"
                        >
                            {#if isLoadingMore}
                                <div class="loading-spinner small"></div>
                                Loading...
                            {:else}
                                üìÑ Load More Results
                            {/if}
                        </fluent-button>
                    </div>
                {/if}
            </fluent-card>
        </div>
    {/if}

    <!-- Legacy XML Results (keeping for backward compatibility) -->
    {#if false && resultFormat === 'xml' && xmlResults}
        <div class="results-section">
            <fluent-card class="xml-results">
                <div class="xml-header">
                    <h3>üìÑ Search Results (XML Format)</h3>
                    <div class="xml-actions">
                        <fluent-button
                            appearance="outline"
                            on:click={() => navigator.clipboard.writeText(xmlResults)}
                            on:keydown={(e: KeyboardEvent) => handleKeyboardClick(e, () => navigator.clipboard.writeText(xmlResults))}
                            role="button"
                            tabindex="0"
                        >
                            üìã Copy XML
                        </fluent-button>
                    </div>
                </div>
                <div class="xml-content">
                    <pre><code>{xmlResults}</code></pre>
                </div>
            </fluent-card>
        </div>
    {/if}

    <!-- Loading State -->
    {#if isSearching}
        <fluent-card class="loading-state">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <p>Searching through your codebase...</p>
            </div>
        </fluent-card>
    {/if}

    <!-- Empty State -->
    {#if !isSearching && searchResults.length === 0 && !xmlResults && !searchQuery.trim() && searchHistory.length === 0}
        <fluent-card class="empty-state">
            <div class="empty-content">
                <div class="empty-icon">üîç</div>
                <h3>Ready to Search</h3>
                <p>Enter a search query above to find relevant code in your indexed codebase.</p>
                <div class="search-tips">
                    <h4>Search Tips:</h4>
                    <ul>
                        <li>Use natural language: "function that validates email"</li>
                        <li>Describe functionality: "code that handles file uploads"</li>
                        <li>Ask questions: "how to connect to database"</li>
                    </ul>
                </div>
            </div>
        </fluent-card>
    {/if}
</div>

<style>
    .query-view {
        max-width: 1000px;
        margin: 0 auto;
        padding: 20px;
        font-family: var(--vscode-font-family);
    }

    .query-header {
        text-align: center;
        margin-bottom: 30px;
    }

    .query-header h1 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
        font-size: 28px;
    }

    .query-header p {
        margin: 0;
        color: var(--vscode-descriptionForeground);
        font-size: 16px;
    }

    .search-section {
        margin-bottom: 20px;
        padding: 20px;
    }

    .search-input-container {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-bottom: 10px;
    }

    .search-input {
        flex: 1;
    }

    .search-button {
        min-width: 120px;
    }

    .search-stats {
        font-size: 14px;
        color: var(--vscode-descriptionForeground);
        text-align: center;
    }

    .search-history {
        margin-bottom: 20px;
        padding: 20px;
    }

    .search-history h3 {
        margin: 0 0 15px 0;
        color: var(--vscode-textLink-foreground);
    }

    .history-items {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
    }

    .history-item {
        padding: 8px 12px;
        border: 1px solid var(--vscode-panel-border);
        border-radius: 4px;
        background-color: var(--vscode-sideBar-background);
        color: var(--vscode-foreground);
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        transition: background-color 0.2s ease;
    }

    .history-item:hover {
        background-color: var(--vscode-list-hoverBackground);
    }

    .results-section {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .result-item {
        padding: 20px;
    }

    .result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .result-file {
        flex: 1;
    }

    .file-link {
        background: none;
        border: none;
        color: var(--vscode-textLink-foreground);
        cursor: pointer;
        font-family: inherit;
        font-size: 16px;
        font-weight: 500;
        text-decoration: underline;
        padding: 0;
    }

    .file-link:hover {
        color: var(--vscode-textLink-activeForeground);
    }

    .line-number {
        color: var(--vscode-descriptionForeground);
        font-weight: normal;
    }

    .result-content {
        margin-bottom: 15px;
    }

    .result-content pre {
        margin: 0;
        padding: 15px;
        background-color: var(--vscode-textCodeBlock-background);
        border-radius: 4px;
        overflow-x: auto;
        font-family: var(--vscode-editor-font-family);
        font-size: 14px;
        line-height: 1.4;
    }

    .result-content code {
        color: var(--vscode-foreground);
    }

    .result-context {
        margin-bottom: 15px;
        padding: 10px;
        background-color: var(--vscode-sideBar-background);
        border-radius: 4px;
        font-size: 14px;
        color: var(--vscode-foreground);
    }

    .related-files {
        margin-top: 15px;
    }

    .related-files-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 10px 0;
    }

    .related-file {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px;
        background-color: var(--vscode-sideBar-background);
        border-radius: 4px;
    }

    .related-reason {
        flex: 1;
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
    }

    .loading-state {
        padding: 40px;
        text-align: center;
    }

    .loading-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    .loading-spinner {
        width: 32px;
        height: 32px;
        border: 3px solid var(--vscode-panel-border);
        border-top: 3px solid var(--vscode-button-background);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .empty-state {
        padding: 40px;
        text-align: center;
    }

    .empty-content {
        max-width: 500px;
        margin: 0 auto;
    }

    .empty-icon {
        font-size: 48px;
        margin-bottom: 20px;
    }

    .empty-content h3 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
    }

    .empty-content p {
        margin: 0 0 20px 0;
        color: var(--vscode-descriptionForeground);
    }

    .search-tips {
        text-align: left;
        background-color: var(--vscode-sideBar-background);
        padding: 20px;
        border-radius: 6px;
    }

    .search-tips h4 {
        margin: 0 0 10px 0;
        color: var(--vscode-textLink-foreground);
    }

    .search-tips ul {
        margin: 0;
        padding-left: 20px;
        color: var(--vscode-foreground);
    }

    .search-tips li {
        margin-bottom: 5px;
    }

    .notification {
        padding: 12px 16px;
        border-radius: 4px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .notification.error {
        background-color: var(--vscode-inputValidation-errorBackground);
        border: 1px solid var(--vscode-inputValidation-errorBorder);
        color: var(--vscode-inputValidation-errorForeground);
    }

    .notification-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
        margin-left: 10px;
    }

    /* Advanced Controls Styles */
    .advanced-controls {
        display: flex;
        gap: 20px;
        align-items: center;
        margin-top: 15px;
        padding: 15px;
        background-color: var(--vscode-sideBar-background);
        border-radius: 6px;
        border: 1px solid var(--vscode-panel-border);
    }

    .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .control-group label {
        font-size: 14px;
        color: var(--vscode-foreground);
        font-weight: 500;
        white-space: nowrap;
    }

    .number-input {
        width: 80px;
    }

    .checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        user-select: none;
    }

    .checkbox-input {
        margin: 0;
        cursor: pointer;
    }

    .checkbox-text {
        font-size: 14px;
        color: var(--vscode-foreground);
        cursor: pointer;
    }

    @media (max-width: 600px) {
        .advanced-controls {
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
        }
    }

    /* Sidebar-specific responsive styles */
    @media (max-width: 400px) {
        .query-container {
            padding: 8px;
        }

        .search-section {
            padding: 12px;
        }

        .advanced-controls {
            padding: 12px;
        }

        .control-group {
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
        }

        .number-input {
            width: 100%;
            max-width: 120px;
        }

        .xml-actions {
            flex-direction: column;
            gap: 8px;
        }

        .xml-content {
            padding: 10px;
            max-height: 300px;
        }
    }

    @container (max-width: 350px) {
        .query-container {
            padding: 4px;
        }

        .search-section,
        .advanced-controls {
            padding: 8px;
        }

        .xml-content {
            padding: 8px;
            max-height: 250px;
        }
    }

    /* XML Results Styles */
    .xml-results {
        margin-bottom: 20px;
    }

    .xml-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--vscode-panel-border);
    }

    .xml-header h3 {
        margin: 0;
        color: var(--vscode-textLink-foreground);
        font-size: 16px;
    }

    .xml-actions {
        display: flex;
        gap: 10px;
    }

    .xml-content {
        background-color: var(--vscode-editor-background);
        border: 1px solid var(--vscode-panel-border);
        border-radius: 4px;
        padding: 15px;
        overflow-x: auto;
        max-height: 500px;
        overflow-y: auto;
    }

    .xml-content pre {
        margin: 0;
        font-family: var(--vscode-editor-font-family);
        font-size: var(--vscode-editor-font-size);
        line-height: 1.4;
        color: var(--vscode-editor-foreground);
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .xml-content code {
        background: none;
        padding: 0;
        border: none;
        font-family: inherit;
        font-size: inherit;
        color: inherit;
    }

    /* View Toggle Styles */
    .view-toggle-section {
        margin-bottom: 16px;
    }

    .view-toggle-card {
        padding: 12px 16px;
    }

    .view-toggle-container {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .toggle-label {
        font-size: 13px;
        font-weight: 500;
        color: var(--vscode-foreground);
    }

    .toggle-buttons {
        display: flex;
        gap: 4px;
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        overflow: hidden;
    }

    .toggle-btn {
        background-color: var(--vscode-button-secondaryBackground);
        border: none;
        color: var(--vscode-button-secondaryForeground);
        cursor: pointer;
        font-size: 12px;
        padding: 8px 12px;
        transition: all 0.2s ease;
        border-radius: 0;
    }

    .toggle-btn:hover {
        background-color: var(--vscode-button-secondaryHoverBackground);
    }

    .toggle-btn.active {
        background-color: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
    }

    .xml-ui-message {
        padding: 20px;
        text-align: center;
    }

    .message-content h3 {
        margin: 0 0 8px 0;
        color: var(--vscode-foreground);
    }

    .message-content p {
        margin: 0;
        color: var(--vscode-descriptionForeground);
        font-size: 13px;
    }

    /* History Section Styles */
    .history-section {
        margin-bottom: 16px;
    }

    /* Pagination Styles */
    .pagination-section {
        margin-top: 16px;
    }

    .pagination-card {
        padding: 16px 20px;
        background-color: var(--vscode-sideBar-background);
        border: 1px solid var(--vscode-panel-border);
    }

    .pagination-info {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
        font-size: 13px;
        color: var(--vscode-descriptionForeground);
    }

    .results-summary {
        font-weight: 500;
        color: var(--vscode-foreground);
    }

    .search-time {
        color: var(--vscode-charts-green);
        font-family: var(--vscode-editor-font-family);
    }

    .pagination-actions {
        display: flex;
        justify-content: center;
    }

    .load-more-btn {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 160px;
        justify-content: center;
    }

    .loading-spinner.small {
        width: 14px;
        height: 14px;
        border-width: 2px;
    }
</style>
</file>

<file path="webview/src/routes/+page.svelte">
<script lang="ts">
    import { onMount } from 'svelte';
    import { currentView, type ViewType } from '$lib/stores/viewStore';
    import { initializePersistence } from '$lib/stores/persistence';
    import { appActions, appState } from '$lib/stores/appStore';
    import ErrorBoundary from '$lib/components/ErrorBoundary.svelte';
    import GuidedTour from '$lib/components/GuidedTour.svelte';
    import NoWorkspaceView from '$lib/components/NoWorkspaceView.svelte';
    import { performanceTracker, measureComponentLoad } from '$lib/utils/performance';
    import { registerCoreComponents } from '$lib/utils/fluentUI';
    import { fadeIn, slideInFromBottom } from '$lib/utils/animations';
    import { postMessage, onMessage } from '$lib/vscodeApi';

    // Dynamic imports for code splitting
    let SetupView: any = null;
    let IndexingView: any = null;
    let QueryView: any = null;
    let DiagnosticsView: any = null;

    // Loading states
    let componentsLoaded = {
        setup: false,
        indexing: false,
        query: false,
        diagnostics: false
    };

    // Component container references for animations
    let componentContainer: HTMLElement;

    // Current view state
    let view: ViewType = 'setup';

    // Guided tour state
    let guidedTourComponent: GuidedTour;
    let hasCompletedFirstRun = true; // Default to true, will be updated from extension

    /**
     * Animate component when it loads
     */
    function animateComponentLoad() {
        if (componentContainer) {
            slideInFromBottom(componentContainer, { duration: 400 });
        }
    }

    /**
     * Dynamically load a component
     */
    async function loadComponent(componentName: 'setup' | 'indexing' | 'query' | 'diagnostics') {
        if (componentsLoaded[componentName]) return;

        const loadMeasure = measureComponentLoad(componentName);
        loadMeasure.start();

        try {
            switch (componentName) {
                case 'setup':
                    if (!SetupView) {
                        const module = await import('$lib/components/SetupView.svelte');
                        SetupView = module.default;
                        componentsLoaded.setup = true;
                        // Trigger animation after component is ready
                        setTimeout(animateComponentLoad, 50);
                    }
                    break;
                case 'indexing':
                    if (!IndexingView) {
                        const module = await import('$lib/components/IndexingView.svelte');
                        IndexingView = module.default;
                        componentsLoaded.indexing = true;
                    }
                    break;
                case 'query':
                    if (!QueryView) {
                        const module = await import('$lib/components/QueryView.svelte');
                        QueryView = module.default;
                        componentsLoaded.query = true;
                    }
                    break;
                case 'diagnostics':
                    if (!DiagnosticsView) {
                        const module = await import('$lib/components/DiagnosticsView.svelte');
                        DiagnosticsView = module.default;
                        componentsLoaded.diagnostics = true;
                    }
                    break;
            }
            loadMeasure.end();
        } catch (error) {
            loadMeasure.end();
            console.error(`Failed to load ${componentName} component:`, error);
        }
    }

    /**
     * Preload components based on current view
     */
    async function preloadComponents(currentView: ViewType) {
        // Always load the current view
        await loadComponent(currentView);

        // Preload likely next views
        if (currentView === 'setup') {
            // Preload indexing view as it's the next logical step
            setTimeout(() => loadComponent('indexing'), 100);
        } else if (currentView === 'indexing') {
            // Preload query view as it's the final step
            setTimeout(() => loadComponent('query'), 100);
        }
    }

    // Subscribe to view store changes
    onMount(() => {
        // Start performance tracking
        performanceTracker.start('app-initialization');

        // Register core Fluent UI components
        registerCoreComponents();

        // Initialize persistence system
        const cleanupPersistence = initializePersistence();

        // Initialize app
        appActions.initialize();

        // End performance tracking
        performanceTracker.end('app-initialization');

        const unsubscribe = currentView.subscribe(async (newView) => {
            view = newView;
            await preloadComponents(newView);
        });

        // VS Code API for receiving initial view state
        const vscode = (window as any).acquireVsCodeApi();

        // Listen for view change messages from extension
        window.addEventListener('message', (event) => {
            const message = event.data;
            if (message.type === 'initialState') {
                // Handle initial state message from extension
                appState.update((state: any) => ({
                    ...state,
                    isWorkspaceOpen: message.data.isWorkspaceOpen
                }));
            } else if (message.type === 'workspaceStateChanged') {
                // Handle workspace state change message from extension
                appActions.setWorkspaceOpen(message.data.isWorkspaceOpen);
            } else if (message.command === 'setView') {
                currentView.set(message.view);
            } else if (message.command === 'globalStateResponse') {
                // Handle global state response for first-run check
                if (message.key === 'hasCompletedFirstRun') {
                    hasCompletedFirstRun = message.value ?? false;
                }
            } else if (message.command === 'startTour') {
                // Start the guided tour
                if (guidedTourComponent && !hasCompletedFirstRun) {
                    guidedTourComponent.startTour();
                }
            }
        });

        // Request initial view state
        vscode.postMessage({ command: 'getInitialView' });

        // Request first-run state
        vscode.postMessage({ command: 'getGlobalState', key: 'hasCompletedFirstRun' });

        // Load initial component
        preloadComponents(view);

        return () => {
            unsubscribe();
            cleanupPersistence();
        };
    });
</script>

<main class="app-container">
    <ErrorBoundary
        fallbackMessage="The application encountered an error. Please try refreshing or contact support if the problem persists."
        showDetails={true}
        onError={(error) => console.error('Application error:', error)}
    >
        {#if !$appState.isWorkspaceOpen}
            <NoWorkspaceView />
        {:else}
            {#if view === 'setup'}
                {#if SetupView}
                    <div bind:this={componentContainer} class="component-container">
                        <svelte:component this={SetupView} />
                    </div>
                {:else}
                    <div class="loading-component">
                        <div class="loading-spinner"></div>
                        <p>Loading Setup...</p>
                    </div>
                {/if}
            {:else if view === 'indexing'}
                {#if IndexingView}
                    <svelte:component this={IndexingView} />
                {:else}
                    <div class="loading-component">
                        <div class="loading-spinner"></div>
                        <p>Loading Indexing...</p>
                    </div>
                {/if}
            {:else if view === 'query'}
                {#if QueryView}
                    <svelte:component this={QueryView} />
                {:else}
                    <div class="loading-component">
                        <div class="loading-spinner"></div>
                        <p>Loading Query...</p>
                    </div>
                {/if}
            {:else if view === 'diagnostics'}
                {#if DiagnosticsView}
                    <svelte:component this={DiagnosticsView} />
                {:else}
                    <div class="loading-component">
                        <div class="loading-spinner"></div>
                        <p>Loading Diagnostics...</p>
                    </div>
                {/if}
            {:else}
                <!-- Fallback to setup view -->
                {#if SetupView}
                    <svelte:component this={SetupView} />
                {:else}
                    <div class="loading-component">
                        <div class="loading-spinner"></div>
                        <p>Loading...</p>
                    </div>
                {/if}
            {/if}
        {/if}
    </ErrorBoundary>

    <!-- Guided Tour Component -->
    <GuidedTour bind:this={guidedTourComponent} on:tourCompleted={() => {
        hasCompletedFirstRun = true;
    }} />
</main>

<style>
    .app-container {
        min-height: 100vh;
        background-color: var(--vscode-editor-background);
        color: var(--vscode-foreground);
        container-type: inline-size;
        padding: 8px;
    }

    /* Responsive adjustments for sidebar view */
    @media (max-width: 400px) {
        .app-container {
            padding: 4px;
            min-height: auto;
        }
    }

    @container (max-width: 350px) {
        .app-container {
            padding: 2px;
        }
    }

    .component-container {
        /* Initial state for animation */
        opacity: 0;
        transform: translateY(20px);
    }

    .loading-component {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 200px;
        padding: 40px 20px;
        text-align: center;
    }

    .loading-spinner {
        width: 32px;
        height: 32px;
        border: 3px solid var(--vscode-panel-border);
        border-top: 3px solid var(--vscode-button-background);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 16px;
    }

    .loading-component p {
        margin: 0;
        font-size: 14px;
        color: var(--vscode-descriptionForeground);
        font-weight: 500;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Fade in animation for loaded components */
    :global(.component-fade-in) {
        animation: fadeIn 0.3s ease-in-out;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    :global(body) {
        margin: 0;
        padding: 0;
        font-family: var(--vscode-font-family);
        background-color: var(--vscode-editor-background);
        color: var(--vscode-foreground);
    }

    :global(*) {
        box-sizing: border-box;
    }
</style>
</file>

<file path="src/extension.ts">
import * as vscode from 'vscode';
import { ExtensionManager } from './extensionManager';

class ExtensionStateManager {
    private static instance: ExtensionStateManager;
    private extensionManager: ExtensionManager | null = null;

    private constructor() {}

    static getInstance(): ExtensionStateManager {
        if (!ExtensionStateManager.instance) {
            ExtensionStateManager.instance = new ExtensionStateManager();
        }
        return ExtensionStateManager.instance;
    }

    setExtensionManager(manager: ExtensionManager): void {
        this.extensionManager = manager;
    }

    dispose(): void {
        if (this.extensionManager) {
            this.extensionManager.dispose();
            this.extensionManager = null;
        }
    }
}

const extensionState = ExtensionStateManager.getInstance();

export async function activate(context: vscode.ExtensionContext) {
    console.log('Congratulations, your extension "code-context-engine" is now active!');

    try {
        const manager = new ExtensionManager(context);
        await manager.initialize();
        extensionState.setExtensionManager(manager);
        console.log('ExtensionManager initialized successfully');
    } catch (error) {
        console.error('Failed to initialize ExtensionManager:', error);
        vscode.window.showErrorMessage('Code Context Engine failed to initialize. Please check the logs.');
        throw error;
    }
}

export function deactivate() {
    extensionState.dispose();
}
</file>

<file path="src/context/contextService.ts">
/**
 * Context Service Module
 * 
 * This module provides a service for managing and querying code context within a VS Code workspace.
 * It leverages vector embeddings and similarity search to find related code chunks and files,
 * enabling semantic code navigation and contextual understanding of codebases.
 * 
 * The service integrates with:
 * - QdrantService for vector database operations
 * - EmbeddingProvider for generating semantic embeddings
 * - IndexingService for processing and indexing code files
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { IndexingService } from '../indexing/indexingService';
import { QdrantService, SearchResult } from '../db/qdrantService';
import { IEmbeddingProvider } from '../embeddings/embeddingProvider';
import { ConfigService } from '../configService';
import { CentralizedLoggingService } from '../logging/centralizedLoggingService';

/**
 * Represents the result of a file content retrieval operation
 * 
 * @property filePath - Path to the file that was retrieved
 * @property content - The text content of the file
 * @property language - Programming language of the file (derived from extension)
 * @property size - File size in bytes
 * @property lastModified - Last modification timestamp
 * @property relatedChunks - Optional array of semantically related code chunks from the same file
 */
export interface FileContentResult {
    filePath: string;
    content: string;
    language?: string;
    size: number;
    lastModified: Date;
    relatedChunks?: SearchResult[];
}

/**
 * Represents a file that is semantically related to a query or another file
 * 
 * @property filePath - Path to the related file
 * @property similarity - Similarity score (0-1) indicating relevance
 * @property reason - Human-readable explanation of why this file is related
 * @property chunkCount - Number of code chunks that matched the query
 * @property language - Programming language of the file
 */
export interface RelatedFile {
    filePath: string;
    similarity: number;
    reason: string;
    chunkCount: number;
    language?: string;
}

/**
 * Parameters for performing a context query
 *
 * @property query - The search query text
 * @property filePath - Optional current file path for context
 * @property includeRelated - Whether to include related files in results
 * @property maxResults - Maximum number of results to return
 * @property includeContent - Whether to include file content in results
 * @property minSimilarity - Minimum similarity threshold (0-1)
 * @property fileTypes - Optional array of file types to filter by
 * @property page - Page number for pagination (1-based, default: 1)
 * @property pageSize - Number of results per page (default: 20)
 */
export interface ContextQuery {
    query: string;
    filePath?: string;
    includeRelated?: boolean;
    maxResults?: number;
    includeContent?: boolean;
    minSimilarity?: number;
    fileTypes?: string[];
    page?: number;
    pageSize?: number;
}

/**
 * Results of a context query operation
 *
 * @property query - The original search query
 * @property results - Array of matching code chunks for current page
 * @property relatedFiles - Array of related files
 * @property totalResults - Total number of results found across all pages
 * @property processingTime - Time taken to process the query in milliseconds
 * @property page - Current page number (1-based)
 * @property pageSize - Number of results per page
 * @property totalPages - Total number of pages available
 * @property hasMore - Whether there are more results available
 */
export interface ContextResult {
    query: string;
    results: SearchResult[];
    relatedFiles: RelatedFile[];
    totalResults: number;
    processingTime: number;
    page: number;
    pageSize: number;
    totalPages: number;
    hasMore: boolean;
}

/**
 * Core service for managing and querying code context
 * 
 * This service provides methods for:
 * - Retrieving file content with related chunks
 * - Finding files related to a query or current file
 * - Performing semantic searches across the codebase
 * - Checking service status and readiness
 */
export class ContextService {
    private workspaceRoot: string;
    private indexingService: IndexingService;
    private qdrantService: QdrantService;
    private embeddingProvider: IEmbeddingProvider;
    private configService: ConfigService;
    private loggingService: CentralizedLoggingService;
    
    // Configuration constants
    private readonly DEFAULT_CHUNK_LIMIT = 50;
    private readonly DEFAULT_RELATED_FILES_LIMIT = 10;
    
    /**
     * Creates an empty context result object
     * Helper method to reduce code duplication
     *
     * @param query - The original query string
     * @param page - Current page number
     * @param pageSize - Page size
     * @param startTime - Optional start time for calculating processing time
     * @returns An empty ContextResult object
     */
    private createEmptyResult(query: string, page: number = 1, pageSize: number = 20, startTime?: number): ContextResult {
        return {
            query: query,
            results: [],
            relatedFiles: [],
            totalResults: 0,
            processingTime: startTime ? Date.now() - startTime : 0,
            page: page,
            pageSize: pageSize,
            totalPages: 0,
            hasMore: false
        };
    }

    /**
     * Constructor now uses dependency injection for better testability and decoupling
     *
     * @param workspaceRoot - The workspace root path
     * @param qdrantService - Injected QdrantService instance
     * @param embeddingProvider - Injected embedding provider instance
     * @param indexingService - Injected IndexingService instance
     * @param configService - Injected ConfigService instance
     * @param loggingService - Injected CentralizedLoggingService instance
     */
    constructor(
        workspaceRoot: string,
        qdrantService: QdrantService,
        embeddingProvider: IEmbeddingProvider,
        indexingService: IndexingService,
        configService: ConfigService,
        loggingService: CentralizedLoggingService
    ) {
        this.workspaceRoot = workspaceRoot;
        this.qdrantService = qdrantService;
        this.embeddingProvider = embeddingProvider;
        this.indexingService = indexingService;
        this.configService = configService;
        this.loggingService = loggingService;
    }

    /**
     * Generates a unique collection name for the current workspace
     * 
     * The collection name is derived from the workspace folder name,
     * sanitized to ensure compatibility with Qdrant naming requirements.
     * 
     * @returns A sanitized collection name string
     */
    /**
     * Generates a unique collection name for the current workspace
     * 
     * The collection name is derived from the workspace folder name,
     * sanitized to ensure compatibility with Qdrant naming requirements.
     * Uses path module for cross-platform compatibility.
     * 
     * @returns A sanitized collection name string
     */
    private generateCollectionName(): string {
        const workspaceName = path.basename(this.workspaceRoot) || 'workspace';
        const sanitizedName = workspaceName.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        return `code_context_${sanitizedName}`;
    }

    /**
     * Retrieves file content with optional related chunks
     * 
     * @param filePath - Path to the file to retrieve
     * @param includeRelatedChunks - Whether to include semantically related chunks from the same file
     * @returns Promise resolving to file content and metadata
     * @throws Error if file cannot be read or processed
     */
    async getFileContent(filePath: string, includeRelatedChunks: boolean = false): Promise<FileContentResult> {
        try {
            // Resolve absolute path
            const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(this.workspaceRoot, filePath);
            const uri = vscode.Uri.file(absolutePath);

            // Read file content
            const fileData = await vscode.workspace.fs.readFile(uri);
            const content = Buffer.from(fileData).toString('utf8');

            // Get file stats
            const stats = await vscode.workspace.fs.stat(uri);
            
            // Check file size to prevent memory issues with very large files
            const MAX_SAFE_FILE_SIZE = 10 * 1024 * 1024; // 10MB
            if (stats.size > MAX_SAFE_FILE_SIZE) {
                console.warn(`Large file detected (${(stats.size / 1024 / 1024).toFixed(2)}MB): ${filePath}`);
            }
            
            // Determine language from file extension
            const language = this.getLanguageFromPath(filePath);

            const result: FileContentResult = {
                filePath: filePath,
                content: content,
                language: language,
                size: stats.size,
                lastModified: new Date(stats.mtime)
            };

            // Optionally include related chunks
            if (includeRelatedChunks) {
                if (!this.embeddingProvider) {
                    console.warn('Embedding provider not available, cannot include related chunks');
                } else {
                    // Search for chunks from this file
                    const collectionName = this.generateCollectionName();
                    const searchResults = await this.qdrantService.search(
                        collectionName,
                        [], // Empty vector, we'll use filter instead
                        this.DEFAULT_CHUNK_LIMIT,
                        {
                            must: [
                                {
                                    key: 'filePath',
                                    match: { value: filePath }
                                }
                            ]
                        }
                    );
                    result.relatedChunks = searchResults;
                }
            }

            return result;
        } catch (error) {
            console.error(`Failed to get file content for ${filePath}:`, error);
            throw new Error(`Failed to read file: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Finds files related to a query or current file
     * 
     * This method performs semantic search to find files that are conceptually
     * related to the provided query. It groups results by file and calculates
     * file-level similarity scores.
     * 
     * @param query - The search query text
     * @param currentFilePath - Optional current file path to exclude from results
     * @param maxResults - Maximum number of related files to return
     * @param minSimilarity - Minimum similarity threshold (0-1)
     * @returns Promise resolving to array of related files
     */
    async findRelatedFiles(
        query: string,
        currentFilePath?: string,
        maxResults?: number,
        minSimilarity?: number
    ): Promise<RelatedFile[]> {
        // Get configuration values with fallbacks
        maxResults = maxResults ?? this.configService.getMaxSearchResults() ?? 10;
        minSimilarity = minSimilarity ?? this.configService.getMinSimilarityThreshold() ?? 0.5;
        try {
            if (!this.embeddingProvider) {
                throw new Error('Embedding provider not available');
            }

            // Generate embedding for the query
            const queryEmbeddings = await this.embeddingProvider.generateEmbeddings([query]);
            if (queryEmbeddings.length === 0) {
                return [];
            }

            const collectionName = this.generateCollectionName();
            
            // Search for similar chunks - get 3x results to ensure good file coverage
            const searchResults = await this.qdrantService.search(
                collectionName,
                queryEmbeddings[0],
                maxResults * 3 // Get more results to group by file
            );

            // Group results by file and calculate file-level similarity
            const fileGroups = new Map<string, {
                chunks: SearchResult[];
                maxScore: number;
                avgScore: number;
                language?: string;
            }>();

            // Process search results and group by file path
            for (const result of searchResults) {
                // Skip results below similarity threshold
                if (result.score < minSimilarity) continue;
                // Skip current file if provided
                if (currentFilePath && result.payload.filePath === currentFilePath) continue;

                const filePath = result.payload.filePath;
                // Initialize group if this is the first chunk for this file
                if (!fileGroups.has(filePath)) {
                    fileGroups.set(filePath, {
                        chunks: [],
                        maxScore: 0,
                        avgScore: 0,
                        language: result.payload.language
                    });
                }

                // Add chunk to file group and update max score
                const group = fileGroups.get(filePath)!;
                group.chunks.push(result);
                group.maxScore = Math.max(group.maxScore, result.score);
            }

            // Calculate average scores and create RelatedFile objects
            const relatedFiles: RelatedFile[] = [];
            for (const [filePath, group] of fileGroups) {
                // Calculate average similarity score across all chunks
                group.avgScore = group.chunks.reduce((sum, chunk) => sum + chunk.score, 0) / group.chunks.length;
                
                // Generate human-readable reason for the relation
                const topChunk = group.chunks[0];
                const reason = this.generateRelationReason(topChunk, group.chunks.length);

                relatedFiles.push({
                    filePath: filePath,
                    similarity: group.maxScore, // Use max score as the file similarity
                    reason: reason,
                    chunkCount: group.chunks.length,
                    language: group.language
                });
            }

            // Sort by similarity (descending) and return top results
            return relatedFiles
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, maxResults);

        } catch (error) {
            console.error('Failed to find related files:', error);
            return [];
        }
    }

    /**
     * Performs an advanced context query
     * 
     * This is the main entry point for semantic code search. It supports:
     * - Filtering by file type
     * - Including related files
     * - Minimum similarity thresholds
     * - Performance tracking
     * 
     * @param contextQuery - Query parameters
     * @returns Promise resolving to query results
     */
    async queryContext(contextQuery: ContextQuery): Promise<ContextResult> {
        const startTime = Date.now();

        try {
            if (!this.embeddingProvider) {
                throw new Error('Embedding provider not available');
            }

            // Extract pagination parameters with defaults
            const page = Math.max(1, contextQuery.page ?? 1); // Ensure page is at least 1
            const pageSize = Math.max(1, Math.min(100, contextQuery.pageSize ?? 20)); // Limit pageSize between 1-100

            // Generate embedding for the query
            const queryEmbeddings = await this.embeddingProvider.generateEmbeddings([contextQuery.query]);
            if (queryEmbeddings.length === 0) {
                return this.createEmptyResult(contextQuery.query, page, pageSize, startTime);
            }

            const collectionName = this.generateCollectionName();

            // Get configuration values with fallbacks
            // For pagination, we need to fetch more results than just the current page
            // to ensure we have enough data for proper pagination
            const maxSearchResults = contextQuery.maxResults ?? this.configService.getMaxSearchResults() ?? 100;
            const defaultMinSimilarity = this.configService.getMinSimilarityThreshold() ?? 0.5;
            
            // Build filter for file types if specified
            let filter: { should: Array<{ key: string, match: { value: string } }> } | undefined = undefined;
            if (contextQuery.fileTypes && contextQuery.fileTypes.length > 0) {
                // Create a filter that matches any of the specified languages
                filter = {
                    should: contextQuery.fileTypes.map(lang => ({
                        key: 'language',
                        match: { value: lang }
                    }))
                };
            }

            // Search for similar chunks - fetch more results to ensure good deduplication
            const searchLimit = maxSearchResults * 5; // Fetch 5x more to have enough for deduplication
            const searchResults = await this.qdrantService.search(
                collectionName,
                queryEmbeddings[0],
                searchLimit,
                filter
            );

            // Filter by minimum similarity if specified
            const minSimilarity = contextQuery.minSimilarity ?? defaultMinSimilarity;
            const filteredResults = searchResults.filter(r => r.score >= minSimilarity);

            // Implement deduplication logic - group by file path and keep highest score
            const uniqueFiles = new Map<string, SearchResult>();

            for (const result of filteredResults) {
                const filePath = result.payload.filePath;
                const existing = uniqueFiles.get(filePath);

                // If we haven't seen this file, or the new result has a higher score, store it
                if (!existing || result.score > existing.score) {
                    uniqueFiles.set(filePath, result);
                }
            }

            // Convert map to array and sort by score (descending)
            const allDeduplicatedResults = Array.from(uniqueFiles.values())
                .sort((a, b) => b.score - a.score);

            // Calculate pagination metadata
            const totalResults = allDeduplicatedResults.length;
            const totalPages = Math.ceil(totalResults / pageSize);
            const startIndex = (page - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, totalResults);
            const hasMore = page < totalPages;

            // Get the results for the current page
            const paginatedResults = allDeduplicatedResults.slice(startIndex, endIndex);

            // Conditionally read file content if requested (only for current page results)
            if (contextQuery.includeContent) {
                for (const result of paginatedResults) {
                    try {
                        const filePath = result.payload.filePath;
                        const uri = vscode.Uri.file(path.join(this.workspaceRoot, filePath));
                        const fileContent = await vscode.workspace.fs.readFile(uri);
                        const content = Buffer.from(fileContent).toString('utf8');

                        // Add content to the result payload
                        result.payload.content = content;
                    } catch (error) {
                        console.warn(`Failed to read content for ${result.payload.filePath}:`, error);
                        // Continue without content for this file
                    }
                }
            }

            // Find related files if requested
            let relatedFiles: RelatedFile[] = [];
            if (contextQuery.includeRelated) {
                relatedFiles = await this.findRelatedFiles(
                    contextQuery.query,
                    contextQuery.filePath,
                    this.DEFAULT_RELATED_FILES_LIMIT, // Use configurable constant
                    minSimilarity
                );
            }

            // Return complete result object with timing and pagination information
            return {
                query: contextQuery.query,
                results: paginatedResults,
                relatedFiles: relatedFiles,
                totalResults: totalResults,
                processingTime: Date.now() - startTime,
                page: page,
                pageSize: pageSize,
                totalPages: totalPages,
                hasMore: hasMore
            };

        } catch (error) {
            console.error('Context query failed:', error);
            // Return empty results with timing and pagination information on error
            const page = Math.max(1, contextQuery.page ?? 1);
            const pageSize = Math.max(1, Math.min(100, contextQuery.pageSize ?? 20));
            return this.createEmptyResult(contextQuery.query, page, pageSize, startTime);
        }
    }

    /**
     * Maps file extensions to programming language identifiers
     * 
     * @param filePath - Path to the file
     * @returns Language identifier or undefined if not recognized
     */
    /**
     * Maps file extensions to programming language identifiers
     * Supports common file types and can be extended as needed
     * 
     * @param filePath - Path to the file
     * @returns Language identifier or undefined if not recognized
     */
    private getLanguageFromPath(filePath: string): string | undefined {
        const ext = path.extname(filePath).toLowerCase();
        const languageMap: Record<string, string> = {
            // JavaScript family
            '.ts': 'typescript',
            '.tsx': 'typescript',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.mjs': 'javascript',
            '.cjs': 'javascript',
            
            // Web technologies
            '.html': 'html',
            '.css': 'css',
            '.scss': 'scss',
            '.less': 'less',
            '.vue': 'vue',
            '.svelte': 'svelte',
            
            // Backend languages
            '.py': 'python',
            '.rb': 'ruby',
            '.php': 'php',
            '.java': 'java',
            '.cs': 'csharp',
            '.go': 'go',
            '.rs': 'rust',
            
            // Data formats
            '.json': 'json',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.xml': 'xml',
            '.md': 'markdown',
            
            // Shell scripts
            '.sh': 'shell',
            '.bash': 'shell',
            '.zsh': 'shell',
            '.ps1': 'powershell'
        };
        
        return languageMap[ext];
    }

    /**
     * Generates a human-readable reason for why a file is related
     * 
     * @param topChunk - The highest-scoring chunk from the file
     * @param chunkCount - Total number of matching chunks in the file
     * @returns A descriptive string explaining the relation
     */
    private generateRelationReason(topChunk: SearchResult, chunkCount: number): string {
        const type = topChunk.payload.type;
        const name = topChunk.payload.name;
        
        if (chunkCount > 1) {
            return `Contains ${chunkCount} related ${type}s${name ? ` including "${name}"` : ''}`;
        } else {
            return `Contains related ${type}${name ? ` "${name}"` : ''}`;
        }
    }

    /**
     * Checks if the context service is ready for use
     * 
     * Verifies that both the vector database and embedding provider are available.
     * 
     * @returns Promise resolving to boolean indicating readiness
     */
    /**
     * Checks if the context service is ready for use
     * 
     * Verifies that both the vector database and embedding provider are available.
     * Logs any errors encountered during the check.
     * 
     * @returns Promise resolving to boolean indicating readiness
     */
    async isReady(): Promise<boolean> {
        try {
            // Check if Qdrant is available
            const qdrantReady = await this.qdrantService.healthCheck();
            if (!qdrantReady) {
                console.warn('Qdrant service health check failed');
                return false;
            }

            // Check if embedding provider is available
            if (!this.embeddingProvider) {
                console.warn('Embedding provider not available');
                return false;
            }
            
            return true;
        } catch (error) {
            console.error('Error checking service readiness:', error);
            return false;
        }
    }

    /**
     * Gets detailed status information about the service
     * 
     * Provides information about:
     * - Vector database connection
     * - Embedding provider availability
     * - Collection existence and metadata
     * 
     * @returns Promise resolving to status object
     */
    async getStatus(): Promise<{
        qdrantConnected: boolean;
        embeddingProvider: string | null;
        collectionExists: boolean;
        collectionInfo?: any;
    }> {
        // Check Qdrant connection
        const qdrantConnected = await this.qdrantService.healthCheck();
        
        // Get embedding provider name if available
        let embeddingProvider: string | null = null;
        try {
            embeddingProvider = this.embeddingProvider?.getProviderName() || null;
        } catch {
            // Provider not available
        }

        // Check if collection exists and get its info
        const collectionName = this.generateCollectionName();
        const collectionInfo = await this.qdrantService.getCollectionInfo(collectionName);
        const collectionExists = collectionInfo !== null;

        // Return comprehensive status object
        return {
            qdrantConnected,
            embeddingProvider,
            collectionExists,
            collectionInfo: collectionExists ? collectionInfo : undefined
        };
    }
}
</file>

<file path="src/messageRouter.ts">
import * as vscode from 'vscode';
import { ContextService, ContextQuery, RelatedFile } from './context/contextService';
import { IndexingService } from './indexing/indexingService';
import { SearchManager, SearchFilters } from './searchManager';
import { ConfigurationManager as LegacyConfigurationManager } from './configurationManager';
import { PerformanceManager } from './performanceManager';
import { SystemValidator } from './validation/systemValidator';
import { TroubleshootingSystem } from './validation/troubleshootingGuide';
import { ConfigurationManager } from './configuration/configurationManager';
import { StateManager } from './stateManager';
import { XmlFormatterService } from './formatting/XmlFormatterService';
import { WorkspaceManager } from './workspaceManager';

/**
 * MessageRouter - Central message handling system for VS Code extension webview communication
 * 
 * This file implements the core message routing logic that facilitates communication between
 * the extension's webview UI and the backend services. It acts as the central hub for all
 * webview-to-extension communication, providing a clean separation of concerns and ensuring
 * type-safe message handling.
 * 
 * Key responsibilities:
 * - Route incoming webview messages to appropriate handlers
 * - Integrate with various backend services (ContextService, IndexingService, etc.)
 * - Handle database operations (Qdrant, ChromaDB, Pinecone)
 * - Manage configuration and state operations
 * - Provide search and context query functionality
 * - Handle error responses and logging
 * 
 * Architecture:
 * The MessageRouter follows a command pattern where each message type has a dedicated handler
 * method. This approach ensures maintainability and makes it easy to add new message types
 * without modifying the core routing logic.
 */
export class MessageRouter {
    private contextService: ContextService;
    private indexingService: IndexingService;
    private searchManager?: SearchManager;
    private legacyConfigurationManager?: LegacyConfigurationManager;
    private performanceManager?: PerformanceManager;
    private context: vscode.ExtensionContext;
    private systemValidator: SystemValidator;
    private troubleshootingSystem: TroubleshootingSystem;
    private configurationManager: ConfigurationManager;
    private stateManager: StateManager;
    private xmlFormatterService?: XmlFormatterService;
    private workspaceManager?: WorkspaceManager;

    /**
     * Constructs a new MessageRouter instance with core services
     * 
     * @param contextService - Service for handling context-related operations (file content, related files, etc.)
     * @param indexingService - Service for managing document indexing operations
     * @param context - VS Code extension context providing access to extension APIs and storage
     * @param stateManager - Service for managing extension state and persistence
     */
    constructor(contextService: ContextService, indexingService: IndexingService, context: vscode.ExtensionContext, stateManager: StateManager) {
        this.contextService = contextService;
        this.indexingService = indexingService;
        this.context = context;
        this.stateManager = stateManager;
        this.systemValidator = new SystemValidator(context);
        this.troubleshootingSystem = new TroubleshootingSystem();
        this.configurationManager = new ConfigurationManager(context);
    }

    /**
     * Sets up advanced managers for enhanced functionality
     * 
     * This method is called after initial construction to provide access to optional
     * advanced services that may not be available during initial startup or may require
     * additional initialization.
     * 
     * @param searchManager - Advanced search management service with filtering and suggestions
     * @param legacyConfigurationManager - Legacy configuration management service
     * @param performanceManager - Performance monitoring and metrics collection service
     * @param xmlFormatterService - XML formatting and processing service
     */
    setAdvancedManagers(
        searchManager: SearchManager,
        legacyConfigurationManager: LegacyConfigurationManager,
        performanceManager: PerformanceManager,
        xmlFormatterService: XmlFormatterService
    ): void {
        this.searchManager = searchManager;
        this.legacyConfigurationManager = legacyConfigurationManager;
        this.performanceManager = performanceManager;
        this.xmlFormatterService = xmlFormatterService;
        console.log('MessageRouter: Advanced managers set');
    }

    /**
     * Main message entry point - routes incoming webview messages to appropriate handlers
     * 
     * This method serves as the central dispatcher for all webview communications. It implements
     * a try-catch pattern to ensure that errors in individual handlers don't crash the entire
     * message processing system.
     * 
     * @param message - The incoming message object from the webview, must contain a 'command' property
     * @param webview - The VS Code webview instance that sent the message, used for responses
     */
    async handleMessage(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling message:', message.command);

            // Route message to appropriate handler based on command type
            switch (message.command) {
                case 'ping':
                    await this.handlePing(message, webview);
                    break;
                case 'checkSetupStatus':
                    await this.handleCheckSetupStatus(message, webview);
                    break;
                case 'startDatabase':
                    await this.handleStartDatabase(message, webview);
                    break;
                case 'validateDatabase':
                    await this.handleValidateDatabase(message, webview);
                    break;
                case 'saveSecretValue':
                    await this.handleSaveSecretValue(message, webview);
                    break;
                case 'getSecretValue':
                    await this.handleGetSecretValue(message, webview);
                    break;
                case 'runSystemValidation':
                    await this.handleRunSystemValidation(message, webview);
                    break;
                case 'getTroubleshootingGuides':
                    await this.handleGetTroubleshootingGuides(message, webview);
                    break;
                case 'runAutoFix':
                    await this.handleRunAutoFix(message, webview);
                    break;
                case 'openTroubleshootingGuide':
                    await this.handleOpenTroubleshootingGuide(message, webview);
                    break;
                case 'exportConfiguration':
                    await this.handleExportConfiguration(message, webview);
                    break;
                case 'importConfiguration':
                    await this.handleImportConfiguration(message, webview);
                    break;
                case 'getConfigurationTemplates':
                    await this.handleGetConfigurationTemplates(message, webview);
                    break;
                case 'getConfigurationBackups':
                    await this.handleGetConfigurationBackups(message, webview);
                    break;
                case 'validateConfiguration':
                    await this.handleValidateConfiguration(message, webview);
                    break;
                case 'applyConfigurationTemplate':
                    await this.handleApplyConfigurationTemplate(message, webview);
                    break;
                case 'createConfigurationBackup':
                    await this.handleCreateConfigurationBackup(message, webview);
                    break;
                case 'restoreConfigurationBackup':
                    await this.handleRestoreConfigurationBackup(message, webview);
                    break;
                case 'getFileContent':
                    await this.handleGetFileContent(message, webview);
                    break;
                case 'findRelatedFiles':
                    await this.handleFindRelatedFiles(message, webview);
                    break;
                case 'queryContext':
                    await this.handleQueryContext(message, webview);
                    break;
                case 'search':
                    await this.handleSearch(message, webview);
                    break;
                case 'getServiceStatus':
                    await this.handleGetServiceStatus(webview);
                    break;
                case 'startIndexing':
                    await this.handleStartIndexing(webview);
                    break;
                case 'pauseIndexing':
                    await this.handlePauseIndexing(webview);
                    break;
                case 'resumeIndexing':
                    await this.handleResumeIndexing(webview);
                    break;
                case 'getIndexInfo':
                    await this.handleGetIndexInfo(webview);
                    break;
                case 'clearIndex':
                    await this.handleClearIndex(webview);
                    break;
                case 'getWorkspaceList':
                    await this.handleGetWorkspaceList(webview);
                    break;
                case 'switchWorkspace':
                    await this.handleSwitchWorkspace(message, webview);
                    break;
                case 'getWorkspaceStats':
                    await this.handleGetWorkspaceStats(webview);
                    break;
                case 'advancedSearch':
                    await this.handleAdvancedSearch(message, webview);
                    break;
                case 'getSearchSuggestions':
                    await this.handleGetSearchSuggestions(message, webview);
                    break;
                case 'getSearchHistory':
                    await this.handleGetSearchHistory(webview);
                    break;
                // Note: Duplicate 'validateConfiguration' case - intentional for backward compatibility
                case 'validateConfiguration':
                    await this.handleValidateConfiguration(message, webview);
                    break;
                case 'getConfigurationPresets':
                    await this.handleGetConfigurationPresets(webview);
                    break;
                case 'applyConfigurationPreset':
                    await this.handleApplyConfigurationPreset(message, webview);
                    break;
                case 'getPerformanceMetrics':
                    await this.handleGetPerformanceMetrics(webview);
                    break;
                case 'getFilePreview':
                    await this.handleGetFilePreview(message, webview);
                    break;
                // Note: 'MapToSettings' and 'openSettings' both handle the same action
                case 'MapToSettings':
                    await this.handleMapToSettings(webview);
                    break;
                case 'openSettings':
                    await this.handleMapToSettings(webview);
                    break;
                case 'getGlobalState':
                    await this.handleGetGlobalState(message, webview);
                    break;
                case 'setGlobalState':
                    await this.handleSetGlobalState(message, webview);
                    break;
                case 'checkFirstRunAndStartTour':
                    await this.handleCheckFirstRunAndStartTour(webview);
                    break;
                case 'requestOpenFolder':
                    await this.handleRequestOpenFolder(message, webview);
                    break;
                default:
                    // Handle unknown commands with a warning and error response
                    console.warn('MessageRouter: Unknown command:', message.command);
                    await this.sendErrorResponse(webview, `Unknown command: ${message.command}`);
                    break;
            }
        } catch (error) {
            // Global error handling to prevent uncaught exceptions from crashing the message router
            console.error('MessageRouter: Error handling message:', error);
            await this.sendErrorResponse(webview, error instanceof Error ? error.message : String(error));
        }
    }

    /**
     * Handles ping messages for connection testing
     * 
     * Simple ping-pong implementation used to verify that the webview-to-extension
     * communication channel is working properly. This is often used during initial
     * connection setup or as a heartbeat mechanism.
     * 
     * @param message - The ping message, should contain requestId for correlation
     * @param webview - The webview to send the pong response to
     */
    private async handlePing(message: any, webview: vscode.Webview): Promise<void> {
        console.log('MessageRouter: Received ping from webview', message.requestId);

        // Respond with pong including the same requestId for correlation and current timestamp
        await webview.postMessage({
            command: 'pong',
            requestId: message.requestId,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Checks if the workspace is properly configured for first-time setup
     * 
     * This handler determines if the extension has been properly configured by checking:
     * 1. If a workspace folder is open
     * 2. If required services are connected and configured
     * 
     * @param message - The check setup status message, should contain requestId
     * @param webview - The webview to send the response to
     */
    private async handleCheckSetupStatus(message: any, webview: vscode.Webview): Promise<void> {
        try {
            // First check if there's an open workspace folder
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                await webview.postMessage({
                    command: 'response',
                    requestId: message.requestId,
                    data: {
                        isConfigured: false,
                        reason: 'No workspace folder'
                    }
                });
                return;
            }

            // Check if core services are properly configured and running
            const status = await this.contextService.getStatus();
            const isConfigured = status.qdrantConnected && status.embeddingProvider !== null;

            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                data: {
                    isConfigured,
                    status: status
                }
            });

        } catch (error) {
            console.error('MessageRouter: Error checking setup status:', error);
            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                error: error instanceof Error ? error.message : String(error),
                data: {
                    isConfigured: false
                }
            });
        }
    }

    /**
     * Handles requests to start local database services
     * 
     * This handler supports starting different types of local databases via Docker:
     * - Qdrant: Vector database for semantic search
     * - ChromaDB: Alternative vector database
     * 
     * @param message - The start database message, should contain database type and config
     * @param webview - The webview to send status updates to
     */
    private async handleStartDatabase(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { database, config } = message;
            console.log('MessageRouter: Starting database:', database, config);

            // Route to appropriate database startup method based on type
            switch (database) {
                case 'qdrant':
                    await this.startQdrant(webview);
                    break;
                case 'chromadb':
                    await this.startChromaDB(webview, config);
                    break;
                default:
                    throw new Error(`Unsupported database type for starting: ${database}`);
            }

        } catch (error) {
            console.error('MessageRouter: Error starting database:', error);
            await webview.postMessage({
                command: 'databaseStatus',
                data: {
                    status: 'error',
                    error: error instanceof Error ? error.message : String(error)
                }
            });
        }
    }

    /**
     * Handles requests to validate cloud database connections
     * 
     * This handler validates connections to cloud-based database services:
     * - Pinecone: Cloud vector database service
     * 
     * @param message - The validate database message, should contain database type and config
     * @param webview - The webview to send validation results to
     */
    private async handleValidateDatabase(message: any, webview: vscode.Webview): Promise<void> {
        try {
            const { database, config } = message;
            console.log('MessageRouter: Validating database:', database);

            // Route to appropriate database validation method based on type
            switch (database) {
                case 'pinecone':
                    await this.validatePinecone(webview, config);
                    break;
                default:
                    throw new Error(`Unsupported database type for validation: ${database}`);
            }

        } catch (error) {
            console.error('MessageRouter: Error validating database:', error);
            await webview.postMessage({
                command: 'databaseStatus',
                data: {
                    status: 'error',
                    error: error instanceof Error ? error.message : String(error)
                }
            });
        }
    }

    /**
     * Starts Qdrant vector database using Docker
     * 
     * This method creates a new VS Code terminal and runs the Qdrant Docker container.
     * After starting the container, it initiates health checking to determine when
     * the database is ready to accept connections.
     * 
     * @param webview - The webview to send status updates to
     */
    private async startQdrant(webview: vscode.Webview): Promise<void> {
        // Create a dedicated terminal for Qdrant to keep it separate from other terminals
        const terminal = vscode.window.createTerminal('Qdrant Database');
        terminal.sendText('docker run -p 6333:6333 qdrant/qdrant');
        terminal.show();

        // Notify webview that database startup has been initiated
        await webview.postMessage({
            command: 'databaseStarted',
            data: { database: 'qdrant', status: 'starting' }
        });

        // Begin polling to check when the database is healthy and ready
        this.pollDatabaseHealth(webview, 'qdrant');
    }

    /**
     * Starts ChromaDB vector database using Docker
     * 
     * This method creates a new VS Code terminal and runs the ChromaDB Docker container
     * with a configurable port. After starting the container, it initiates health checking.
     * 
     * @param webview - The webview to send status updates to
     * @param config - Configuration object that may contain custom port settings
     */
    private async startChromaDB(webview: vscode.Webview, config: any): Promise<void> {
        // Use provided port or default to 8000
        const port = config?.port || 8000;
        const terminal = vscode.window.createTerminal('ChromaDB Database');
        terminal.sendText(`docker run -p ${port}:8000 chromadb/chroma`);
        terminal.show();

        // Notify webview that database startup has been initiated
        await webview.postMessage({
            command: 'databaseStarted',
            data: { database: 'chromadb', status: 'starting' }
        });

        // Begin polling to check when the database is healthy and ready
        this.pollDatabaseHealth(webview, 'chromadb', config);
    }

    /**
     * Validates Pinecone cloud database connection
     * 
     * This method tests the connection to Pinecone by attempting to list databases.
     * It handles various error scenarios including invalid API keys, permission issues,
     * and network timeouts.
     * 
     * @param webview - The webview to send validation results to
     * @param config - Configuration object containing API key and environment settings
     * @throws Error if validation fails or connection times out
     */
    private async validatePinecone(webview: vscode.Webview, config: any): Promise<void> {
        // Validate required configuration parameters
        if (!config?.apiKey || !config?.environment) {
            throw new Error('Pinecone API key and environment are required');
        }

        try {
            // Test Pinecone connection by listing databases via their API
            const response = await fetch(`https://controller.${config.environment}.pinecone.io/databases`, {
                method: 'GET',
                headers: {
                    'Api-Key': config.apiKey,
                    'Content-Type': 'application/json'
                },
                // Set timeout to prevent hanging on slow connections
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                // Connection successful
                await webview.postMessage({
                    command: 'databaseStatus',
                    data: { status: 'running' }
                });
            } else if (response.status === 401) {
                // Authentication failed
                throw new Error('Invalid Pinecone API key');
            } else if (response.status === 403) {
                // Authorization failed
                throw new Error('Access denied - check your API key permissions');
            } else {
                // Other HTTP errors
                throw new Error(`Pinecone connection failed: ${response.status} ${response.statusText}`);
            }

        } catch (error) {
            // Handle network timeouts specifically
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('Pinecone connection timeout - check your environment');
            }
            throw error;
        }
    }

    /**
     * Polls database health endpoint to determine when service is ready
     * 
     * This method implements a polling mechanism to check if a database service
     * has started successfully and is ready to accept connections. It will poll
     * for a maximum of 30 seconds before timing out.
     * 
     * @param webview - The webview to send health status updates to
     * @param database - The type of database being checked ('qdrant' or 'chromadb')
     * @param config - Optional configuration for database-specific settings (like port)
     */
    private async pollDatabaseHealth(webview: vscode.Webview, database: string, config?: any): Promise<void> {
        const maxAttempts = 30; // 30 seconds total timeout
        let attempts = 0;

        const checkHealth = async (): Promise<void> => {
            try {
                attempts++;
                let healthUrl: string;

                // Determine the appropriate health endpoint URL based on database type
                switch (database) {
                    case 'qdrant':
                        healthUrl = 'http://localhost:6333/health';
                        break;
                    case 'chromadb':
                        const port = config?.port || 8000;
                        healthUrl = `http://localhost:${port}/api/v1/heartbeat`;
                        break;
                    default:
                        throw new Error(`Unsupported database for health check: ${database}`);
                }

                // Make HTTP request to health endpoint
                const response = await fetch(healthUrl);
                if (response.ok) {
                    // Database is healthy and ready
                    await webview.postMessage({
                        command: 'databaseStatus',
                        data: { status: 'running' }
                    });
                    return;
                }

                // If not ready yet and we haven't exceeded max attempts, schedule another check
                if (attempts < maxAttempts) {
                    setTimeout(checkHealth, 1000); // Check again in 1 second
                } else {
                    // Max attempts reached without success
                    await webview.postMessage({
                        command: 'databaseStatus',
                        data: {
                            status: 'error',
                            error: `${database} failed to start within 30 seconds`
                        }
                    });
                }

            } catch (error) {
                // Handle connection errors (likely database not ready yet)
                if (attempts < maxAttempts) {
                    setTimeout(checkHealth, 1000); // Check again in 1 second
                } else {
                    // Max attempts reached with persistent errors
                    await webview.postMessage({
                        command: 'databaseStatus',
                        data: {
                            status: 'error',
                            error: `${database} health check failed`
                        }
                    });
                }
            }
        };

        // Start health checking after a short delay to allow database initialization
        setTimeout(checkHealth, 2000); // Wait 2 seconds before first check
    }

    /**
     * Retrieves content of a specified file with optional related chunks
     * 
     * This handler fetches the content of a file and can optionally include
     * semantically related code chunks for enhanced context understanding.
     * 
     * @param message - The get file content message, should contain filePath and includeRelatedChunks flag
     * @param webview - The webview to send the file content response to
     */
    private async handleGetFileContent(message: any, webview: vscode.Webview): Promise<void> {
        const { filePath, includeRelatedChunks = false } = message;
        
        // Validate required parameters
        if (!filePath) {
            await this.sendErrorResponse(webview, 'File path is required');
            return;
        }

        // Retrieve file content from context service
        const result = await this.contextService.getFileContent(filePath, includeRelatedChunks);
        
        // Send result back to webview
        await webview.postMessage({
            command: 'fileContentResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Finds files related to a given query using semantic search
     * 
     * This handler uses the context service to perform semantic search and find
     * files that are related to the provided query, with configurable similarity
     * thresholds and result limits.
     * 
     * @param message - The find related files message, should contain query and optional parameters
     * @param webview - The webview to send the related files response to
     */
    private async handleFindRelatedFiles(message: any, webview: vscode.Webview): Promise<void> {
        const { query, currentFilePath, maxResults = 10, minSimilarity = 0.5 } = message;
        
        // Validate required parameters
        if (!query) {
            await this.sendErrorResponse(webview, 'Query is required');
            return;
        }

        // Perform semantic search for related files
        const result = await this.contextService.findRelatedFiles(
            query, 
            currentFilePath, 
            maxResults, 
            minSimilarity
        );
        
        // Send results back to webview
        await webview.postMessage({
            command: 'relatedFilesResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Performs advanced context queries with customizable parameters
     * 
     * This handler allows for complex context queries with various filtering
     * and configuration options through the ContextQuery object.
     * 
     * @param message - The query context message, should contain a ContextQuery object
     * @param webview - The webview to send the context query response to
     */
    private async handleQueryContext(message: any, webview: vscode.Webview): Promise<void> {
        const contextQuery: ContextQuery = message.contextQuery;
        
        // Validate required parameters
        if (!contextQuery.query) {
            await this.sendErrorResponse(webview, 'Query is required');
            return;
        }

        // Execute advanced context query
        const result = await this.contextService.queryContext(contextQuery);
        
        // Send results back to webview
        await webview.postMessage({
            command: 'contextQueryResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Performs basic search operations with default parameters
     * 
     * This handler provides a simplified search interface that uses default
     * parameters for max results and similarity threshold. It internally
     * delegates to the context service's queryContext method.
     * 
     * @param message - The search message, should contain the query string
     * @param webview - The webview to send the search response to
     */
    private async handleSearch(message: any, webview: vscode.Webview): Promise<void> {
        const { query } = message;
        
        // Validate required parameters
        if (!query) {
            await this.sendErrorResponse(webview, 'Query is required');
            return;
        }

        // Perform search with default parameters
        const result = await this.contextService.queryContext({
            query,
            maxResults: 20,
            minSimilarity: 0.5
        });
        
        // Send results back to webview
        await webview.postMessage({
            command: 'searchResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Retrieves the current status of all core services
     * 
     * This handler provides a comprehensive status overview of all services
     * managed by the context service, including database connections and
     * embedding provider status.
     * 
     * @param webview - The webview to send the service status response to
     */
    private async handleGetServiceStatus(webview: vscode.Webview): Promise<void> {
        // Get current status from context service
        const status = await this.contextService.getStatus();
        
        // Send status back to webview
        await webview.postMessage({
            command: 'serviceStatusResponse',
            data: status
        });
    }

    /**
     * Initiates the document indexing process
     *
     * This handler triggers the indexing of workspace documents to make them
     * searchable. It includes state validation to prevent concurrent indexing
     * operations and provides appropriate error responses.
     *
     * @param webview - The webview to send the response to
     */
    private async handleStartIndexing(webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling start indexing request');

            // Check if indexing is already in progress
            if (this.stateManager.isIndexing()) {
                const errorResponse = {
                    command: 'startIndexing',
                    error: 'Indexing is already in progress.'
                };
                webview.postMessage(errorResponse);
                console.log('MessageRouter: Indexing already in progress, request rejected');
                return;
            }

            // Delegate to the existing VS Code command for indexing
            await vscode.commands.executeCommand('code-context-engine.startIndexing');

            const successResponse = {
                command: 'startIndexing',
                result: 'Indexing started successfully.'
            };
            webview.postMessage(successResponse);
            console.log('MessageRouter: Indexing started successfully');

        } catch (error) {
            console.error('MessageRouter: Error starting indexing:', error);
            const errorResponse = {
                command: 'startIndexing',
                error: error instanceof Error ? error.message : 'An unknown error occurred while starting indexing.'
            };
            webview.postMessage(errorResponse);
        }
    }

    /**
     * Pauses the current indexing operation
     *
     * This handler pauses an ongoing indexing process, allowing it to be resumed later.
     * The indexing state is preserved so it can continue from where it left off.
     *
     * @param webview - The webview to send the response to
     */
    private async handlePauseIndexing(webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling pause indexing request');

            // Check if indexing is currently running
            if (!this.stateManager.isIndexing()) {
                await webview.postMessage({
                    command: 'pauseIndexingResponse',
                    success: false,
                    error: 'No indexing operation is currently running'
                });
                return;
            }

            // Check if already paused
            if (this.stateManager.isPaused()) {
                await webview.postMessage({
                    command: 'pauseIndexingResponse',
                    success: false,
                    error: 'Indexing is already paused'
                });
                return;
            }

            // Pause the indexing operation
            this.indexingService.pause();

            await webview.postMessage({
                command: 'pauseIndexingResponse',
                success: true,
                message: 'Indexing paused successfully'
            });

        } catch (error) {
            console.error('MessageRouter: Error pausing indexing:', error);
            await this.sendErrorResponse(webview, `Failed to pause indexing: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Resumes a paused indexing operation
     *
     * This handler resumes a previously paused indexing process, continuing
     * from where it left off using the saved state.
     *
     * @param webview - The webview to send the response to
     */
    private async handleResumeIndexing(webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling resume indexing request');

            // Check if indexing is paused
            if (!this.stateManager.isPaused()) {
                await webview.postMessage({
                    command: 'resumeIndexingResponse',
                    success: false,
                    error: 'No paused indexing operation to resume'
                });
                return;
            }

            // Resume the indexing operation
            await this.indexingService.resume();

            await webview.postMessage({
                command: 'resumeIndexingResponse',
                success: true,
                message: 'Indexing resumed successfully'
            });

        } catch (error) {
            console.error('MessageRouter: Error resuming indexing:', error);
            await this.sendErrorResponse(webview, `Failed to resume indexing: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Gets information about the current index
     *
     * This handler retrieves statistics about the current workspace index,
     * including the number of indexed files and vectors.
     *
     * @param webview - The webview to send the response to
     */
    private async handleGetIndexInfo(webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling get index info request');

            // Get index information from the indexing service
            const indexInfo = await this.indexingService.getIndexInfo();

            if (indexInfo) {
                await webview.postMessage({
                    command: 'getIndexInfoResponse',
                    success: true,
                    data: {
                        fileCount: indexInfo.fileCount,
                        vectorCount: indexInfo.vectorCount,
                        collectionName: indexInfo.collectionName
                    }
                });
            } else {
                await webview.postMessage({
                    command: 'getIndexInfoResponse',
                    success: true,
                    data: {
                        fileCount: 0,
                        vectorCount: 0,
                        collectionName: 'No collection found'
                    }
                });
            }

        } catch (error) {
            console.error('MessageRouter: Error getting index info:', error);
            await this.sendErrorResponse(webview, `Failed to get index info: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Clears the entire index for the current workspace
     *
     * This handler removes all indexed data from the vector database,
     * effectively resetting the index to an empty state.
     *
     * @param webview - The webview to send the response to
     */
    private async handleClearIndex(webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling clear index request');

            // Clear the index using the indexing service
            const success = await this.indexingService.clearIndex();

            if (success) {
                await webview.postMessage({
                    command: 'clearIndexResponse',
                    success: true,
                    message: 'Index cleared successfully'
                });
            } else {
                await webview.postMessage({
                    command: 'clearIndexResponse',
                    success: false,
                    error: 'Failed to clear index'
                });
            }

        } catch (error) {
            console.error('MessageRouter: Error clearing index:', error);
            await this.sendErrorResponse(webview, `Failed to clear index: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Performs advanced search with customizable filters
     * 
     * This handler provides enhanced search capabilities with filtering options
     * such as file types, date ranges, and other search criteria. It requires
     * the SearchManager to be available.
     * 
     * @param message - The advanced search message, should contain query and optional filters
     * @param webview - The webview to send the advanced search response to
     */
    private async handleAdvancedSearch(message: any, webview: vscode.Webview): Promise<void> {
        // Check if SearchManager is available
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'SearchManager not available');
            return;
        }

        const { query, filters } = message;
        
        // Validate required parameters
        if (!query) {
            await this.sendErrorResponse(webview, 'Query is required');
            return;
        }

        // Perform advanced search with filters
        const result = await this.searchManager.search(query, filters);
        
        // Send results back to webview
        await webview.postMessage({
            command: 'advancedSearchResponse',
            requestId: message.requestId,
            data: result
        });
    }

    /**
     * Retrieves search suggestions based on partial query input
     * 
     * This handler provides autocomplete suggestions as the user types
     * their search query. It requires the SearchManager to be available.
     * 
     * @param message - The get search suggestions message, should contain partialQuery
     * @param webview - The webview to send the search suggestions response to
     */
    private async handleGetSearchSuggestions(message: any, webview: vscode.Webview): Promise<void> {
        // Check if SearchManager is available
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'SearchManager not available');
            return;
        }

        const { partialQuery } = message;
        // Get suggestions based on partial query
        const suggestions = this.searchManager.getSuggestions(partialQuery);
        
        // Send suggestions back to webview
        await webview.postMessage({
            command: 'searchSuggestionsResponse',
            requestId: message.requestId,
            data: suggestions
        });
    }

    /**
     * Retrieves the user's search history
     * 
     * This handler returns a list of recent searches performed by the user,
     * enabling quick access to previous queries. It requires the SearchManager
     * to be available.
     * 
     * @param webview - The webview to send the search history response to
     */
    private async handleGetSearchHistory(webview: vscode.Webview): Promise<void> {
        // Check if SearchManager is available
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'SearchManager not available');
            return;
        }

        // Get search history from SearchManager
        const history = this.searchManager.getSearchHistory();
        
        // Send history back to webview
        await webview.postMessage({
            command: 'searchHistoryResponse',
            data: history
        });
    }

    /**
     * Retrieves available configuration presets
     * 
     * This handler returns a list of predefined configuration presets that
     * users can apply to quickly configure the extension for different use cases.
     * 
     * @param webview - The webview to send the configuration presets response to
     */
    private async handleGetConfigurationPresets(webview: vscode.Webview): Promise<void> {
        // Get configuration presets from legacy configuration manager
        const presets = this.legacyConfigurationManager?.getConfigurationPresets() || [];
        
        // Send presets back to webview
        await webview.postMessage({
            command: 'configurationPresetsResponse',
            data: presets
        });
    }

    /**
     * Applies a configuration preset by name
     * 
     * This handler applies a predefined configuration preset to quickly set up
     * the extension for a specific use case. It requires the legacy
     * ConfigurationManager to be available.
     * 
     * @param message - The apply configuration preset message, should contain presetName
     * @param webview - The webview to send the application result to
     */
    private async handleApplyConfigurationPreset(message: any, webview: vscode.Webview): Promise<void> {
        // Check if ConfigurationManager is available
        if (!this.legacyConfigurationManager) {
            await this.sendErrorResponse(webview, 'ConfigurationManager not available');
            return;
        }

        const { presetName } = message;
        
        try {
            // Apply the specified preset
            await this.legacyConfigurationManager.applyPreset(presetName);
            
            // Send success response
            await webview.postMessage({
                command: 'configurationPresetAppliedResponse',
                requestId: message.requestId,
                data: { success: true }
            });
        } catch (error) {
            // Forward error to webview
            await this.sendErrorResponse(webview, error instanceof Error ? error.message : String(error));
        }
    }

    /**
     * Retrieves current performance metrics
     * 
     * This handler returns performance metrics collected by the PerformanceManager,
     * such as memory usage, response times, and other performance indicators.
     * It requires the PerformanceManager to be available.
     * 
     * @param webview - The webview to send the performance metrics response to
     */
    private async handleGetPerformanceMetrics(webview: vscode.Webview): Promise<void> {
        // Check if PerformanceManager is available
        if (!this.performanceManager) {
            await this.sendErrorResponse(webview, 'PerformanceManager not available');
            return;
        }

        // Get current metrics from PerformanceManager
        const metrics = this.performanceManager.getMetrics();
        
        // Send metrics back to webview
        await webview.postMessage({
            command: 'performanceMetricsResponse',
            data: metrics
        });
    }

    /**
     * Retrieves a preview of a file with surrounding context
     * 
     * This handler provides a preview of a specific file at a given line number,
     * with optional surrounding context lines. It's useful for showing search results
     * or code references with context. It requires the SearchManager to be available.
     * 
     * @param message - The get file preview message, should contain filePath, lineNumber, and optional contextLines
     * @param webview - The webview to send the file preview response to
     */
    private async handleGetFilePreview(message: any, webview: vscode.Webview): Promise<void> {
        // Check if SearchManager is available
        if (!this.searchManager) {
            await this.sendErrorResponse(webview, 'SearchManager not available');
            return;
        }

        const { filePath, lineNumber, contextLines } = message;
        
        // Validate required parameters
        if (!filePath || lineNumber === undefined) {
            await this.sendErrorResponse(webview, 'File path and line number are required');
            return;
        }

        // Get file preview with context
        const preview = await this.searchManager.getFilePreview(filePath, lineNumber, contextLines);
        
        // Send preview back to webview
        await webview.postMessage({
            command: 'filePreviewResponse',
            requestId: message.requestId,
            data: preview
        });
    }

    /**
     * Opens the VS Code settings UI filtered to this extension
     * 
     * This handler opens the VS Code settings interface and filters it to show
     * only settings related to this extension, making it easy for users to
     * configure extension-specific options.
     * 
     * @param webview - The webview (not used in this implementation but kept for consistency)
     */
    private async handleMapToSettings(webview: vscode.Webview): Promise<void> {
        // Open VS Code settings filtered to this extension
        await vscode.commands.executeCommand('workbench.action.openSettings', '@ext:bramburn.code-context-engine');
    }

    /**
     * Retrieves a value from the extension's global state
     * 
     * This handler fetches a value stored in the extension's global state
     * using the provided key. Global state persists across VS Code sessions.
     * 
     * @param message - The get global state message, should contain the key to retrieve
     * @param webview - The webview to send the global state response to
     */
    private async handleGetGlobalState(message: any, webview: vscode.Webview): Promise<void> {
        const { key } = message;
        
        // Validate required parameters
        if (!key) {
            await this.sendErrorResponse(webview, 'Key is required');
            return;
        }

        // Get value from global state
        const value = this.context.globalState.get(key);
        
        // Send value back to webview
        await webview.postMessage({
            command: 'globalStateResponse',
            requestId: message.requestId,
            data: { key, value }
        });
    }

    /**
     * Sets a value in the extension's global state
     * 
     * This handler stores a value in the extension's global state using the
     * provided key. Global state persists across VS Code sessions.
     * 
     * @param message - The set global state message, should contain key and value
     * @param webview - The webview to send the update confirmation to
     */
    private async handleSetGlobalState(message: any, webview: vscode.Webview): Promise<void> {
        const { key, value } = message;
        
        // Validate required parameters
        if (!key) {
            await this.sendErrorResponse(webview, 'Key is required');
            return;
        }

        // Update global state with new value
        await this.context.globalState.update(key, value);
        
        // Send confirmation back to webview
        await webview.postMessage({
            command: 'globalStateUpdatedResponse',
            requestId: message.requestId,
            data: { key, success: true }
        });
    }

    /**
     * Checks if this is the first run of the extension and starts tour if needed
     * 
     * This handler determines if the extension is being run for the first time
     * by checking a global state flag. If it's the first run, it sets the flag
     * and would typically trigger an onboarding tour or setup wizard.
     * 
     * @param webview - The webview to send the first run check response to
     */
    private async handleCheckFirstRunAndStartTour(webview: vscode.Webview): Promise<void> {
        // Check if this is the first run by looking for the 'hasRunBefore' flag
        const isFirstRun = !this.context.globalState.get('hasRunBefore');
        
        if (isFirstRun) {
            // Mark that the extension has been run before
            await this.context.globalState.update('hasRunBefore', true);
            // TODO: Implement tour start logic here
            // This would typically trigger an onboarding experience or guided tour
        }
        
        // Send first run status back to webview
        await webview.postMessage({
            command: 'firstRunCheckResponse',
            data: { isFirstRun }
        });
    }

    /**
     * Sends a standardized error response to the webview
     * 
     * This utility method provides a consistent way to send error messages
     * back to the webview, ensuring proper error handling and user feedback.
     * 
     * @param webview - The webview to send the error response to
     * @param errorMessage - The error message to send
     */
    private async sendErrorResponse(webview: vscode.Webview, errorMessage: string): Promise<void> {
        await webview.postMessage({
            command: 'error',
            message: errorMessage
        });
    }

    // ===== Placeholder methods for handlers that are not yet implemented =====
    // These methods provide basic error responses until their full implementation
    // is completed. Each follows the same pattern of sending a "not implemented yet"
    // error response to maintain consistency in the API.

    /**
     * Placeholder handler for saving secret values
     * 
     * This method is not yet implemented. When completed, it should use
     * VS Code's secret storage API to securely store sensitive information.
     * 
     * @param message - The save secret value message
     * @param webview - The webview to send the response to
     */
    private async handleSaveSecretValue(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would use VS Code's secret storage API
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for retrieving secret values
     * 
     * This method is not yet implemented. When completed, it should use
     * VS Code's secret storage API to securely retrieve sensitive information.
     * 
     * @param message - The get secret value message
     * @param webview - The webview to send the response to
     */
    private async handleGetSecretValue(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would use VS Code's secret storage API
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for running system validation
     * 
     * This method is not yet implemented. When completed, it should run
     * comprehensive system validation checks to ensure all dependencies
     * and requirements are met.
     * 
     * @param message - The run system validation message
     * @param webview - The webview to send the response to
     */
    private async handleRunSystemValidation(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would run system validation checks
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for retrieving troubleshooting guides
     * 
     * This method is not yet implemented. When completed, it should return
     * available troubleshooting guides to help users resolve common issues.
     * 
     * @param message - The get troubleshooting guides message
     * @param webview - The webview to send the response to
     */
    private async handleGetTroubleshootingGuides(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would return troubleshooting guides
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for running automatic fixes
     * 
     * This method is not yet implemented. When completed, it should automatically
     * detect and fix common configuration or setup issues.
     * 
     * @param message - The run auto fix message
     * @param webview - The webview to send the response to
     */
    private async handleRunAutoFix(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would run automatic fixes
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for opening troubleshooting guides
     *
     * This method is not yet implemented. When completed, it should open
     * specific troubleshooting guides in the webview or external browser.
     *
     * @param message - The open troubleshooting guide message
     * @param webview - The webview to send the response to
     */
    private async handleOpenTroubleshootingGuide(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would open troubleshooting guide
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Handle request to open folder dialog
     *
     * This method triggers the VS Code "Open Folder" dialog to allow users
     * to select a workspace folder when none is currently open.
     *
     * @param message - The request open folder message
     * @param webview - The webview to send the response to
     */
    private async handleRequestOpenFolder(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling request to open folder');

            // Execute the VS Code command to open folder dialog
            await vscode.commands.executeCommand('vscode.openFolder');

            // Send success response
            await webview.postMessage({
                command: 'response',
                requestId: message.requestId,
                data: { success: true }
            });

            console.log('MessageRouter: Open folder dialog triggered successfully');
        } catch (error) {
            console.error('MessageRouter: Failed to open folder dialog:', error);
            await this.sendErrorResponse(webview, error instanceof Error ? error.message : String(error));
        }
    }

    /**
     * Placeholder handler for exporting configuration
     * 
     * This method is not yet implemented. When completed, it should export
     * the current configuration to a file for backup or sharing purposes.
     * 
     * @param message - The export configuration message
     * @param webview - The webview to send the response to
     */
    private async handleExportConfiguration(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would export configuration
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for importing configuration
     * 
     * This method is not yet implemented. When completed, it should import
     * configuration from a file, allowing users to restore or share settings.
     * 
     * @param message - The import configuration message
     * @param webview - The webview to send the response to
     */
    private async handleImportConfiguration(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would import configuration
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for retrieving configuration templates
     * 
     * This method is not yet implemented. When completed, it should return
     * available configuration templates that users can use as starting points.
     * 
     * @param message - The get configuration templates message
     * @param webview - The webview to send the response to
     */
    private async handleGetConfigurationTemplates(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would return configuration templates
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for retrieving configuration backups
     * 
     * This method is not yet implemented. When completed, it should return
     * a list of available configuration backups that users can restore from.
     * 
     * @param message - The get configuration backups message
     * @param webview - The webview to send the response to
     */
    private async handleGetConfigurationBackups(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would return configuration backups
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for validating configuration
     * 
     * This method is not yet implemented. When completed, it should validate
     * the current configuration to ensure all settings are correct and compatible.
     * 
     * @param message - The validate configuration message
     * @param webview - The webview to send the response to
     */
    private async handleValidateConfiguration(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would validate configuration
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for applying configuration templates
     * 
     * This method is not yet implemented. When completed, it should apply
     * a selected configuration template to set up the extension for a specific use case.
     * 
     * @param message - The apply configuration template message
     * @param webview - The webview to send the response to
     */
    private async handleApplyConfigurationTemplate(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would apply configuration template
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for creating configuration backups
     * 
     * This method is not yet implemented. When completed, it should create
     * a backup of the current configuration that can be restored later.
     * 
     * @param message - The create configuration backup message
     * @param webview - The webview to send the response to
     */
    private async handleCreateConfigurationBackup(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would create configuration backup
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Placeholder handler for restoring configuration backups
     * 
     * This method is not yet implemented. When completed, it should restore
     * the extension configuration from a previously created backup.
     * 
     * @param message - The restore configuration backup message
     * @param webview - The webview to send the response to
     */
    private async handleRestoreConfigurationBackup(message: any, webview: vscode.Webview): Promise<void> {
        // Implementation would restore configuration backup
        await this.sendErrorResponse(webview, 'Not implemented yet');
    }

    /**
     * Gets the list of available workspaces
     *
     * This handler retrieves all available workspace folders and their information,
     * including the currently active workspace.
     *
     * @param webview - The webview to send the response to
     */
    private async handleGetWorkspaceList(webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling get workspace list request');

            if (!this.workspaceManager) {
                await webview.postMessage({
                    command: 'workspaceListResponse',
                    success: false,
                    error: 'Workspace manager not available'
                });
                return;
            }

            const workspaces = this.workspaceManager.getAllWorkspaces();
            const currentWorkspace = this.workspaceManager.getCurrentWorkspace();

            await webview.postMessage({
                command: 'workspaceListResponse',
                success: true,
                data: {
                    workspaces: workspaces,
                    current: currentWorkspace?.id || null
                }
            });

        } catch (error) {
            console.error('MessageRouter: Error getting workspace list:', error);
            await this.sendErrorResponse(webview, `Failed to get workspace list: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Switches to a different workspace
     *
     * This handler changes the active workspace and notifies the UI of the change.
     *
     * @param message - The switch workspace message containing the workspace ID
     * @param webview - The webview to send the response to
     */
    private async handleSwitchWorkspace(message: any, webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling switch workspace request');

            if (!this.workspaceManager) {
                await webview.postMessage({
                    command: 'workspaceSwitchResponse',
                    success: false,
                    error: 'Workspace manager not available'
                });
                return;
            }

            const workspaceId = message.data?.workspaceId;
            if (!workspaceId) {
                await webview.postMessage({
                    command: 'workspaceSwitchResponse',
                    success: false,
                    error: 'Workspace ID is required'
                });
                return;
            }

            const success = this.workspaceManager.switchToWorkspace(workspaceId);

            if (success) {
                await webview.postMessage({
                    command: 'workspaceSwitchResponse',
                    success: true,
                    data: {
                        workspaceId: workspaceId
                    }
                });
            } else {
                await webview.postMessage({
                    command: 'workspaceSwitchResponse',
                    success: false,
                    error: 'Workspace not found'
                });
            }

        } catch (error) {
            console.error('MessageRouter: Error switching workspace:', error);
            await this.sendErrorResponse(webview, `Failed to switch workspace: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Gets workspace statistics
     *
     * This handler retrieves statistics about the current workspace setup,
     * including the total number of workspaces and current workspace info.
     *
     * @param webview - The webview to send the response to
     */
    private async handleGetWorkspaceStats(webview: vscode.Webview): Promise<void> {
        try {
            console.log('MessageRouter: Handling get workspace stats request');

            if (!this.workspaceManager) {
                await webview.postMessage({
                    command: 'workspaceStatsResponse',
                    success: false,
                    error: 'Workspace manager not available'
                });
                return;
            }

            const stats = this.workspaceManager.getWorkspaceStats();

            await webview.postMessage({
                command: 'workspaceStatsResponse',
                success: true,
                data: stats
            });

        } catch (error) {
            console.error('MessageRouter: Error getting workspace stats:', error);
            await this.sendErrorResponse(webview, `Failed to get workspace stats: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}
</file>

<file path="src/webviewManager.ts">
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { MessageRouter } from './messageRouter';
import { ExtensionManager } from './extensionManager';
import { CentralizedLoggingService } from './logging/centralizedLoggingService';
import { NotificationService } from './notifications/notificationService';

/**
 * Webview panel configuration interface
 * 
 * Defines the configuration options for creating a webview panel in VS Code.
 * These options determine how the webview behaves, what resources it can access,
 * and how it's displayed in the editor.
 */
export interface WebviewConfig {
    /** Unique identifier for the webview panel */
    id: string;
    /** Title displayed in the webview panel's tab */
    title: string;
    /** Editor column where the webview should be shown (defaults to first column) */
    viewColumn?: vscode.ViewColumn;
    /** Whether to preserve focus when showing the panel (defaults to false) */
    preserveFocus?: boolean;
    /** Whether to enable JavaScript in the webview (defaults to true) */
    enableScripts?: boolean;
    /** Whether to enable command URIs in the webview (defaults to false) */
    enableCommandUris?: boolean;
    /** Local resources that the webview can access (defaults to resources folder) */
    localResourceRoots?: vscode.Uri[];
    /** Port mapping for local development servers */
    portMapping?: vscode.WebviewPortMapping[];
}

/**
 * Enhanced webview panel interface with metadata
 * 
 * Extends the basic VS Code webview panel with additional metadata for tracking
 * panel state, configuration, and message handlers. This interface provides
 * a comprehensive view of the webview panel's current state and capabilities.
 */
export interface WebviewPanel {
    /** Unique identifier for the webview panel */
    id: string;
    /** The underlying VS Code webview panel */
    panel: vscode.WebviewPanel;
    /** Configuration used to create this panel */
    config: WebviewConfig;
    /** Whether the panel is currently visible */
    visible: boolean;
    /** Timestamp of the last update to this panel */
    lastUpdated: Date;
    /** Map of message type to handler functions for processing webview messages */
    messageHandlers: Map<string, Function>;
}

/**
 * Webview message structure
 * 
 * Defines the standard format for messages exchanged between the extension
 * and webview content. This standardized format ensures consistent
 * message handling and processing across all webview communications.
 */
export interface WebviewMessage {
    /** Type of message for routing to appropriate handlers */
    type: string;
    /** Message payload containing the actual data */
    data: any;
    /** Timestamp when the message was created */
    timestamp: Date;
}

/**
 * Centralized webview management system for VS Code extensions
 * 
 * The WebviewManager class provides a comprehensive solution for managing multiple
 * webview panels within a VS Code extension. It handles the complete lifecycle of
 * webview panels including creation, configuration, message passing, resource management,
 * and disposal. This manager implements a debounced message queue system to optimize
 * performance and prevent excessive updates to webview content.
 * 
 * Key features:
 * - Dynamic creation and configuration of webview panels with customizable options
 * - Bidirectional message passing between extension and webview content
 * - Resource management with secure local file access through webview URIs
 * - Panel lifecycle management with proper disposal and cleanup
 * - Event-driven updates and notifications with debouncing for performance
 * - Centralized error handling and logging throughout all operations
 */
export class WebviewManager implements vscode.WebviewViewProvider {
    /** Extension context for resolving webview URIs */
    private context: vscode.ExtensionContext;
    /** Extension manager for accessing all services */
    private extensionManager: ExtensionManager;
    /** Centralized logging service for unified logging */
    private loggingService: CentralizedLoggingService;
    /** Notification service for user notifications */
    private notificationService: NotificationService;
    /** Map storing all managed webview panels by their unique IDs */
    private panels: Map<string, WebviewPanel> = new Map();
    /** Array of disposable resources for cleanup */
    private disposables: vscode.Disposable[] = [];
    /** Message queues for each panel to enable debounced updates */
    private messageQueue: Map<string, WebviewMessage[]> = new Map();
    /** Update timers for debouncing message processing */
    private updateTimers: Map<string, NodeJS.Timeout> = new Map();
    /** Debounce delay in milliseconds for message processing */
    private readonly updateDebounceMs = 100;

    /** Reference to the main panel for single-instance management */
    private mainPanel: vscode.WebviewPanel | undefined;
    /** Reference to the settings panel for single-instance management */
    private settingsPanel: vscode.WebviewPanel | undefined;

    /**
     * Initializes a new WebviewManager instance
     *
     * Sets up the manager with empty data structures and registers
     * event listeners for configuration changes and other system events.
     *
     * @param context - The VS Code extension context for resolving webview URIs
     * @param extensionManager - The extension manager for accessing all services
     * @param loggingService - The CentralizedLoggingService instance for logging
     * @param notificationService - The NotificationService instance for user notifications
     */
    constructor(
        context: vscode.ExtensionContext,
        extensionManager: ExtensionManager,
        loggingService: CentralizedLoggingService,
        notificationService: NotificationService
    ) {
        this.context = context;
        this.extensionManager = extensionManager;
        this.loggingService = loggingService;
        this.notificationService = notificationService;
        this.setupEventListeners();
    }

    /**
     * Resolves the webview view for the sidebar
     *
     * This method is called by VS Code when the sidebar view needs to be rendered.
     * It implements the WebviewViewProvider interface to provide content for the
     * sidebar webview.
     *
     * @param webviewView - The webview view to resolve
     * @param context - The webview view resolve context
     * @param token - Cancellation token
     */
    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        token: vscode.CancellationToken
    ): void | Thenable<void> {
        try {
            // Configure webview options
            webviewView.webview.options = {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.joinPath(this.context.extensionUri, 'webview', 'build')]
            };

            // Set HTML content using the helper method
            webviewView.webview.html = this.getWebviewContent(webviewView.webview, this.context.extensionUri);

            // Set up message handling
            webviewView.webview.onDidReceiveMessage(
                message => {
                    this.handleSidebarMessage(message);
                },
                undefined,
                this.disposables
            );

            // Send initial state message to the webview
            webviewView.webview.postMessage({
                type: 'initialState',
                data: {
                    isWorkspaceOpen: !!vscode.workspace.workspaceFolders?.length,
                    isSidebar: true
                }
            });

            this.loggingService.info('Sidebar webview resolved successfully', {}, 'WebviewManager');
        } catch (error) {
            this.loggingService.error('Failed to resolve sidebar webview', { error: error instanceof Error ? error.message : String(error) }, 'WebviewManager');
        }
    }

    /**
     * Handles messages from the sidebar webview
     *
     * @param message - The message received from the sidebar webview
     */
    private handleSidebarMessage(message: any): void {
        try {
            this.loggingService.debug('Received sidebar message', { type: message.type }, 'WebviewManager');

            // Handle sidebar-specific messages here
            switch (message.type) {
                case 'openMainPanel':
                    // Open the main panel when requested from sidebar
                    this.showMainPanel({ isWorkspaceOpen: !!vscode.workspace.workspaceFolders?.length });
                    break;
                default:
                    // For other messages, you might want to delegate to a general message handler
                    this.loggingService.debug('Unhandled sidebar message type', { type: message.type }, 'WebviewManager');
                    break;
            }
        } catch (error) {
            this.loggingService.error('Error handling sidebar message', { error: error instanceof Error ? error.message : String(error) }, 'WebviewManager');
        }
    }

    /**
     * Creates a new webview panel with the specified configuration
     * 
     * This method creates a VS Code webview panel and wraps it with additional
     * metadata and functionality. It sets up message handling, disposal callbacks,
     * and stores the panel in the internal management system.
     * 
     * @param config - Configuration object defining the webview panel properties
     * @returns The unique ID of the created webview panel
     * @throws Error if panel creation fails
     */
    createPanel(config: WebviewConfig): string {
        try {
            this.loggingService.info('Creating webview panel', { configId: config.id }, 'WebviewManager');

            // Check if panel already exists to prevent duplicates
            if (this.panels.has(config.id)) {
                this.loggingService.warn(`Panel with ID '${config.id}' already exists`, {}, 'WebviewManager');
                return config.id;
            }

            // Create VS Code webview panel with specified configuration
            const panel = vscode.window.createWebviewPanel(
                config.id,
                config.title,
                config.viewColumn || vscode.ViewColumn.One,
                {
                    enableScripts: config.enableScripts || true,
                    enableCommandUris: config.enableCommandUris || false,
                    localResourceRoots: config.localResourceRoots || [vscode.Uri.joinPath(vscode.Uri.file(__dirname), 'resources')],
                    portMapping: config.portMapping
                }
            );

            // Set up message handling using MessageRouter for centralized routing
            const messageRouter = new MessageRouter(
                this.extensionManager.getContextService(),
                this.extensionManager.getIndexingService(),
                this.context,
                this.extensionManager.getStateManager()
            );

            // Set up advanced managers if available
            try {
                messageRouter.setAdvancedManagers(
                    this.extensionManager.getSearchManager(),
                    this.extensionManager.getConfigurationManager(),
                    this.extensionManager.getPerformanceManager(),
                    this.extensionManager.getXmlFormatterService()
                );
            } catch (error) {
                console.warn('WebviewManager: Some advanced managers not available during panel creation:', error);
            }

            panel.webview.onDidReceiveMessage(
                message => messageRouter.handleMessage(message, panel.webview),
                undefined,
                this.disposables
            );

            // Handle panel disposal to maintain consistent state
            panel.onDidDispose(
                () => this.handlePanelDispose(config.id),
                undefined,
                this.disposables
            );

            // Create enhanced panel object with metadata
            const webviewPanel: WebviewPanel = {
                id: config.id,
                panel,
                config,
                visible: true,
                lastUpdated: new Date(),
                messageHandlers: new Map()
            };

            // Store the panel in our management system
            this.panels.set(config.id, webviewPanel);
            
            this.loggingService.info(`Created webview panel '${config.id}'`, {}, 'WebviewManager');
            return config.id;

        } catch (error) {
            this.loggingService.error('Failed to create webview panel', { error: error instanceof Error ? error.message : String(error) }, 'WebviewManager');
            throw error;
        }
    }

    /**
     * Shows an existing webview panel by bringing it to focus
     * 
     * This method reveals a previously created or hidden webview panel,
     * making it visible in the specified editor column. The panel's
     * visibility state is updated accordingly.
     * 
     * @param id - Unique identifier of the webview panel to show
     */
    showPanel(id: string): void {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return;
            }

            // Reveal the panel in the specified column with focus options
            webviewPanel.panel.reveal(webviewPanel.config.viewColumn, webviewPanel.config.preserveFocus);
            webviewPanel.visible = true;
            webviewPanel.lastUpdated = new Date();

            console.log(`WebviewManager: Showed webview panel '${id}'`);

        } catch (error) {
            console.error('WebviewManager: Failed to show webview panel:', error);
        }
    }

    /**
     * Hides a webview panel by disposing its VS Code panel instance
     * 
     * This method disposes the underlying VS Code webview panel,
     * effectively hiding it from view while maintaining the panel
     * metadata in our management system for potential later use.
     * 
     * @param id - Unique identifier of the webview panel to hide
     */
    hidePanel(id: string): void {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return;
            }

            // Dispose the VS Code panel to hide it
            webviewPanel.panel.dispose();
            webviewPanel.visible = false;
            webviewPanel.lastUpdated = new Date();

            console.log(`WebviewManager: Hid webview panel '${id}'`);

        } catch (error) {
            console.error('WebviewManager: Failed to hide webview panel:', error);
        }
    }

    /**
     * Toggles the visibility state of a webview panel
     * 
     * This method provides a convenient way to switch between showing
     * and hiding a webview panel based on its current visibility state.
     * If the panel is visible, it will be hidden; if hidden, it will be shown.
     * 
     * @param id - Unique identifier of the webview panel to toggle
     */
    togglePanel(id: string): void {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return;
            }

            // Toggle visibility based on current state
            if (webviewPanel.visible) {
                this.hidePanel(id);
            } else {
                this.showPanel(id);
            }

        } catch (error) {
            console.error('WebviewManager: Failed to toggle webview panel:', error);
        }
    }

    /**
     * Retrieves a webview panel by its unique identifier
     * 
     * This method provides access to the enhanced webview panel object
     * containing both the VS Code panel and additional metadata.
     * 
     * @param id - Unique identifier of the webview panel to retrieve
     * @returns The webview panel object if found, undefined otherwise
     */
    getPanel(id: string): WebviewPanel | undefined {
        return this.panels.get(id);
    }

    /**
     * Retrieves all managed webview panels
     * 
     * This method returns an array of all webview panels currently
     * managed by this WebviewManager instance, regardless of their
     * visibility state.
     * 
     * @returns Array of all managed webview panels
     */
    getAllPanels(): WebviewPanel[] {
        return Array.from(this.panels.values());
    }

    /**
     * Retrieves all currently visible webview panels
     * 
     * This method filters the managed panels to return only those
     * that are currently visible to the user.
     * 
     * @returns Array of visible webview panels
     */
    getVisiblePanels(): WebviewPanel[] {
        return Array.from(this.panels.values()).filter(panel => panel.visible);
    }

    /**
     * Completely removes a webview panel from management
     * 
     * This method performs a full cleanup of the specified webview panel,
     * including disposal of the VS Code panel, removal from internal maps,
     * and cleanup of any associated timers and message queues.
     * 
     * @param id - Unique identifier of the webview panel to delete
     */
    deletePanel(id: string): void {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return;
            }

            // Dispose the VS Code panel to free resources
            webviewPanel.panel.dispose();
            
            // Remove from our management system
            this.panels.delete(id);
            this.messageQueue.delete(id);
            
            // Clear any pending update timers
            const timer = this.updateTimers.get(id);
            if (timer) {
                clearTimeout(timer);
                this.updateTimers.delete(id);
            }

            console.log(`WebviewManager: Deleted webview panel '${id}'`);

        } catch (error) {
            console.error('WebviewManager: Failed to delete webview panel:', error);
        }
    }

    /**
     * Sets the HTML content for a webview panel
     * 
     * This method updates the webview panel's HTML content, which will
     * be immediately rendered in the panel. The content can include
     * references to local resources through the webview's URI system.
     * 
     * @param id - Unique identifier of the webview panel
     * @param html - HTML content to set for the webview
     */
    setHtml(id: string, html: string): void {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return;
            }

            // Set the HTML content directly on the webview
            webviewPanel.panel.webview.html = html;
            webviewPanel.lastUpdated = new Date();

            console.log(`WebviewManager: Set HTML for panel '${id}'`);

        } catch (error) {
            console.error('WebviewManager: Failed to set HTML:', error);
        }
    }

    /**
     * Posts a message to a webview panel with debouncing
     * 
     * This method queues messages for delivery to webview panels,
     * implementing a debouncing mechanism to optimize performance.
     * Messages are standardized to the WebviewMessage format and
     * processed in batches to minimize webview updates.
     * 
     * @param id - Unique identifier of the webview panel
     * @param message - Message data to post (can be string or object)
     */
    postMessage(id: string, message: any): void {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return;
            }

            // Initialize message queue for this panel if it doesn't exist
            if (!this.messageQueue.has(id)) {
                this.messageQueue.set(id, []);
            }
            
            // Standardize message format for consistent handling
            const webviewMessage: WebviewMessage = {
                type: typeof message === 'string' ? message : message.type || 'default',
                data: typeof message === 'string' ? { text: message } : message.data || message,
                timestamp: new Date()
            };

            // Add message to queue and schedule debounced processing
            this.messageQueue.get(id)!.push(webviewMessage);
            this.scheduleMessageUpdate(id);

        } catch (error) {
            console.error('WebviewManager: Failed to post message:', error);
        }
    }

    /**
     * Registers a message handler for a specific message type
     * 
     * This method allows the extension to handle incoming messages
     * from the webview content. Each message type can have its own
     * dedicated handler function for processing the message data.
     * 
     * @param id - Unique identifier of the webview panel
     * @param messageType - Type of message to handle
     * @param handler - Function to process messages of this type
     */
    registerMessageHandler(id: string, messageType: string, handler: Function): void {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return;
            }

            // Register the handler for the specified message type
            webviewPanel.messageHandlers.set(messageType, handler);
            console.log(`WebviewManager: Registered message handler for '${messageType}' on panel '${id}'`);

        } catch (error) {
            console.error('WebviewManager: Failed to register message handler:', error);
        }
    }

    /**
     * Unregisters a previously registered message handler
     * 
     * This method removes a message handler for a specific message type,
     * effectively stopping the processing of messages of that type.
     * 
     * @param id - Unique identifier of the webview panel
     * @param messageType - Type of message to unregister
     */
    unregisterMessageHandler(id: string, messageType: string): void {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return;
            }

            // Remove the handler for the specified message type
            webviewPanel.messageHandlers.delete(messageType);
            console.log(`WebviewManager: Unregistered message handler for '${messageType}' on panel '${id}'`);

        } catch (error) {
            console.error('WebviewManager: Failed to unregister message handler:', error);
        }
    }

    /**
     * Gets a webview-compatible URI for local resources
     * 
     * This method converts local file paths to webview-compatible URIs
     * that can be safely accessed from within the webview content.
     * This is essential for loading local resources like images, stylesheets,
     * or scripts in the webview.
     * 
     * @param id - Unique identifier of the webview panel
     * @param path - Relative path to the local resource
     * @returns Webview-compatible URI for the resource, or undefined if panel not found
     */
    getLocalResourceUri(id: string, path: string): vscode.Uri | undefined {
        try {
            const webviewPanel = this.panels.get(id);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${id}' not found`);
                return undefined;
            }

            // Create a file URI and convert it to a webview URI
            const resourcePath = vscode.Uri.joinPath(vscode.Uri.file(__dirname), path);
            return webviewPanel.panel.webview.asWebviewUri(resourcePath);

        } catch (error) {
            console.error('WebviewManager: Failed to get local resource URI:', error);
            return undefined;
        }
    }

    /**
     * Processes incoming messages from webview panels
     * 
     * This private method handles messages received from webview content,
     * routing them to the appropriate registered handlers based on the
     * message type. It provides centralized message processing with
     * error handling and logging.
     * 
     * @param panelId - Unique identifier of the source webview panel
     * @param message - The message data received from the webview
     */
    private handleMessage(panelId: string, message: any): void {
        try {
            const webviewPanel = this.panels.get(panelId);
            if (!webviewPanel) {
                console.warn(`WebviewManager: Panel with ID '${panelId}' not found`);
                return;
            }

            // Determine message type and get appropriate handler
            const messageType = message.type || 'default';
            const handler = webviewPanel.messageHandlers.get(messageType);
            
            if (handler) {
                // Execute the handler with the message data
                handler(message);
            } else {
                console.warn(`WebviewManager: No handler registered for message type '${messageType}' on panel '${panelId}'`);
            }

        } catch (error) {
            console.error('WebviewManager: Failed to handle message:', error);
        }
    }

    /**
     * Handles the disposal of webview panels
     * 
     * This private method is called when a webview panel is disposed,
     * either by the user or programmatically. It updates the panel's
     * visibility state and cleans up associated resources like message
     * queues and update timers.
     * 
     * @param panelId - Unique identifier of the disposed webview panel
     */
    private handlePanelDispose(panelId: string): void {
        try {
            const webviewPanel = this.panels.get(panelId);
            if (webviewPanel) {
                // Update panel state to reflect disposal
                webviewPanel.visible = false;
                webviewPanel.lastUpdated = new Date();
                console.log(`WebviewManager: Panel '${panelId}' disposed`);
            }

            // Clean up associated resources
            this.messageQueue.delete(panelId);
            const timer = this.updateTimers.get(panelId);
            if (timer) {
                clearTimeout(timer);
                this.updateTimers.delete(panelId);
            }

        } catch (error) {
            console.error('WebviewManager: Failed to handle panel disposal:', error);
        }
    }

    /**
     * Schedules debounced message processing for a panel
     * 
     * This private method implements the debouncing mechanism for message
     * processing. It cancels any existing timer for the panel and creates
     * a new one to process the message queue after the specified delay.
     * This prevents excessive updates and improves performance.
     * 
     * @param panelId - Unique identifier of the webview panel
     */
    private scheduleMessageUpdate(panelId: string): void {
        // Cancel any existing timer for this panel
        const existingTimer = this.updateTimers.get(panelId);
        if (existingTimer) {
            clearTimeout(existingTimer);
        }

        // Create a new timer to process messages after debounce delay
        const timer = setTimeout(() => {
            this.processMessageQueue(panelId);
            this.updateTimers.delete(panelId);
        }, this.updateDebounceMs);

        this.updateTimers.set(panelId, timer);
    }

    /**
     * Processes the message queue for a specific panel
     * 
     * This private method processes all queued messages for a panel,
     * sending them to the webview content in a batch. It clears the
     * queue after processing to prepare for new messages.
     * 
     * @param panelId - Unique identifier of the webview panel
     */
    private processMessageQueue(panelId: string): void {
        try {
            const webviewPanel = this.panels.get(panelId);
            if (!webviewPanel) {
                return;
            }

            const messages = this.messageQueue.get(panelId);
            if (!messages || messages.length === 0) {
                return;
            }

            // Send all queued messages to the webview
            messages.forEach(message => {
                webviewPanel.panel.webview.postMessage(message);
            });

            // Clear the queue after processing
            this.messageQueue.set(panelId, []);

            console.log(`WebviewManager: Processed ${messages.length} messages for panel '${panelId}'`);

        } catch (error) {
            console.error('WebviewManager: Failed to process message queue:', error);
        }
    }

    /**
     * Sets up event listeners for system and configuration changes
     * 
     * This private method registers event listeners for various system
     * events that may affect webview panels, such as configuration changes.
     * These listeners ensure that webview panels remain synchronized with
     * the current system state.
     */
    private setupEventListeners(): void {
        // Listen for configuration changes that might affect webviews
        const configChangeListener = vscode.workspace.onDidChangeConfiguration(e => {
            console.log('WebviewManager: Configuration changed, updating webview panels');
            // Update panels based on configuration changes
            this.panels.forEach((webviewPanel, id) => {
                // Re-apply configuration if needed
                if (webviewPanel.visible) {
                    webviewPanel.lastUpdated = new Date();
                }
            });
        });

        // Store the listener for proper cleanup
        this.disposables.push(configChangeListener);
    }

    /**
     * Shows the main panel with single-instance management
     *
     * This method manages the main code context panel, ensuring only one instance
     * exists at a time. If the panel already exists, it brings it into focus.
     * Otherwise, it creates a new panel with proper HTML content loading.
     */
    showMainPanel(options: { isWorkspaceOpen: boolean }): void {
        const panelId = 'codeContextMain';
        const panelTitle = 'Code Context';

        // If main panel already exists, just reveal it
        if (this.mainPanel) {
            this.mainPanel.reveal(vscode.ViewColumn.One);
            return;
        }

        // Create new main panel
        this.mainPanel = vscode.window.createWebviewPanel(
            panelId,
            panelTitle,
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.joinPath(this.context.extensionUri, 'webview', 'build')]
            }
        );

        // Set HTML content using the helper method
        this.mainPanel.webview.html = this.getWebviewContent(this.mainPanel.webview, this.context.extensionUri);

        // Send initial state message to the webview
        this.mainPanel.webview.postMessage({
            type: 'initialState',
            data: { isWorkspaceOpen: options.isWorkspaceOpen }
        });

        // Set up MessageRouter for message handling
        const messageRouter = new MessageRouter(
            this.extensionManager.getContextService(),
            this.extensionManager.getIndexingService(),
            this.context,
            this.extensionManager.getStateManager()
        );

        // Set up advanced managers if available
        try {
            messageRouter.setAdvancedManagers(
                this.extensionManager.getSearchManager(),
                this.extensionManager.getConfigurationManager(),
                this.extensionManager.getPerformanceManager(),
                this.extensionManager.getXmlFormatterService()
            );
        } catch (error) {
            console.warn('WebviewManager: Some advanced managers not available for main panel:', error);
        }

        this.mainPanel.webview.onDidReceiveMessage(
            message => messageRouter.handleMessage(message, this.mainPanel!.webview),
            undefined,
            this.disposables
        );

        // Set up disposal listener to clear the reference
        this.mainPanel.onDidDispose(() => {
            this.mainPanel = undefined;
            this.deletePanel(panelId);
        }, null, this.disposables);

        // Add to general panels map for consistent management
        this.panels.set(panelId, {
            id: panelId,
            panel: this.mainPanel,
            config: { id: panelId, title: panelTitle, enableScripts: true },
            visible: true,
            lastUpdated: new Date(),
            messageHandlers: new Map()
        });

        console.log('WebviewManager: Main panel created and displayed');
    }

    /**
     * Shows the settings panel with single-instance management
     *
     * This method manages the settings panel, ensuring only one instance
     * exists at a time. If the panel already exists, it brings it into focus.
     * Otherwise, it creates a new panel with proper HTML content loading.
     */
    showSettingsPanel(): void {
        const panelId = 'codeContextSettings';
        const panelTitle = 'Code Context Settings';

        // If settings panel already exists, just reveal it
        if (this.settingsPanel) {
            this.settingsPanel.reveal(vscode.ViewColumn.One);
            return;
        }

        // Create new settings panel
        this.settingsPanel = vscode.window.createWebviewPanel(
            panelId,
            panelTitle,
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                localResourceRoots: [vscode.Uri.joinPath(this.context.extensionUri, 'webview', 'build')]
            }
        );

        // Set HTML content using the helper method
        this.settingsPanel.webview.html = this.getWebviewContent(this.settingsPanel.webview, this.context.extensionUri);

        // Set up MessageRouter for message handling
        const messageRouter = new MessageRouter(
            this.extensionManager.getContextService(),
            this.extensionManager.getIndexingService(),
            this.context,
            this.extensionManager.getStateManager()
        );

        // Set up advanced managers if available
        try {
            messageRouter.setAdvancedManagers(
                this.extensionManager.getSearchManager(),
                this.extensionManager.getConfigurationManager(),
                this.extensionManager.getPerformanceManager(),
                this.extensionManager.getXmlFormatterService()
            );
        } catch (error) {
            console.warn('WebviewManager: Some advanced managers not available for settings panel:', error);
        }

        this.settingsPanel.webview.onDidReceiveMessage(
            message => messageRouter.handleMessage(message, this.settingsPanel!.webview),
            undefined,
            this.disposables
        );

        // Set up disposal listener to clear the reference
        this.settingsPanel.onDidDispose(() => {
            this.settingsPanel = undefined;
            this.deletePanel(panelId);
        }, null, this.disposables);

        // Add to general panels map for consistent management
        this.panels.set(panelId, {
            id: panelId,
            panel: this.settingsPanel,
            config: { id: panelId, title: panelTitle, enableScripts: true },
            visible: true,
            lastUpdated: new Date(),
            messageHandlers: new Map()
        });

        console.log('WebviewManager: Settings panel created and displayed');
    }

    /**
     * Shows the diagnostics panel (legacy compatibility method)
     *
     * This method provides backward compatibility with the expected interface.
     * It creates or shows the diagnostics panel.
     */
    showDiagnosticsPanel(): void {
        const diagnosticsPanelId = 'codeContextDiagnostics';

        // Check if panel already exists
        if (this.panels.has(diagnosticsPanelId)) {
            this.showPanel(diagnosticsPanelId);
            return;
        }

        // Create new diagnostics panel
        this.createPanel({
            id: diagnosticsPanelId,
            title: 'Code Context Diagnostics',
            viewColumn: vscode.ViewColumn.Two,
            enableScripts: true
        });
    }

    /**
     * Updates the workspace state in all webview panels
     *
     * This method sends a message to all webview panels to update their
     * workspace state, which will trigger UI updates as needed.
     *
     * @param isWorkspaceOpen - Whether a workspace is currently open
     */
    updateWorkspaceState(isWorkspaceOpen: boolean): void {
        try {
            // Send workspace state update to all visible panels
            this.panels.forEach((webviewPanel, id) => {
                if (webviewPanel.visible) {
                    webviewPanel.panel.webview.postMessage({
                        type: 'workspaceStateChanged',
                        data: { isWorkspaceOpen }
                    });
                    console.log(`WebviewManager: Sent workspace state update to panel '${id}'`);
                }
            });
        } catch (error) {
            console.error('WebviewManager: Failed to update workspace state:', error);
        }
    }

    /**
     * Static property for view type (legacy compatibility)
     */
    static readonly viewType = 'codeContextMain';

    /**
     * Loads and prepares webview HTML content with proper asset URI resolution
     *
     * This helper method reads the index.html file from the webview/build directory
     * and replaces relative asset paths with webview-compatible URIs using
     * webview.asWebviewUri. This ensures that CSS, JavaScript, and other assets
     * load correctly within the webview context.
     *
     * @param webview - The webview instance for URI resolution
     * @param extensionUri - The extension's base URI
     * @returns The processed HTML content with resolved asset URIs
     */
    private getWebviewContent(webview: vscode.Webview, extensionUri: vscode.Uri): string {
        try {
            const htmlPath = path.join(extensionUri.fsPath, 'webview', 'build', 'index.html');

            // Check if the HTML file exists
            if (!fs.existsSync(htmlPath)) {
                console.warn(`WebviewManager: HTML file not found at ${htmlPath}, using fallback content`);
                return this.getFallbackHtmlContent();
            }

            let html = fs.readFileSync(htmlPath, 'utf8');

            // Generate a nonce for inline scripts
            const nonce = this.generateNonce();

            // Add Content Security Policy for VS Code webview with nonce
            const cspSource = webview.cspSource;
            const csp = `<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${cspSource} 'unsafe-inline'; script-src ${cspSource} 'nonce-${nonce}'; font-src ${cspSource}; img-src ${cspSource} https: data:; connect-src ${cspSource};">`;

            // Insert CSP after the charset meta tag
            html = html.replace(
                /<meta charset="utf-8" \/>/,
                `<meta charset="utf-8" />\n\t\t\t${csp}`
            );

            // Replace relative paths with webview-compatible URIs
            // This handles SvelteKit's typical asset patterns
            html = html.replace(/(src|href)="(\/_app\/[^"]+)"/g, (match, attr, src) => {
                const resourceUri = webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'webview', 'build', src));
                console.log(`WebviewManager: Replacing ${src} with ${resourceUri}`);
                return `${attr}="${resourceUri}"`;
            });

            // Also handle any other relative paths that might exist
            html = html.replace(/(src|href)="(\/[^"]+\.(js|css|png|jpg|jpeg|gif|svg|ico|json))"/g, (match, attr, src) => {
                const resourceUri = webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'webview', 'build', src));
                console.log(`WebviewManager: Replacing ${src} with ${resourceUri}`);
                return `${attr}="${resourceUri}"`;
            });

            // Replace import() calls in inline scripts to use webview URIs
            html = html.replace(/import\("(\/_app\/[^"]+)"\)/g, (match, src) => {
                const resourceUri = webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, 'webview', 'build', src));
                return `import("${resourceUri}")`;
            });

            // Add nonce to inline scripts
            html = html.replace(/<script>/g, `<script nonce="${nonce}">`);

            // Inject fetch interceptor for SvelteKit runtime requests
            const fetchInterceptor = `
                <script nonce="${nonce}">
                    // Intercept fetch requests for SvelteKit assets
                    const originalFetch = window.fetch;
                    window.fetch = function(url, options) {
                        // Handle relative URLs that start with /_app/
                        if (typeof url === 'string' && url.startsWith('/_app/')) {
                            console.log('Intercepting fetch for:', url);
                            // For version.json, return a mock response since it's just used for cache busting
                            if (url.includes('version.json')) {
                                return Promise.resolve(new Response('{"version":"${Date.now()}"}', {
                                    status: 200,
                                    headers: { 'Content-Type': 'application/json' }
                                }));
                            }
                        }
                        return originalFetch.call(this, url, options);
                    };
                </script>
            `;

            // Insert fetch interceptor before the first script tag
            html = html.replace(/<script/, fetchInterceptor + '<script');

            return html;
        } catch (error) {
            console.error('WebviewManager: Error loading webview content:', error);
            return this.getFallbackHtmlContent();
        }
    }

    /**
     * Provides fallback HTML content when the main HTML file cannot be loaded
     *
     * @returns Basic HTML content for the webview
     */
    private getFallbackHtmlContent(): string {
        return `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Code Context Engine</title>
                <style>
                    body {
                        font-family: var(--vscode-font-family);
                        color: var(--vscode-foreground);
                        background-color: var(--vscode-editor-background);
                        padding: 20px;
                        margin: 0;
                    }
                    .container {
                        max-width: 800px;
                        margin: 0 auto;
                        text-align: center;
                    }
                    .error {
                        color: var(--vscode-errorForeground);
                        margin: 20px 0;
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>Code Context Engine</h1>
                    <div class="error">
                        <p>Unable to load the main interface. Please ensure the webview assets are built.</p>
                        <p>Run <code>npm run build:webview</code> to build the webview assets.</p>
                    </div>
                </div>
            </body>
            </html>
        `;
    }

    /**
     * Generates a cryptographically secure nonce for Content Security Policy
     *
     * @returns A base64-encoded nonce string
     */
    private generateNonce(): string {
        const crypto = require('crypto');
        return crypto.randomBytes(16).toString('base64');
    }

    /**
     * Disposes of the WebviewManager and all associated resources
     *
     * This method performs a complete cleanup of all resources managed
     * by the WebviewManager, including all webview panels, timers,
     * message queues, and event listeners. This should be called when
     * the extension is deactivated to prevent memory leaks.
     */
    dispose(): void {
        try {
            // Clear all pending update timers
            this.updateTimers.forEach(timer => clearTimeout(timer));
            this.updateTimers.clear();

            // Dispose all managed webview panels
            this.panels.forEach(webviewPanel => {
                webviewPanel.panel.dispose();
            });
            this.panels.clear();

            // Clear all message queues
            this.messageQueue.clear();

            // Dispose all registered event listeners
            this.disposables.forEach(disposable => disposable.dispose());
            this.disposables = [];

            console.log('WebviewManager: Disposed');

        } catch (error) {
            console.error('WebviewManager: Error during disposal:', error);
        }
    }
}
</file>

</files>
